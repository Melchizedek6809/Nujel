; Nujel - Copyright (C) 2020-2021 - Benjamin Vincent Schulenburg
; This project uses the MIT license, a copy should be included under /LICENSE

;; Some functions about trees

[defun tree/zip [keys values]
       "Return a tree where KEYS point to VALUES"
       [def ret @[]]
       [for-in [key keys]
	      [tree/set! ret key [car values]]
	      [cdr! values]]
       ret]

[defun tree/+= [t k v]
       "Increment value at K in T by V"
       [tree/set! t k [+ v [int [tree/ref t k]]]]]

[defmacro tree/-= [t k v]
       "Decrement value at K in T by V"
       `[tree/+= ~t ~k [- ~v]]]

[defmacro tree/++ [t k]
       "Increment value at K in T by 1"
       `[tree/+= ~t ~k 1]]

[defmacro tree/-- [t k]
       "Increment value at K in T by 1"
       `[tree/-= ~t ~k 1]]

[defun tree/equal? [a b]
       "Compares two trees for equality"
       [if [and [tree? a]
                [tree? b]]
           [and [== [tree/key* a]
                    [tree/key* b]]
                [equal? [tree/value* a]
                        [tree/value* b]]
                [tree/equal? [tree/left* a]
                             [tree/left* b]]
                [tree/equal? [tree/right* a]
                             [tree/right* b]]]
           [equal? a b]]]

[defun tree/reduce [l o s]
       "Combine all elements in l using operation o and starting value s"
       [for-in [e [tree/keys l]]
               [set! s [o [tree/ref l e] s e]]]
       s]

[defun tree/filter [l f]
       "Return a new tree with all elements from L where F retunrs true"
       [def ret @[]]
       [for-in [e [tree/keys l]]
               [def t [tree/ref l e]]
               [when [f t]
                     [tree/set! ret e t]]]
       ret]
