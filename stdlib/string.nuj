; Some nujel string λs

[defun br [num]
        "Return NUM=1 linebreaks"
        [if [or [nil? num] [<= [int num] 1]]
            "\n"
            ["\n" [br [-- num]]]]
]

[defun path/ext?! [ext]
		  "Return a predicate that checks if a path ends on EXT"
		  [λ [path]
		    [eq? ext [lowercase [path/extension path]]]
		  ]
]

[defun path/extension [path]
        "Return the extension of PATH"
        [def last-period [last-index-of path "."]]
        [if [>= last-period 0]
            [substr path [+ 1 last-period] [str/length path]]
            path]
]

[defun path/without-extension [path]
        "Return PATH, but without the extension part"
        [def last-period [last-index-of path "."]]
        [if [>= last-period 0]
            [substr path 0 last-period]
            path]
]

[defun int->string/binary [v]
        [def ret ""]
        [unless v [def v 0]]
        [when [zero? v] [set! ret "0"]]
        [while [not-zero? v]
               [set! ret [cat [from-char-code [+ #\0 [logand v #b1]]] ret]]
               [set! v [ash v -1]]
        ]
        ret
]

[defun int->string/octal [v]
        [def ret ""]
        [unless v [def v 0]]
        [when [zero? v] [set! ret "0"]]
        [while [not-zero? v]
               [set! ret [cat [from-char-code [+ #\0 [logand v #b111]]] ret]]
               [set! v [ash v -3]]
        ]
        ret
]


[def int->string/hex [let*
        [def conversion-arr #["0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F"]]

        [λ [v]
                [def ret ""]
                [unless v [def v 0]]
                [when [zero? v] [set! ret "0"]]
                [while [not-zero? v]
                       [set! ret [cat [conversion-arr [logand v #b1111]] ret]]
                       [set! v [ash v -4]]
                ]
                ret
]]]

[defun int->string/decimal [v]
        [string v]
]
[def int->string int->string/decimal]
