; Subroutines and macros for formatted text output

[def fmt/tmp 123]

[def fmt/expr/count 0]
[defun fmt/expr [expr arguments-used]
       [when-not [string? expr]
                 [throw [list :format-error "fmt needs a string literal as a first argument, since it is implemented as a macro" expr [current-lambda]]]]
       [when [== "" expr]
             [set! expr [cat "#" [-- fmt/expr/count]]]]
       [when [== [char-at expr 0] #\#]
             [def i [read/single [substr expr 1]]]
             [when-not [int? i]
                       [throw [list :format-error "fmt expects numbered values to be indexed by an integer" expr [current-lambda]]]]
             [when [or [< i 0] [>= i [array/length arguments-used]]]
                   [throw [list :format-error "fmt numbered argument is out of bounds" expr [current-lambda]]]]
             [array/set! arguments-used i #t]]
       [str->sym expr]]

[def fmt/args/map-fun/count 0]
[defun fmt/args/map-fun [arg]
       [def s [str->sym [cat "#" fmt/args/map-fun/count]]]
       [++ fmt/args/map-fun/count]
       [list 'def s arg]]

[defmacro fmt [format-string . args]
          "Return a formatted string"
          [when-not [string? format-string]
                    [throw [list :type-error "fmt needs a string literal as a first argument, since it is implemented as a macro" format-string [current-lambda]]]]
          [def cuts #nil]
          [for [i 0 [string/length format-string]]
               [case [char-at format-string i]
                     [#\{ [do [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]]
                              [set! cuts [cons i cuts]]]]
                     [#\} [do [when-not [int? [car cuts]] [throw [list :format-error "fmt expects all brackets to be closed" format-string [current-lambda]]]]
                              [set! cuts [cons [cons [car cuts] i] [cdr cuts]]]]]]]
          [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]]
          [def expr-list #nil]
          [def last-pos [string/length format-string]]
          [def arguments-used [-> [array/allocate [length args]] [array/fill! #f]]]

          [set! fmt/expr/count [array/length arguments-used]]
          [for-in [c cuts]
                  [def lit [substr format-string [+ [cdr c] 1] last-pos]]
                  [when-not [== "" lit] [set! expr-list [cons lit expr-list]]]
                  [def expr [fmt/expr [substr format-string [+ 1 [car c]] [cdr c]] arguments-used]]
                  [set! expr-list [cons expr expr-list]]
                  [set! last-pos [car c]]]
          [when [> last-pos 0]
                [def lit [substr format-string 0 last-pos]]
                [set! expr-list [cons lit expr-list]]]
          [for [i 0 [array/length arguments-used]]
               [when-not [array/ref arguments-used i]
                         [throw [list :format-error "fmt expects all arguments to be used" [list format-string [list/ref args i]] [current-lambda]]]]]
          [def expr [if [cdr expr-list]
                        [cons 'cat expr-list]
                        [if [string? [car expr-list]]
                            [car expr-list]
                            [cons 'string expr-list]]]]
          [set! fmt/args/map-fun/count 0]
          [if args
              `[let* ~@[map args fmt/args/map-fun]
                      ~expr]
              expr]]

[defmacro pfmt [format-string . args]
          "Print a formatted string"
          `[print [fmt ~format-string ~@args]]]

[defmacro efmt [format-string . args]
          "Print a formatted string"
          `[error [fmt ~format-string ~@args]]]
