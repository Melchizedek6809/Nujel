;;; Nujel - Copyright (C) 2020-2021 - Benjamin Vincent Schulenburg
;;; This project uses the MIT license, a copy should be included under /LICENSE
;;;
;;; Contains native nujel implementations of some
;;; core language constructs and essential macros

[def otherwise #t]
[defmacro deftest l #nil] ; Tests should be skipped when compiling

[defmacro comment body
          "Does nothing"
          #nil]

[defmacro += [val inc]
          `[set! ~val [+ ~val ~inc]]]

[def let [let*
              [defn let/arg [arg]
                    [when arg
                      [when [or [not [pair? arg]]
                                [not [symbol? [car arg]]]]
                        [throw [list :invalid-let-form "Please fix the structure of the let form" arg]]]
                      `[def ~[car arg] ~[cadr arg]]]]

              [defn let/args [args]
                    [if-not args #nil
                            [cons [let/arg [car args]]
                                  [let/args [cdr args]]]]]
              [defmacro let [bindings . body]
                        "Evalutes to BODY if PRED is true"
                        `[let* [do ~@[let/args bindings] ~@body]]]]]

[defn boolean [v] :inline
      "Coerce to boolean"
      [if v #t #f]]

[defn not [v] :inline
      "Return true if V is false"
      [if v #f #t]]

[defn identity [α] :inline
      "Returns its argument"
      α]

[defn list arguments
      "Return ARGUMENTS as a list"
      arguments]

[defn caar [p] :inline
      "[car [car p]]"
      [car [car p]]]

[defn cadr [p] :inline
      "[car [cdr p]]"
      [car [cdr p]]]

[defn cdar [p] :inline
      "[cdr [car p]]"
      [cdr [car p]]]

[defn cddr [p] :inline
      "[cdr [cdr p]]"
      [cdr [cdr p]]]

[defn cadar [p]
      "[cdr [car p]]"
      [car [cdr [car p]]]]

[defn caddr [p]
      "[car [cdr [cdr p]]]"
      [car [cdr [cdr p]]]]

[defn cdddr [p]
      "[cdr [cdr [cdr p]]]"
      [cdr [cdr [cdr p]]]]

[defn cadddr [p]
      "[car [cdr [cdr [cdr p]]]]"
      [car [cdr [cdr [cdr p]]]]]

[defn cddddr [p]
      "[car [cdr [cdr [cdr p]]]]"
      [cdr [cdr [cdr [cdr p]]]]]

[defn caddddr [p]
      "[car [cdr [cdr [cdr p]]]]"
      [car [cdr [cdr [cdr [cdr p]]]]]]

[defn cdddddr [p]
      "[cdr [cdr [cdr [cdr p]]]]"
      [cdr [cdr [cdr [cdr [cdr p]]]]]]

[defn keyword->string [kw]
      "Convert a keyword into a string"
      ""
      "kw: The input keyword"
      ""
      "Returns the string for kw"
      :cat :type-conversion
      :related string->keyword
      [deftest "asd" [keyword->string :asd]]

      [when-not [keyword? kw] [exception :type-error "[keyword->string] can only be called on keywords" kw]]
      [string [keyword->symbol kw]]]

[defn string->keyword [kw]
      "Convert a string into a keyword"
      ""
      "kw: The input string"
      ""
      "Returns the keyword for kw"
      :cat :type-conversion
      :related keyword->string
      [deftest :asd [string->keyword "asd"]]

      [when-not [string? kw] [exception :type-error "[string->keyword] can only be called on strings" kw]]
      [symbol->keyword [string->symbol kw]]]

[defmacro exception [type description value]
          `[throw [list ~type ~description ~value [current-lambda]]]]
