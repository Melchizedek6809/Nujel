; Nujel - Copyright (C) 2020-2021 - Benjamin Vincent Schulenburg
; This project uses the MIT license, a copy should be included under /LICENSE

;; Some predicates that were simpler to do in nujel

[defun numeric? [a]
        "Return #t if a is a number"
        [or [int? a] [float? a] [vec? a]]]

[defun last? [a]
        "Return #t if a is the last pair in a list"
        [nil? [cdr a]]]

[defun pos? [a]
        "Return #t if a is positive"
        [and [numeric? a] [>= [float a] 0.0]]]

[defun zero-neg? [a]
        "Return #t if a is zero or negative"
        [and [numeric? a] [<= [float a] 0.0]]]

[defun neg? [a]
        "Returns #t if a is negative"
        [and [numeric? a] [< [float a] 0.0]]]

[defun odd? [a]
        "Predicate that returns #t if a is odd"
        [== [% [int a] 2] 1]]

[defun even? [a]
        "Predicate that returns #t if a is even"
        [== [mod/int [int a] 2] 0]]

[defun zero? [val]
        "#t if VAL is zero"
        [== 0 val]]

[defun not-zero? [val]
        "#t if VAL is not zero"
        [!= 0 val]]

[defun equal? [a b]
       "High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow."
       [def cur-type [type-of a]]
       [if [!= cur-type [type-of b]]
           #f
           [case cur-type
                 [:array [array/equal? a b]]
                 [:tree [tree/equal? a b]]
                 [:pair [list/equal? a b]]
                 [otherwise [== a b]]]]]

[defun inequal? [a b]
       "High level inequality comparator"
       [not [equal? a b]]]

[defun int? [val]
        "#t if VAL is a integer"
        [== :int [type-of val]]]

[defun float? [val]
        "#t if VAL is a floating-point number"
        [== :float [type-of val]]]

[defun vec? [val]
        "#t if VAL is a vector"
        [== :vec [type-of val]]]

[defun bool? [val]
        "#t if VAL is a boolean"
        [== :bool [type-of val]]]

[defun pair? [val]
        "#t if VAL is a pair"
        [== :pair [type-of val]]]

[defun array? [val]
	"#t if VAL is an array"
	[== :array [type-of val]]]

[defun string? [val]
        "#t if VAL is a string"
        [== :string [type-of val]]]

[defun symbol? [val]
        "#t if VAL is a symbol"
        [== :symbol [type-of val]]]

[defun object? [val]
        "#t if VAL is an object"
        [== :object [type-of val]]]

[defun tree? [val]
        "#t if VAL is an object"
        [== :tree [type-of val]]]

[defun macro? [val]
        "#t if VAL is an object"
        [== :macro [type-of val]]]

[defun lambda? [val]
        "#t if VAL is a lambda"
        [or [== :lambda [type-of val]]]]

[defun native? [val]
        "#t if VAL is a native function"
        [== :native-function [type-of val]]]

[defun special-form? [val]
        "#t if VAL is a native function"
        [== :special-form [type-of val]]]

[defun procedure? [val]
        "#t if VAL is a native or lisp function"
        [or [lambda? val] [native? val] [special-form? val]]]

[defun bytecode-array? [v]
       [== :bytecode-array [type-of v]]]

[defun bytecode-op? [v]
       [== :bytecode-op [type-of v]]]

[defun in-range? [v min max]
       [and [>= v min] [<= v max]]]
