;; Some predicates that were simpler to do in nujel

[defun number? [a]
        "Return #t if a is a number"
        [or [int? a] [float? a] [vec? a]]
]

[defun empty? [a]
        "Return #t if a is empty"
        [nil? a]
]

[defun last? [a]
        "Return #t if a is the last pair in a list"
        [nil? [cdr a]]
]

[defun pos? [a]
        "Return #t if a is positive"
        [>= a 0]
]

[defun zn? [a]
        "Return #t if a is zero or negative"
        [<= a 0]
]

[defun neg? [a]
        "Returns #t if a is negative"
        [< a 0]
]

[defun odd? [a]
        "Predicate that returns #t if a is odd"
        [= [% [int a] 2] 1]
]

[defun even? [a]
        "Predicate that returns #t if a is even"
        [= [% [int a] 2] 0]
]

[defun zero? [val]
        "#t if VAL is zero"
        [eq? 0 val]
]

[defun not-zero? [val]
        "#t if VAL is not zero"
        [ineq? 0 val]
]

[defun list-equal? [a b]
        "#t if A and B are equal"
        [when [eq? [type-of a] [type-of b]]
              [if [pair? a]
                  [and [list-equal? [car a] [car b]]
                      [list-equal? [cdr a] [cdr b]]]
                  [eq? a b]]
        ]
]

[defun there-exists? [l pred]
        "Applies predicate to each element and return #t if it holds true for any element, otherwise #f"
        [cond [[nil? l] #f]
              [[pred [car l]] #t]
              [#t [there-exists? [cdr l] pred]]
        ]
]

[defun for-all? [l pred]
        "Applies predicate to each element returns #t if it holds true for every element, otherwise #f"
        [cond [[nil? l] #t]
              [[not [pred [car l]]] #f]
              [#t [for-all? [cdr l] pred]]
        ]
]

[defun int? [val]
        "#t if VAL is a integer"
        [eq? :int [type-of val]]
]

[defun float? [val]
        "#t if VAL is a floating-point number"
        [eq? :float [type-of val]]
]

[defun vec? [val]
        "#t if VAL is a vector"
        [eq? :vec [type-of val]]
]

[defun bool? [val]
        "#t if VAL is a boolean"
        [eq? :bool [type-of val]]
]

[defun inf? [val]
        "#t if VAL is infinite"
        [eq? :infinity [type-of val]]
]

[defun pair? [val]
        "#t if VAL is a pair"
        [eq? :pair [type-of val]]
]

[defun arr? [val]
	"#t if VAL is an array"
	[eq? :array [type-of val]]
]

[defun string? [val]
        "#t if VAL is a string"
        [eq? :string [type-of val]]
]

[defun symbol? [val]
        "#t if VAL is a symbol"
        [eq? :symbol [type-of val]]
]

[defun object? [val]
        "#t if VAL is an object"
        [eq? :object [type-of val]]
]

[defun tree? [val]
        "#t if VAL is an object"
        [eq? :tree [type-of val]]
]

[defun macro? [val]
        "#t if VAL is an object"
        [eq? :macro [type-of val]]
]

[defun lambda? [val]
        "#t if VAL is a lambda"
        [or [eq? :lambda [type-of val]] [eq? :dynamic [type-of val]]]
]

[defun native? [val]
        "#t if VAL is a native function"
        [eq? :native-function [type-of val]]
]

[defun procedure? [val]
        "#t if VAL is a native or lisp function"
        [or [lambda? val] [native? val]]
]

[defun in-range? [v min max]
       [and [>= v min] [<= v max]]
]
