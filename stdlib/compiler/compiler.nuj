[defn load/forms [source environment]
      "Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined"
      [doseq [form source]
             [apply environment [compile* source environment]]]]

[defn macroexpand/forms [source-raw environment]
      "Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined."
      [when-not environment [set! environment [ω]]]
      [load/forms source-raw environment]
      [macroexpand source-raw environment]]

[defn compile* [source environment]
      "Compile SOURCE so it can be evaluated/applied"
      [-> [macroexpand source environment]
          constant-fold
          backend]]

[defn compile/debug [expr]
      [disassemble [compile expr]]]

[defn compile/do* [source environment]
      [compile* [cons do source] environment]]

[defmacro compile [source]
          "Compile SOURCE so it can be evaluated/applied"
          `[compile* ~source [current-closure]]]

[defmacro compile/do [source]
          "Compile SOURCE so it can be evaluated/applied"
          `[compile* [cons do ~source] [current-closure]]]

[defn meta/parse/body [type args body]
      [def meta @[]]
      [doseq [v body]
             [case [type-of v]
                   [:pair [return meta]]
                   [:string [tree/set! meta :documentation [trim [cat [string [tree/ref meta :documentation]]
                                                                      "\n"
                                                                       v]]]]
                   [:keyword [tree/set! meta v #t]]]]
      [return meta]]

[defmacro defmacro [name args . body]
          "Define a new macro"
          `[def ~name [macro* '~name
                               '~args
                               ~[tree/set! [meta/parse/body :macro args body] :source body]
                               '~[compile/do* body [current-closure]]]]]

[defmacro fn [args . body]
          "Define an anonymous function"
          `[fn* 'anonymous
                 '~args
                 ~[tree/set! [meta/parse/body :lambda args body] :source body]
                 '~[compile/do* body [current-closure]]]]

[defmacro defn [name args . body]
          "Define a new function"
          `[def ~name [fn* '~name
                            '~args
                            ~[tree/set! [meta/parse/body :lambda args body] :source body]
                            '~[compile/do* body [current-closure]]]]]

[defmacro ω body
          "Defines and returns new object after evaluating body within"
          [macroexpand [cons 'ω* body]]]
[def defobj ω]

[defn eval-in [closure expr]
      "Compile and the immediatly evaluate the result"
      ""
      "Mostly used by lRun()"
      [try display/error
           [apply closure
                  [compile* expr closure]]]]

[defmacro eval [expr]
          "Compile, Evaluate and then return the result of EXPR"
          `[eval-in [current-closure] ~expr]]

[defmacro typecheck/only [v t]
          `[when-not [= [type-of ~v] ~t] [throw [list :type-error ~[fmt "Expected a value of type {t}"] ~v [current-lambda]]]]]

[defn typecheck/numeric/single [v]
      `[when-not [numeric? ~v] [throw [list :type-error ~[fmt "Expected numeric value"] ~v [current-lambda]]]]]

[defmacro typecheck/numeric v
          [map v typecheck/numeric/single]]
