;;; Nujel - Copyright (C) 2020-2021 - Benjamin Vincent Schulenburg
;;; This project uses the MIT license, a copy should be included under /LICENSE
;;;
(import (VT100) :term/VT100)

(defclass TermApp
  "A high-level I/O interface for a terminal"
  :export

  (defn new (self in out)
        (def term (:new VT100 in out))
        (:start term)
        (def ret { :term term
                   :width 0
                   :height 0
                   :frontbuffer #nil
                   :backbuffer #nil
                   :input-buffer (buffer/allocate 16)
                   :input-buffer-pos 0
                   :event-queue #nil
                   :cursor-x -1
                   :cursor-y -1
                   :prototype* self })
        (:resize ret))

  (defn start (self)
        self)

  (defn stop (self)
        (:stop self.term)
        self)

  (defn resize (self)
        (def term self.term)
        (def size (:get-size term))
        (def buf-size (* 2 size.width size.height))
        (set! self.width size.width)
        (set! self.height size.height)
        (set! self.frontbuffer (buffer/allocate buf-size))
        (set! self.backbuffer (buffer/allocate buf-size)))

  (defn flip (self)
        (def backbuffer self.backbuffer)
        (def frontbuffer self.frontbuffer)
        (def term self.term)
        (:hide-cursor term)
        (def last-color -1)
        (def pos-x -1)
        (def pos-y -1)
        (dotimes (y self.height)
                 (dotimes (x self.width)
                          (def off (* 2 (+ x (* y self.width))))
                          (def bc  (+ (ref backbuffer off)
                                      (bit-shift-left (ref backbuffer (inc off)) 8)))
                          (def fc  (+ (ref frontbuffer off)
                                      (bit-shift-left (ref frontbuffer (inc off)) 8)))
                          (when (not= fc bc)
                            (when (or (not= x pos-x)
                                      (not= y pos-y))
                              (:move-cursor term x y))
                            (set! pos-y y)
                            (set! pos-x (inc x))
                            (when (not= (bit-shift-right bc 8) last-color)
                              (:set-color-code term (bit-shift-right bc 8))
                              (set! last-color (bit-shift-right bc 8)))
                            (:put-char term (bit-and #xFF bc))
                            (set! frontbuffer off (bit-and bc #xFF))
                            (set! frontbuffer (inc off) (bit-shift-right bc 8)))))
        (when (and (> self.cursor-x 0)
                   (> self.cursor-y 0)
                   (< self.cursor-x self.width)
                   (< self.cursor-y self.height))
          (:move-cursor term self.cursor-x self.cursor-y)
          (:show-cursor term))
        (:flip self.term)
        self)

  (defn draw-char (self char x y color)
        (when (>= x self.width) (return))
        (when (>= y self.height) (return))
        (when (< x 0) (return))
        (when (< y 0) (return))
        (def off (* 2 (+ x (* y self.width))))
        (def color color)
        (set! self.backbuffer off char)
        (set! self.backbuffer (inc off) color))

  (defn set-cursor (self x y)
       (set! self.cursor-x x)
       (set! self.cursor-y y))

  (defn clear-screen (self)
        (def bb self.backbuffer)
        (dotimes (i (:length bb) self)
                 (set! bb i 0)))

  (defn draw-text (self text x y w h color)
        (set! x (max 0 x))
        (set! y (max 0 y))
        (set! w (min (- self.width x) w (:length text)))
        (set! h (min (- self.height y) h))
        (def off (* 2 (+ x (* y self.width))))
        (def bb self.backbuffer)
        (dotimes (i w self)
                 (set! bb off (ref text i))
                 (set! bb (inc off) color)
                 (set! off (+ off 2))))

  (defn get-size (self)
        { :width self.width
          :height self.height })

  (defn pop-input-buffer! (self bytes)
        (dotimes (i (:length self.input-buffer))
          (def src-pos (+ i self.input-buffer-pos))
          (def src-key (if (< src-pos (:length self.input-buffer))
                           (ref self.input-buffer (+ i self.input-buffer-pos))
                           0))
          (set! self.input-buffer i src-key))
        (set! self.input-buffer-pos 0)
        (return self))

  (defn add-input-event (self event)
        (set! self.event-queue (cons event self.event-queue)))

  (defn parse-input-buffer (self)
        (when (zero? self.input-buffer-pos) (return))

        (def c (ref self.input-buffer 0))
        (when (= c 194) ;; Meta digit Input
          (def d (ref self.input-buffer 1))
          (when (= d 0)
            (return))
          (when (and (>= d 160) (<= d 191))
            (def key (:keyword (fmt "M-{}" (from-char-code (+ #x20 (- d 160))))))
            (:add-input-event self { :T :key-down :key key })
            (:pop-input-buffer! self 2)
            (return (:parse-input-buffer self)))
          (exception :invalid-input (fmt "Unknown meta input: {d:X}") d))
        (when (= c 195) ;; Meta Char Input
          (def d (ref self.input-buffer 1))
          (when (= d 0)
            (return))
          (when (and (>= d 129) (<= d 186))
            (def key (:keyword (fmt "M-{}" (from-char-code (+ #x20 (- d 96))))))
            (:add-input-event self { :T :key-down :key key })
            (:pop-input-buffer! self 2)
            (return (:parse-input-buffer self)))
          (exception :invalid-input (fmt "Unknown meta input: {d:X}") d))
        (when (= c #x1B) ; Escaped Input
          (def d (ref self.input-buffer 1))
          (when (= d #x1B) ; Double Escape
            (:add-input-event self { :T :key-down :key :escape })
            (:pop-input-buffer! self 2)
            (return (:parse-input-buffer self)))
          (when (= d 79) ; F Input
            (def e (ref self.input-buffer 2))
            (when (and (>= e 80) (< e 92))
              (def key (:keyword (fmt "F{}" (- e 79))))
              (:add-input-event self { :T :key-down :key key })
              (:pop-input-buffer! self 3)
              (return (:parse-input-buffer self))))
          (when (= d #\[) ; Bracketed Input
            (def e (ref self.input-buffer 2))
            (case e
                  (0 (return))
                  #;(0 (:add-input-event self { :T :key-down :key (:keyword "M-[") })
                     (:pop-input-buffer! self 2)
                     (return (:parse-input-buffer self)))
                  ((#x32 #x33 #x35 #x36)
                   (def f (ref self.input-buffer 3))
                   (when (= f 0) (return))
                   (when (= f #x37)
                     (:add-input-event self { :T :key-down :key :print })
                     (:pop-input-buffer! self 4)
                     (return (:parse-input-buffer self)))
                   (when (= f 126)
                     (case e
                           (#x32 (:add-input-event self { :T :key-down
                                                :key :insert }))
                           (#x33 (:add-input-event self { :T :key-down
                                                :key :delete }))
                           (#x35 (:add-input-event self { :T :key-down
                                                :key :page-up }))
                           (#x36 (:add-input-event self { :T :key-down
                                                          :key :page-down }))
                           (otherwise (exception :invalid-input (fmt "Unknown bracketed input: {e:X}") e)))
                     (:pop-input-buffer! self 4)
                     (return (:parse-input-buffer self)))
                   (exception :invalid-input (fmt "Unknown bracketed input suffix: {f:X}") f))
                  (#\A (:add-input-event self { :T :key-down
                                                :key :up }))
                  (#\B (:add-input-event self { :T :key-down
                                                :key :down }))
                  (#\C (:add-input-event self { :T :key-down
                                                :key :right }))
                  (#\D (:add-input-event self { :T :key-down
                                                :key :left }))
                  (#\F (:add-input-event self { :T :key-down
                                                :key :end }))
                  (#\H (:add-input-event self { :T :key-down
                                                :key :home }))
                  (otherwise (exception :invalid-input (fmt "Unknown bracketed input: {e:X}") e)))
            (:pop-input-buffer! self 3)
            (return (:parse-input-buffer self)))
          (when (= d 127)
            (:add-input-event self { :T :key-down :key :M-backspace })
            (:pop-input-buffer! self 2)
            (return (:parse-input-buffer self)))
          (when (= d #\Tab)
            (:add-input-event self { :T :key-down :key :M-tab })
            (:pop-input-buffer! self 2)
            (return (:parse-input-buffer self)))
          (when (and (>= d #\0) (<= d #\9))
            (def key (:keyword (fmt "M-{}" (from-char-code d))))
            (:add-input-event self { :T :key-down :key key })
            (:pop-input-buffer! self 2)
            (return (:parse-input-buffer self)))
          (when (and (>= d #x20) (< d #x79))
            (def key (:keyword (fmt "M-{}" (from-char-code d))))
            (:add-input-event self { :T :key-down :key key })
            (:pop-input-buffer! self 2)
            (return (:parse-input-buffer self)))
          (when (and (>= d #\a) (<= d #\z))
            (def key (:keyword (fmt "M-{}" (from-char-code d))))
            (:add-input-event self { :T :key-down :key key })
            (:pop-input-buffer! self 2)
            (return (:parse-input-buffer self))))
        (when (< c 27)
          (when (= c 0)
            (:add-input-event self { :T :key-down :key :C-spc })
            (:pop-input-buffer! self 1)
            (return (:parse-input-buffer self)))
          (when (< c 9)
            (def key (:keyword (fmt "C-{}" (from-char-code (+ #\a (dec c))))))
            (:add-input-event self { :T :key-down :key key })
            (:pop-input-buffer! self 1)
            (return (:parse-input-buffer self)))
          (when (= c 9)
            (:add-input-event self { :T :key-down :key :tab })
            (:pop-input-buffer! self 1)
            (return (:parse-input-buffer self)))
          (when (= c 13)
            (:add-input-event self { :T :key-down :key :ret })
            (:pop-input-buffer! self 1)
            (return (:parse-input-buffer self)))
          (def key (:keyword (fmt "C-{}" (from-char-code (+ #\j (- c 10))))))
            (:add-input-event self { :T :key-down :key key })
            (:pop-input-buffer! self 1)
            (return (:parse-input-buffer self)))
        (when (and (> c 27) (< c 32))
          (when (= c 31)
            (:add-input-event self { :T :key-down :key :C-/ })
            (:pop-input-buffer! self 1)
            (return (:parse-input-buffer self)))
          (when (> c 27)
            (def key (:keyword (fmt "C-{}" (from-char-code (+ #\[ (- c 27))))))
            (:add-input-event self { :T :key-down :key key })
            (:pop-input-buffer! self 1)
            (return (:parse-input-buffer self))))
        (when (= c 127)
          (:add-input-event self { :T :key-down :key :backspace })
          (:pop-input-buffer! self 1)
          (return (:parse-input-buffer self)))
        (when (and (>= c #x20) (<  c #x80))
          (:add-input-event self { :T :input
                                   :code c
                                   :char (buffer->string self.input-buffer 1 0)
                                   })
          (:pop-input-buffer! self 1)
          (return (:parse-input-buffer self))))

  (defn parse-input-key (self key)
        (when key
          (:add-input-event self { :T :raw-input :code key })
          (set! self.input-buffer self.input-buffer-pos key)
          (set! self.input-buffer-pos (inc self.input-buffer-pos)))
        (:parse-input-buffer self))

  (defn get-events (self)
        (when-not self.event-queue (return #nil))
        (def ret (car self.event-queue))
        (set! self.event-queue (cdr self.event-queue))
        (return ret))

  (defn poll-input (self)
        (def key (:poll-input self.term))
        (:parse-input-key self key)
        key)

  (defn poll-events (self)
        (:poll-input self)
        (:get-events self)))
