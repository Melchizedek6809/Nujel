/* This file is auto-generated, manual changes will be overwritten! */
unsigned char stdlib_no_data[] = "#{##(bit-shift-right (cur-val shift-amount) #@(documentation: \"Shift all the bits in cur-val to the right by shift-amount\\n\\ncur-val: The integer val whose bits we want to shift\\nshift-amount: The amount of digits we want to shift the value by\\n\\nA shifted integer\" cat: :bitwise-operations tests: ((16 (bit-shift-right 16 0)) (1 (bit-shift-right 16 4)) (0 (bit-shift-right 16 8)))) #{##(bit-shift-left cur-val - shift-amount)\n"
"0E000E010E020E030401040201\n"
"} bit-test? (test-val bit-pos) #@(documentation: \"Test bit at position i\\n\\nWe check if test-val has a 1 at bit-pos and return #t if that is the case\\n\\ntest-val: The integer in which to look for the bit\\nbit-pos: Which bit to look for, with 0 being the least significant digit\\n\\nA boolean signifying whether the bit is set or not\" cat: :bitwise-operations tests: ((#f (bit-test? 9 7)) (#f (bit-test? 9 1)) (#t (bit-test? 9 0)))) #{##(type-of test-val :int throw list :type-error \"Expected a value of type :int\" current-lambda bit-pos bit-and bit-shift-left)\n"
"0E000E0104011A02200B0007240900150E030E041A051A060E010E0704000404\n"
"04010D0E000E0804011A02200B0007240900150E030E041A051A060E080E0704\n"
"00040404010D0E090E010E0A02010E08040204022A0B00071C0900041B01\n"
"} bit-set (cur-val bit-pos) #@(documentation: \"Set bit-pos within cur-val to 1\\n\\ncur-val: The integer where we set the bit in\\nbit-pos: The index of the bit we want to change, with 0 being the least significant digit\\n\\nAn integer cur-val but with a guaranteed 1 at bit-pos\" cat: :bitwise-operations tests: ((15 (bit-set 11 2)))) #{##(bit-or cur-val bit-shift-left bit-pos)\n"
"0E000E010E0202010E030402040201\n"
"} bit-flip (cur-val bit-pos) #@(documentation: \"Flip the bit at bit-pos within cur-val\\n\\ncur-val: The integer where we flip the bit in\\nbit-pos: The index of the bit we want to flip, with 0 being the least significant digit\\n\\nAn integer cur-val but with the bit at position bit-pos flipped\" cat: :bitwise-operations tests: ((11 (bit-flip 15 2)) (15 (bit-flip 11 2)))) #{##(bit-xor cur-val bit-shift-left bit-pos)\n"
"0E000E010E0202010E030402040201\n"
"} bit-clear (cur-val bit-pos) #@(documentation: \"Clear the bit at bit-pos within cur-val\\n\\ncur-val: The integer where we clear the bit in\\nbit-pos: The index of the bit we want to clear, with 0 being the least significant digit\\n\\nAn integer cur-val but with the bit at position bit-pos forced to 0\" cat: :bitwise-operations tests: ((11 (bit-clear 11 2)) (9 (bit-clear 11 1)))) #{##(bit-and cur-val bit-not bit-shift-left bit-pos)\n"
"0E000E010E020E0302010E0404020401040201\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A081A091A0A1A0B\n"
"1707080D1A0C1A0D1A0E1A0F17070C0D1A101A111A121A1317071001\n"
"}#{##(array/+= (a i v) #@(documentation: \"Add V to the value in A at position I and store the result in A returning A\") #{##(array/set! a i v ref)\n"
"0E000E010E020E030E040E010E02040225040301\n"
"} array/++ (a i) #@(documentation: \"Increment position I in A and return A\") #{##(array/+= a i)\n"
"0E000E010E020201040301\n"
"} array/fill! (a v) #@(documentation: \"Fills array a with value v\") #{##(array/length a len i array/set! v)\n"
"0E000E01040107020D15020007030D240900140D0E040E010E030E0504030D0E\n"
"032305030E030E021E0AFFEA0D0E011601\n"
"} array/append (a b) #@(documentation: \"Append array A to array B\") #{##(:array type-of a b throw list :type-error \"array/append expects two arrays as its arguments\" current-lambda array/allocate array/length ret i array/set! ref rl)\n"
"1A000E010E020401200C0B000D0D1A000E010E030401200B0007240900140E04\n"
"0E051A061A07240E080400040404010D0E090E0A0E0204010E0A0E0304012504\n"
"01070B0D150200070C0D2409001A0D0E0D0E0B0E0C0E0E0E020E0C040204030D\n"
"0E0C23050C0E0C0E0A0E0204011E0AFFE00D24160D150E0A0E020401070C0D0E\n"
"0A0E0B0401070F0D240900230D0E0D0E0B0E0C0E0E0E030E0C0E0A0E02040126\n"
"040204030D0E0C020103050C0E0C0E0F1E0AFFDB160D0E0B0101\n"
"} array/dup (a) #@(documentation: \"Duplicate Array A\") #{##(array/allocate array/length a ret i array/set! ref)\n"
"0E000E010E020401040107030D15020007040D2409001A0D0E050E030E040E06\n"
"0E020E04040204030D0E042305040E040E010E0204011E0AFFE00D0E031601\n"
"} array/reduce (arr fun α) #@(documentation: \"Reduce an array, (reduce) should be preferred\") #{##(array/length arr len i fun α ref)\n"
"0E000E01040107020D15020007030D2409001A0D0E040E050E060E010E030402\n"
"040205050D0E032305030E030E021E0AFFE40D0E051601\n"
"} array/map (arr fun) #@(documentation: \"Map an array, (map) should be preferred\") #{##(array/length arr len i array/set! fun ref)\n"
"0E000E01040107020D15020007030D2409001E0D0E040E010E030E050E060E01\n"
"0E030402040104030D0E032305030E030E021E0AFFE00D0E011601\n"
"} array/filter (arr pred) #@(documentation: \"Filter an array, (filter) should be preferred\") #{##(ri array/length arr len array/allocate ret ai pred ref array/set! array/length!)\n"
"020007000D0E010E02040107030D0E040E03040107050D15020007060D240900\n"
"350D0E070E080E020E06040204010B001E0E090E050E000E080E020E06040204\n"
"030D0E000201250500090004240D0E062305060E060E031E0AFFC90D0E0A0E05\n"
"0E0004021601\n"
"} array/equal? (a b) #@() #{##(:array type-of a b not= array/length #f i equal? ref)\n"
"1A000E010E020401200B00071C0900041B0C0A00310D1A000E010E030401200B\n"
"00071C0900041B0C0A001B0D0E040E050E0204010E050E03040104020C0A0006\n"
"0D1A060B00081C0109004015020007070D240900270D0E080E090E020E070402\n"
"0E090E030E07040204020B0007240900051C010D0E072305070E070E050E0204\n"
"011E0AFFD30D1B1601\n"
"} array/push (arr val) #@(documentation: \"Append VAL to ARR\") #{##(array/set! array/length! arr array/length val)\n"
"0E000E010E0202010E030E0204012504020E030E0204010201260E04040301\n"
"} array/swap (arr i j) #@(documentation: \"Swap values at I and J in ARR\") #{##(ref arr i tmp array/set! j)\n"
"0E000E010E02040207030D0E040E040E010E020E000E010E05040204030E050E\n"
"03040301\n"
"} array/heapify (arr n at) #@(documentation: \"bubble up the element from index AT to until the max-heap property is satisfied\") #{##(at top looping bit-shift-left l r n ref arr array/swap)\n"
"0E0007010D1B07020D2409008B0D0E030E000201040202012507040D0E030E00\n"
"0201040202022507050D0E040E061E0C0B00150D0E070E080E0404020E070E08\n"
"0E010402220B000A0E040501090004240D0E050E061E0C0B00150D0E070E080E\n"
"0504020E070E080E010402220B000A0E050501090004240D0E010E00200B0009\n"
"1C05020900120E090E080E000E0104030D0E0105000E020AFF760D0E080101\n"
"} array/make-heap (arr) #{##(array/length arr l div/int l2 array/heapify)\n"
"0E000E01040107020D0E030E020202040207040D240900160D0E050E010E020E\n"
"0404030D0E0402012605040E040200210AFFE80D0E010101\n"
"} array/heap-sort (arr) #{##(array/make-heap arr array/length l array/swap array/heapify)\n"
"0E000E0104010D0E020E01040107030D240900210D0E0302012605030D0E040E\n"
"0102000E0304030D0E050E010E03020004030E030200220AFFDD0D0E010101\n"
"} array/sort array/cut (arr start end) #@(documentation: \"Return a newly allocated array with the values of ARR from START to END\") #{##(max start min array/length arr end array/allocate ret i array/set! ref)\n"
"0E0002000E01040205010D0E020E030E0404010E05040205050D0E060E000200\n"
"0E050E01260402040107070D0E0107080D2409001F0D0E090E070E080E01260E\n"
"0A0E040E08040204030D0E0802010305080E080E051E0AFFDF0D0E070101\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A081A091A0A1A0B\n"
"1707080D1A0C1A0D1A0E1A0F17070C0D1A101A111A121A131707100D1A141A15\n"
"1A161A171707140D1A181A191A1A1A1B1707180D1A1C1A1D1A1E1A1F17071C0D\n"
"1A201A211A221A231707200D1A241A251A261A271707240D1A281A291A2A1A2B\n"
"1707280D151A2C1A2D1A2E1A2F17072C0D1A301A311A221A321707300D1A331A\n"
"341A221A351707331607330D0E3307360D1A371A381A391A3A17073701\n"
"}#{##(sum (collection) #@(documentation: \"Return the sum of every value in collection\\n\\ncollection: The collection to sum, can be a List, Vector or something else supported by reduce.\\n\\nThe numeric sum of all the elements of collection\" cat: :collection-operations tests: ((6 (sum '(1 2 3))) (15 (sum (array/new 1 2 3 4 5))) (10 (+ (sum '(1 2 3)) (apply (fn (α) (+ 1 α)) '(3)))) (:type-error (try car (sum 123))) (:type-error (try car (sum '(1 2 3 . 4)))))) #{##(reduce collection +)\n"
"0E000E010E020200040301\n"
"} every? (collection predicate?) #@(documentation: \"Returns whether predicate? is #t for every member of the collection\\n\\ncollection: The collection to test, can be a List, Vector or something else supported by reduce.\\npredicate?: A function that takes a single argument and returns a bool.\\n\\nWhether every invocation returned #t or not\" cat: :collection-operations tests: ((#t (every? (array/new #nil) float?)) (#t (every? (array/new 1.0 6.0) float?)) (#f (every? (array/new 1 2 3 4 5 6.0) int?)) (#t (every? (array/new 1 2 3 4 5 6) int?)) (#f (every? '(#nil) float?)) (#t (every? '(1.0 6.0) float?)) (#f (every? '(1 2 3 4 5 6.0) int?)) (#t (every? '(1 2 3 4 5 6) int?)))) #{##(reduce collection anonymous (a b) #@() #{##(a predicate? b)\n"
"0E000C0B000A0D0E010E02040101\n"
"})\n"
"0E000E011A021A031A041A05171B040301\n"
"} count (collection predicate?) #@(documentation: \"Count the number of items in the collection where predicate? is #t.\\nIf no predicate is provided, it will count the number of elements instead.\\n\\ncollection: The collection to count in\\npredicate?: Optional, a function that takes a single argument which is then called for every item.\\n\\nThe number of times predicate? returned #t\" cat: :collection-operations tests: ((0 (count '(1 2 3 4 5 6) float?)) (6 (count '(1 2 3 4 5 6) int?)) (3 (count '(1 2 3 4 5 6) even?)) (3 (count '(1 2 3 4 5 6) odd?)) (2 (count (array/new 1 2 3 4) even?)) (3 (count (array/new 1 2 3))) (3 (count '(1 2 3))) (1 (count (array/new 1))) (1 (count '(1))) (0 (count (array/new #nil))) (0 (count #nil)))) #{##(predicate? reduce collection anonymous (a b) #@() #{##(a predicate? b)\n"
"0E000E010E0204010B0008020109000502002501\n"
"} (a b) #{##(a)\n"
"0E0002012501\n"
"})\n"
"0E000B00170E010E021A031A041A051A0617020004030900140E010E021A031A\n"
"071A051A08170200040301\n"
"} delete (l e) #@(documentation: \"Returns a filtered list l with all elements equal to e omitted\") #{##(filter l anonymous (a) #@() #{##(a e)\n"
"0E000E01200B00071C0900041B01\n"
"})\n"
"0E000E011A021A031A041A0517040201\n"
"} remove (l p) #@(documentation: \"Returns a filtered list l with all elements where P equal true removed\") #{##(filter l anonymous (a) #@() #{##(p a)\n"
"0E000E0104010B00071C0900041B01\n"
"})\n"
"0E000E011A021A031A041A0517040201\n"
"} flatten-λ (a b) #@() #{##(type-of b ΓεnΣym-1 :pair :array :tree #f append reduce flatten-λ a)\n"
"150E000E01040107020D0E021A03200C0A001A0D0E021A04200C0A00100D0E02\n"
"1A05200C0A00060D1A060B00071B0900041C160B00150E070E080E010E092404\n"
"030E0A04020900101B0B000B0E010E0A140900042401\n"
"} flatten (l) #@(documentation: \"Flatten a collection of collections into a simple list\") #{##(type-of l ΓεnΣym-2 :pair :array :tree #f nreverse reduce flatten-λ)\n"
"150E000E01040107020D0E021A03200C0A001A0D0E021A04200C0A00100D0E02\n"
"1A05200C0A00060D1A060B00071B0900041C160B00130E070E080E010E092404\n"
"0304010900050E0101\n"
"} join (l glue) #@(documentation: \"Join every element of α together into a string with GLUE inbetween\") #{##(glue \"\" l reduce anonymous (a b) #@() #{##(a cat glue b)\n"
"0E000B00100E010E000E020E0304030900050E0301\n"
"})\n"
"0E000B0007240900071A0105000D0E020B00160E030E021A041A051A061A0717\n"
"2404030900051A0101\n"
"} for-each (l f) #@(documentation: \"Runs F over every item in collection L\") #{##(reduce l anonymous (a b) #@() #{##(f b)\n"
"0E000E01040101\n"
"})\n"
"0E000E011A021A031A041A051724040301\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A081A091A0A1A0B\n"
"1707080D1A0C1A0D1A0E1A0F17070C0D1A101A111A121A131707100D151A141A\n"
"151A161A171707140D1A181A191A1A1A1B1707181607180D1A1C1A1D1A1E1A1F\n"
"17071C0D1A201A211A221A2317072001\n"
"}#{##(filter (l p) #@(documentation: \"Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true\") #{##(type-of l ΓεnΣym-1 :nil :pair list/filter p :array array/filter :tree tree/filter throw list :type-error \"You can only filter collections\" current-lambda)\n"
"150E000E01040107020D0E021A03200B00072409004E0E021A04200B000E0E05\n"
"0E010E06040209003B0E021A07200B000E0E080E010E0604020900280E021A09\n"
"200B000E0E0A0E010E0604020900150E0B0E0C1A0D1A0E0E010E0F0400040404\n"
"011601\n"
"} reduce (l f α) #@(documentation: \"Combine all elements in collection l using operation F and starting value α\") #{##(type-of l ΓεnΣym-2 :nil α :tree tree/reduce f :array array/reduce :pair list/reduce throw list :type-error \"You can only reduce collections\" current-lambda)\n"
"150E000E01040107020D0E021A03200B00080E040900540E021A05200B00100E\n"
"060E010E070E04040309003F0E021A08200B00100E090E010E070E0404030900\n"
"2A0E021A0A200B00100E0B0E010E070E0404030900150E0C0E0D1A0E1A0F0E01\n"
"0E100400040404011601\n"
"} length (α) #@(documentation: \"Returns the length of collection α\") #{##(type-of α ΓεnΣym-3 :nil :pair list/length :array array/length :tree tree/size :buffer :string :buffer-view #f buffer/length throw list :type-error \"You can only use length with a collection\" current-lambda)\n"
"150E000E01040107020D0E021A03200B000802000900740E021A04200B000C0E\n"
"050E0104010900630E021A06200B000C0E070E0104010900520E021A08200B00\n"
"0C0E090E0104010900410E021A0A200C0A001A0D0E021A0B200C0A00100D0E02\n"
"1A0C200C0A00060D1A0D0B000C0E0E0E0104010900150E0F0E101A111A120E01\n"
"0E130400040404011601\n"
"} map (l f) #@(documentation: \"Runs f over every item in collection l and returns the resulting list\") #{##(type-of l ΓεnΣym-4 :nil :pair list/map f :array array/map throw list :type-error \"You can only use map with a collection\" current-lambda)\n"
"150E000E01040107020D0E021A03200B00072409003B0E021A04200B000E0E05\n"
"0E010E0604020900280E021A07200B000E0E080E010E0604020900150E090E0A\n"
"1A0B1A0C0E010E0D0400040404011601\n"
"} sort (l) #@(documentation: \"Sorts the collection L\") #{##(type-of l ΓεnΣym-5 :nil :pair list/sort :array array/sort throw list :type-error \"You can only use sort with a collection\" current-lambda)\n"
"150E000E01040107020D0E021A03200B0007240900370E021A04200B000C0E05\n"
"0E0104010900260E021A06200B000C0E070E0104010900150E080E091A0A1A0B\n"
"0E010E0C0400040404011601\n"
"} cut (l start end) #@(documentation: \"Return a subcollection of L from START to END\") #{##(type-of l ΓεnΣym-6 :pair list/cut start end :array array/cut :string string/cut throw list :type-error \"You can only use member with a collection\" current-lambda)\n"
"150E000E01040107020D0E021A03200B00100E040E010E050E06040309003F0E\n"
"021A07200B00100E080E010E050E06040309002A0E021A09200B00100E0A0E01\n"
"0E050E0604030900150E0B0E0C1A0D1A0E0E010E0F0400040404011601\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A081A091A0A1A0B\n"
"1707080D1A0C1A0D1A0E1A0F17070C0D1A101A111A121A131707100D1A141A15\n"
"1A161A1717071401\n"
"}#{##(cdr! (l) #@(documentation: \"(set! l (cdr l))\") #{##(set! l cdr)\n"
"1A000E011A020E012414142414141401\n"
"} cons! (v l) #@(documentation: \"Cons V onto L and set! the value for L\") #{##(set! l cons v)\n"
"1A000E011A020E030E01241414142414141401\n"
"} except-last-pair/iter (list rest) #@(documentation: \"Iterator for except-last-pair\") #{##(nil? list reverse rest except-last-pair/iter)\n"
"0E000E011204010B000C0E020E0304010900100E040E01120E01110E03140402\n"
"01\n"
"} except-last-pair (list) #@(documentation: \"Return a copy of LIST without the last pair\") #{##(except-last-pair/iter list)\n"
"0E000E0124040201\n"
"} last-pair (list) #@(documentation: \"Return the last pair of LIST\") #{##(list)\n"
"240900090D0E001205000E00120AFFF70D0E0001\n"
"} range (end start step) #@(documentation: \"Return a list containing values from START (inclusive) to END (exclusive) by STEP\") #{##(end throw list :arity-error \"(range) needs at least a specific end\" current-lambda start step 0.0 < > pred ret nreverse)\n"
"0E000B0007240900140E010E021A031A04240E050400040404010D0E060B0007\n"
"24090007020005060D0E070B000724090007020105070D0E071A08210B00080E\n"
"090900050E0A070B0D24070C0D240900130D0E060E0C14050C0D0E060E072505\n"
"060E0B0E060E0004020AFFE80D0E0D0E0C040101\n"
"} list/reduce (l o s) #@(documentation: \"Combine all elements in l using operation o and starting value s\") #{##(l ΓεnΣym-1 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" e o s)\n"
"150E0007010D240900600D1A020E030E010401200B0007240900150E040E051A\n"
"061A070E000E080400040404010D0E030E0104011A02200B0007240900150E04\n"
"0E051A061A090E010E080400040404010D0E0111070A0D0E0B0E0C0E0A040205\n"
"0C0D0E011205010E010AFFA10D0E0C1601\n"
"} reverse (l) #@(documentation: \"Return the list l in reverse order\") #{##(ret l ΓεnΣym-2 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" e)\n"
"2407000D150E0107020D2409005D0D1A030E040E020401200B0007240900150E\n"
"050E061A071A080E010E090400040404010D0E040E0204011A03200B00072409\n"
"00150E050E061A071A0A0E020E090400040404010D0E0211070B0D0E0B0E0014\n"
"05000D0E021205020E020AFFA40D0E001601\n"
"} list/length (l) #@(documentation: \"Returns the length of list l\") #{##(ret l ΓεnΣym-3 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" e)\n"
"020007000D150E0107020D2409005D0D1A030E040E020401200B000724090015\n"
"0E050E061A071A080E010E090400040404010D0E040E0204011A03200B000724\n"
"0900150E050E061A071A0A0E020E090400040404010D0E0211070B0D0E000201\n"
"2505000D0E021205020E020AFFA40D0E001601\n"
"} list/filter (l p) #@(documentation: \"Runs predicate p over every item in list l and returns a list consiting solely of items where p is true\") #{##(ret l ΓεnΣym-4 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" e p nreverse)\n"
"2407000D150E0107020D2409006A0D1A030E040E020401200B0007240900150E\n"
"050E061A071A080E010E090400040404010D0E040E0204011A03200B00072409\n"
"00150E050E061A071A0A0E020E090400040404010D0E0211070B0D0E0C0E0B04\n"
"010B000D0E0B0E00140500090004240D0E021205020E020AFF970D0E0D0E0004\n"
"011601\n"
"} list/map (l f) #@(documentation: \"Runs f over every item in list l and returns the resulting list\") #{##(ret l ΓεnΣym-5 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" e f nreverse)\n"
"2407000D150E0107020D240900610D1A030E040E020401200B0007240900150E\n"
"050E061A071A080E010E090400040404010D0E040E0204011A03200B00072409\n"
"00150E050E061A071A0A0E020E090400040404010D0E0211070B0D0E0C0E0B04\n"
"010E001405000D0E021205020E020AFFA00D0E0D0E0004011601\n"
"} append (a b) #@(documentation: \"Appends two lists A and B together\") #{##(b ret reverse a ΓεnΣym-6 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" t)\n"
"0E0007010D0E020E03040105030D150E0307040D2409005D0D1A050E060E0404\n"
"01200B0007240900150E070E081A091A0A0E030E0B0400040404010D0E060E04\n"
"04011A05200B0007240900150E070E081A091A0C0E040E0B0400040404010D0E\n"
"0411070D0D0E0D0E011405010D0E041205040E040AFFA40D0E011601\n"
"} list/merge-sorted-lists (l1 l2 pred) #@() #{##(nil? l1 l2 pred list/merge-sorted-lists)\n"
"0E000E0104010B00080E020900470E000E0204010B00080E010900391B0B0034\n"
"0E030E01110E021104020B00150E01110E040E01120E020E030403140900120E\n"
"02110E040E010E02120E030403140900042401\n"
"} list/split-half-rec (l acc1 acc2) #{##(nil? l acc1 acc2 list/split-half-rec)\n"
"0E000E0104010B000B0E020E03140900360E000E011204010B000F0E01110E02\n"
"140E03140900201B0B001B0E040E0112120E01110E02140E0112110E03140403\n"
"0900042401\n"
"} list/split-half (l) #{##(list/split-half-rec l)\n"
"0E000E012424040301\n"
"} list/sort/merge (l pred) #@(documentation: \"Sorts a list\") #{##(pred < nil? l list/split-half parts list/merge-sorted-lists list/sort/merge)\n"
"0E000B0007240900070E0105000D0E020E031204010B00080E030900240E040E\n"
"03040107050D0E060E070E05110E0004020E070E05120E0004020E00040301\n"
"} list-merge-sort list/sort list? (a) #@(documentation: \"Return #t is A is a proper list\") #{##(a :pair type-of)\n"
"0E000B0007240900051C010D2409001C0D1A010E020E000401200B0007240900\n"
"051C010D0E001205000E000AFFE50D1B0101\n"
"} list/equal? (a b) #@(documentation: \"#t if A and B are equal\") #{##(:pair type-of a list/equal? b equal?)\n"
"1A000E010E020401200B001F0E030E02110E041104020C0B000E0D0E030E0212\n"
"0E0412040209000B0E050E020E04040201\n"
"} list-take (l count) #@(documentation: \"Take the first COUNT elements from list L\") #{##(count l list-take)\n"
"0E0002001F0B0007240900130E01110E020E01120E0002012604021401\n"
"} list-drop (l count) #@(documentation: \"Drop the final COUNT elements from list L\") #{##(count l list-drop)\n"
"0E0002001F0B00080E0109000F0E020E01120E00020126040201\n"
"} list/cut (l start end) #@(documentation: \"Return a subsequence of L from START to END\") #{##(list-take list-drop l max start end)\n"
"0E000E010E020E0302000E04040204020E050E0302000E04040226040201\n"
"} list/replace (l search-for replace-with) #@(documentation: \"Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH\\n\\nUses (equal?) so we can search/replace lists/trees and other complex data structures\") #{##(l equal? search-for replace-with list/replace :pair type-of)\n"
"0E000B00071C0900041B0B0007240900620E010E000E0204020B00080E030900\n"
"520E010E00110E0204020B00140E030E040E00120E020E030403140900351B0B\n"
"00301A050E060E00110401200B00110E040E00110E020E0304030900060E0011\n"
"0E040E00120E020E030403140900042401\n"
"})\n"
"1A001A011A021A031807000D1A041A051A061A071807040D151A081A091A0A1A\n"
"0B1707080D1A0C1A0D1A0E1A0F17070C16070C0D1A101A111A121A131707100D\n"
"1A141A151A161A171707140D1A181A191A1A1A1B1707180D1A1C1A1D1A1E1A1F\n"
"17071C0D1A201A211A221A231707200D1A241A251A261A271707240D1A281A29\n"
"1A2A1A2B1707280D1A2C1A2D1A2E1A2F17072C0D151A301A311A321A33170730\n"
"0D1A341A351A321A361707340D1A371A381A321A391707370D1A3A1A3B1A3C1A\n"
"3D17073A16073E0D0E3E073F0D1A401A411A421A431707400D1A441A451A461A\n"
"471707440D1A481A491A4A1A4B1707480D1A4C1A4D1A4E1A4F17074C0D1A501A\n"
"511A521A531707500D1A541A551A561A5717075401\n"
"}#{##(tree/zip (keys values) #@(documentation: \"Return a tree where KEYS point to VALUES\") #{##(tree/new ret keys ΓεnΣym-1 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" key tree/set! values)\n"
"0E0024040107010D150E0207030D240900670D1A040E050E030401200B000724\n"
"0900150E060E071A081A090E020E0A0400040404010D0E050E0304011A04200B\n"
"0007240900150E060E071A081A0B0E030E0A0400040404010D0E0311070C0D0E\n"
"0D0E010E0C0E0E1104030D0E0E12050E0D0E031205030E030AFF9A0D0E011601\n"
"} tree/+= (t k v) #@(documentation: \"Increment value at K in T by V\") #{##(tree/set! t k v int ref #f)\n"
"0E000E010E020E030E040E050E010E0204020C0A000D0D02000C0A00060D1A06\n"
"040125040301\n"
"} tree/-= (t k v) #@(documentation: \"Decrement value at K in T by V\") #{##(tree/+= t k - v)\n"
"1A000E010E021A030E04241414241414141401\n"
"} tree/++ (t k) #@(documentation: \"Increment value at K in T by 1\") #{##(tree/+= t k)\n"
"1A000E010E020201241414141401\n"
"} tree/-- (t k) #{##(tree/-= t k)\n"
"1A000E010E020201241414141401\n"
"} tree/equal? (a b) #@(documentation: \"Compares two trees for equality\") #{##(:tree type-of a b tree/key* equal? tree/value* tree/equal? tree/left* tree/right*)\n"
"1A000E010E020401200C0B000D0D1A000E010E030401200B00520E040E020401\n"
"0E040E030401200C0B003E0D0E050E060E0204010E060E03040104020C0B0029\n"
"0D0E070E080E0204010E080E03040104020C0B00140D0E070E090E0204010E09\n"
"0E030401040209000B0E050E020E03040201\n"
"} tree/reduce (l o s) #@(documentation: \"Combine all elements in l using operation o and starting value s\") #{##(list/reduce tree/values l o s)\n"
"0E000E010E0204010E030E04040301\n"
"} tree/filter (l f) #@(documentation: \"Return a new tree with all elements from L where F returns true\") #{##(tree/new ret tree/keys l ΓεnΣym-2 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" e ref t f tree/set!)\n"
"0E0024040107010D150E020E03040107040D2409007C0D1A050E060E04040120\n"
"0B0007240900190E070E081A091A0A0E020E0304010E0B0400040404010D0E06\n"
"0E0404011A05200B0007240900150E070E081A091A0C0E040E0B040004040401\n"
"0D0E0411070D0D0E0E0E030E0D0402070F0D0E100E0F04010B00100E110E010E\n"
"0D0E0F0403090004240D0E041205040E040AFF850D0E011601\n"
"} tree/merge (a b) #@(documentation: \"Merge two trees together, if a key is contained in both trees the on in B gets priority\") #{##(b a tree/dup tree/new ret tree/keys ΓεnΣym-3 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" k tree/set! ref)\n"
"0E000B0007240900170E010B000C0E020E0104010900080E03240401010D0E01\n"
"0B00072409000A0E020E000401010D0E020E01040107040D150E050E00040107\n"
"060D2409006A0D1A070E080E060401200B0007240900190E090E0A1A0B1A0C0E\n"
"050E0004010E0D0400040404010D0E080E0604011A07200B0007240900150E09\n"
"0E0A1A0B1A0E0E060E0D0400040404010D0E0611070F0D0E100E040E0F0E110E\n"
"000E0F040204030D0E061205060E060AFF970D0E041601\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A081A091A0A1A0B\n"
"1807080D1A0C1A0D1A0E1A0F18070C0D1A101A111A0E1A121807100D1A131A14\n"
"1A151A161707130D1A171A181A191A1A1707170D1A1B1A1C1A1D1A1E17071B0D\n"
"1A1F1A201A211A2217071F01\n"
"}#{##($nop (#nil) #@(documentation: \"() -> () --- Do Nothing\" source: (\"() -> () --- Do Nothing\" :cat :bytecode :internal :inline '(#$0)) cat: :bytecode internal: #t inline: #t) #{##((#$0))\n"
"1A0001\n"
"} $ret (#nil) #@(documentation: \"(a) -> () --- Return top of value stack\" source: (\"(a) -> () --- Return top of value stack\" :cat :bytecode :internal :inline '(#$1)) cat: :bytecode internal: #t inline: #t) #{##((#$1))\n"
"1A0001\n"
"} $add/int (#nil) #@(documentation: \"(a b) -> (result) --- Adds the two topmost values and pushes the result\" source: (\"(a b) -> (result) --- Adds the two topmost values and pushes the result\" :cat :bytecode :internal :inline '(#$3)) cat: :bytecode internal: #t inline: #t) #{##((#$3))\n"
"1A0001\n"
"} $dup (#nil) #@(documentation: \"(a) -> (a a) --- Duplicates the value that is on the top of the stack\" source: (\"(a) -> (a a) --- Duplicates the value that is on the top of the stack\" :cat :bytecode :internal :inline '(#$C)) cat: :bytecode internal: #t inline: #t) #{##((#$C))\n"
"1A0001\n"
"} $drop (#nil) #@(documentation: \"(a) -> () --- Drop whatever is on top of the stack\" source: (\"(a) -> () --- Drop whatever is on top of the stack\" :cat :bytecode :internal :inline '(#$D)) cat: :bytecode internal: #t inline: #t) #{##((#$D))\n"
"1A0001\n"
"} $closure/push (#nil) #@(documentation: \"() -> (closure) --- Push the current closure as a λ on the stack\" source: (\"() -> (closure) --- Push the current closure as a λ on the stack\" :cat :bytecode :internal :inline '(#$13)) cat: :bytecode internal: #t inline: #t) #{##((#$13))\n"
"1A0001\n"
"} $let (#nil) #@(documentation: \"() -> () --- Create a new let closure and switch to it\" source: (\"() -> () --- Create a new let closure and switch to it\" :cat :bytecode :internal :inline '(#$15)) cat: :bytecode internal: #t inline: #t) #{##((#$15))\n"
"1A0001\n"
"} $closure/pop (#nil) #@(documentation: \"() -> () --- Leave the current closure and return to the parent one\" source: (\"() -> () --- Leave the current closure and return to the parent one\" :cat :bytecode :internal :inline '(#$16)) cat: :bytecode internal: #t inline: #t) #{##((#$16))\n"
"1A0001\n"
"} $< (#nil) #@(documentation: \"(a b) -> (bool) --- Compare A and B and push the result on the stack\" source: (\"(a b) -> (bool) --- Compare A and B and push the result on the stack\" :cat :bytecode :internal :inline '(#$1E)) cat: :bytecode internal: #t inline: #t) #{##((#$1E))\n"
"1A0001\n"
"} $<= (#nil) #@(documentation: \"(a b) -> (bool) --- Compare A and B and push the result on the stack\" source: (\"(a b) -> (bool) --- Compare A and B and push the result on the stack\" :cat :bytecode :internal :inline '(#$1F)) cat: :bytecode internal: #t inline: #t) #{##((#$1F))\n"
"1A0001\n"
"} $= (#nil) #@(documentation: \"(a b) -> (bool) --- Compare A and B and push the result on the stack\" source: (\"(a b) -> (bool) --- Compare A and B and push the result on the stack\" :cat :bytecode :internal :inline '(#$20)) cat: :bytecode internal: #t inline: #t) #{##((#$20))\n"
"1A0001\n"
"} $>= (#nil) #@(documentation: \"(a b) -> (bool) --- Compare A and B and push the result on the stack\" source: (\"(a b) -> (bool) --- Compare A and B and push the result on the stack\" :cat :bytecode :internal :inline '(#$21)) cat: :bytecode internal: #t inline: #t) #{##((#$21))\n"
"1A0001\n"
"} $> (#nil) #@(documentation: \"(a b) -> (bool) --- Compare A and B and push the result on the stack\" source: (\"(a b) -> (bool) --- Compare A and B and push the result on the stack\" :cat :bytecode :internal :inline '(#$22)) cat: :bytecode internal: #t inline: #t) #{##((#$22))\n"
"1A0001\n"
"} $push/nil (#nil) #@(documentation: \"() -> (nil) --- Push a #nil on the stack\" source: (\"() -> (nil) --- Push a #nil on the stack\" :cat :bytecode :internal :inline '(#$24)) cat: :bytecode internal: #t inline: #t) #{##((#$24))\n"
"1A0001\n"
"} $car (#nil) #@(documentation: \"(l) -> (car) --- Replace L with its car\" source: (\"(l) -> (car) --- Replace L with its car\" :cat :bytecode :internal :inline '(#$11)) cat: :bytecode internal: #t inline: #t) #{##((#$11))\n"
"1A0001\n"
"} $cdr (#nil) #@(documentation: \"(l) -> (cdr) --- Replace L with its cdr\" source: (\"(l) -> (cdr) --- Replace L with its cdr\" :cat :bytecode :internal :inline '(#$12)) cat: :bytecode internal: #t inline: #t) #{##((#$12))\n"
"1A0001\n"
"} $cons (#nil) #@(documentation: \"(car cdr) -> (pair) --- Cons CAR and CDR together and put it on the stack\" source: (\"(car cdr) -> (pair) --- Cons CAR and CDR together and put it on the stack\" :cat :bytecode :internal :inline '(#$14)) cat: :bytecode internal: #t inline: #t) #{##((#$14))\n"
"1A0001\n"
"} $fn/dynamic (#nil) #@(documentation: \"(name args docs body) -> (λ) --- Create a new λ\" source: (\"(name args docs body) -> (λ) --- Create a new λ\" :cat :bytecode :internal :inline '(#$17)) cat: :bytecode internal: #t inline: #t) #{##((#$17))\n"
"1A0001\n"
"} $macro/dynamic (#nil) #@(documentation: \"(name args docs body) -> (μ) --- Create a new μ\" source: (\"(name args docs body) -> (μ) --- Create a new μ\" :cat :bytecode :internal :inline '(#$18)) cat: :bytecode internal: #t inline: #t) #{##((#$18))\n"
"1A0001\n"
"} $add (#nil) #@(documentation: \"(a b) -> (result)\" source: (\"(a b) -> (result)\" :cat :bytecode :internal :inline '(#$25)) cat: :bytecode internal: #t inline: #t) #{##((#$25))\n"
"1A0001\n"
"} $sub (#nil) #@(documentation: \"(a b) -> (result)\" source: (\"(a b) -> (result)\" :cat :bytecode :internal :inline '(#$26)) cat: :bytecode internal: #t inline: #t) #{##((#$26))\n"
"1A0001\n"
"} $mul (#nil) #@(documentation: \"(a b) -> (result)\" source: (\"(a b) -> (result)\" :cat :bytecode :internal :inline '(#$27)) cat: :bytecode internal: #t inline: #t) #{##((#$27))\n"
"1A0001\n"
"} $div (#nil) #@(documentation: \"(a b) -> (result)\" source: (\"(a b) -> (result)\" :cat :bytecode :internal :inline '(#$28)) cat: :bytecode internal: #t inline: #t) #{##((#$28))\n"
"1A0001\n"
"} $rem (#nil) #@(documentation: \"(a b) -> (result)\" source: (\"(a b) -> (result)\" :cat :bytecode :internal :inline '(#$29)) cat: :bytecode internal: #t inline: #t) #{##((#$29))\n"
"1A0001\n"
"} $push/true (#nil) #@(documentation: \"() -> (#t)\" source: (\"() -> (#t)\" :cat :bytecode :internal :inline '(#$1B)) cat: :bytecode internal: #t inline: #t) #{##((#$1B))\n"
"1A0001\n"
"} $push/false (#nil) #@(documentation: \"() -> (#f)\" source: (\"() -> (#f)\" :cat :bytecode :internal :inline '(#$1C)) cat: :bytecode internal: #t inline: #t) #{##((#$1C))\n"
"1A0001\n"
"} $eval (#nil) #@(documentation: \"(bc env) -> (return-val)\" source: (\"(bc env) -> (return-val)\" :cat :bytecode :internal :inline '(#$1D)) cat: :bytecode internal: #t inline: #t) #{##((#$1D))\n"
"1A0001\n"
"} $zero? (#nil) #@(documentation: \"(a) -> (result)\" source: (\"(a) -> (result)\" :cat :bytecode :internal :inline '(#$2A)) cat: :bytecode internal: #t inline: #t) #{##((#$2A))\n"
"1A0001\n"
"} $inc/int (#nil) #@(documentation: \"(a) -> (result) --- Adds 1 to the topmost int\" source: (\"(a) -> (result) --- Adds 1 to the topmost int\" :cat :bytecode :internal :inline '(#$23)) cat: :bytecode internal: #t inline: #t) #{##((#$23))\n"
"1A0001\n"
"} int-fit-in-byte? (a) #@() #{##(a)\n"
"0E00027F1F0C0B00090D0E0002802101\n"
"} $push/int (a) #@(documentation: \"() -> (a) --- Push A on the stack as an :int\" cat: :bytecode internal: #t) #{##(int-fit-in-byte? a $push/int/byte $push/val)\n"
"0E000E0104010B000C0E020E0104010900090E030E01040101\n"
"} $push/int/byte (a) #@(documentation: \"() -> (a) --- Push A on the stack as an :int that fits within a byte\" cat: :bytecode internal: #t) #{##(int-fit-in-byte? a throw list :invalid-bc-op \"$push/int/byte can only push a signed 8-bit value\" current-lambda #$2 int->bytecode-op)\n"
"0E000E0104010B0007240900150E020E031A041A050E010E060400040404010D\n"
"0E031A070E080E010401040201\n"
"} $apply/optimize? (fun arg-count) #@(cat: :bytecode internal: #t) #{##(fun ΓεnΣym-1 + - * / rem bytecode-eval* #f arg-count zero? car cdr add/int inc/int cons < <= = >= >)\n"
"150E0007010D0E010E02200C0A00380D0E010E03200C0A002E0D0E010E04200C\n"
"0A00240D0E010E05200C0A001A0D0E010E06200C0A00100D0E010E07200C0A00\n"
"060D1A080B000B0E0902022009007B0E010E0A200C0A006A0D0E010E0B200C0A\n"
"00600D0E010E0C200C0A00560D0E010E0D200C0A004C0D0E010E0E200C0A0042\n"
"0D0E010E0F200C0A00380D0E010E10200C0A002E0D0E010E11200C0A00240D0E\n"
"010E12200C0A001A0D0E010E13200C0A00100D0E010E14200C0A00060D1A080B\n"
"00071B090004241601\n"
"} $apply/optimized (arg-count fun) #@(documentation: \"arguments -> (result) --- Read arg-count arguments from the stack, apply the to fun and push the result on the stack\" cat: :bytecode internal: #t) #{##(arg-count ΓεnΣym-2 fun ΓεnΣym-3 car (#$11) cdr (#$12) zero? (#$2A) inc/int (#$23) throw list :arity-error \"Wrong number of arguments for that function\" current-lambda ΓεnΣym-4 add/int (#$3) + (#$25) - (#$26) * (#$27) / (#$28) rem (#$29) cons (#$14) < (#$1E) <= (#$1F) = (#$20) >= (#$21) > (#$22) bytecode-eval* (#$1D))\n"
"150E0007010D0E010201200B0053150E0207030D0E030E04200B00081A050900\n"
"3C0E030E06200B00081A0709002F0E030E08200B00081A090900220E030E0A20\n"
"0B00081A0B0900150E0C0E0D1A0E1A0F0E020E10040004040401160900E20E01\n"
"0202200B00C8150E0207110D0E110E12200B00081A130900B10E110E14200B00\n"
"081A150900A40E110E16200B00081A170900970E110E18200B00081A1909008A\n"
"0E110E1A200B00081A1B09007D0E110E1C200B00081A1D0900700E110E1E200B\n"
"00081A1F0900630E110E20200B00081A210900560E110E22200B00081A230900\n"
"490E110E24200B00081A2509003C0E110E26200B00081A2709002F0E110E2820\n"
"0B00081A290900220E110E2A200B00081A2B0900150E0C0E0D1A0E1A0F0E020E\n"
"10040004040401160900150E0C0E0D1A0E1A0F0E020E100400040404011601\n"
"} $apply (arg-count fun) #{##(arg-count 255 throw list :arity-error \"Functions can only take up to 255 arguments directly, try to pass a list/array/map instead\" current-lambda #$4 int->bytecode-op)\n"
"0E001A01220B00180E020E031A041A050E000E06040004040401090004240D0E\n"
"031A070E080E000401040201\n"
"} $try (target) #@(documentation: \"() -> () --- Try something, jumping to target if an exception occurs\" cat: :bytecode internal: #t) #{##(list #$19 :relocate target int->bytecode-op)\n"
"0E001A010E001A020E03020802000E040200040104050E001A020E0302000201\n"
"0E04020004010405040301\n"
"} $jmp (target) #{##(list #$9 :relocate target int->bytecode-op)\n"
"0E001A010E001A020E03020802000E040200040104050E001A020E0302000201\n"
"0E04020004010405040301\n"
"} $push/val (v) #@(documentation: \"() -> (v) --- Pushes v onto the stack\" cat: :bytecode internal: #t) #{##(nil? v throw list :invalid-bc-op \"Can't push #nil as a normal lVal\" current-lambda #$1A :literal)\n"
"0E000E0104010B00180E020E031A041A050E010E06040004040401090004240D\n"
"0E031A070E031A080E010402040201\n"
"} $push/val/ext $get/val (v) #@(documentation: \"() -> (v) --- Resolve V and get the associated value on the stack\" cat: :bytecode internal: #t) #{##(:symbol type-of v throw list :invalid-bc-op \"Can only get symbol\" current-lambda #$E :literal)\n"
"1A000E010E020401200B0007240900150E030E041A051A060E020E0704000404\n"
"04010D0E041A080E041A090E020402040201\n"
"} $set/val (v) #@(documentation: \"(v) -> (v) --- Resolve V and get the associated value on the stack\" cat: :bytecode internal: #t) #{##(:symbol type-of v throw list :invalid-bc-op \"Can only get symbol\" current-lambda #$5 :literal)\n"
"1A000E010E020401200B0007240900150E030E041A051A060E020E0704000404\n"
"04010D0E041A080E041A090E020402040201\n"
"} $def/val (v) #{##(:symbol type-of v throw list :invalid-bc-op \"Can only get symbol\" current-lambda #$7 :literal)\n"
"1A000E010E020401200B0007240900150E030E041A051A060E020E0704000404\n"
"04010D0E041A080E041A090E020402040201\n"
"} $jt (target) #{##(list #$A :relocate target int->bytecode-op)\n"
"0E001A010E001A020E03020802000E040200040104050E001A020E0302000201\n"
"0E04020004010405040301\n"
"} $jf (target) #{##(list #$B :relocate target int->bytecode-op)\n"
"0E001A010E001A020E03020802000E040200040104050E001A020E0302000201\n"
"0E04020004010405040301\n"
"} $fn (name args docs body) #{##(list #$25 val->bytecode-op name args docs body)\n"
"0E001A010E020E0304010E020E0404010E020E0504010E020E060401040501\n"
"} $macro* (name args docs body) #{##(list #$26 val->bytecode-op name args docs body)\n"
"0E001A010E020E0304010E020E0404010E020E0504010E020E060401040501\n"
"} assemble/build-sym-map (code sym-map pos) #{##(type-of code ΓεnΣym-5 :bytecode-op tree/set! sym-map :last-op pos :keyword ΓεnΣym-6 :label :literal :pair assemble/build-sym-map)\n"
"2409008A0D150E000E0111040107020D0E021A03200B00150E040E051A060E07\n"
"0201250507040309005D0E021A08200B003C150E011107090D0E091A0A200B00\n"
"180E040E050E0112110E0704030D0E011205010900140E091A0B200B000B0E01\n"
"120501090004241609001C0E021A0C200B00130E0D0E01110E050E0704030507\n"
"09000424160D0E011205010E010AFF770D0E070101\n"
"} assemble/relocate-op (code sym-map pos out) #{##(ref sym-map code target pos off array/set! out int->bytecode-op bit-and bit-shift-right 255)\n"
"0E000E010E021211040207030D0E030E0212121211250E042607050D0E060E07\n"
"0E0402012505040E080E090E0A0E050E0212121104021A0B0402040104030D0E\n"
"040101\n"
"} assemble/emit-relocated-ops (code sym-map pos out) #{##(code :relocate assemble/relocate-op sym-map pos out ΓεnΣym-7 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" op ΓεnΣym-8 :bytecode-op array/set! assemble/emit-relocated-ops)\n"
"0E00111A01200B00140E020E000E030E040E05040405040900A8150E0007060D\n"
"240900950D1A070E080E060401200B0007240900150E090E0A1A0B1A0C0E000E\n"
"0D0400040404010D0E080E0604011A07200B0007240900150E090E0A1A0B1A0E\n"
"0E060E0D0400040404010D0E0611070F0D150E080E0F040107100D0E101A1120\n"
"0B00150E120E050E0402012505040E0F040309001D0E101A07200B00140E130E\n"
"0F0E030E040E050404050409000424160D0E061205060E060AFF6C0D0E041601\n"
"} literal-index->bytecode-op (i) #{##(i 256 int->bytecode-op list bit-and bit-shift-right 255)\n"
"0E001A011E0B000C0E020E0004010900250E030E020E040E050E00020804021A\n"
"06040204010E020E040E001A0604020401040201\n"
"} *max-literal-arr* assemble/add-literal (lit lit-arr) #{##(array/length lit-arr 65535 throw list :out-of-bounds \"Can only store up to 255 literals per bytecode-arr\" code current-lambda not= type-of lit :pair i equal? ref literal-index->bytecode-op array/length! array/set!)\n"
"0E000E0104011A02210B00180E030E041A051A060E070E080400040404010900\n"
"04240D0E090E0A0E0B04011A0C04020B0042150200070D0D240900260D0E0E0E\n"
"0F0E010E0D04020E0B04020B000D0E100E0D040101090004240D0E0D23050D0E\n"
"0D0E000E0104011E0AFFD40D2416090004240D0E110E0102010E000E01040125\n"
"04020D0E120E010E000E0104010201260E0B04030D0E100E000E010401020126\n"
"040101\n"
"} assemble/build-lit-arr (code lit-arr) #{##(code :pair type-of assemble/build-lit-arr lit-arr #$1A :literal assemble/add-literal index-op #$6 #$E #$F #$5 #$10 #$7 #$8 otherwise)\n"
"0E000B00072409000524010D1A010E020E00110401200B00190E030E00110E04\n"
"04020E030E00120E040402140901720E00111A05200C0B000C0D0E001211111A\n"
"06200B003A0E001205000D0E070E001112110E04040207080D1A010E020E0804\n"
"01200B00081A090900051A050E080E030E00120E04040214140901250E00111A\n"
"0A200C0B000C0D0E001211111A06200B003A0E001205000D0E070E001112110E\n"
"04040207080D1A010E020E080401200B00081A0B0900051A0A0E080E030E0012\n"
"0E04040214140900D80E00111A0C200C0B000C0D0E001211111A06200B003A0E\n"
"001205000D0E070E001112110E04040207080D1A010E020E080401200B00081A\n"
"0D0900051A0C0E080E030E00120E040402141409008B0E00111A0E200C0B000C\n"
"0D0E001211111A06200B003A0E001205000D0E070E001112110E04040207080D\n"
"1A010E020E080401200B00081A0F0900051A0E0E080E030E00120E0404021414\n"
"09003E1A060E0011200B001F0E001205000D0E070E00110E0404020E030E0012\n"
"0E040402140900190E100B00130E00110E030E00120E040402140900042401\n"
"} assemble/flatten (code ret) #{##(code ret :pair type-of assemble/flatten :keyword)\n"
"0E000B0007240900060E01010D1A020E030E000401200B0007240900060E0101\n"
"0D0E040E00120E01040205010D1A020E030E00110401200C0B00170D1A050E03\n"
"0E0011110401200B00071C0900041B0B000F0E040E00110E0104020900090E00\n"
"110E011401\n"
"} assemble* (code) #@(documentation: \"Assemble all arguments into a single :bytecode-array\" cat: :bytecode internal: #t) #{##(tree/new sym-map array/new lit-arr assemble/build-lit-arr assemble/flatten code tmp assemble/build-sym-map array/allocate ref :last-op out assemble/emit-relocated-ops arr->bytecode-arr)\n"
"0E0024040107010D0E0224040107030D0E040E050E0604010E03040207070D0E\n"
"080E070E01020004030D0E090E0A0E011A0B04020401070C0D0E0D0E070E0102\n"
"FF0E0C04040D0E0E0E0C0E03040201\n"
"} assemble l #{##(assemble* l)\n"
"0E000E01040101\n"
"} asmrun ops #@(documentation: \"Assemble and evaluate all bytecode arguments\" cat: :bytecode internal: #t) #{##(bytecode-eval* assemble append ops current-closure)\n"
"1A001A010E020E03240402141A0424142414141401\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A081A091A0A1A0B\n"
"1707080D1A0C1A0D1A0E1A0F17070C0D1A101A111A121A131707100D1A141A15\n"
"1A161A171707140D1A181A191A1A1A1B1707180D1A1C1A1D1A1E1A1F17071C0D\n"
"1A201A211A221A231707200D1A241A251A261A271707240D1A281A291A2A1A2B\n"
"1707280D1A2C1A2D1A2E1A2F17072C0D1A301A311A321A331707300D1A341A35\n"
"1A361A371707340D1A381A391A3A1A3B1707380D1A3C1A3D1A3E1A3F17073C0D\n"
"1A401A411A421A431707400D1A441A451A461A471707440D1A481A491A4A1A4B\n"
"1707480D1A4C1A4D1A4E1A4F17074C0D1A501A511A521A531707500D1A541A55\n"
"1A561A571707540D1A581A591A5A1A5B1707580D1A5C1A5D1A5E1A5F17075C0D\n"
"1A601A611A621A631707600D1A641A651A661A671707640D1A681A691A6A1A6B\n"
"1707680D1A6C1A6D1A6E1A6F17076C0D1A701A711A721A731707700D1A741A75\n"
"1A761A771707740D1A781A791A7A1A7B1707780D1A7C1A7D1A7E1A7F17077C0D\n"
"1A801A811A821A831707800D1A841A851A861A871707840D1A881A891A861A8A\n"
"1707880D1A8B1A8C1A8D1A8E17078B0D1A8F1A901A821A9117078F0D1A921A93\n"
"1A941A951707920D0E9207960D1A971A981A991A9A1707970D1A9B1A9C1A9D1A\n"
"9E17079B0D1A9F1AA01A9D1AA117079F0D1AA21AA31A821AA41707A20D1AA51A\n"
"A61A821AA71707A50D1AA81AA91A821AAA1707A80D1AAB1AAC1A821AAD1707AB\n"
"0D151AAE1AAF1A761AB01707AE0D1AB11AB21A761AB31707B10D1AB41AB51A76\n"
"1AB61707B40D1AB71AB81A761AB91707B70D020007BA0D1ABB1ABC1A761ABD17\n"
"07BB0D1ABE1ABF1A761AC01707BE0D1AC11AC21A761AC31707C10D1AC41AC51A\n"
"C61AC71707C41607C40D1AC81AC91AC61ACA1707C80D1ACB1ACC1ACD1ACE1807\n"
"CB01\n"
"}#{##(bytecompile/gen-label/counter bytecompile/gen-label (prefix) #@() #{##(bytecompile/gen-label/counter string->symbol cat prefix \"label-\")\n"
"0E0002012505000D0E010E020E031A040E000403040101\n"
"} bytecompile/literal (source) #{##(type-of source ΓεnΣym-1 :int $push/int :nil (#$24) :bool (#$1B) (#$1C) :symbol list $get/val :native-function :lambda #f bytecompile/literal closure/name $push/val)\n"
"150E000E01040107020D0E021A03200B000C0E040E0104010900680E021A0520\n"
"0B00081A0609005B0E021A07200B00120E010B00081A080900051A090900440E\n"
"021A0A200B00100E0B0E0C0E010401040109002F0E021A0D200C0A00100D0E02\n"
"1A0E200C0A00060D1A0F0B00100E100E110E01040104010900090E120E010401\n"
"1601\n"
"} bytecompile/quote (source) #{##(type-of source ΓεnΣym-2 :nil (#$24) :int $push/int $push/val)\n"
"150E000E01040107020D0E021A03200B00081A0409001A0E021A05200B000C0E\n"
"060E0104010900090E070E0104011601\n"
"} bytecompile/do/form (source env) #{##(source bytecompile* env nil? (#$D) bytecompile/do/form)\n"
"0E000B002C0E010E00110E0204020E030E001204010B0007240900071A042414\n"
"140E050E00120E020402140900042401\n"
"} bytecompile/do (source env) #{##(list bytecompile/do/form source env)\n"
"0E000E010E02120E030402040101\n"
"} bytecompile/def (source env) #{##(:symbol type-of source #f throw list :type-error \"(def) needs a symbol name and a value as arguments\" env bytecompile* $def/val)\n"
"1A000E010E0212110401200B00071C0900041B0C0A00170D0E0212120B00071C\n"
"0900041B0C0A00060D1A030B00150E040E051A061A07240E0804040401090004\n"
"240D0E050E090E021212110E0804020E0A0E0212110401040201\n"
"} bytecompile/set! (source env) #{##(:symbol type-of source #f throw list :type-error \"(set!) needs a symbol name and a value as arguments\" env bytecompile* $set/val)\n"
"1A000E010E0212110401200B00071C0900041B0C0A00170D0E0212120B00071C\n"
"0900041B0C0A00060D1A030B00150E040E051A061A07240E0804040401090004\n"
"240D0E050E090E021212110E0804020E0A0E0212110401040201\n"
"} bytecompile/if (source env) #{##(bytecompile/gen-label sym-else sym-after list bytecompile* source env $jf $jmp :label)\n"
"150E00040007010D0E00040007020D0E030E040E0512110E0604020E070E0104\n"
"010E040E051212110E0604020E080E0204010E031A090E0104020E040E051212\n"
"12110E0604020E031A090E02040204071601\n"
"} bytecompile/while (source env) #{##(bytecompile/gen-label sym-start sym-end list (#$24) $jmp :label (#$D) bytecompile/do/form source env bytecompile* $jt)\n"
"0E00040007010D0E00040007020D0E031A040E050E0204010E031A060E010402\n"
"1A070E080E0912120E0A04020E031A060E0204020E0B0E0912110E0A04020E0C\n"
"0E010401040801\n"
"} bytecompile/procedure/arg (source env) #{##(nil? source bytecompile* env bytecompile/procedure/arg)\n"
"0E000E011204010B000F0E020E01110E0304020900160E020E01110E0304020E\n"
"040E01120E0304021401\n"
"} bytecompile/procedure/inline? (op) #{##(meta op :inline)\n"
"0E000E011A02040201\n"
"} bytecompile/procedure/inline (op args env) #{##(length args arg-count throw list :compiler-error \"For now only monadic functions can be inlined\" op env macroexpand do meta :source form closure/arguments arg-name bytecompile* list/replace)\n"
"0E000E01040107020D0E020201220B00160E030E041A051A060E070E08040404\n"
"01090004240D0E091A0A0E0B0E071A0C0402140E080402070D0D0E0E0E070401\n"
"11070F0D0E010B00170E100E110E0D0E0F0E011104030E08040209000B0E100E\n"
"0D0E08040201\n"
"} bytecompile/procedure (op args env op-raw) #{##(bytecompile/procedure/inline? op bytecompile/procedure/inline args env bytecompile/procedure/default op-raw)\n"
"0E000E0104010B00100E020E010E030E04040309000F0E050E010E030E040E06\n"
"040401\n"
"} bytecompile/procedure/default (op args env op-raw) #{##(procedure? op :symbol type-of :pair throw list :type-error \"Can't apply to that\" current-lambda length args arg-count $apply/optimize? bytecompile/procedure/arg $apply/optimized bytecompile* op-raw env $apply)\n"
"0E000E0104010B00071C0900041B0C0B002B0D1A020E030E010401200B00071C\n"
"0900041B0C0B00150D1A040E030E010401200B00071C0900041B0B00180E050E\n"
"061A071A080E010E09040004040401090004240D0E0A0E0B0401070C0D0E0D0E\n"
"010E0C04020B00210E060E0B0B000C0E0E0E0B0401090004240E0F0E0C0E0104\n"
"0204020900240E060E100E110E1204020E0B0B000C0E0E0E0B0401090004240E\n"
"130E0C0401040301\n"
"} bytecompile/and/rec (source env label-end) #{##(list bytecompile* source env (#$C) $jf label-end (#$D) bytecompile/and/rec)\n"
"0E000E010E02110E0304020E02120B001F0E001A040E050E0604011A070E080E\n"
"02120E030E060403040409000424040201\n"
"} bytecompile/and (source env) #{##(bytecompile/gen-label label-end list bytecompile/and/rec source env :label)\n"
"0E00040007010D0E020E030E04120E050E0104030E021A060E010402040201\n"
"} bytecompile/or/rec (source env label-end) #{##(source list bytecompile* env (#$C) $jt label-end (#$D) bytecompile/or/rec)\n"
"0E000B00280E010E020E00110E0304021A040E050E0604011A070E080E00120E\n"
"030E06040304050900042401\n"
"} bytecompile/or (source env) #{##(bytecompile/gen-label label-end list bytecompile/or/rec source env $push/val :label)\n"
"0E00040007010D0E020E030E04120E050E0104030E061C04010E021A070E0104\n"
"02040301\n"
"} bytecompile/fn* (source env) #{##(length source arg-count not= throw list :arity-error \"(fn*) needs exactly 4 arguments\" current-lambda bytecompile* env (#$17))\n"
"0E000E0112040107020D0E030E02020504020B00180E040E051A061A070E010E\n"
"08040004040401090004240D0E011205010D0E050E090E01110E0A04020E090E\n"
"0112110E0A04020E090E011212110E0A04020E090E01121212110E0A04021A0B\n"
"040501\n"
"} bytecompile/macro* (source env) #{##(length source arg-count not= throw list :arity-error \"(macro*) needs exactly 4 arguments\" current-lambda bytecompile* env (#$18))\n"
"0E000E0112040107020D0E030E02020504020B00180E040E051A061A070E010E\n"
"08040004040401090004240D0E011205010D0E050E090E01110E0A04020E090E\n"
"0112110E0A04020E090E011212110E0A04020E090E01121212110E0A04021A0B\n"
"040501\n"
"} bytecompile/environment* (source env) #{##(list (#$15) bytecompile/do/form source env (#$D) (#$13) (#$16))\n"
"0E001A010E020E03120E0404021A051A061A07040501\n"
"} bytecompile/let* (source env) #{##(list (#$15) bytecompile/do source env (#$16))\n"
"0E001A010E020E0312110E0404021A05040301\n"
"} bytecompile/return (source env) #{##(list bytecompile* source env (#$1))\n"
"0E000E010E0212110E0304021A04040201\n"
"} bytecompile/try (source env) #{##(bytecompile/gen-label end-sym list bytecompile* source env $try bytecompile/do/form (#$16) :label)\n"
"0E00040007010D0E020E030E0412110E0504020E060E0104010E070E0412120E\n"
"0504021A080E021A090E010402040501\n"
"} bytecompile* (source env) #@(documentation: \"Compile the forms in source\" cat: :bytecode internal: #t) #{##(resolves? source env resolve op type-of ΓεnΣym-3 :lambda :native-function :pair :symbol #f ΓεnΣym-4 do bytecompile/do let* bytecompile/let* def bytecompile/def set! bytecompile/set! if bytecompile/if while bytecompile/while and bytecompile/and or bytecompile/or fn* bytecompile/fn* macro* bytecompile/macro* environment* bytecompile/environment* try bytecompile/try return bytecompile/return quote bytecompile/quote bytecompile/procedure throw list :type-error \"Can't evaluate that\" current-lambda bytecompile/literal)\n"
"0E000E01110E0204020B000F0E030E01110E0204020900060E011107040D150E\n"
"050E04040107060D0E061A07200C0A00240D0E061A08200C0A001A0D0E061A09\n"
"200C0A00100D0E061A0A200C0A00060D1A0B0B0125150E04070C0D0E0C0E0D20\n"
"0B000E0E0E0E010E0204020901080E0C0E0F200B000E0E100E010E0204020900\n"
"F50E0C0E11200B000E0E120E010E0204020900E20E0C0E13200B000E0E140E01\n"
"0E0204020900CF0E0C0E15200B000E0E160E010E0204020900BC0E0C0E17200B\n"
"000E0E180E010E0204020900A90E0C0E19200B000E0E1A0E010E020402090096\n"
"0E0C0E1B200B000E0E1C0E010E0204020900830E0C0E1D200B000E0E1E0E010E\n"
"0204020900700E0C0E1F200B000E0E200E010E02040209005D0E0C0E21200B00\n"
"0E0E220E010E02040209004A0E0C0E23200B000E0E240E010E0204020900370E\n"
"0C0E25200B000E0E260E010E0204020900240E0C0E27200B000E0E280E011211\n"
"04010900110E290E040E01120E020E011104041609002A1A090E050E01040120\n"
"0B00180E2A0E2B1A2C1A2D0E010E2E0400040404010900090E2F0E0104011601\n"
"} bytecompile (form environment) #@(cat: :bytecode internal: #t) #{##(list bytecompile* form environment (#$1))\n"
"0E000E010E020E0304021A04040201\n"
"})\n"
"15020007000D1A011A021A031A041707010D1A051A061A031A071707050D1A08\n"
"1A091A031A0A1707080D1A0B1A0C1A031A0D17070B0D1A0E1A0F1A031A101707\n"
"0E0D1A111A121A031A131707110D1A141A151A031A161707140D1A171A181A03\n"
"1A191707170D1A1A1A1B1A031A1C17071A0D1A1D1A1E1A031A1F17071D0D1A20\n"
"1A211A031A221707200D1A231A241A031A251707230D1A261A271A031A281707\n"
"260D1A291A2A1A031A2B1707290D1A2C1A2D1A031A2E17072C0D1A2F1A301A03\n"
"1A3117072F0D1A321A331A031A341707320D1A351A361A031A371707350D1A38\n"
"1A391A031A3A1707380D1A3B1A3C1A031A3D17073B0D1A3E1A3F1A031A401707\n"
"3E0D1A411A421A031A431707410D1A441A451A031A461707440D1A471A481A03\n"
"1A491707470D1A4A1A4B1A4C1A4D17074A16074A0D1A4E1A4F1A501A5117074E\n"
"01\n"
"}#{##(disassemble/length (op) #@(documentation: \"Return the length in bytes of a bytecode operation and all its arguments\") #{##(op ΓεnΣym-1 #$0 #$1 #$3 #$C #$D #$11 #$12 #$13 #$14 #$15 #$16 #$17 #$18 #$19 #$1B #$1C #$1E #$1F #$20 #$21 #$22 #$23 #$24 #$25 #$26 #$27 #$28 #$29 #$2A #f #$2 #$4 #$5 #$7 #$E #$1A #$6 #$8 #$9 #$A #$B #$F #$10 throw list :unknown-op \"This op needs its length specified for disassembly to work\" current-lambda)\n"
"150E0007010D0E011A02200C0A011E0D0E011A03200C0A01140D0E011A04200C\n"
"0A010A0D0E011A05200C0A01000D0E011A06200C0A00F60D0E011A07200C0A00\n"
"EC0D0E011A08200C0A00E20D0E011A09200C0A00D80D0E011A0A200C0A00CE0D\n"
"0E011A0B200C0A00C40D0E011A0C200C0A00BA0D0E011A0D200C0A00B00D0E01\n"
"1A0E200C0A00A60D0E011A0F200C0A009C0D0E011A10200C0A00920D0E011A11\n"
"200C0A00880D0E011A12200C0A007E0D0E011A13200C0A00740D0E011A14200C\n"
"0A006A0D0E011A15200C0A00600D0E011A16200C0A00560D0E011A17200C0A00\n"
"4C0D0E011A18200C0A00420D0E011A19200C0A00380D0E011A1A200C0A002E0D\n"
"0E011A1B200C0A00240D0E011A1C200C0A001A0D0E011A1D200C0A00100D0E01\n"
"1A1E200C0A00060D1A1F0B000802010900AB0E011A20200C0A00380D0E011A21\n"
"200C0A002E0D0E011A22200C0A00240D0E011A23200C0A001A0D0E011A24200C\n"
"0A00100D0E011A25200C0A00060D1A1F0B000802020900650E011A26200C0A00\n"
"420D0E011A27200C0A00380D0E011A28200C0A002E0D0E011A29200C0A00240D\n"
"0E011A2A200C0A001A0D0E011A2B200C0A00100D0E011A2C200C0A00060D1A1F\n"
"0B000802030900150E2D0E2E1A2F1A300E000E310400040404011601\n"
"} bytecode/nil-catcher (error) #@() #{##(error :type-error throw)\n"
"0E00111A01200B0007240900090E020E00040101\n"
"} bytecode-arr->val (a i) #@(documentation: \"Read a bytecode encoded value in A at I and return it\") #{##(bytecode/nil-catcher bytecode-op->val ref a i)\n"
"0E001900260E010E020E030E0404020E020E0302010E042504020E020E030202\n"
"0E0425040204031601\n"
"} bytecode-arr->sym (a i) #@(documentation: \"Read a bytecode encoded symbol in A at I and return it\") #{##(bytecode/nil-catcher bytecode-op->sym ref a i)\n"
"0E001900260E010E020E030E0404020E020E0302010E042504020E020E030202\n"
"0E0425040204031601\n"
"} bytecode-op->offset (a b) #@(documentation: \"Turn two bytecode ops encoding an offset into the integer representation\") #{##(bit-or bit-shift-left bytecode-op->int a b t 32768 - 65536)\n"
"0E000E010E020E030401020804020E020E040401040207050D0E051A06220B00\n"
"0F0E071A080E052604010900050E0501\n"
"} bytecode-arr->offset (a i) #@(documentation: \"Read a bytecode encoded offset in A at I and return it as a signed integer\") #{##(bytecode-op->offset ref a i)\n"
"0E000E010E020E0304020E010E0202010E03250402040201\n"
"} disassemble/maybe-quote (v) #@(documentation: \"Quotes symbols but just passes through every other value\") #{##(:symbol type-of v list quote :bytecode-array disassemble/bytecode-array)\n"
"1A000E010E020401200B000E0E031A040E0204020900221A050E010E02040120\n"
"0B000C0E060E02040109000D1B0B00080E020900042401\n"
"} disassemble/op (a i literals) #@(documentation: \"Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval\") #{##(ref a i ΓεnΣym-2 #$0 ($nop) #$1 ($ret) #$2 $push/int/byte bytecode-op->int #$3 ($add/int) #$4 $apply #$5 $set/val disassemble/maybe-quote literals #$6 $push/val/ext bit-or bit-shift-left #$7 $def/val #$8 $def/val/ext #$9 $jmp* bytecode-arr->offset #$A $jt* #$B $jf* #$C ($dup) #$D ($drop) #$E $get/val #$F $get/val/ext #$10 $set/val/ext #$11 ($car) #$12 ($cdr) #$13 ($closure/push) #$14 ($cons) #$15 ($let) #$16 ($closure/pop) #$17 ($fn/dynamic) #$18 ($macro/dynamic) #$19 $try #$1A $push/val #$1B ($push/true) #$1C ($push/false) #$1D ($eval) #$1E ($<) #$1F ($<=) #$20 ($=) #$21 ($>=) #$22 ($>) #$23 ($inc/int) #$24 ($push/nil) #$25 ($add) #$26 ($sub) #$27 ($mul) #$28 ($div) #$29 ($rem) #$2A ($zero?) :unknown-op)\n"
"150E000E010E02040207030D0E031A04200B00081A050903B70E031A06200B00\n"
"081A070903AA0E031A08200B001A1A090E0A0E000E010E020201250402040124\n"
"141409038B0E031A0B200B00081A0C09037E0E031A0D200B001A1A0E0E0A0E00\n"
"0E010E020201250402040124141409035F0E031A0F200B00241A100E110E000E\n"
"120E0A0E000E010E0202012504020401040204012414140903360E031A13200B\n"
"00391A140E000E120E150E0A0E000E010E02020125040204010E160E0A0E000E\n"
"010E020202250402040102080402040204022414140902F80E031A17200B0024\n"
"1A180E110E000E120E0A0E000E010E0202012504020401040204012414140902\n"
"CF0E031A19200B00391A1A0E000E120E150E0A0E000E010E0202012504020401\n"
"0E160E0A0E000E010E020202250402040102080402040204022414140902910E\n"
"031A1B200B00161A1C0E1D0E010E0202012504022414140902760E031A1E200B\n"
"00161A1F0E1D0E010E02020125040224141409025B0E031A20200B00161A210E\n"
"1D0E010E0202012504022414140902400E031A22200B00081A230902330E031A\n"
"24200B00081A250902260E031A26200B00241A270E110E000E120E0A0E000E01\n"
"0E0202012504020401040204012414140901FD0E031A28200B00391A290E000E\n"
"120E150E0A0E000E010E02020125040204010E160E0A0E000E010E0202022504\n"
"02040102080402040204022414140901BF0E031A2A200B00391A2B0E000E120E\n"
"150E0A0E000E010E02020125040204010E160E0A0E000E010E02020225040204\n"
"0102080402040204022414140901810E031A2C200B00081A2D0901740E031A2E\n"
"200B00081A2F0901670E031A30200B00081A3109015A0E031A32200B00081A33\n"
"09014D0E031A34200B00081A350901400E031A36200B00081A370901330E031A\n"
"38200B00081A390901260E031A3A200B00081A3B0901190E031A3C200B00161A\n"
"3D0E1D0E010E0202012504022414140900FE0E031A3E200B00241A3F0E110E00\n"
"0E120E0A0E000E010E0202012504020401040204012414140900D50E031A4020\n"
"0B00081A410900C80E031A42200B00081A430900BB0E031A44200B00081A4509\n"
"00AE0E031A46200B00081A470900A10E031A48200B00081A490900940E031A4A\n"
"200B00081A4B0900870E031A4C200B00081A4D09007A0E031A4E200B00081A4F\n"
"09006D0E031A50200B00081A510900600E031A52200B00081A530900530E031A\n"
"54200B00081A550900460E031A56200B00081A570900390E031A58200B00081A\n"
"5909002C0E031A5A200B00081A5B09001F0E031A5C200B00081A5D0900120E03\n"
"1A5E200B00081A5F0900051A601601\n"
"} disassemble/array (a i literals) #@(documentation: \"Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression\") #{##(ret i disassemble/op a literals disassemble/length ref array/length nreverse)\n"
"2407000D240900280D0E010E020E030E010E040403140E001405000D0E010E05\n"
"0E060E030E01040204012505010E010E070E0304011E0AFFD20D0E080E000401\n"
"01\n"
"} disassemble/bytecode-array (code) #@(documentation: \"Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions,\") #{##(disassemble/array bytecode-arr->arr code bytecode-literals)\n"
"0E000E010E02040102000E030E020401040301\n"
"} disassemble/to-string (bc) #{##(disassemble/bytecode-array bc)\n"
"0E000E01040101\n"
"} disassemble (bc) #@(documentation: \"Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions,\" cat: :bytecode internal: #t) #{##(type-of bc ΓεnΣym-3 :lambda :macro #f disassemble/to-string closure/code :bytecode-array throw list :type-error \"Can't disassemble that\" current-lambda)\n"
"150E000E01040107020D0E021A03200C0A00100D0E021A04200C0A00060D1A05\n"
"0B00100E060E070E01040104010900260E021A08200B000C0E060E0104010900\n"
"150E090E0A1A0B1A0C0E010E0D0400040404011601\n"
"})\n"
"151A001A011A021A031707000D1A041A051A061A071707040D1A081A091A0A1A\n"
"0B1707080D1A0C1A0D1A0E1A0F17070C0D1A101A111A121A131707100D1A141A\n"
"151A161A171707140D1A181A191A1A1A1B1707180D1A1C1A1D1A1E1A1F17071C\n"
"0D1A201A211A221A231707200D1A241A251A261A271707240D1A281A291A061A\n"
"2A1707280D1A2B1A2C1A2D1A2E17072B16072B01\n"
"}#{##(compile/backend/none (expr) #@(cat: :compiler internal: #t) #{##(expr)\n"
"0E0001\n"
"} compile/backend/bytecode (expr) #{##(assemble* bytecompile expr)\n"
"0E000E010E020401040101\n"
"} :bytecode *active-backend* tree/new :none backend/tree backend (expr) #{##(ref backend/tree *active-backend* expr)\n"
"0E000E010E0204020E03040101\n"
"} compile/for (backend expr environment) #@() #{##(*active-backend* last-backend ret anonymous (e) #@() #{##(last-backend *active-backend* throw e)\n"
"0E0005010D0E020E03040101\n"
"} backend compile* expr current-closure)\n"
"0E0007010D2407020D1A031A041A051A061719001E0E0705000D0E080E090E0A\n"
"0400040205020D0E0105000D0E02011601\n"
"})\n"
"1A001A011A021A031707000D1A041A051A021A061707040D1A0707080D0E091A\n"
"070E041A0A0E000404070B0D1A0C1A0D1A021A0E17070C0D1A0F1A101A111A12\n"
"17070F01\n"
"}#{##(compile* (source environment) #@(documentation: \"Compile SOURCE so it can be evaluated/applied\" cat: :compiler internal: #t) #{##(backend constant-fold macroexpand source environment)\n"
"0E000E010E020E030E0404020401040101\n"
"} compile/do* (source environment) #@(cat: :compiler internal: #t) #{##(:pair type-of source compile* do environment)\n"
"1A000E010E020401200B00110E030E040E02140E0504020900050E0201\n"
"} compile (source) #{##(compile* source current-closure)\n"
"1A000E011A0224142414141401\n"
"} meta/parse/body (type args body) #{##(body source tree/new meta v type-of ΓεnΣym-1 :pair deftest tree/set! :tests ref :string :documentation cat string \"\\n\" :keyword ΓεnΣym-2 :inline :source :related :export-as :export :cat trim join map split)\n"
"0E0007010D0E0224040107030D2409010B0D0E001107040D150E050E04040107\n"
"060D0E061A07200B00290E04111A08200B001A0E090E031A0A0E04120E0B0E03\n"
"1A0A04021404030900062405000900C50E061A0C200B00220E090E031A0D0E0E\n"
"0E0F0E0B0E031A0D040204011A100E040403040309009E0E061A11200B009515\n"
"0E0407120D0E121A13200B001A0E090E030E041B04030D0E090E031A140E0104\n"
"0309006C0E121A15200B00210E090E031A150E0012110E0B0E031A1504021404\n"
"030D0E001205000900460E121A16200B00180E090E031A170E00121104030D0E\n"
"001205000900290E121A18200B00180E090E031A180E00121104030D0E001205\n"
"0009000C0E090E030E041B04031609000424160D0E001205000E000AFEF60D0E\n"
"0B0E031A0D04020B002C0E090E031A0D0E190E1A0E1B0E1C0E0B0E031A0D0402\n"
"1A1004020E1904021A10040204010403090004240D0E030101\n"
"} defmacro (name args . body) #@(documentation: \"Define a new macro\") #{##(def name macro* quote args meta/parse/body :macro body compile/do* current-closure)\n"
"1A000E011A021A030E012414141A030E042414140E051A060E040E0704031A03\n"
"0E080E070E09040004022414142414141414142414141401\n"
"} fn/check (args body) #{##(args throw list :type-error \"Every function needs an argument list\" current-lambda :symbol type-of :pair #f \"Wrong type for argument list\" body \"Every function needs a body\")\n"
"0E000B0007240900150E010E021A031A040E000E050400040404010D24090041\n"
"0D1A060E070E000401200C0A00140D1A080E070E000401200C0A00060D1A090B\n"
"0007240900150E010E021A031A0A0E000E050400040404010D0E001205000E00\n"
"0AFFC00D0E0B0B0007240900150E010E021A031A0C0E0B0E0504000404040101\n"
"} fn (args . body) #@(documentation: \"Define an anonymous function\") #{##(fn/check args body fn* quote anonymous meta/parse/body :lambda compile/do* current-closure)\n"
"0E000E010E0204020D1A031A041A052414141A040E012414140E061A070E010E\n"
"0204031A040E080E020E090400040224141424141414141401\n"
"} defn (name args . body) #@(documentation: \"Define a new function\") #{##(fn/check args body meta/parse/body :lambda fn-meta def name fn* quote compile/do* current-closure def-form ref :export list export :symbol type-of)\n"
"0E000E010E0204020D0E031A040E010E02040307050D1A060E071A081A090E07\n"
"2414141A090E012414140E051A090E0A0E020E0B040004022414142414141414\n"
"1424141414070C0D0E0D0E051A0E04020B002D0E0F1A101A110E120E0D0E051A\n"
"0E04020401200B000E0E0D0E051A0E04020900050E070E0C04030900050E0C01\n"
"} eval-in (closure expr) #@(documentation: \"Compile and the immediatly evaluate the result\\n\\nMostly used by lRun() and (eval)\") #{##(compile* expr closure)\n"
"0E000E010E0204020E021D01\n"
"} eval (expr) #@(documentation: \"Compile, Evaluate and then return the result of EXPR\") #{##(eval-in current-closure expr)\n"
"1A001A0124140E022414141401\n"
"} typecheck/only (v t) #@() #{##(when-not = type-of v t throw list :type-error cat \"Expected a value of type \" current-lambda)\n"
"1A001A011A020E032414140E04241414141A051A061A070E081A090E0404020E\n"
"031A0A24142414141414142414142414141401\n"
"} gensym/counter gensym (prefix) #{##(gensym/counter string->symbol cat prefix \"ΓεnΣym-\")\n"
"0E0002012505000D0E010E020E031A040E000403040101\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A081A091A021A0A\n"
"1807080D1A0B1A0C1A061A0D17070B0D1A0E1A0F1A101A1118070E0D1A121A13\n"
"1A061A141707120D1A151A161A171A181807150D1A191A1A1A1B1A1C1807190D\n"
"1A1D1A1E1A1F1A2017071D0D1A211A221A231A241807210D1A251A261A271A28\n"
"1807250D15020007290D1A2A1A2B1A271A2C17072A16072A01\n"
"}#{##(constant-fold/constant? (expr) #@() #{##(:pair type-of expr :symbol)\n"
"1A000E010E020401200B00071C0900041B0C0B001B0D1A030E010E020401200B\n"
"00071C0900041B0C0B00050D1B01\n"
"} constant-fold/pure? (fun) #{##(meta fun :pure)\n"
"0E000E011A02040201\n"
"} constant-fold/resolve (sym) #{##(:symbol type-of sym resolve)\n"
"1A000E010E020401200B0007240900060E02010D0E030E02040101\n"
"} constant-fold/args (expr) #{##(expr :pair type-of constant-fold constant-fold/args)\n"
"0E000B0007240900060E00010D1A010E020E00110401200B00150E030E001104\n"
"010E040E001204011409000E0E00110E040E001204011401\n"
"} constant-fold (expr) #@(documentation: \"Will try and evaluate as many constant as possible to make the expression simpler.\" cat: :compiler internal: #t) #{##(:pair type-of expr folded-fun quote constant-fold/args folded-args constant-fold/pure? every? constant-fold/constant? anonymous (#nil) #@() #{##(folded-fun folded-args)\n"
"0E000E011401\n"
"} apply constant-fold/resolve)\n"
"1A000E010E020401200B0007240900060E02010D0E021107030D1A040E03200B\n"
"00090E0201090004240D0E050E0212040107060D0E070E0304010C0B000C0D0E\n"
"080E060E0904020B001F1A0A1A0B1A0C1A0D171900100E0E0E0F0E0304010E06\n"
"0402160900080E030E061401\n"
"})\n"
"151A001A011A021A031707000D1A041A051A021A061707040D1A071A081A021A\n"
"091707070D1A0A1A0B1A021A0C17070A0D1A0D1A0E1A0F1A1017070D16070D01\n"
"}#{##(macroexpand-do-args (args env) #@() #{##(nil? args macroexpand* env :pair type-of ocar macroexpand-do-args)\n"
"0E000E011204010B00110E020E01110E030402241409004E1A040E050E011104\n"
"01200B0038150E020E01110E03040207060D1A040E050E060401200B00120E06\n"
"0E070E01120E0304021409000C0E070E01120E0304021609000C0E070E01120E\n"
"03040201\n"
"} macroexpand-do (source env) #{##(macroexpand-do-args source env args nil? do)\n"
"0E000E010E02040207030D0E040E031204010B00090E03110900081A050E0314\n"
"01\n"
"} macroexpand-form (source env op arity implicit-do? no-expand-bitmap) #{##(op ret source l i bit-test? no-expand-bitmap macroexpand* env arity implicit-do? macroexpand-do throw list :arity-error cat \" form contains more than \" \" arguments\" nreverse)\n"
"0E00241407010D0E021207030D15020007040D2409002F0D0E050E060E040402\n"
"0B00090E031109000C0E070E03110E0804020E011405010D0E031205030D0E04\n"
"2305040E040E091E0AFFCF0D24160D0E0A0B00130E0B0E030E0804020E011405\n"
"010900260E030B00200E0C0E0D1A0E0E0F0E001A100E091A1104040E020E0804\n"
"040401090004240D0E120E0104010101\n"
"} macroexpand-fold (op source env) #{##(source list op macroexpand-fold except-last-pair env macroexpand* last-pair)\n"
"0E00120B004A0E0012120B00270E010E020E030E020E040E0004010E0504030E\n"
"060E070E000401110E050402040309001C0E010E020E060E00110E0504020E06\n"
"0E0012110E05040204030900120E010E020E060E00110E050402040201\n"
"} macroexpand* (source env) #@(documentation: \"Expand all macros within source\" cat: :compiler internal: #t) #{##(resolves? source env resolve op type-of ΓεnΣym-1 :nil :macro macroexpand* macro-apply :native-function ΓεnΣym-2 quote do macroexpand-do return macroexpand-form try while #f def set! if fn* macro* let* environment* list meta :fold macroexpand-fold map anonymous (α) #@() #{##(macroexpand* α env)\n"
"0E000E010E02040201\n"
"} (α) #{##(macroexpand* α env)\n"
"0E000E010E02040201\n"
"})\n"
"0E000E01110E0204020B000F0E030E01110E0204020900060E011107040D150E\n"
"050E04040107060D0E061A07200B00080E010901640E061A08200B00150E090E\n"
"0A0E040E011204020E02040209014A0E061A0B200B0133150E04070C0D0E0C0E\n"
"0D200B00080E0109011C0E0C0E0E200B000E0E0F0E010E0204020901090E0C0E\n"
"10200B00150E110E010E020E0402011C020004060900EF0E0C0E12200C0A0010\n"
"0D0E0C0E13200C0A00060D1A140B00150E110E010E020E0402011B0200040609\n"
"00C40E0C0E15200C0A00100D0E0C0E16200C0A00060D1A140B00150E110E010E\n"
"020E0402021C020104060900990E0C0E17200B00150E110E010E020E0402031C\n"
"0200040609007F0E0C0E18200C0A00100D0E0C0E19200C0A00060D1A140B0015\n"
"0E110E010E020E0402041B020704060900540E0C0E1A200C0A00100D0E0C0E1B\n"
"200C0A00060D1A140B00150E1C0E040E0F0E01120E02040204020900290E1D0E\n"
"041A1E04020B000F0E1F0E040E011204020900120E200E011A211A221A231A24\n"
"170402160900120E200E011A211A251A231A261704021601\n"
"} macroexpand (source env) #@(documentation: \"Macroexpand the forms in source\") #{##(macroexpand* source env root-closure #f)\n"
"0E000E010E020C0A000D0D0E030C0A00060D1A04040201\n"
"})\n"
"151A001A011A021A031707000D1A041A051A021A061707040D1A071A081A021A\n"
"091707070D1A0A1A0B1A021A0C17070A0D1A0D1A0E1A0F1A1017070D16070D0D\n"
"1A111A121A131A1417071101\n"
"}#{##(keyword->string (kw) #@(documentation: \"Convert a keyword into a string\\n\\nkw: The input keyword\\n\\nReturns the string for kw\" cat: :type-conversion tests: ((\"asd\" (keyword->string :asd))) related: (string->keyword)) #{##(:keyword type-of kw throw list :type-error \"(keyword->string) can only be called on keywords\" current-lambda string keyword->symbol)\n"
"1A000E010E020401200B0007240900150E030E041A051A060E020E0704000404\n"
"04010D0E080E090E020401040101\n"
"} string->keyword (kw) #@(documentation: \"Convert a string into a keyword\\n\\nkw: The input string\\n\\nReturns the keyword for kw\" cat: :type-conversion tests: ((:asd (string->keyword \"asd\"))) related: (keyword->string)) #{##(:string type-of kw throw list :type-error \"(string->keyword) can only be called on strings\" current-lambda symbol->keyword string->symbol)\n"
"1A000E010E020401200B0007240900150E030E041A051A060E020E0704000404\n"
"04010D0E080E090E020401040101\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A0717070401\n"
"}#{##(otherwise += (val inc) #@() #{##(set! val + inc)\n"
"1A000E011A020E010E03241414142414141401\n"
"} let/arg (arg) #{##(arg :pair type-of :symbol #f throw list :invalid-let-form \"Please fix the structure of the let form\" def)\n"
"0E000B00581A010E020E000401200B00071C0900041B0C0A001D0D1A030E020E\n"
"00110401200B00071C0900041B0C0A00060D1A040B00140E050E061A071A080E\n"
"0004030401090004240D1A090E00110E001211241414140900042401\n"
"} let/args (args) #{##(args let/arg let/args)\n"
"0E000B00150E010E001104010E020E00120401140900042401\n"
"} let (bindings . body) #@(documentation: \"Evalutes to BODY if PRED is true\") #{##(let* do append let/args bindings body)\n"
"1A001A010E020E030E0404010E020E0524040204021424141401\n"
"} boolean (v) #@(documentation: \"Coerce to boolean\" source: (\"Coerce to boolean\" :inline :cat :boolean-operations :related not (deftest #t (boolean #t)) (deftest #f (boolean #nil)) (deftest #f (boolean #f)) (deftest #t (boolean 0)) (deftest #t (boolean 1)) (deftest #t (boolean 0.1)) (deftest #t (boolean \"\")) (deftest #t (boolean \"a\")) (if v #t #f)) cat: :boolean-operations tests: ((#t (boolean \"a\")) (#t (boolean \"\")) (#t (boolean 0.1)) (#t (boolean 1)) (#t (boolean 0)) (#f (boolean #f)) (#f (boolean #nil)) (#t (boolean #t))) inline: #t related: (not)) #{##(v)\n"
"0E000B00071B0900041C01\n"
"} not (v) #@(documentation: \"Return true if V is false\" source: (\"Return true if V is false\" :inline :cat :boolean-operations :related boolean (deftest #f (not #t)) (deftest #t (not #f)) (deftest #t (not (< 5 1))) (deftest #t (not (= #f #t))) (deftest #t (not (< 3 2))) (deftest #t (not (>= \"2\" 3))) (if v #f #t)) cat: :boolean-operations tests: ((#t (not (>= \"2\" 3))) (#t (not (< 3 2))) (#t (not (= #f #t))) (#t (not (< 5 1))) (#t (not #f)) (#f (not #t))) inline: #t related: (boolean)) #{##(v)\n"
"0E000B00071C0900041B01\n"
"} identity (α) #@(documentation: \"Returns its argument\" source: (:inline \"Returns its argument\" α) inline: #t) #{##(α)\n"
"0E0001\n"
"} list arguments #@(documentation: \"Return ARGUMENTS as a list\") #{##(arguments)\n"
"0E0001\n"
"} caar (p) #@(documentation: \"(car (car p))\" source: (\"(car (car p))\" :inline :cat :list-manipulation :related cadr :related car :related cdr (deftest #t (caar '((#t) #f))) (car (car p))) cat: :list-manipulation tests: ((#t (caar '((#t) #f)))) inline: #t related: (cdr car cadr)) #{##(p)\n"
"0E00111101\n"
"} cadr (p) #@(documentation: \"(car (cdr p))\" source: (\"(car (cdr p))\" :inline :cat :list-manipulation :related caar :related car :related cdr (deftest #t (cadr '(#f #t #f))) (car (cdr p))) cat: :list-manipulation tests: ((#t (cadr '(#f #t #f)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E00121101\n"
"} cdar (p) #@(documentation: \"(cdr (car p))\" source: (\"(cdr (car p))\" :inline :cat :list-manipulation :related caar :related car :related cdr (deftest #t (cdar '((#f . #t) #f))) (deftest (#t) (cdar '((#f #t) #f))) (cdr (car p))) cat: :list-manipulation tests: (((#t) (cdar '((#f #t) #f))) (#t (cdar '((#f . #t) #f)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E00111201\n"
"} cddr (p) #@(documentation: \"(cdr (cdr p))\" source: (\"(cdr (cdr p))\" :inline :cat :list-manipulation :related caar :related car :related cdr (deftest #t (cddr '(#f #f . #t))) (deftest (#t) (cddr '(#f #f #t))) (cdr (cdr p))) cat: :list-manipulation tests: (((#t) (cddr '(#f #f #t))) (#t (cddr '(#f #f . #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E00121201\n"
"} cadar (p) #@(documentation: \"(car (cdr (car p)))\" source: (\"(car (cdr (car p)))\" :inline :cat :list-manipulation :related caar :related car :related cdr (deftest #t (cadar '((#f #t) #f))) (car (cdr (car p)))) cat: :list-manipulation tests: ((#t (cadar '((#f #t) #f)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E0011121101\n"
"} caddr (p) #@(documentation: \"(car (cdr (cdr p)))\" source: (\"(car (cdr (cdr p)))\" :inline :cat :list-manipulation :related caar :related car :related cdr (deftest #t (caddr '(#f #f #t))) (car (cdr (cdr p)))) cat: :list-manipulation tests: ((#t (caddr '(#f #f #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E0012121101\n"
"} cdddr (p) #@(documentation: \"(cdr (cdr (cdr p)))\" source: (\"(cdr (cdr (cdr p)))\" :inline :cat :list-manipulation :related caar :related car :related cdr (deftest #t (cdddr '(#f #f #f . #t))) (deftest (#t) (cdddr '(#f #f #f #t))) (cdr (cdr (cdr p)))) cat: :list-manipulation tests: (((#t) (cdddr '(#f #f #f #t))) (#t (cdddr '(#f #f #f . #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E0012121201\n"
"} cadddr (p) #@(documentation: \"(car (cdr (cdr (cdr p))))\" source: (\"(car (cdr (cdr (cdr p))))\" :inline :cat :list-manipulation :related caar :related car :related cdr (deftest #t (cadddr '(#f #f #f #t))) (car (cdr (cdr (cdr p))))) cat: :list-manipulation tests: ((#t (cadddr '(#f #f #f #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E001212121101\n"
"} cddddr (p) #@(documentation: \"(cdr (cdr (cdr (cdr p))))\" source: (\"(cdr (cdr (cdr (cdr p))))\" :inline :cat :list-manipulation :related caar :related car :related cdr (deftest #t (cddddr '(#f #f #f #f . #t))) (cdr (cdr (cdr (cdr p))))) cat: :list-manipulation tests: ((#t (cddddr '(#f #f #f #f . #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E001212121201\n"
"} caddddr (p) #@(documentation: \"(car (cdr (cdr (cdr (cdr p)))))\" source: (\"(car (cdr (cdr (cdr (cdr p)))))\" :inline :cat :list-manipulation :related caar :related car :related cdr (deftest #t (caddddr '(#f #f #f #f #t))) (car (cdr (cdr (cdr (cdr p)))))) cat: :list-manipulation tests: ((#t (caddddr '(#f #f #f #f #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E00121212121101\n"
"} cdddddr (p) #@(documentation: \"(cdr (cdr (cdr (cdr (cdr p)))))\" source: (\"(cdr (cdr (cdr (cdr (cdr p)))))\" :inline :cat :list-manipulation :related caar :related car :related cdr (deftest #t (cdddddr '(#f #f #f #f #f . #t))) (cdr (cdr (cdr (cdr (cdr p)))))) cat: :list-manipulation tests: ((#t (cdddddr '(#f #f #f #f #f . #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E00121212121201\n"
"} exception (type description value) #{##(throw list type description value current-lambda)\n"
"1A001A010E020E030E041A05241424141414141424141401\n"
"})\n"
"1B07000D1A011A021A031A041807010D151A051A061A031A071707050D1A081A\n"
"091A031A0A1707080D1A0B1A0C1A0D1A0E18070B16070B0D1A0F1A101A111A12\n"
"17070F0D1A131A141A151A161707130D1A171A181A191A1A1707170D1A1B1A1C\n"
"1A1D1A1E17071B0D1A1F1A201A211A2217071F0D1A231A241A251A261707230D\n"
"1A271A281A291A2A1707270D1A2B1A2C1A2D1A2E17072B0D1A2F1A301A311A32\n"
"17072F0D1A331A341A351A361707330D1A371A381A391A3A1707370D1A3B1A3C\n"
"1A3D1A3E17073B0D1A3F1A401A411A4217073F0D1A431A441A451A461707430D\n"
"1A471A481A491A4A1707470D1A4B1A4C1A031A4D18074B01\n"
"}#{##(if-not (pred then else) #@() #{##(if pred else then)\n"
"1A000E010E020E03241414141401\n"
"} when-not (pred . body) #@(documentation: \"Evalutes to BODY if PRED is false\") #{##(if pred do append body)\n"
"1A000E01241A020E030E0424040214241414141401\n"
"} when (pred . body) #@(documentation: \"Evalutes to BODY if PRED is true\") #{##(if pred do append body)\n"
"1A000E011A020E030E042404021424241414141401\n"
"} case/clauses/multiple (key-sym cases) #{##(cases list = key-sym case/clauses/multiple)\n"
"0E000B001B0E011A020E030E001104030E040E030E00120402140900042401\n"
"} case/clauses (key-sym clauses) #{##(clauses otherwise do list if :pair type-of quote nil? :symbol = key-sym or case/clauses/multiple case/clauses)\n"
"0E000B00950E0011111A01200B000D1A020E0011121409007E0E031A041A050E\n"
"060E0011110401200B004E0E001111111A07200C0B00200D0E080E0011111212\n"
"04010C0B00110D1A090E060E00111112110401200B00120E031A0A0E0B0E0011\n"
"1104030900101A0C0E0D0E0B0E00111104021409000F0E031A0A0E0B0E001111\n"
"04031A020E001112140E0E0E0B0E0012040204040900042401\n"
"} case (key-form . clauses) #{##(gensym key-sym list let* def key-form case/clauses clauses)\n"
"0E00040007010D0E021A030E021A040E010E0504030E060E010E070402040301\n"
"} cond body #@(documentation: \"Contains multiple cond clauses\") #{##(body list if do macro-apply cond)\n"
"0E000C0B00080D0E0011110B00200E011A020E0011111A030E001112140E040E\n"
"050E0012040204040900042401\n"
"} dotimes (binding . body) #@(documentation: \"binding => (name n result-form)\\nRepeatedly executes body with name bound to integers from 0 through n-1. Returns result-form or #nil.\") #{##(binding sym type-of :symbol throw list :type-error \"Expected a value of type :symbol\" current-lambda times result-form let while < append body set! inc/int)\n"
"0E001107010D0E020E0104011A03200B0007240900150E040E051A061A070E01\n"
"0E080400040404010D0E00121107090D0E00121211070A0D1A0B0E0102002414\n"
"1424141A0C1A0D0E010E09241414140E0E0E0F1A100E011A110E012414142414\n"
"14142414040214140E0A241414141401\n"
"} doseq (for-loop . body) #@(documentation: \"(doseq (l (list 1 2 3 4) result-form) (println l))\") #{##(gensym symbol-name let for-loop while when-not pair? exception :type-error \"Improper list detected, please provide a proper list instead\" typecheck/only :pair def car append body cdr!)\n"
"0E00040007010D1A020E010E03121124141424141A040E011A051A060E012414\n"
"141A071A081A090E0312112414141414241414141A0A0E011A0B241414141A0C\n"
"0E03111A0D0E01241414241414140E0E0E0F1A100E0124141424140402141414\n"
"14140E03121211241414141401\n"
"} thread/-> (init fun) #{##(fun :pair type-of thread/-> init append list)\n"
"0E000B003E1A010E020E00110401200B001E0E0011110E030E040E001204020E\n"
"050E00111224040214140900130E060E00110E030E040E001204020402090005\n"
"0E0401\n"
"} -> (init . fun) #@(documentation: \"Thread init as the first argument through every function in fun\") #{##(thread/-> init reverse fun)\n"
"0E000E010E020E030401040201\n"
"})\n"
"1A001A011A021A031807000D1A041A051A061A071807040D1A081A091A0A1A0B\n"
"1807080D151A0C1A0D1A021A0E17070C0D1A0F1A101A021A1117070F0D1A121A\n"
"131A021A141807121607120D1A151A161A171A181807150D1A191A1A1A1B1A1C\n"
"1807190D1A1D1A1E1A1F1A2018071D0D151A211A221A021A231707210D1A241A\n"
"251A261A2718072416072401\n"
"}#{##(tree/new module/cache module/store module/loader module/save-state (#nil) #@(cat: :modules internal: #t) #{##(tree/new :cache module/cache :loader module/loader)\n"
"0E001A010E021A030E04040401\n"
"} module/restore-state (c) #{##(ref c :cache module/cache :loader module/loader)\n"
"0E000E011A02040205030D0E000E011A040402050501\n"
"} module/qualify-symbol (module-name symbol) #{##(type-of module-name ΓεnΣym-1 :string module/qualify-symbol string->keyword symbol :keyword string->symbol cat keyword->symbol \"/\" string throw list \"Can't qualify that\" current-lambda)\n"
"150E000E01040107020D0E021A03200B00120E040E050E0104010E0604020900\n"
"350E021A07200B001C0E080E090E0A0E0104011A0B0E0C0E0604010403040109\n"
"00140E0D0E0E1A0F0E01240E100400040404011601\n"
"} require* (module env qualify?) #{##(module/load module env mod throw list \"Can't load that module\" current-lambda resolve exports tree/keys ΓεnΣym-2 :pair type-of :type-error \"Improper list detected, please provide a proper list instead\" \"Expected a value of type :pair\" k def-in! qualify? module/qualify-symbol keyword->symbol ref)\n"
"0E000E010E02040207030D0E030B0007240900140E040E051A060E01240E0704\n"
"00040404010D0E081A090E03040207090D150E0A0E090401070B0D240900820D\n"
"1A0C0E0D0E0B0401200B0007240900190E040E051A0E1A0F0E0A0E0904010E07\n"
"0400040404010D0E0D0E0B04011A0C200B0007240900150E040E051A0E1A100E\n"
"0B0E070400040404010D0E0B1107110D0E120E020E130B00120E140E010E150E\n"
"11040104020900090E150E1104010E160E090E11040204030D0E0B12050B0E0B\n"
"0AFF7F0D241601\n"
"} module/load/cache (name) #{##(ref module/cache name)\n"
"0E000E010E02040201\n"
"} module/load/store (name) #{##(ref module/store name source eval-in defmodule append read module/load/cache)\n"
"0E000E010E02040207030D0E030B00270E0415240D13161A050E020E060E070E\n"
"030401240402141404020D0E080E0204010900042401\n"
"} module/load/external (name) #{##(module/loader ΓεnΣym-3 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" loader name mod tree/set! module/cache)\n"
"150E0007010D240900760D1A020E030E010401200B0007240900150E040E051A\n"
"061A070E000E080400040404010D0E030E0104011A02200B0007240900150E04\n"
"0E051A061A090E010E080400040404010D0E0111070A0D0E0A0E0B0401070C0D\n"
"0E0C0B00140E0D0E0E0E0B0E0C04030D0E0C01090004240D0E011205010E010A\n"
"FF8B0D241601\n"
"} module/insert/defer (name module-source) #{##(tree/set! module/store name module-source)\n"
"0E000E010E020E03040301\n"
"} module/insert (name module) #{##(tree/set! module/cache name module)\n"
"0E000E010E020E03040301\n"
"} module/resolve-string/join (parts ret) #{##(parts ret \"\" \".\" #f module/resolve-string/join \"..\" throw list \"Invalid path\" current-lambda otherwise)\n"
"0E000B00071C0900041B0B00080E010900731A020E0011200C0A00110D1A030E\n"
"0011200C0A00060D1A040B000F0E050E00120E01040209004C1A060E0011200B\n"
"002D0E0012110B0007240900140E070E081A090E00240E0A0400040404010D0E\n"
"050E0012120E0104020900190E0B0B00130E050E00120E00110E011404020900\n"
"042401\n"
"} module/resolve-string (name wd) #{##(wd mod-path module/resolve-string/join nreverse append split \"/\" name parts string->keyword join \"\")\n"
"0E0007010D0E020E030E040E050E011A0604020E050E071A0604020402040124\n"
"040207080D0E090E0A1A0B0E08141A060402040101\n"
"} module/load (name env) #{##(type-of name ΓεnΣym-4 :environment :string module/load module/resolve-string resolve *module-path* env :keyword module/load/cache module/load/store module/load/external #f throw list \"Can't load that value as a module\" current-lambda)\n"
"150E000E01040107020D0E021A03200B00080E010900610E021A04200B001A0E\n"
"050E060E010E071A080E09040204020E0904020900420E021A0A200B00290E0B\n"
"0E0104010C0A001C0D0E0C0E0104010C0A00110D0E0D0E0104010C0A00060D1A\n"
"0E0900140E0F0E101A110E01240E120400040404011601\n"
"} module/import-all (module symbol) #{##(resolve exports module type-of :tree throw list :type-error \"Expected a value of type :tree\" current-lambda)\n"
"0E001A010E02040207010D0E030E0104011A04200B0007240900150E050E061A\n"
"071A080E010E090400040404010D0E010101\n"
"} module/import (module symbol) #{##(module/import-all module symbol exports tree/has? throw list :import-error resolves? \"That symbol was not exported\" \"That symbol does not exist in that module\" current-lambda ref)\n"
"0E000E010E02040207030D0E040E030E0204020B0007240900240E050E061A07\n"
"0E080E020E0104020B00081A090900051A0A240E0B0400040404010D0E0C0E03\n"
"0E02040201\n"
"} module/add-loader (f) #@() #{##(f module/loader)\n"
"0E000E0114050101\n"
"} module body #@(documentation: \"Define a new module and return it\") #{##(macroexpand environment* (def exports (tree/new #nil)) body)\n"
"0E001A011A020E031414040101\n"
"} defmodule (name . body) #@(documentation: \"Define a new named module\") #{##(module/insert name module def *module* append body)\n"
"1A000E011A021A031A040E01241414140E050E0624040214142414141401\n"
"} defmodule/defer (name . body) #{##(module/insert/defer name string/write list quote do body)\n"
"1A000E011A020E031A041A050E061404022414142414141401\n"
"} export (name value) #{##(tree/set! exports quote name value)\n"
"1A001A011A020E032414140E04241414141401\n"
"} use (module) #{##(require* module current-closure)\n"
"1A000E011A02241424241414141401\n"
"} require (module) #{##(require* module current-closure)\n"
"1A000E011A0224141B241414141401\n"
"} import* (local-symbol module module-symbol) #{##(def local-symbol module/import module quote module-symbol)\n"
"1A000E011A020E031A040E05241414241414142414141401\n"
"} import (names module) #{##(list? names import* module/load module current-closure ret :as do nreverse)\n"
"0E000E0104010B00072409001B1A020E011A030E041A052414241414140E0124\n"
"14141414010D2407060D2409005C0D0E0112111A07200B002D1A020E01121211\n"
"1A030E041A052414241414140E011124141414140E061405060D0E0112120501\n"
"0900211A020E01111A030E041A052414241414140E011124141414140E061405\n"
"060D0E011205010E010AFFA50D0E080E090E0604011401\n"
"} module/main (module args) #@(documentation: \"Import and run MODULE's main function with ARGS\") #{##(module/load module current-closure mod throw list \"Module not found\" current-lambda resolve exports \"Invalid module, can't resolve exports\" ref :main main \"There is no symbol exported as main\" procedure? \"main is not a callable value\" args)\n"
"0E000E010E020400040207030D0E030B0007240900140E040E051A060E01240E\n"
"070400040404010D0E081A090E03040207090D0E090B0007240900140E040E05\n"
"1A0A0E01240E070400040404010D0E0B0E091A0C0402070D0D0E0D0B00072409\n"
"00140E040E051A0E0E01240E070400040404010D0E0F0E0D04010B0007240900\n"
"140E040E051A100E01240E070400040404010D0E0D0E11040101\n"
"})\n"
"0E0024040107010D0E0024040107020D2407030D1A041A051A061A071707040D\n"
"1A081A091A061A0A1707080D1A0B1A0C1A061A0D17070B0D1A0E1A0F1A061A10\n"
"17070E0D1A111A121A061A131707110D1A141A151A061A161707140D1A171A18\n"
"1A061A191707170D1A1A1A1B1A061A1C17071A0D1A1D1A1E1A061A1F17071D0D\n"
"1A201A211A061A221707200D1A231A241A061A251707230D1A261A271A061A28\n"
"1707260D1A291A2A1A061A2B1707290D1A2C1A2D1A061A2E17072C0D1A2F1A30\n"
"1A311A3217072F0D1A331A341A351A361807330D1A371A381A391A3A1807370D\n"
"1A3B1A3C1A391A3D18073B0D1A3E1A3F1A311A4018073E0D1A411A421A311A43\n"
"1807410D1A441A451A311A461807440D1A471A481A311A491807470D1A4A1A4B\n"
"1A311A4C18074A0D1A4D1A4E1A4F1A5017074D01\n"
"}#{##(last? (a) #@(documentation: \"Return #t if a is the last pair in a list\" source: (:inline \"Return #t if a is the last pair in a list\" (nil? (cdr a))) inline: #t) #{##(nil? a)\n"
"0E000E0112040101\n"
"} pos? (a) #@(documentation: \"Return #t if a is positive\" source: (:inline \"Return #t if a is positive\" (>= a 0.0)) inline: #t) #{##(a 0.0)\n"
"0E001A012101\n"
"} zero-neg? (a) #@(documentation: \"Return #t if a is zero or negative\" source: (:inline \"Return #t if a is zero or negative\" (<= a 0.0)) inline: #t) #{##(a 0.0)\n"
"0E001A011F01\n"
"} neg? (a) #@(documentation: \"Returns #t if a is negative\" source: (:inline \"Returns #t if a is negative\" (< a 0.0)) inline: #t) #{##(a 0.0)\n"
"0E001A011E01\n"
"} odd? (a) #@(documentation: \"Predicate that returns #t if a is odd\") #{##(int a)\n"
"0E000E01040102022902012001\n"
"} even? (a) #@(documentation: \"Predicate that returns #t if a is even\") #{##(mod/int int a)\n"
"0E000E010E0204010202040202002001\n"
"} not-zero? (val) #@(documentation: \"#t if VAL is not zero\" source: (:inline \"#t if VAL is not zero\" (not= 0 val)) inline: #t) #{##(not= val)\n"
"0E0002000E01040201\n"
"} equal? (val-a val-b) #@(documentation: \"Test whether two values are equal\\n\\nUnlike = this is actually comparing the contents of compound data,\\nwhich can be very slow.\\n\\nval-a: The first argument\\nval-b: The second argument\\n\\nWhether the two arguments are equal?\" cat: :predicate tests: ((#t (equal? (array/new '(1 2 3) '(4.0 5.0 (tree/new :a 1 :b 2)) '(\"7\" (array/new 8 88) :9)) (array/new '(1 2 3) '(4.0 5.0 (tree/new :a 1 :b 2)) '(\"7\" (array/new 8 88) :9)))) (#t (equal? '(1 :b \"c\" (array/new 4.0)) '(1 :b \"c\" (array/new 4.0)))) (#f (equal? '(1 :b \"c\" (array/new 4.0)) '(1 :b \"c\"))) (#t (equal? '(1 :b \"c\") '(1 :b \"c\"))) (#f (equal? :a :b)) (#t (equal? :a :a)) (#f (equal? 2.0 2.1)) (#t (equal? 2.0 2.0)) (#t (equal? 1 1)))) #{##(type-of val-a cur-type not= val-b ΓεnΣym-1 :array array/equal? :tree tree/equal? :pair list/equal?)\n"
"0E000E01040107020D0E030E020E000E04040104020B00071C090048150E0207\n"
"050D0E051A06200B000E0E070E010E04040209002E0E051A08200B000E0E090E\n"
"010E04040209001B0E051A0A200B000E0E0B0E010E0404020900080E010E0420\n"
"1601\n"
"} not-equal? (val-a val-b) #@(documentation: \"Test whether two values are not equal\\n\\nThis is using equal? under the hood, meaning it can be quite slow since\\nit actually compares the contents of complex data structures.\\n\\nval-a: The first argument\\nval-b: The second argument\\n\\nWhether the two arguments are not equal?\" cat: :predicate tests: ((#t (not-equal? (array/new '(1 2 3) '(4.0 5.0 6.0) '(\"7\" (array/new 8 88) :9)) (array/new '(1 2 3) '(4.0 5.0 6.0) '(\"7\" (array/new 8 88) :99)))) (#t (not-equal? '(1 :b \"c\" (array/new 4.0)) '(1 :b \"c\"))) (#t (not-equal? :a :b)) (#f (not-equal? :a :a)) (#t (not-equal? (array/new '(1 2 3) '(4.0 5.0 (tree/new :a 1 :b 2)) '(\"7\" (array/new 8 88) :9)) (array/new '(1 2 3) '(4.0 5.0 (tree/new :a 1 :a 2)) '(\"7\" (array/new 8 88) :9)))))) #{##(equal? val-a val-b)\n"
"0E000E010E0204020B00071C0900041B01\n"
"} int? (val) #@(documentation: \"Test whether val is an integer\\n\\nInteger are sometimes called fixnum's as well\\n\\nval: This argument is going to be tested\\n\\nWhether val is an integer\" source: (\"Test whether val is an integer\\n\\n      Integer are sometimes called fixnum's as well\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is an integer\" :cat :type-predicate (deftest #t (int? 123)) (deftest #f (int? 123.123)) (deftest #f (int? 'asd)) :inline (= :int (type-of val))) cat: :type-predicate tests: ((#f (int? 'asd)) (#f (int? 123.123)) (#t (int? 123))) inline: #t) #{##(:int type-of val)\n"
"1A000E010E0204012001\n"
"} float? (val) #@(documentation: \"Test whether val is a floating-point number\\n\\nFloat's are sometimes called flonum's as well\\n\\nval: This argument is going to be tested\\n\\nWhether val is a floating-point number\" source: (\"Test whether val is a floating-point number\\n\\n      Float's are sometimes called flonum's as well\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a floating-point number\" :cat :type-predicate (deftest #f (float? 123)) (deftest #t (float? 123.123)) (deftest #f (float? 'abc)) :inline (= :float (type-of val))) cat: :type-predicate tests: ((#f (float? 'abc)) (#t (float? 123.123)) (#f (float? 123))) inline: #t) #{##(:float type-of val)\n"
"1A000E010E0204012001\n"
"} number? (val) #@(documentation: \"Test whether val is a number\\n\\nRight now this means either a floating-point or integer number.\\n\\nval: This argument is going to be tested\\n\\nWhether val is a number\" cat: :type-predicate tests: ((#f (number? \"123\")) (#f (number? 'abc)) (#t (number? 123.123)) (#t (number? 123)))) #{##(:int type-of val :float #f)\n"
"1A000E010E020401200C0A00140D1A030E010E020401200C0A00060D1A0401\n"
"} bool? (val) #@(documentation: \"Test whether val is a boolean\\n\\nval: This argument is going to be tested\\n\\nWhether val is a boolean\" source: (\"Test whether val is a boolean\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a boolean\" :cat :type-predicate (deftest #t (bool? #t)) (deftest #t (bool? #f)) (deftest #f (bool? #nil)) (deftest #f (bool? 123)) (deftest #f (bool? 123.123)) (deftest #f (bool? 'qwe)) :inline (= :bool (type-of val))) cat: :type-predicate tests: ((#f (bool? 'qwe)) (#f (bool? 123.123)) (#f (bool? 123)) (#f (bool? #nil)) (#t (bool? #f)) (#t (bool? #t))) inline: #t) #{##(:bool type-of val)\n"
"1A000E010E0204012001\n"
"} pair? (val) #@(documentation: \"Test whether val is a pair\\n\\nA pair is sometimes also called a cons cell, which can be used to build lists and much more.\\n\\nval: This argument is going to be tested\\n\\nWhether val is a pair\" source: (\"Test whether val is a pair\\n\\n      A pair is sometimes also called a cons cell, which can be used to build lists and much more.\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a pair\" :cat :type-predicate (deftest #t (pair? '(#nil))) (deftest #t (pair? '(123))) (deftest #f (pair? 123)) (deftest #f (pair? 123.123)) (deftest #f (pair? 'qwe)) :inline (= :pair (type-of val))) cat: :type-predicate tests: ((#f (pair? 'qwe)) (#f (pair? 123.123)) (#f (pair? 123)) (#t (pair? '(123))) (#t (pair? '(#nil)))) inline: #t) #{##(:pair type-of val)\n"
"1A000E010E0204012001\n"
"} array? (val) #@(documentation: \"Test whether val is an array\\n\\nSometimes also called a vector.\\n\\nval: This argument is going to be tested\\n\\nWhether val is an array\" source: (\"Test whether val is an array\\n\\n      Sometimes also called a vector.\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is an array\" :cat :type-predicate (deftest #t (array? (array/new #nil))) (deftest #f (array? '(123))) (deftest #f (array? 123)) (deftest #f (array? 123.123)) (deftest #f (array? 'abc)) :inline (= :array (type-of val))) cat: :type-predicate tests: ((#f (array? 'abc)) (#f (array? 123.123)) (#f (array? 123)) (#f (array? '(123))) (#t (array? (array/new #nil)))) inline: #t) #{##(:array type-of val)\n"
"1A000E010E0204012001\n"
"} string? (val) #@(documentation: \"Test whether val is a string\\n\\nval: This argument is going to be tested\\n\\nWhether val is a string\" source: (\"Test whether val is a string\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a string\" :cat :type-predicate (deftest #t (string? \"asd\")) (deftest #f (string? (array/new #nil))) (deftest #f (string? '(123))) (deftest #f (string? 123)) (deftest #f (string? 123.123)) (deftest #f (string? 'abc)) :inline (= :string (type-of val))) cat: :type-predicate tests: ((#f (string? 'abc)) (#f (string? 123.123)) (#f (string? 123)) (#f (string? '(123))) (#f (string? (array/new #nil))) (#t (string? \"asd\"))) inline: #t) #{##(:string type-of val)\n"
"1A000E010E0204012001\n"
"} symbol? (val) #@(documentation: \"Test whether val is a symbol\\n\\nval: This argument is going to be tested\\n\\nWhether val is a symbol\" source: (\"Test whether val is a symbol\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a symbol\" :cat :type-predicate (deftest #t (symbol? 'abc)) (deftest #f (symbol? \"asd\")) (deftest #f (symbol? '(123))) (deftest #f (symbol? 123)) (deftest #f (symbol? 123.123)) :inline (= :symbol (type-of val))) cat: :type-predicate tests: ((#f (symbol? 123.123)) (#f (symbol? 123)) (#f (symbol? '(123))) (#f (symbol? \"asd\")) (#t (symbol? 'abc))) inline: #t) #{##(:symbol type-of val)\n"
"1A000E010E0204012001\n"
"} environment? (val) #@(documentation: \"Test whether val is an environment\\n\\nSometimes also called a closure\\n\\nval: This argument is going to be tested\\n\\nWhether val is an environment\" source: (\"Test whether val is an environment\\n\\n      Sometimes also called a closure\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is an environment\" :cat :type-predicate (deftest #t (environment? (current-closure))) (deftest #f (environment? (array/new #nil))) (deftest #f (environment? '(123))) :inline (= :environment (type-of val))) cat: :type-predicate tests: ((#f (environment? '(123))) (#f (environment? (array/new #nil))) (#t (environment? (current-closure)))) inline: #t) #{##(:environment type-of val)\n"
"1A000E010E0204012001\n"
"} tree? (val) #@(documentation: \"Test whether val is a binary tree\\n\\nTrees can also be used as maps, tuples or '\\n\\nval: This argument is going to be tested\\n\\nWhether val is a tree\" source: (\"Test whether val is a binary tree\\n\\n      Trees can also be used as maps, tuples or '\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a tree\" :cat :type-predicate (deftest #t (tree? (tree/new #nil))) (deftest #f (tree? (current-closure))) (deftest #f (tree? (array/new #nil))) (deftest #f (tree? '(123))) (deftest #f (tree? 123)) (deftest #f (tree? 123.123)) (deftest #f (tree? 'abc)) :inline (= :tree (type-of val))) cat: :type-predicate tests: ((#f (tree? 'abc)) (#f (tree? 123.123)) (#f (tree? 123)) (#f (tree? '(123))) (#f (tree? (array/new #nil))) (#f (tree? (current-closure))) (#t (tree? (tree/new #nil)))) inline: #t) #{##(:tree type-of val)\n"
"1A000E010E0204012001\n"
"} collection? (l) #@(documentation: \"Test whether val is a collection\\n\\nval: This argument is going to be tested\\n\\nWhether val is a collection\" source: (\"Test whether val is a collection\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a collection\" :cat :type-predicate (deftest #t (collection? (tree/new #nil))) (deftest #t (collection? (array/new #nil))) (deftest #t (collection? '(123))) (deftest #f (collection? (current-closure))) (deftest #f (collection? 123)) (deftest #f (collection? 123.123)) (deftest #f (collection? 'abc)) :inline (case (type-of l) ((:pair :array :tree) #t) (otherwise #f))) cat: :type-predicate tests: ((#f (collection? 'abc)) (#f (collection? 123.123)) (#f (collection? 123)) (#f (collection? (current-closure))) (#t (collection? '(123))) (#t (collection? (array/new #nil))) (#t (collection? (tree/new #nil)))) inline: #t) #{##(type-of l ΓεnΣym-2 :pair :array :tree #f)\n"
"150E000E01040107020D0E021A03200C0A001A0D0E021A04200C0A00100D0E02\n"
"1A05200C0A00060D1A060B00071B0900041C1601\n"
"} keyword? (v) #@(documentation: \"Test whether val is a keyword\\n\\nval: This argument is going to be tested\\n\\nWhether val is a keyword\" source: (\"Test whether val is a keyword\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a keyword\" :cat :type-predicate (deftest #t (keyword? :abc)) (deftest #f (keyword? 'abc)) (deftest #f (keyword? \"asd\")) (deftest #f (keyword? (array/new #nil))) (deftest #f (keyword? '(123))) (deftest #f (keyword? 123)) (deftest #f (keyword? 123.123)) :inline (= :keyword (type-of v))) cat: :type-predicate tests: ((#f (keyword? 123.123)) (#f (keyword? 123)) (#f (keyword? '(123))) (#f (keyword? (array/new #nil))) (#f (keyword? \"asd\")) (#f (keyword? 'abc)) (#t (keyword? :abc))) inline: #t) #{##(:keyword type-of v)\n"
"1A000E010E0204012001\n"
"} macro? (val) #@(documentation: \"Test whether val is a macro\\n\\nval: This argument is going to be tested\\n\\nWhether val is a macro\" source: (\"Test whether val is a macro\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a macro\" :cat :type-predicate (deftest #t (macro? case)) (deftest #f (macro? :abc)) :inline (= :macro (type-of val))) cat: :type-predicate tests: ((#f (macro? :abc)) (#t (macro? case))) inline: #t) #{##(:macro type-of val)\n"
"1A000E010E0204012001\n"
"} lambda? (val) #@(documentation: \"Test whether val is a function\\n\\nSometimes also called lambda or subroutine\\n\\nval: This argument is going to be tested\\n\\nWhether val is a function\" source: (\"Test whether val is a function\\n\\n      Sometimes also called lambda or subroutine\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a function\" :cat :type-predicate (deftest #t (lambda? min)) (deftest #f (lambda? case)) (deftest #f (lambda? (current-closure))) (deftest #f (lambda? 'abc)) :inline (or (= :lambda (type-of val)))) cat: :type-predicate tests: ((#f (lambda? 'abc)) (#f (lambda? (current-closure))) (#f (lambda? case)) (#t (lambda? min))) inline: #t) #{##(:lambda type-of val #f)\n"
"1A000E010E020401200C0A00060D1A0301\n"
"} native? (val) #@(documentation: \"Test whether val is a native function\\n\\nSometimes also called lambda or subroutine\\n\\nval: This argument is going to be tested\\n\\nWhether val is a native function\" source: (\"Test whether val is a native function\\n\\n      Sometimes also called lambda or subroutine\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a native function\" :cat :type-predicate (deftest #t (native? sin)) (deftest #f (native? (defn +123 (a) (+ a 123)))) (deftest #f (native? (defmacro +123 (a) (+ a 123)))) :inline (= :native-function (type-of val))) cat: :type-predicate tests: ((#f (native? (defmacro +123 (a) (+ a 123)))) (#f (native? (defn +123 (a) (+ a 123)))) (#t (native? sin))) inline: #t) #{##(:native-function type-of val)\n"
"1A000E010E0204012001\n"
"} buffer? (v) #@(documentation: \"Test whether val is a buffer\\n\\nBuffers are just modifiable chunks of memory\\n\\nval: This argument is going to be tested\\n\\nWhether val is a buffer\" source: (\"Test whether val is a buffer\\n\\n      Buffers are just modifiable chunks of memory\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a buffer\" :cat :type-predicate (deftest #t (buffer? #m00)) (deftest #f (buffer? \"asd\")) (deftest #f (buffer? (array/new #nil))) :inline (= :buffer (type-of v))) cat: :type-predicate tests: ((#f (buffer? (array/new #nil))) (#f (buffer? \"asd\")) (#t (buffer? #m00))) inline: #t) #{##(:buffer type-of v)\n"
"1A000E010E0204012001\n"
"} buffer-view? (v) #@(documentation: \"Test whether val is a buffer view\\n\\nval: This argument is going to be tested\\n\\nWhether val is a buffer view\" source: (\"Test whether val is a buffer view\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a buffer view\" :cat :type-predicate (deftest #t (buffer-view? (buffer/u8* #m00))) (deftest #f (buffer-view? #m00)) (deftest #f (buffer-view? \"asd\")) (deftest #f (buffer-view? (array/new #nil))) :inline (= :buffer-view (type-of v))) cat: :type-predicate tests: ((#f (buffer-view? (array/new #nil))) (#f (buffer-view? \"asd\")) (#f (buffer-view? #m00)) (#t (buffer-view? (buffer/u8* #m00)))) inline: #t) #{##(:buffer-view type-of v)\n"
"1A000E010E0204012001\n"
"} bytecode-array? (v) #@(documentation: \"Test whether val is a bytecode-array\\n\\nval: This argument is going to be tested\\n\\nWhether val is a buffer view\" source: (\"Test whether val is a bytecode-array\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a buffer view\" :cat :type-predicate (deftest #t (bytecode-array? #{##()\n"
"01\n"
"})) (deftest #f (bytecode-array? (buffer/u8* #m00))) (deftest #f (bytecode-array? #m00)) (deftest #f (bytecode-array? \"asd\")) (deftest #f (bytecode-array? (array/new #nil))) :inline (= :bytecode-array (type-of v))) cat: :type-predicate tests: ((#f (bytecode-array? (array/new #nil))) (#f (bytecode-array? \"asd\")) (#f (bytecode-array? #m00)) (#f (bytecode-array? (buffer/u8* #m00))) (#t (bytecode-array? #{##()\n"
"01\n"
"}))) inline: #t) #{##(:bytecode-array type-of v)\n"
"1A000E010E0204012001\n"
"} bytecode-op? (v) #@(documentation: \"Test whether val is a bytecode operation\\n\\nval: This argument is going to be tested\\n\\nWhether val is a bytecode op\" source: (\"Test whether val is a bytecode operation\\n\\n      val: This argument is going to be tested\\n\\n      Whether val is a bytecode op\" :cat :type-predicate (deftest #t (bytecode-op? (int->bytecode-op 1))) (deftest #f (bytecode-op? 1)) (deftest #f (bytecode-op? #{##()\n"
"01\n"
"})) (deftest #f (bytecode-op? (buffer/u8* #m00))) (deftest #f (bytecode-op? #m00)) (deftest #f (bytecode-op? (array/new #nil))) :inline (= :bytecode-op (type-of v))) cat: :type-predicate tests: ((#f (bytecode-op? (array/new #nil))) (#f (bytecode-op? #m00)) (#f (bytecode-op? (buffer/u8* #m00))) (#f (bytecode-op? #{##()\n"
"01\n"
"})) (#f (bytecode-op? 1)) (#t (bytecode-op? (int->bytecode-op 1)))) inline: #t) #{##(:bytecode-op type-of v)\n"
"1A000E010E0204012001\n"
"} procedure? (val) #@(documentation: \"Test whether val is a procedure\\n\\nProcedures in this context mean something you can use with map or put at the beginning of an expression.\\n\\nval: This argument is going to be tested\\n\\nWhether val is a procedure\" cat: :type-predicate tests: ((#f (procedure? (current-closure))) (#f (procedure? case)) (#t (procedure? sin)) (#t (procedure? min)) (#t (and (lambda? min) (procedure? min))) (#t (and (native? sin) (procedure? sin))))) #{##(:lambda type-of val #f :native-function)\n"
"1A000E010E020401200C0A00060D1A030C0A00140D1A040E010E020401200C0A\n"
"00060D1A0301\n"
"} callable? (val) #@(documentation: \"Test whether val is callable\\n\\nThis means basically anything where procedure? returns true, as well as macros, since they are\\njust standard procedures, but ones who run during compile time.\\n\\nval: This argument is going to be tested\\n\\nWhether val is callable\" cat: :type-predicate tests: ((#f (callable? (current-closure))) (#t (callable? sin)) (#t (callable? min)) (#t (and (macro? case) (callable? case))))) #{##(:macro type-of val procedure? #f)\n"
"1A000E010E020401200C0A00110D0E030E0204010C0A00060D1A0401\n"
"} in-range? (v min max) #@() #{##(v min max)\n"
"0E000E01210C0B00090D0E000E021F01\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A081A091A0A1A0B\n"
"1707080D1A0C1A0D1A0E1A0F17070C0D1A101A111A121A131707100D1A141A15\n"
"1A161A171707140D1A181A191A1A1A1B1707180D1A1C1A1D1A1E1A1F17071C0D\n"
"1A201A211A221A231707200D1A241A251A261A271707240D1A281A291A2A1A2B\n"
"1707280D1A2C1A2D1A2E1A2F17072C0D1A301A311A321A331707300D1A341A35\n"
"1A361A371707340D1A381A391A3A1A3B1707380D1A3C1A3D1A3E1A3F17073C0D\n"
"1A401A411A421A431707400D1A441A451A461A471707440D1A481A491A4A1A4B\n"
"1707480D1A4C1A4D1A4E1A4F17074C0D1A501A511A521A531707500D1A541A55\n"
"1A561A571707540D1A581A591A5A1A5B1707580D1A5C1A5D1A5E1A5F17075C0D\n"
"1A601A611A621A631707600D1A641A651A661A671707640D1A681A691A6A1A6B\n"
"1707680D1A6C1A6D1A6E1A6F17076C0D1A701A711A721A731707700D1A741A75\n"
"1A761A771707740D1A781A791A7A1A7B17077801\n"
"}#{##(quasiquote-real (l depth) #@() #{##(l :pair type-of unquote-splicing depth list append quasiquote-real unquote quasiquote cons :symbol quote)\n"
"0E000B00072409000524010D1A010E020E000401200B00C20E0011111A03200B\n"
"00360E042A0B001A0E051A060E001112110E070E00120E04040204030900160E\n"
"051A030E070E00121102FF0E0425040204020900820E00111A08200B00260E04\n"
"2A0B000A0E0012110900160E051A080E070E00121102FF0E0425040204020900\n"
"560E00111A09200B00190E070E070E00121102010E042504020E040402090037\n"
"0E042A0B001E0E051A0A0E070E00110E0404020E070E00120E04040204030900\n"
"160E070E00110E0404020E070E00120E040402140900230E042A0C0B000D0D1A\n"
"0B0E020E000401200B000D1A0C0E002414140900050E0001\n"
"} quasiquote (l) #{##(quasiquote-real l)\n"
"0E000E010200040201\n"
"} unquote (expr) #{##(throw list :unquote-without-quasiquote \"unquote should only occur inside a quasiquote, never evaluated directly\")\n"
"0E000E011A021A030402040101\n"
"} unquote-splicing (expr) #{##(throw list :unquote-splicing-without-quasiquote \"unquote-splicing should only occur inside a quasiquote, never evaluated directly\")\n"
"0E000E011A021A030402040101\n"
"})\n"
"151A001A011A021A031707000D1A041A051A021A061807041607040D1A071A08\n"
"1A021A091707070D1A0A1A0B1A021A0C17070A01\n"
"}#{##(3.141593 PI π inc (x) #@(documentation: \"Return a number 1 greater than x\" source: (:inline \"Return a number 1 greater than x\" (+ 1 x)) inline: #t) #{##(x)\n"
"02010E002501\n"
"} dec (x) #@(documentation: \"Return a number 1 less than x\" source: (:inline \"Return a number 1 less than x\" (- x 1)) inline: #t) #{##(x)\n"
"0E0002012601\n"
"} inc! (i v) #@(documentation: \"Decrement I by V (defaults to 1) and store the result in I\") #{##(set! i + v #f)\n"
"1A000E011A020E010E030C0A000D0D02010C0A00060D1A042414141424141414\n"
"01\n"
"} dec! (i v) #@(documentation: \"Decrement I by V and store the result in I\") #{##(set! i - v #f)\n"
"1A000E011A020E010E030C0A000D0D02010C0A00060D1A042414141424141414\n"
"01\n"
"} +x (α) #@(documentation: \"Return a function that adds α to it's argument, useful for mapping\") #{##(anonymous (β) #@() #{##(α β)\n"
"0E000E012501\n"
"})\n"
"1A001A011A021A031701\n"
"} radians (degrees) #@(documentation: \"Convert a quantity in degrees to radians\") #{##(π degrees 180.0)\n"
"0E000E01271A022801\n"
"} min args #@(documentation: \"Returns the minimum value of its arguments\\n\\nargs: A varible amount of numbers\\n\\nThe smallest value\" cat: :math tests: ((4 (min 4 9)) (4 (min 4)) (#nil (min)) (1 (reduce (array/new 25 4 9 1) min)) (1 (apply min '(25 4 9 1))) (4 (min 25.3 4 9.1)) (8.2 (reduce (array/new 32 9 8.2) min)) (1 (apply min '(1 4 9 25))) (2 (min 2 4 9 25)))) #{##(reduce args anonymous (a b) #@() #{##(a b)\n"
"0E000E011E0B00080E000900050E0101\n"
"})\n"
"0E000E011A021A031A041A0517040201\n"
"} max #@(documentation: \"Returns the maximum value of its arguments\\n\\nargs: A variable amount of numbers\\n\\nThe biggest value\" cat: :math tests: ((25 (reduce (array/new 25 4 9 1) max)) (25 (apply max '(25 4 9 1))) (31.0 (max 31.0 4 9 1)) (25 (reduce (array/new 1 4 9 25) max)) (25 (apply max '(1 4 9 25))) (25 (max 1 4 9 25)) (9.1 (max 4 9.1)) (1 (max 1)) (#nil (max)))) #{##(reduce args anonymous (a b) #@() #{##(a b)\n"
"0E000E01220B00080E000900050E0101\n"
"})\n"
"0E000E011A021A031A041A0517040201\n"
"})\n"
"1A0007010D0E0107020D1A031A041A051A061707030D1A071A081A091A0A1707\n"
"070D1A0B1A0C1A0D1A0E18070B0D1A0F1A101A111A1218070F0D1A131A141A15\n"
"1A161707130D1A171A181A191A1A1707170D1A1B1A1C1A1D1A1E17071B0D1A1F\n"
"1A1C1A201A2117071F01\n"
"}#{##(describe/closure (c i) #@(cat: :compiler internal: #t) #{##(c root-closure cat int i #f \"# <root environment>\" \"\\r\\n\" closure/data data length l \"# \" string/write \" - \" resolve *module* \"-+- Very big tree structure -+-\" describe/closure closure/caller)\n"
"0E000B00A50E000E01200B00260E020E020E030E040C0A000D0D02000C0A0006\n"
"0D1A0504011A0604021A0704020900770E080E00040107090D0E0A0E09040107\n"
"0B0D0E020E030E040C0A000D0D02000C0A00060D1A0504011A0C0E0D0E000401\n"
"1A0E0E0F1A100E0004021A0E0E0B02101E0B000C0E0D0E0904010900051A111A\n"
"070E120E130E0004010E030E040C0A000D0D02000C0A00060D1A050401020125\n"
"040204090900042401\n"
"} stacktrace (#nil) #@() #{##(print describe/closure closure/caller current-lambda)\n"
"0E000E010E020E03040004010401040101\n"
"} print/error/wrap (i v) #{##(i ΓεnΣym-1 v string/write describe/closure string)\n"
"150E0007010D0E010200200B00080E0209002B0E010202200B000C0E030E0204\n"
"0109001A0E010203200B000C0E040E0204010900090E050E0204011601\n"
"} print/error/iter (error i) #{##(error print/error/wrap i print/error/iter \"\")\n"
"0E000B001C0E010E020E001104020E030E001202010E02250402140900071A04\n"
"241401\n"
"} print/error (error) #@(documentation: \"Display ERROR in a nice, human readable way\") #{##(print join print/error/iter error \"\\r\\n\")\n"
"0E000E010E020E03020004021A040402040101\n"
"} closure/documentation (o) #{##(meta o :documentation)\n"
"0E000E011A02040201\n"
"} closure/cat (o) #{##(meta o :cat :unsorted #f)\n"
"0E000E011A0204020C0A000D0D1A030C0A00060D1A0401\n"
"} describe/thing (o) #@(documentation: \"Describe a specific value O\") #{##(closure/documentation o documentation closure/name name print fmt-arg-0 cat \"(\" closure/arguments arguments :pair type-of ΓεnΣym-2 throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" arg \" \" println \")\" \" . \" \"\\n\")\n"
"0E000E01040107020D0E030E01040107040D0E05150E030E01040107060D0E07\n"
"1A080E0604021604010D0E090E010401070A0D1A0B0E0C0E0A0401200B008515\n"
"0E0A070D0D2409006B0D1A0B0E0C0E0D0401200B0007240900150E0E0E0F1A10\n"
"1A110E0A0E120400040404010D0E0C0E0D04011A0B200B0007240900150E0E0E\n"
"0F1A101A130E0D0E120400040404010D0E0D1107140D0E140B00120E050E071A\n"
"150E1404020401090004240D0E0D12050D0E0D0AFF960D0E161A170401160900\n"
"110E050E071A180E0A1A17040304010D0E160E071A190E02040204010D2401\n"
"} describe/string (a) #@(documentation: \"Descibe whatever value string A resolves to\") #{##(describe/thing resolve string->symbol a)\n"
"0E000E010E020E0304010401040101\n"
"} describe (fun) #@(documentation: \"Describe FUN, if there is documentation available\") #{##(:string type-of fun describe/string describe/thing)\n"
"1A000E010E020401200B000C0E030E0204010900090E040E02040101\n"
"} current-closure root-closure deftest l #{##()\n"
"2401\n"
"} comment body #@(documentation: \"Does nothing, mainly used for commenting out\\nparts of an expression, but having the sub expressions\\nbe available so you can use them easily via nujel-mode.\" cat: :documentation tests: ((#nil (let (x #nil) (comment (set! x #t)) x)))) #{##()\n"
"2401\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D151A081A091A061A\n"
"0A1707080D1A0B1A0C1A061A0D17070B0D1A0E1A0F1A101A1117070E16070E0D\n"
"1A121A131A061A141707120D1A151A161A061A171707150D151A181A191A1A1A\n"
"1B1707180D1A1C1A1D1A1E1A1F17071C0D1A201A211A221A231707201607200D\n"
"0E24040007250D1A261A271A061A281807260D1A291A2A1A2B1A2C18072901\n"
"}#{##(lower-case-char (c) #@() #{##(c)\n"
"0E0002411E0B00080E000900150E00025A220B00080E000900080E0002202501\n"
"} upper-case-char (c) #{##(c)\n"
"0E0002611E0B00080E000900150E00027A220B00080E000900080E0002E02501\n"
"} whitespace? (c) #@(documentation: \"Return #t if C is a whitespace char\") #{##(c #f)\n"
"0E000220200C0A00240D0E000209200C0A001A0D0E00020A210C0B00090D0E00\n"
"020D1F0C0A00060D1A0101\n"
"} from-char-code l #@(documentation: \"Turn the provided char codes into a string and return it\") #{##(buffer/allocate list/length l buf i :int type-of 255 #f throw list :type-error \"(from-char-code) expects :int arguments from 0 to 255, not: \" current-lambda buffer/set! buffer/length buffer->string)\n"
"0E000E010E020401040107030D15020007040D240900650D1A050E060E021104\n"
"01200B00071C0900041B0C0A001C0D0E02111A07220C0A00110D0E021102001E\n"
"0C0A00060D1A080B00190E090E0A1A0B1A0C0E02110E0D040004040401090004\n"
"240D0E0E0E030E040E021104030D0E021205020D0E042305040E040E0F0E0304\n"
"011E0AFF950D0E100E0304011601\n"
"})\n"
"1A001A011A021A031707000D1A041A051A021A061707040D1A071A081A091A0A\n"
"1707070D1A0B1A0C1A0D1A0E17070B01\n"
"}#{##(tree/new :align :right :debug :base :width :padding-char \" \" fmt/format-arg/default fmt/find-non-digit-from-right (s i) #@() #{##(i ref s char fmt/find-non-digit-from-right)\n"
"0E0002001E0B000802FF0900300E010E020E00040207030D0E030230210C0B00\n"
"090D0E0302391F0B00110E040E020E0002012604020900050E0001\n"
"} fmt/parse-spec (opts spec) #{##(buffer/length spec opts ref ΓεnΣym-1 #f fmt/find-non-digit-from-right next-non-digit string/cut number tree/set! :width read/single :padding-char \"0\" fmt/parse-spec :debug :base :HEXADECIMAL :hexadecimal :decimal :octal :binary :align :left :center :right :precision throw list :format-error \"Unknown form-spec option\" current-closure)\n"
"0E000E0104012A0B00080E020902A3150E030E010E000E010401020126040207\n"
"040D0E040230200C0A00600D0E040231200C0A00560D0E040232200C0A004C0D\n"
"0E040233200C0A00420D0E040234200C0A00380D0E040235200C0A002E0D0E04\n"
"0236200C0A00240D0E040237200C0A001A0D0E040238200C0A00100D0E040239\n"
"200C0A00060D1A050B006B0E060E010E000E010401020126040207070D0E080E\n"
"0102010E07250E000E010401040307090D0E0A0E021A0B0E0C0E09040104030D\n"
"02300E030E0902000402200B00100E0A0E021A0D1A0E0403090004240D0E0F0E\n"
"020E080E01020002010E0725040304020901BE0E04023F200B00240E0F0E0A0E\n"
"021A101B04030E080E0102000E000E010401020126040304020901950E040258\n"
"200B00250E0F0E0A0E021A111A1204030E080E0102000E000E01040102012604\n"
"03040209016B0E040278200B00250E0F0E0A0E021A111A1304030E080E010200\n"
"0E000E010401020126040304020901410E040264200B00250E0F0E0A0E021A11\n"
"1A1404030E080E0102000E000E010401020126040304020901170E04026F200B\n"
"00250E0F0E0A0E021A111A1504030E080E0102000E000E010401020126040304\n"
"020900ED0E040262200B00250E0F0E0A0E021A111A1604030E080E0102000E00\n"
"0E010401020126040304020900C30E04023C200B00250E0F0E0A0E021A171A18\n"
"04030E080E0102000E000E010401020126040304020900990E04025E200B0025\n"
"0E0F0E0A0E021A171A1904030E080E0102000E000E0104010201260403040209\n"
"006F0E04023E200B00250E0F0E0A0E021A171A1A04030E080E0102000E000E01\n"
"0401020126040304020900450E04022E200B002B0E0F0E0A0E021A1B0E030E02\n"
"1A0B040204030E080E0102000E000E010401020126040304020900150E1C0E1D\n"
"1A1E1A1F0E010E200400040404011601\n"
"} fmt/debug (opts) #{##(ref opts :debug tree/set! :argument list string/write)\n"
"0E000E011A0204020B001C0E030E011A040E050E060E000E011A040402040204\n"
"030900050E0101\n"
"} fmt/number-format (opts) #{##(ref opts :base ΓεnΣym-2 :binary tree/set! :argument list int->string/binary :octal int->string/octal :decimal int->string/decimal :hexadecimal int->string/hex :HEXADECIMAL int->string/HEX)\n"
"150E000E011A02040207030D0E031A04200B001C0E050E011A060E070E080E00\n"
"0E011A060402040204030900890E031A09200B001C0E050E011A060E070E0A0E\n"
"000E011A060402040204030900680E031A0B200B001C0E050E011A060E070E0C\n"
"0E000E011A060402040204030900470E031A0D200B001C0E050E011A060E070E\n"
"0E0E000E011A060402040204030900260E031A0F200B001C0E050E011A060E07\n"
"0E100E000E011A060402040204030900050E011601\n"
"} :binary \"#b\" :octal \"#o\" :decimal \"#d\" :hexadecimal \"#x\" :HEXADECIMAL fmt/number-format-prefixex fmt/number-format-prefix (opts) #{##(ref opts :debug :base #f tree/set! fmt/number-format-prefixex :argument list cat)\n"
"0E000E011A0204020B00071C0900041B0C0A001B0D0E000E011A0304020B0007\n"
"1C0900041B0C0A00060D1A040B00080E010900440E050E000E060E000E011A03\n"
"040204020B002A0E050E011A070E080E090E000E060E000E011A03040204020E\n"
"000E011A070402040304030900050E011A021C040301\n"
"} fmt/add-padding (opts) #{##(ref opts :width tree/set! :argument list :align ΓεnΣym-3 :right pad-start :center pad-middle :left pad-end :debug :base :padding-char)\n"
"0E000E011A0204020B00850E030E011A040E05150E000E011A06040207070D0E\n"
"071A08200B00080E0909001E0E071A0A200B00080E0B0900110E071A0C200B00\n"
"080E0D09000424160E000E011A0404020E000E011A0E04020C0B000C0D0E000E\n"
"011A0F04020B00110E000E011A02040202022609000B0E000E011A0204020E00\n"
"0E011A100402040404030900050E0101\n"
"} fmt/precision (opts) #{##(ref opts :precision tree/set! :argument list string/round)\n"
"0E000E011A0204020B00240E030E011A040E050E060E000E011A0404020E000E\n"
"011A020402040304030900050E0101\n"
"} fmt/truncate (opts) #{##(ref opts :width tree/set! :argument list string/cut)\n"
"0E000E011A0204020B00290E030E011A040E050E060E000E011A040402020002\n"
"010E000E011A02040225040404030900050E0101\n"
"} fmt/output (opts) #{##(ref opts :argument)\n"
"0E000E011A02040201\n"
"} fmt/format-arg (spec argument) #{##(fmt/output fmt/debug fmt/number-format-prefix fmt/truncate fmt/add-padding fmt/precision fmt/number-format tree/set! fmt/parse-spec tree/dup fmt/format-arg/default spec :argument argument)\n"
"0E000E010E020E030E040E050E060E070E080E090E0A04010E0B04021A0C0E0D\n"
"0403040104010401040104010401040101\n"
"} fmt/valid-argument? (argument) #{##(:int type-of argument :symbol #f)\n"
"1A000E010E020401200C0A00140D1A030E010E020401200C0A00060D1A0401\n"
"} fmt/arg-sym (v) #{##(type-of v ΓεnΣym-4 :int fmt/arg-sym cat \"fmt-arg-\" string :symbol :string string->symbol throw list :type-error \"Invalid fmt argument name\" current-lambda)\n"
"150E000E01040107020D0E021A03200B00160E040E051A060E070E0104010402\n"
"04010900330E021A08200B00080E010900260E021A09200B000C0E0A0E010401\n"
"0900150E0B0E0C1A0D1A0E0E010E0F0400040404011601\n"
"} fmt/expr (expr arguments-used opts) #{##(:string type-of expr throw list :format-error \"fmt needs a string literal as a first argument, since it is implemented as a macro\" current-lambda split \":\" split-expr argument \"\" #f format-spec tree/+= opts :expr-count array/set! arguments-used ref fmt/format-arg fmt/arg-sym read read-vals \"Format argument specifier contains more than a single atom\" fmt/valid-argument? \"Format argument specifier should be either an integer or a symbol\" :int array/length \"fmt numbered argument is out of bounds\")\n"
"1A000E010E020401200B0007240900150E030E041A051A060E020E0704000404\n"
"04010D0E080E021A090402070A0D0E0A11070B0D0E0A12110C0A000D0D1A0C0C\n"
"0A00060D1A0D070E0D1A0C0E0B200B00330E0F0E101A1102FF04030D0E120E13\n"
"0E140E101A1104021B04030D0E150E0E0E160E140E101A110402040104020900\n"
"AB150E170E0B040107180D0E18120B00180E030E041A051A190E0B0E07040004\n"
"040401090004240D0E1A0E181104010B0007240900150E030E041A051A1B0E0B\n"
"0E070400040404010D1A1C0E010E18110401200B00460E181102001E0C0A0015\n"
"0D0E18110E1D0E130401210C0A00060D1A0D0B00180E030E041A051A1E0E0B0E\n"
"07040004040401090004240D0E120E130E18111B0403090004240D0E150E0E0E\n"
"160E1811040104021601\n"
"} fmt (format-string . args) #@(documentation: \"Return a formatted string\") #{##(:string type-of format-string throw list :type-error \"fmt needs a string literal as a first argument, since it is implemented as a macro\" current-lambda cuts i ref ΓεnΣym-5 :int :format-error \"fmt placeholders can't be nested\" \"fmt expects all brackets to be closed\" buffer/length expr-list last-pos array/fill! array/allocate length args arguments-used tree/new :expr-count array/length opts ΓεnΣym-6 :pair \"Improper list detected, please provide a proper list instead\" \"Expected a value of type :pair\" c string/cut lit \"\" fmt/expr expr \"fmt expects all arguments to be used\" cat string fmt/args/map-fun/count fmt/args/map-fun (arg) #@() #{##(string->symbol cat \"fmt-arg-\" string fmt/args/map-fun/count s list def arg)\n"
"0E000E011A020E030E0404010402040107050D0E0402012505040D0E061A070E\n"
"050E08040301\n"
"} let* append map)\n"
"1A000E010E020401200B0007240900150E030E041A051A060E020E0704000404\n"
"04010D2407080D15020007090D240900890D150E0A0E020E090402070B0D0E0B\n"
"027B200B00311A0C0E010E08110401200B00180E030E041A0D1A0E0E020E0704\n"
"0004040401090004240D0E090E0814050809003F0E0B027D200B00361A0C0E01\n"
"0E08110401200B0007240900150E030E041A0D1A0F0E020E070400040404010D\n"
"0E08110E09140E081214050809000424160D0E092305090E090E100E0204011E\n"
"0AFF710D24160D1A0C0E010E08110401200B00180E030E041A0D1A0E0E020E07\n"
"040004040401090004240D2407110D0E100E02040107120D0E130E140E150E16\n"
"040104011C040207170D0E181A190E1A0E1704010402071B0D150E08071C0D24\n"
"0900A20D1A1D0E010E1C0401200B0007240900150E030E041A051A1E0E080E07\n"
"0400040404010D0E010E1C04011A1D200B0007240900150E030E041A051A1F0E\n"
"1C0E070400040404010D0E1C1107200D0E210E020E20120201250E1204030722\n"
"0D1A230E22200B00072409000A0E220E111405110D0E240E210E0202010E2011\n"
"250E201204030E170E1B040307250D0E250E111405110D0E201105120D0E1C12\n"
"051C0E1C0AFF5F0D24160D0E120200220B001A0E210E0202000E12040307220D\n"
"0E220E11140511090004240D15020007090D240900370D0E0A0E170E0904020B\n"
"0007240900210E030E041A0D1A260E040E020E0A0E160E09040204020E070400\n"
"040404010D0E092305090E090E1A0E1704011E0AFFC30D24160D0E11120B000B\n"
"1A270E111409001B1A000E010E11110401200B00090E11110900081A280E1114\n"
"07250D020007290D1A2A1A2B1A2C1A2D17072A0D0E160B00191A2E0E2F0E300E\n"
"160E2A04020E2524140402140900050E2501\n"
"} pfmt (format-string . args) #@(documentation: \"Print a formatted string\") #{##(print fmt format-string append args)\n"
"1A001A010E020E030E04240402141424141401\n"
"} efmt (format-string . args) #{##(error fmt format-string append args)\n"
"1A001A010E020E030E04240402141424141401\n"
"} pfmtln (format-string . args) #{##(println fmt format-string append args)\n"
"1A001A010E020E030E04240402141424141401\n"
"} efmtln (format-string . args) #{##(errorln fmt format-string append args)\n"
"1A001A010E020E030E04240402141424141401\n"
"})\n"
"150E001A011A021A031C1A041C1A05241A061A07040A07080D1A091A0A1A0B1A\n"
"0C1707090D1A0D1A0E1A0B1A0F17070D0D1A101A111A0B1A121707100D1A131A\n"
"141A0B1A151707130D0E001A161A171A181A191A1A1A1B1A1C1A1D1A1E1A1D04\n"
"0A071F0D1A201A211A0B1A221707200D1A231A241A0B1A251707230D1A261A27\n"
"1A0B1A281707260D1A291A2A1A0B1A2B1707290D1A2C1A2D1A0B1A2E17072C0D\n"
"1A2F1A301A0B1A3117072F0D1A321A331A0B1A341707320D1A351A361A0B1A37\n"
"1707350D1A381A391A0B1A3A1707380D1A3B1A3C1A3D1A3E18073B16073B0D1A\n"
"3F1A401A411A4218073F0D1A431A441A411A451807430D1A461A471A411A4818\n"
"07460D1A491A4A1A411A4B18074901\n"
"}#{##(path/ext?! (ext) #@(documentation: \"Return a predicate that checks if a path ends on EXT\") #{##(type-of ext ΓεnΣym-1 :string anonymous (path) #@() #{##(ext lower-case path/extension path)\n"
"0E000E010E020E03040104012001\n"
"} :pair (path) #{##(lower-case path/extension path cext reduce ext anonymous (α β) #@() #{##(α β cext #f)\n"
"0E000C0A00100D0E010E02200C0A00060D1A0301\n"
"})\n"
"0E000E010E020401040107030D0E040E051A061A071A081A0917040201\n"
"} throw list :type-error \"Expected a :string or :list\" current-lambda)\n"
"150E000E01040107020D0E021A03200B000F1A041A051A061A07170900290E02\n"
"1A08200B000F1A041A091A061A0A170900150E0B0E0C1A0D1A0E0E010E0F0400\n"
"040404011601\n"
"} path/extension (path) #@(documentation: \"Return the extension of PATH\") #{##(last-index-of path \".\" last-period string/cut buffer/length)\n"
"0E000E011A02040207030D0E030200210B00170E040E0102010E03250E050E01\n"
"040104030900050E0101\n"
"} path/without-extension (path) #@(documentation: \"Return PATH, but without the extension part\") #{##(last-index-of path \".\" last-period string/cut)\n"
"0E000E011A02040207030D0E030200210B00100E040E0102000E030403090005\n"
"0E0101\n"
"} path/dirname (path) #@(documentation: \"Return the directory part of a PATH\") #{##(last-index-of path \"/\" last-slash string/cut \"\")\n"
"0E000E011A02040207030D0E030200210B00100E040E0102000E030403090005\n"
"1A0501\n"
"} path/basename (path) #@(documentation: \"Return the path without the directory part\") #{##(last-index-of path \"/\" last-slash string/cut)\n"
"0E000E011A02040207030D0E030200210B00110E040E0102010E032504020900\n"
"050E0101\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A081A091A0A1A0B\n"
"1707080D1A0C1A0D1A0E1A0F17070C0D1A101A111A121A1317071001\n"
"}#{##(make-output-port make-string-output-port make-input-port buffer/allocate temporary-buffer buffer/u8* temporary-buffer-view tree/new :flush-output anonymous (handle) #@() #{##(file/flush* handle)\n"
"0E000E01040101\n"
"} :block-write (handle buffer size) #{##(file/write* handle buffer size)\n"
"0E000E010E020E03040301\n"
"} :char-write (handle char) #{##(buffer/set! temporary-buffer-view char file/write* handle)\n"
"0E000E0102000E0204030D0E030E040E01040201\n"
"} :close! (handle) #{##(file/close* handle)\n"
"0E000E01040101\n"
"} :position (handle) #{##(file/tell* handle)\n"
"0E000E01040101\n"
"} :position! (handle new-position) #{##(file/seek* handle new-position)\n"
"0E000E010E020200040301\n"
"} :file-handle (handle) #{##(handle)\n"
"0E0001\n"
"} :methods (handle) #{##(output-port-method-table)\n"
"0E0001\n"
"} output-port-method-table (self buffer size) #{##(meta self :buffer buf size buffer/length buffer :position buffer/length! 128 bit-and buffer/copy meta!)\n"
"0E000E011A02040207030D0E040B00072409000B0E050E06040105040D0E040E\n"
"050E0304010E000E011A07040226220B001E0E080E031A090E0A0E050E030401\n"
"0E042502800402250402090004240D0E0B0E030E060E000E011A0704020E0404\n"
"040D0E0C0E011A070E000E011A0704020E0425040301\n"
"} (self char) #{##(meta self :buffer buf buffer/length :position buffer/length! 128 buffer/set! char meta!)\n"
"0E000E011A02040207030D0E040E0304010E000E011A0504022602011E0B0015\n"
"0E060E031A070E040E030401250402090004240D0E080E030E000E011A050402\n"
"0E0904030D0E0A0E011A050E000E011A050402020125040301\n"
"} :write (self . buffers) #{##(buffers ΓεnΣym-1 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" buf self :block-write)\n"
"150E0007010D2409005E0D1A020E030E010401200B0007240900150E040E051A\n"
"061A070E000E080400040404010D0E030E0104011A02200B0007240900150E04\n"
"0E051A061A090E010E080400040404010D0E0111070A0D0E0B1A0C0E0A04020D\n"
"0E011205010E010AFFA30D0E0B1601\n"
"} (self) #{##(self)\n"
"0E0001\n"
"} :return-string (self) #{##(buffer->string meta self :buffer :position)\n"
"0E000E010E021A0304020E010E021A040402040201\n"
"} (self) #{##(string-out-methods)\n"
"0E0001\n"
"} string-out-methods :block-read (handle buffer size) #{##(file/eof*? handle :end-of-file file/read* buffer size)\n"
"0E000E0104010B00091A0201090004240D0E030E010E040E05040301\n"
"} :char-read (handle char) #{##(file/eof*? handle :end-of-file file/read* temporary-buffer-view ref char)\n"
"0E000E0104010B00091A0201090004240D0E030E010E04020104030B00072409\n"
"00061A02010D0E050E0402000E06040301\n"
"} :raw! (handle) #{##(file/raw* handle)\n"
"0E000E011B040201\n"
"} ref (handle) #{##(input-port-method-table)\n"
"0E0001\n"
"} input-port-method-table (handle) #@(documentation: \"Create a new output port for HANDLE\") #{##(anonymous (method . args) #@() #{##(apply ref output-port-method-table method handle args)\n"
"0E000E010E020E0304020E040E0514040201\n"
"})\n"
"1A001A011A021A031701\n"
"} (#nil) #@(documentation: \"Create a new string output port\") #{##(self anonymous (method . args) #@() #{##(apply ref string-out-methods method self args)\n"
"0E000E010E020E0304020E040E0514040201\n"
"} meta! :buffer buffer/allocate 128 :position)\n"
"2407000D1A011A021A031A041705000D0E050E001A060E071A08040104030D0E\n"
"050E001A090200040301\n"
"} (handle) #@(documentation: \"Create a new input port for HANDLE\") #{##(anonymous (method . args) #@() #{##(apply ref input-port-method-table method handle args)\n"
"0E000E010E020E0304020E040E0514040201\n"
"})\n"
"1A001A011A021A031701\n"
"} with-string-port (name . body) #{##(let name make-string-output-port append body quote return-string)\n"
"1A000E011A02241424141424140E030E040E011A051A06241414241414241404\n"
"02141401\n"
"} cat l #@(documentation: \"ConCATenates all arguments into a single string\") #{##(make-string-output-port p l ΓεnΣym-2 :pair type-of throw list :type-error \"Improper list detected, please provide a proper list instead\" current-lambda \"Expected a value of type :pair\" c block-write string/display return-string)\n"
"0E00040007010D150E0207030D240900620D1A040E050E030401200B00072409\n"
"00150E060E071A081A090E020E0A0400040404010D0E050E0304011A04200B00\n"
"07240900150E060E071A081A0B0E030E0A0400040404010D0E0311070C0D0E01\n"
"1A0D0E0E0E0C040104020D0E031205030E030AFF9F0D0E011A0F04011601\n"
"})\n"
"2407000D2407010D2407020D150E030201040107040D0E050E04040107060D0E\n"
"071A081A091A0A1A0B1A0C171A0D1A091A0E1A0B1A0F171A101A091A111A0B1A\n"
"12171A131A091A141A0B1A15171A161A091A171A0B1A18171A191A091A1A1A0B\n"
"1A1B171A1C1A091A1D1A0B1A1E171A1F1A091A201A0B1A2117041007220D0E07\n"
"1A0D1A091A231A0B1A24171A101A091A251A0B1A26171A271A091A281A0B1A29\n"
"171A131A091A2A1A0B1A2B171A2C1A091A2D1A0B1A2E171A1F1A091A2F1A0B1A\n"
"3017040C07310D0E071A321A091A331A0B1A34171A351A091A361A0B1A37171A\n"
"381A091A391A0B1A3A171A130E3B0E221A1304021A160E3B0E221A1604021A19\n"
"0E3B0E221A1904021A1C0E3B0E221A1C04021A1F1A091A3C1A0B1A3D17041007\n"
"3E0D1A091A3F1A401A411705000D1A091A421A431A441705010D1A091A451A46\n"
"1A47170502160D1A481A491A0B1A4A1807480D1A4B1A4C1A4D1A4E17074B01\n"
"}#{##(int->string/binary (α) #@(documentation: \"Turn α into a its **binary** string representation\") #{##(\"\" ret α #f \"0\" cat from-char-code bit-and bit-shift-right not=)\n"
"1A0007010D0E020B00071C0900041B0C0A000E0D0E022A0C0A00060D1A030B00\n"
"091A0401090004240D240900260D0E050E0602300E070E02020104022504010E\n"
"01040205010D0E080E020201040205020E0902000E0204020AFFD50D0E0101\n"
"} int->string/octal (α) #@(documentation: \"Turn α into a its **octal** string representation\") #{##(\"\" ret α #f \"0\" cat from-char-code bit-and bit-shift-right not=)\n"
"1A0007010D0E020B00071C0900041B0C0A000E0D0E022A0C0A00060D1A030B00\n"
"091A0401090004240D240900260D0E050E0602300E070E02020704022504010E\n"
"01040205010D0E080E020203040205020E0902000E0204020AFFD50D0E0101\n"
"} ##(\"0\" \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\") int->string/hex/conversion-arr int->string/HEX (α) #@(documentation: \"Turn α into a its **hexadecimal** string representation\") #{##(\"\" ret α #f \"0\" throw list :type-error \"Can't print negative numbers in hex for now\" current-lambda cat ref int->string/hex/conversion-arr bit-and bit-shift-right not=)\n"
"1A0007010D0E020B00071C0900041B0C0A000E0D0E022A0C0A00060D1A030B00\n"
"091A0401090004240D0E0202001E0B00180E050E061A071A080E020E09040004\n"
"040401090004240D240900250D0E0A0E0B0E0C0E0D0E02020F040204020E0104\n"
"0205010D0E0E0E020204040205020E0F02000E0204020AFFD60D0E0101\n"
"} int->string/hex (α) #{##(lower-case int->string/HEX α)\n"
"0E000E010E020401040101\n"
"} int->string/decimal (α) #@(documentation: \"Turn α into a its **decimal** string representation\") #{##(string α)\n"
"0E000E01040101\n"
"} int->string write/raw/array (v port hr?) #@() #{##(port block-write \"##(\" i write/raw ref v hr? array/length \" \" \")\")\n"
"0E001A011A0204020D15020007030D240900360D0E040E050E060E0304020E00\n"
"0E0704030D0E030E080E0604010201261E0B000E0E001A011A09040209000424\n"
"0D0E032305030E030E080E0604011E0AFFC40D24160D0E001A011A0A040201\n"
"} write/raw/buffer (v port hr?) #{##(hr? port write \"#<buffer :id \" int->string/decimal val->id v \" :size \" int->string/hex buffer/length \">\" block-write \"#m\" buffer/u8* view i pad-start int->string/HEX ref \"0\")\n"
"0E000B00260E011A021A030E040E050E06040104011A070E080E090E06040104\n"
"011A0A040609004F0E011A0B1A0C04020D0E0D0E060401070E0D150200070F0D\n"
"240900240D0E011A0B0E100E110E120E0E0E0F0402040102021A13040304020D\n"
"0E0F23050F0E0F0E090E0604011E0AFFD60D241601\n"
"} write/raw/bytecode-array (v port hr?) #{##(port block-write \"#{\" write/raw/array bytecode-literals v i bit-and \"\\n\" pad-start int->string/HEX bytecode-op->int ref \"0\" bytecode-array/length \"\\n}\")\n"
"0E001A011A0204020D0E030E040E0504010E001C04030D15020007060D240900\n"
"410D0E070E06021F04022A0B000E0E001A011A080402090004240D0E001A010E\n"
"090E0A0E0B0E0C0E050E0604020401040102021A0D040304020D0E062305060E\n"
"060E0E0E0504011E0AFFB90D24160D0E001A011A0F040201\n"
"} write/raw/tree/rec (v port hr? always-space?) #{##(v tree/key* #f always-space? write/raw/tree/rec tree/left* port hr? block-write \" \" keyword->string \": \" write/raw tree/value* tree/right*)\n"
"0E000B00071C0900041B0C0A00190D0E010E0004010B00071C0900041B0C0A00\n"
"060D1A020B00090E0301090004240D0E040E050E0004010E060E070E0304040B\n"
"000E0E061A081A090402090004240D0E061A080E0A0E010E000401040104020D\n"
"0E061A081A0B04020D0E0C0E0D0E0004010E060E0704030D0E040E0E0E000401\n"
"0E060E071B040401\n"
"} write/raw/tree (v port hr?) #{##(port block-write \"#@(\" write/raw/tree/rec v hr? \")\")\n"
"0E001A011A0204020D0E030E040E000E051C04040D0E001A011A06040201\n"
"} write/raw/pair (v port hr?) #{##(quote v nil? :pair type-of port block-write \"'\" write/raw hr? \"(\" first? \" \" \". \" \")\")\n"
"1A000E0111200C0B001B0D0E020E01121204010C0B000E0D1A030E040E011204\n"
"01200B001C0E051A061A0704020D0E080E0112110E050E09040301090004240D\n"
"0E051A061A0A04020D1C070B0D2409004B0D0E0B0B000E0E051A061A0C040209\n"
"00061B050B0D1A030E040E010401200B00110E080E01110E050E090403090016\n"
"0E051A061A0D04020D0E080E010E050E0904030D0E011205010E010AFFB60D0E\n"
"051A061A0E040201\n"
"} write/raw/string (v port hr?) #{##(hr? port block-write v \"\\\"\" i ref c ΓεnΣym-1 \"\\\\a\" \"\\\\b\" \"\\\\t\" \"\\\\n\" \"\\\\v\" \"\\\\f\" \"\\\\r\" \"\\\\e\" \"\\\\\\\"\" \"\\\\\\\\\" char-write buffer/length)\n"
"0E000B000F0E011A020E03040201090004240D0E011A021A0404020D15020007\n"
"050D240900F60D0E060E030E05040207070D150E0707080D0E080200200B000F\n"
"0E011A021A040402010900C90E080207200B000E0E011A021A0904020900B60E\n"
"080208200B000E0E011A021A0A04020900A30E080209200B000E0E011A021A0B\n"
"04020900900E08020A200B000E0E011A021A0C040209007D0E08020B200B000E\n"
"0E011A021A0D040209006A0E08020C200B000E0E011A021A0E04020900570E08\n"
"020D200B000E0E011A021A0F04020900440E08021B200B000E0E011A021A1004\n"
"020900310E080222200B000E0E011A021A11040209001E0E08025C200B000E0E\n"
"011A021A12040209000B0E011A130E070402160D0E052305050E050E140E0304\n"
"011E0AFF040D24160D0E011A021A04040201\n"
"} write/raw (v port hr?) #{##(type-of v ΓεnΣym-2 :nil hr? port block-write \"#nil\" :bool \"#t\" \"#f\" :environment write \"#<environment \" int->string/hex val->id \">\" :file-handle \"#<file-handle \" :buffer-view \"#<buffer-view \" :lambda :macro :native-function #f string closure/name anonymous :int int->string/decimal :float :keyword \":\" keyword->string :symbol :bytecode-op \"#$\" int->string/HEX bytecode-op->int :array write/raw/array :buffer write/raw/buffer :bytecode-array write/raw/bytecode-array :string write/raw/string :tree write/raw/tree :pair write/raw/pair throw list :type-error fmt-arg-0 cat \"Don't know how to write \" current-lambda)\n"
"150E000E01040107020D0E021A03200B00170E040B00072409000B0E051A061A\n"
"0704020901DD0E021A08200B00180E051A060E010B00081A090900051A0A0402\n"
"0901C00E021A0B200B001A0E051A0C1A0D0E0E0E0F0E01040104011A10040409\n"
"01A10E021A11200B001A0E051A0C1A120E0E0E0F0E01040104011A1004040901\n"
"820E021A13200B001A0E051A0C1A140E0E0E0F0E01040104011A100404090163\n"
"0E021A15200C0A001A0D0E021A16200C0A00100D0E021A17200C0A00060D1A18\n"
"0B00240E051A060E190E1A0E0104010C0A000D0D1A1B0C0A00060D1A18040104\n"
"0209011F0E021A1C200B00120E051A060E1D0E01040104020901080E021A1E20\n"
"0B00120E051A060E190E01040104020900F10E021A1F200B00140E051A0C1A20\n"
"0E210E01040104030900D80E021A22200B00120E051A060E190E010401040209\n"
"00C10E021A23200B00180E051A0C1A240E250E260E010401040104030900A40E\n"
"021A27200B00100E280E010E050E04040309008F0E021A29200B00100E2A0E01\n"
"0E050E04040309007A0E021A2B200B00100E2C0E010E050E0404030900650E02\n"
"1A2D200B00100E2E0E010E050E0404030900500E021A2F200B00100E300E010E\n"
"050E04040309003B0E021A31200B00100E320E010E050E0404030900260E330E\n"
"341A35150E000E01040107360D0E371A380E360402160E010E39040004040401\n"
"1601\n"
"} write (v port) #{##(write/raw v port stdout #f)\n"
"0E000E010E020C0A000D0D0E030C0A00060D1A041C040301\n"
"} display/new (v port) #{##(write/raw v port stdout #f)\n"
"0E000E010E020C0A000D0D0E030C0A00060D1A041B040301\n"
"} string/write (v) #{##(make-string-output-port p write/raw v :return-string)\n"
"0E00040007010D0E020E030E011C04030D0E011A04040101\n"
"} string/display (v) #{##(make-string-output-port p write/raw v :return-string)\n"
"0E00040007010D0E020E030E011B04030D0E011A04040101\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A0807090D1A0A1A\n"
"0B1A0C1A0D17070A0D1A0E1A0F1A0C1A1017070E0D1A111A121A131A14170711\n"
"0D0E1107150D151A161A171A181A191707160D1A1A1A1B1A181A1C17071A0D1A\n"
"1D1A1E1A181A1F17071D0D1A201A211A181A221707200D1A231A241A181A2517\n"
"07230D1A261A271A181A281707260D1A291A2A1A181A2B1707290D1A2C1A2D1A\n"
"181A2E17072C16072C0D1A2F1A301A181A3117072F0D1A321A331A181A341707\n"
"320D1A351A361A181A371707350D1A381A391A181A3A17073801\n"
"}#{##(pad-start (text pad-length padding) #@(documentation: \"Pad a string to a certain length by prepending another string.\\n\\nThis function will, if necessary, prepend padding on to the beginning of\\ntext repeatedly until the desired pad-length is reached.\\n\\nBecause of this the string in padding can be truncated if the amount of\\ncharacters that need to be added can't be evenly divided through the length of padding.\\n\\nThis means that you have to be careful not to use unicode characters as a padding, or make sure that it can be used without truncation.\\n\\ntext: The input string\\npad-length: The minimum length of the result\\npadding: A string that will be used to pad text, defaults to a single space\\n\\nReturns the padded string\" cat: :string-manipulation tests: ((\"-.-123\" (pad-start '123 6 \".-\")) (\"000123\" (pad-start 123 6 \"0\")) (\"   123\" (pad-start \"123\" 6))) related: (trim pad-end pad-middle)) #{##(padding \" \" :string type-of text string throw list :type-error \"pad-start needs char as a string, so that one can pad with multiple characters\" current-lambda cat buffer/length pad-length string/cut)\n"
"0E000B0007240900071A0105000D1A020E030E040401200B00072409000B0E05\n"
"0E04040105040D1A020E030E000401200B0007240900150E060E071A081A090E\n"
"000E0A0400040404010D2409000E0D0E0B0E000E04040205040E0C0E0404010E\n"
"0D1E0AFFEC0D0E0C0E0404010E0D220B001B0E0E0E040E0C0E0404010E0D260E\n"
"0C0E04040104030900050E0401\n"
"} pad-end (text pad-length padding) #@(documentation: \"Pad a string to a certain length by appending another string.\\n\\nThis function will, if necessary, append padding on to the end of\\ntext repeatedly until the desired pad-length is reached.\\n\\nBecause of this the string in padding can be truncated if the amount of\\ncharacters that need to be added can't be evenly divided through the length of padding.\\n\\nThis means that you have to be careful not to use unicode characters as a padding, or make sure that it can be used without truncation.\\n\\ntext: The input string\\npad-length: The minimum length of the result\\npadding: A string that will be used to pad text, defaults to a single space\\n\\nReturns the padded string\" cat: :string-manipulation tests: ((\"123.-.\" (pad-end '123 6 \".-\")) (\"123000\" (pad-end 123 6 \"0\")) (\"123   \" (pad-end \"123\" 6))) related: (trim pad-start pad-middle)) #{##(padding \" \" :string type-of text string throw list :type-error \"pad-end needs char as a string, so that one can pad with multiple characters\" current-lambda cat buffer/length pad-length string/cut)\n"
"0E000B0007240900071A0105000D1A020E030E040401200B00072409000B0E05\n"
"0E04040105040D1A020E030E000401200B0007240900150E060E071A081A090E\n"
"000E0A0400040404010D2409000E0D0E0B0E040E00040205040E0C0E0404010E\n"
"0D1E0AFFEC0D0E0C0E0404010E0D220B00100E0E0E0402000E0D04030900050E\n"
"0401\n"
"} pad-middle (text pad-length padding) #@(documentation: \"Pad a string to a certain length by surrounding it with another string.\\n\\nThis function will, if necessary, append and prepend padding to the\\nbeginning and end of text repeatedly until the desired pad-length is reached.\\n\\nBecause of this the string in padding can be truncated if the amount of\\ncharacters that need to be added can't be evenly divided through the length of padding.\\n\\nThis means that you have to be careful not to use unicode characters as a padding, or make sure that it can be used without truncation.\\n\\ntext: The input string\\npad-length: The minimum length of the result\\npadding: A string that will be used to pad text, defaults to a single space\\n\\nReturns the padded string\" cat: :string-manipulation tests: ((\"-123.-\" (pad-middle '123 6 \".-\")) (\"012300\" (pad-middle 123 6 \"0\")) (\" 123  \" (pad-middle \"123\" 6))) related: (trim pad-end pad-start)) #{##(padding \" \" :string type-of text string throw list :type-error \"string/pad-middle needs char as a string, so that one can pad with multiple characters\" current-lambda cat buffer/length pad-length div/int end-overflow start-overflow string/cut)\n"
"0E000B0007240900071A0105000D1A020E030E040401200B00072409000B0E05\n"
"0E04040105040D1A020E030E000401200B0007240900150E060E071A081A090E\n"
"000E0A0400040404010D240900100D0E0B0E000E040E00040305040E0C0E0404\n"
"010E0D1E0AFFEA0D0E0C0E0404010E0D220B0036150E0E0E0C0E0404010E0D26\n"
"02020402070F0D0E0C0E0404010E0D260E0F2607100D0E110E040E100E100E0D\n"
"250403160900050E0401\n"
"} trim (text) #@(documentation: \"Remove all whitespace from the start and end of text\\n\\nWhitespace is determined by the whitespace? predicate.\\n\\ntext: The input string\\n\\nReturns a trimmed version of text\" cat: :string-manipulation tests: ((\"Trim Test\" (trim \"   Trim Test    \\n\")) (\"Test\" (trim \"   Test\\t\\n\")) (\"\" (trim \"\")) (\"Test\" (trim \"Test\")) (\"Test\" (trim \"Test \")) (\"Test\" (trim \" Test\"))) related: (trim pad-end pad-middle pad-start)) #{##(start buffer/length text end whitespace? ref string/cut)\n"
"020007000D0E010E02040107030D2409000B0D0E0002012505000E000E031E0C\n"
"0B00100D0E040E050E020E00040204010AFFE20D2409000B0D0E030201260503\n"
"0E030200220C0B00130D0E040E050E020E03020126040204010AFFDF0D0E060E\n"
"020E000E03040301\n"
"} upper-case (text) #@(documentation: \"Convert text into a version using only capitals or uppercase letters.\\n\\ntext: The input string\\n\\nReturns the resulting upper-case version\" cat: :string-manipulation tests: ((\"TESTING THE CAPITALIZATION!\" (upper-case \"Testing THE Capitalization!\"))) related: (capitalize lower-case)) #{##(buffer/allocate buffer/length text ret i buffer/set! upper-case-char ref buffer->string)\n"
"0E000E010E020401040107030D15020007040D2409001E0D0E050E030E040E06\n"
"0E070E020E040402040104030D0E042305040E040E010E0204011E0AFFDC0D0E\n"
"080E0304011601\n"
"} lower-case (text) #@(documentation: \"Convert text into a version using only lowercase letters.\\n\\ntext: The input string\\n\\nReturns the resulting lower-case version\" cat: :string-manipulation tests: ((\"testing the capitalization!\" (lower-case \"Testing THE Capitalization!\"))) related: (capitalize upper-case)) #{##(buffer/allocate buffer/length text ret i buffer/set! lower-case-char ref buffer->string)\n"
"0E000E010E020401040107030D15020007040D2409001E0D0E050E030E040E06\n"
"0E070E020E040402040104030D0E042305040E040E010E0204011E0AFFDC0D0E\n"
"080E0304011601\n"
"} capitalize (text) #@(documentation: \"Convert text into a capitalized version.\\n\\nThis is simplified by having the first character be an upper-case version, as well\\nas any character following a whitespace character, and all other characters be in lower-case.\\n\\ntext: The input string\\n\\nReturns the capitalized version\" cat: :string-manipulation tests: ((\"Testing The Capitalization!\" (capitalize \"Testing THE Capitalization!\"))) related: (lower-case upper-case)) #{##(buffer/allocate buffer/length text ret caps? i buffer/set! upper-case-char lower-case-char ref whitespace? buffer->string)\n"
"0E000E010E020401040107030D1B07040D15020007050D2409003F0D0E060E03\n"
"0E050E040B00080E070900050E080E090E020E050402040104030D0E0A0E090E\n"
"020E05040204010B00071B0900041C05040D0E052305050E050E010E0204011E\n"
"0AFFBB0D0E0B0E0304011601\n"
"} string/round (text decimal-digits) #@(documentation: \"Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period\") #{##(last-index-of text \".\" pos string/cut decimal-digits)\n"
"0E000E011A02040207030D0E030200210B00160E040E0102000E030201250E05\n"
"2504030900050E0101\n"
"} split/empty (str separator) #@() #{##(buffer/length str slen start ret string/cut reverse)\n"
"0E000E01040107020D020007030D2407040D2409001E0D0E050E010E0302010E\n"
"032504030E041405040D0E0302012505030E030E021E0AFFE00D0E060E040401\n"
"01\n"
"} split/string (str separator start) #{##(start index-of str separator pos-found string/cut split/string buffer/length)\n"
"0E000B000724090007020005000D0E010E020E030E00040307040D0E04020021\n"
"0B00220E050E020E000E0404030E060E020E030E040E070E0304012504031409\n"
"00130E050E020E000E070E0204010403241401\n"
"} split (str separator) #@(documentation: \"Splits STR into a list at every occurunse of SEPARATOR\") #{##(type-of str :string throw list :type-error \"Expected a value of type :string\" current-lambda separator buffer/length ΓεnΣym-1 split/empty split/string)\n"
"0E000E0104011A02200B0007240900150E030E041A051A060E010E0704000404\n"
"04010D0E000E0804011A02200B0007240900150E030E041A051A060E080E0704\n"
"00040404010D150E090E080401070A0D0E0A0200200B000C0E0B0E0104010900\n"
"0D0E0C0E010E08020004031601\n"
"} read/single (text) #@(documentation: \"Uses the reader and returns the first single value read from string TEXT\") #{##(type-of text :string throw list :type-error \"Expected a value of type :string\" current-lambda read)\n"
"0E000E0104011A02200B0007240900150E030E041A051A060E010E0704000404\n"
"04010D0E080E0104011101\n"
"} read/int (text) #@(documentation: \"Reads the first string from TEXT\") #{##(int read/single text)\n"
"0E000E010E020401040101\n"
"} read/float (text) #@(documentation: \"Reads the first float from TEXT\") #{##(float read/single text)\n"
"0E000E010E020401040101\n"
"} println (str) #@(documentation: \"Print STR on a single line\") #{##(print cat str \"\\r\\n\")\n"
"0E000E010E021A030402040101\n"
"} errorln (str) #@(documentation: \"Print to stderr STR on a single line\") #{##(error cat str \"\\r\\n\")\n"
"0E000E010E021A030402040101\n"
"})\n"
"1A001A011A021A031707000D1A041A051A061A071707040D1A081A091A0A1A0B\n"
"1707080D1A0C1A0D1A0E1A0F17070C0D1A101A111A121A131707100D1A141A15\n"
"1A161A171707140D1A181A191A1A1A1B1707180D1A1C1A1D1A1E1A1F17071C0D\n"
"151A201A211A221A231707200D1A241A251A221A261707240D1A271A281A291A\n"
"2A1707271607270D1A2B1A2C1A2D1A2E17072B0D1A2F1A301A311A3217072F0D\n"
"1A331A341A351A361707330D1A371A381A391A3A1707370D1A3B1A3C1A3D1A3E\n"
"17073B01\n"
"}#{##(module/insert/defer :ansi string/write (do (def *module* :ansi) (def disabled #f) (defn disable! (v) :export (set! disabled (if (nil? v) #t v))) (export reset (def reset \"\\e[0m\")) (export fg-reset (def fg-reset \"\\e[0;39m\")) (export bg-reset (def bg-reset \"\\e[49m\")) (export ansi-fg (def ansi-fg (array/new \"\\e[0;30m\" \"\\e[0;31m\" \"\\e[0;32m\" \"\\e[0;33m\" \"\\e[0;34m\" \"\\e[0;35m\" \"\\e[0;36m\" \"\\e[0;37m\" \"\\e[1;30m\" \"\\e[1;31m\" \"\\e[1;32m\" \"\\e[1;33m\" \"\\e[1;34m\" \"\\e[1;35m\" \"\\e[1;36m\" \"\\e[1;37m\"))) (export ansi-bg (def ansi-bg (array/new \"\\e[40m\" \"\\e[41m\" \"\\e[42m\" \"\\e[43m\" \"\\e[44m\" \"\\e[45m\" \"\\e[46m\" \"\\e[47m\"))) (defn wrap (code string) \"Wrap STRING in the ansi color CODE\" :export (cat (or disabled (ref ansi-fg code)) string (or disabled reset))) (defn black args :export (wrap 0 (join args))) (defn dark-red args :export (wrap 1 (join args))) (defn dark-green args :export (wrap 2 (join args))) (defn brown args :export (wrap 3 (join args))) (defn dark-blue args :export (wrap 4 (join args))) (defn purple args :export (wrap 5 (join args))) (defn teal args :export (wrap 6 (join args))) (defn dark-gray args :export (wrap 7 (join args))) (defn gray args :export (wrap 8 (join args))) (defn red args :export (wrap 9 (join args))) (defn green args :export (wrap 10 (join args))) (defn yellow args :export (wrap 11 (join args))) (defn blue args :export (wrap 12 (join args))) (defn pink args :export (wrap 13 (join args))) (defn cyan args :export (wrap 14 (join args))) (defn white args :export (wrap 15 (join args))) (defn rainbow args \"Wrap ARGS in the colors of the rainbow!\" :export (let* (def count 0) (cat (join (map (split (join args) \"\") (fn (a) (set! count (bit-and (+ 1 count) 7)) (cat (or disabled (ref ansi-fg (if (zero? count) 7 (+ count 8)))) a))) \"\") (or disabled fg-reset)))) (defn rainbow-bg args \"Wrap ARGS in the colors of the rainbow!\" :export (def count 0) (def colored-list (map (split (join args) \"\") (fn (a) (set! count (bit-and (+ 1 count) 7)) (cat (or disabled (ref ansi-fg (bit-xor count 7))) (or disabled (ref ansi-bg count)) a)))) (cat (join colored-list \"\") (or disabled reset))) (defn reprint-line (text width) :export (when-not width (set! width 20)) (print \"\\r\") (dotimes (i width) (print \" \")) (print \"\\r\") (print text)) (deftest \"\\e[0;33mabc\\e[0m\" (ansi/wrap 3 \"abc\")) (deftest \"\\e[0;30m123\\e[0m\" (ansi/black \"123\")) (deftest \"\\e[0;31m123\\e[0m\" (ansi/dark-red \"123\")) (deftest \"\\e[0;32m123\\e[0m\" (ansi/dark-green \"123\")) (deftest \"\\e[0;33m123\\e[0m\" (ansi/brown \"123\")) (deftest \"\\e[0;34m123\\e[0m\" (ansi/dark-blue \"123\")) (deftest \"\\e[0;35m123\\e[0m\" (ansi/purple \"123\")) (deftest \"\\e[0;36m123\\e[0m\" (ansi/teal \"123\")) (deftest \"\\e[0;37m123\\e[0m\" (ansi/dark-gray \"123\")) (deftest \"\\e[1;30m123\\e[0m\" (ansi/gray \"123\")) (deftest \"\\e[1;31m123\\e[0m\" (ansi/red \"123\")) (deftest \"\\e[1;32m123\\e[0m\" (ansi/green \"123\")) (deftest \"\\e[1;33m123\\e[0m\" (ansi/yellow \"123\")) (deftest \"\\e[1;34m123\\e[0m\" (ansi/blue \"123\")) (deftest \"\\e[1;35m123\\e[0m\" (ansi/pink \"123\")) (deftest \"\\e[1;36m123\\e[0m\" (ansi/cyan \"123\")) (deftest \"\\e[1;37m123\\e[0m\" (ansi/white \"123\")) (deftest \"\\e[1;31mt\\e[1;32me\\e[1;33ms\\e[1;34mt\\e[1;35me\\e[1;36mr\\e[1;37ml\\e[0;37me\\e[0;39m\" (ansi/rainbow \"testerle\")) (deftest \"\\e[0;36m\\e[41mt\\e[0;35m\\e[42me\\e[0;34m\\e[43ms\\e[0;33m\\e[44mt\\e[0;32m\\e[45me\\e[0;31m\\e[46mr\\e[0;30m\\e[47ml\\e[0;37m\\e[40me\\e[0m\" (ansi/rainbow-bg \"testerle\"))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :app/termed/buffer string/write (do (def *module* :app/termed/buffer) (def cur-buffer #nil) (defn set-cur-buffer! (buf) :export (set! cur-buffer buf)) (defn get-cur-buffer (#nil) :export cur-buffer) (defn new-buffer (filename) :export (def lines (array/new (buffer/allocate 16))) (def buf (tree/new :lines lines :filename filename :changed #f :pos-x 0 :pos-y 0 :scroll-x 0 :scroll-y 0)) (return buf)) (defn get-line (buf line-y) :export (def lines (ref buf :lines)) (if (or (< line-y 0) (>= line-y (array/length lines))) #nil (ref lines line-y))) (defn line-length (pos-y) :export (def buf cur-buffer) (def line (get-line buf pos-y)) (when-not line (return 0)) (dotimes (i (buffer/length line) (buffer/length line)) (when (zero? (ref line i)) (return (- i 1))))) (defn backward-delete-line (#nil) :export (def buf cur-buffer) (def lines (ref buf :lines)) (def ll (- (array/length lines) 1)) (def pos-y (ref buf :pos-y)) (when (zero? pos-y) (return)) (while (< pos-y ll) (array/set! lines pos-y (inc pos-y)) (inc! pos-y)) (array/length! lines (max 0 ll)) (tree/set! buf :pos-y (- (ref buf :pos-y) 1)) (tree/set! buf :pos-x (inc (line-length (ref buf :pos-y))))) (defn backward-char (#nil) :export (def buf cur-buffer) (def pos-x (ref buf :pos-x)) (when (< pos-x 1) (def pos-y (ref buf :pos-y)) (when (< pos-y 1) (return)) (tree/set! buf :pos-y (dec pos-y)) (tree/set! buf :pos-x (inc (line-length (dec pos-y)))) (return)) (tree/set! buf :pos-x (dec pos-x))) (defn previous-line (#nil) :export (def buf cur-buffer) (def pos-x (ref buf :pos-x)) (def pos-y (ref buf :pos-y)) (when (< pos-y 1) (return)) (tree/set! buf :pos-y (dec pos-y)) (tree/set! buf :pos-x (min pos-x (inc (line-length (dec pos-y)))))) (defn next-line (#nil) :export (def buf cur-buffer) (def pos-x (ref buf :pos-x)) (def pos-y (ref buf :pos-y)) (def lines (ref buf :lines)) (def ll (- (array/length lines) 1)) (when (>= pos-y ll) (return)) (tree/set! buf :pos-y (inc pos-y)) (tree/set! buf :pos-x (min pos-x (inc (line-length (inc pos-y)))))) (defn forward-char (#nil) :export (def buf cur-buffer) (def pos-x (ref buf :pos-x)) (def pos-y (ref buf :pos-y)) (def ll (line-length pos-y)) (when (> pos-x ll) (when (>= (inc pos-y) (array/length (ref buf :lines))) (return)) (tree/set! buf :pos-x 0) (tree/set! buf :pos-y (inc pos-y)) (return)) (tree/set! buf :pos-x (inc pos-x))) (defn backward-delete-char (#nil) :export (def buf cur-buffer) (def line (get-line buf (ref buf :pos-y))) (when-not line (return)) (def pos-x (ref buf :pos-x)) (when (< pos-x 1) (backward-delete-line) (return)) (def bl (- (buffer/length line) 1)) (buffer/set! line (- pos-x 1) 0) (while (< pos-x (- bl 1)) (buffer/set! line pos-x (ref line (inc pos-x))) (inc! pos-x)) (buffer/set! line bl 0) (tree/set! buf :pos-x (- (ref buf :pos-x) 1))) (defn insert-char (c) :export (def buf cur-buffer) (def line (get-line buf (ref buf :pos-y))) (when-not line (return)) (def pos-x (ref buf :pos-x)) (when (>= pos-x (buffer/length line)) (buffer/length! line (+ (buffer/length line) 16))) (buffer/set! line pos-x c) (tree/set! buf :pos-x (inc pos-x))) (defn insert-newline (#nil) :export (def buf cur-buffer) (def lines (ref buf :lines)) (array/length! lines (inc (array/length lines))) (array/set! lines (- (array/length lines) 1) (buffer/allocate 16)) (tree/set! buf :pos-x 0) (tree/set! buf :pos-y (inc (ref buf :pos-y)))) (defn get-buf-name (buf) :export (def filename (ref buf :filename)) (def saved (if (ref buf :changed) \"*\" \"\")) (fmt \"{filename}{saved}\"))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :app/termed string/write (do (def *module* :app/termed) (import (start stop clear-screen get-size poll-input draw-box move-cursor put-char put-string set-color) :core/term) (import (new-buffer :as new-buffer* get-line line-length forward-char backward-char backward-delete-line backward-delete-char insert-char insert-newline get-buf-name set-cur-buffer! get-cur-buffer previous-line next-line) :app/termed/buffer) (def buffers (array/new #nil)) (def screen-width #nil) (def screen-height #nil) (def last-char 0) (def scroll-interval 10) (defn new-buffer (filename) (def buf (new-buffer* filename)) (array/push buffers buf) buf) (defn draw-gutter (#nil) (draw-box :red 1 2 4 (- screen-height 2))) (defn get-modeline (buf) (def x (ref buf :pos-x)) (def y (inc (ref buf :pos-y))) (def bufname (get-buf-name buf)) (def saved (if (ref buf :changed) \"*\" \"\")) (fmt \" L{y} - {bufname} - KeyCode: {last-char:X}\")) (defn draw-modeline (buf) (draw-box :blue 1 (dec screen-height) screen-width 1) (move-cursor 1 (dec screen-height)) (set-color :yellow :blue) (put-string (get-modeline buf)) (set-color :default :default)) (defn draw-buffer-line (buf term-x term-y term-w line-y) (def line (get-line buf line-y)) (when-not line (return)) (when (= line-y (ref buf :pos-y)) (set-color :yellow :blue)) (move-cursor term-x term-y) (def ln (fmt \" {:4} \" (inc line-y))) (put-string ln) (set-color :default) (move-cursor (+ 1 (buffer/length ln) term-x) term-y) (put-string line)) (defn draw-buffer (buf x y w h) (dotimes (cy h) (def line-y (+ cy (ref buf :scroll-y))) (draw-buffer-line buf x (+ cy y) w line-y)) (draw-modeline buf)) (defn draw-screen (#nil) (clear-screen) (def cur-buffer (get-cur-buffer)) (draw-buffer cur-buffer 1 1 screen-width (- screen-height 2)) (move-cursor (+ 1 1 6 (ref cur-buffer :pos-x)) (- (inc (ref cur-buffer :pos-y)) (ref cur-buffer :scroll-y)))) (defn quit (#nil) (stop) (exit 0)) (defn beginning-of-line (#nil) (tree/set! (get-cur-buffer) :pos-x 0)) (defn end-of-line (#nil) (def buf (get-cur-buffer)) (tree/set! buf :pos-x (inc (line-length (ref buf :pos-y))))) (defn scroll-into-view (#nil) (def buf (get-cur-buffer)) (def frame-height (- screen-height 3)) (when (< (- (ref buf :pos-y) (ref buf :scroll-y)) 0) (tree/set! buf :scroll-y (* scroll-interval (int (floor (/ (ref buf :pos-y) scroll-interval)))))) (when (> (- (ref buf :pos-y) (ref buf :scroll-y)) frame-height) (tree/set! buf :scroll-y (* scroll-interval (int (ceil (/ (- (ref buf :pos-y) frame-height) scroll-interval)))))) (when (< (ref buf :scroll-y) 0) (tree/set! buf :scroll-y))) (defn read-bracketed-input (#nil) (def c (poll-input)) (when (= c 65) (return (previous-line))) (when (= c 66) (return (next-line))) (when (= c 67) (return (forward-char))) (when (= c 68) (return (backward-char))) (return)) (defn read-escaped-input (#nil) (def c (poll-input)) (when (= c 91) (return (read-bracketed-input))) (return (insert-char 91))) (defn read-cx-input (#nil) (def c (poll-input)) (when (= c 3) (return (quit)))) (defn read-input (#nil) (def c (poll-input)) (set! last-char c) (when (= c 27) (return (read-escaped-input))) (when (= c 1) (return (beginning-of-line))) (when (= c 2) (return (backward-char))) (when (= c 5) (return (end-of-line))) (when (= c 6) (return (forward-char))) (when (= c 16) (return (previous-line))) (when (= c 14) (return (next-line))) (when (= c 24) (return (read-cx-input))) (when (= c 127) (return (backward-delete-char))) (when (= c 13) (return (insert-newline))) (when (and (>= c 32) (< c 128)) (return (insert-char c)))) (defn load-buffer (filename) (def buf (new-buffer filename)) (def text (slurp filename)) (when text (tree/set! buf :lines (apply array/new (map (split text \"\\n\") string->buffer))))) (defn main (args) :export (start) (def s (get-size)) (set! screen-width (ref s :width)) (set! screen-height (ref s :height)) (for-each args load-buffer) (when (zero? (array/length buffers)) (new-buffer \"*scratch*\")) (set-cur-buffer! (ref buffers (dec (array/length buffers)))) (while #t (scroll-into-view) (draw-screen) (read-input)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :array/2d string/write (do (def *module* :array/2d) (defn allocate (width height) :export (tree/new :data (-> (array/allocate (* width height)) (array/fill! 0)) :width width :height height)) (defn fill! (data v) :export (array/fill! (ref data :data) v) (return data)) (defn two-dee-ref (data x y oob-val) (if (or (>= x (ref data :width)) (>= y (ref data :height)) (< x 0) (< y 0)) oob-val (ref (ref data :data) (+ x (* y (ref data :width)))))) (export ref two-dee-ref) (defn set! (data x y val) :export (if (or (>= x (ref data :width)) (>= y (ref data :height)) (< x 0) (< y 0)) (exception :out-of-bounds \"Trying to set an array out of bounds\" data) (array/set! (ref data :data) (+ x (* y (ref data :width))) val)) (return data)) (defn print (data) :export (dotimes (y (ref data :height)) (dotimes (x (ref data :width)) (display (cat (array/2d/ref data x y) \" \"))) (newline)) (return data)) (deftest #t (-> (array/2d/allocate 4 4) (array/2d/set! 1 1 #t) (array/2d/ref 1 1))) (deftest #t (-> (array/2d/allocate 3 3) (array/2d/fill! #t) (array/2d/ref 1 1)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :compiler/c-asset-packer string/write (do (def *module* :compiler/c-asset-packer) (def hex-cache (array/allocate 256)) (dotimes (i 256) (array/set! hex-cache i (fmt \"0x{i:02X}, \"))) (defn create-c-asset (raw out symbol-name) :export (typecheck/only out :lambda) (typecheck/only symbol-name :string) (out 'block-write (fmt \"unsigned char {symbol-name}[] = \\\"\")) (dotimes (i (buffer/length raw)) (def c (ref raw i)) (case c (10 (out 'block-write \"\\\\n\\\"\\n\\\"\")) (13 (out 'block-write \"\\\\r\")) (34 (out 'block-write \"\\\\\\\"\")) (92 (out 'block-write \"\\\\\\\\\")) (otherwise (out 'char-write c)))) (out 'block-write \"\\\";\") (out 'close!)) (defn create-string-asset (in symbol-name) :export (with-string-port out (create-c-asset in out symbol-name))) (defn main (args) :export (def filename (car args)) (def output-file (cadr args)) (def symbol-name (caddr args)) (typecheck/only filename :string) (typecheck/only output-file :string) (typecheck/only symbol-name :string) (def out (make-output-port (file/open-output* output-file :replace))) (out 'block-write \"/* This file is auto-generated, manual changes will be overwritten! */\\n\") (create-c-asset (slurp filename) out symbol-name)) (deftest 2716273128 (import (hash) :crypto/adler32) (hash (compiler/c-asset-packer/create-string-asset \"asd\" \"test\"))) (deftest 29 (buffer/length (compiler/c-asset-packer/create-string-asset \"asd\" \"test\"))) (deftest 40 (buffer/length (compiler/c-asset-packer/create-string-asset \"j32093f3223f\" \"secret\"))) (deftest 535759991 (import (hash) :crypto/adler32) (hash (compiler/c-asset-packer/create-string-asset \"j32093f3223f\" \"secret\")))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :compiler/format string/write (do (def *module* :compiler/format) (defn format-form (source indent-level) :export (when-not indent-level (set! indent-level 0)) (cond ((not (pair? source)) (string/write source)) ((not (pair? (car source))) (string/write source)) (case (caar source) ('defn (cat \"asd\" (string/write source))) (else (string/write source))))) (defn main (args) :export (when-not (file/file? (car args)) (println \"Usage: (...FILES)\")) (doseq (file args) (-> (slurp file) (read) (map format-form) (join \"\\n\\n\") (println))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :core/term string/write (do (def *module* :core/term) (defn put-char (char) :export (stdout 'char-write char)) (defn put-string (text) :export (stdout 'block-write text)) (defn clear-screen (#nil) :export (stdout 'block-write \"\\e[2J\")) (defn start (#nil) :export (stdin :raw!) (stdout 'block-write \"\\e[?1049h\")) (defn stop (#nil) :export (stdout 'block-write \"\\e[?1049l\")) (defn move-cursor (column line) :export (stdout 'block-write (fmt \"\\e[{line};{column}H\"))) (def fg-colors (tree/new :default \"\\e[0m\" :black \"\\e[30m\" :red \"\\e[31m\" :green \"\\e[32m\" :yellow \"\\e[33m\" :blue \"\\e[34m\" :pink \"\\e[35m\" :magenta \"\\e[35m\" :purple \"\\e[35m\" :cyan \"\\e[36m\" :teal \"\\e[36m\" :white \"\\e[37m\")) (def bg-colors (tree/new :default \"\\e[49m\" :black \"\\e[40m\" :red \"\\e[41m\" :green \"\\e[42m\" :yellow \"\\e[43m\" :blue \"\\e[44m\" :pink \"\\e[45m\" :magenta \"\\e[45m\" :purple \"\\e[45m\" :cyan \"\\e[46m\" :teal \"\\e[46m\" :white \"\\e[47m\")) (defn set-fg-color (color-name) :export (def v (ref fg-colors color-name)) (when-not v (exception \"Unknown color\" color-name)) (stdout 'block-write v)) (defn set-bg-color (color-name) :export (def v (ref bg-colors color-name)) (when-not v (exception \"Unknown color\" color-name)) (stdout 'block-write v)) (defn set-color (fg-color-name bg-color-name) :export (when fg-color-name (set-fg-color fg-color-name)) (when bg-color-name (set-bg-color bg-color-name))) (defn get-size (#nil) :export (stdout 'block-write \"\\e 7\") (move-cursor 9999 9999) (stdout 'block-write \"\\e[6n\") (stdout 'flush-output) (def buf (buffer/allocate 128)) (def i 0) (while #t (def c (stdin 'char-read)) (when (= c 82) (stdout 'block-write \"\\e 8\") (def s (split (cut (buffer->string buf i) 2) \";\")) (return (tree/new :width (read/int (cadr s)) :height (read/int (car s))))) (buffer/set! buf i c) (inc! i))) (defn get-width (#nil) :export (ref (get-size) :width)) (defn get-height (#nil) :export (ref (get-size) :height)) (defn poll-input (#nil) :export (def c (stdin 'char-read)) (if (= c :end-of-file) 0 c)) (defn draw-box (color pos-x pos-y width height) :export (set-bg-color color) (dotimes (y height) (move-cursor pos-x (+ y pos-y)) (dotimes (x width) (put-char 32))) (set-bg-color :default))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :crypto/adler32 string/write (do (def *module* :crypto/adler32) (defn hash (data) :export (def a 1) (def b 0) (when (string? data) (set! data (string->buffer data))) (when (not= (type-of data) :buffer) (exception :type-error \"Can only hash buffers or strings\")) (def v (buffer/u8* data)) (dotimes (i (buffer/length data)) (set! a (mod/int (add/int a (ref v i)) 65521)) (set! b (mod/int (add/int a b) 65521))) (bit-or a (bit-shift-left b 16))) (deftest \"00620062\" (fmt \"{:08X}\" (crypto/adler32/hash \"a\"))) (deftest \"0F9D02BC\" (fmt \"{:08X}\" (crypto/adler32/hash \"asdQWE123\"))) (deftest \"796B110D\" (fmt \"{:08X}\" (crypto/adler32/hash \"DiesIstEinTestDerNujelAdler32Implementierung\")))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :games/guess string/write (do (def *module* :games/guess) (require :ansi) (require :random) (defn win (guesses-left) (pfmtln \"Fantastic, {} with {guesses-left} guesses left.\" (ansi/rainbow \"you won\")) (pfmtln \"Hope you had fun and have a nice day!\") (exit 0)) (defn loose (#nil) (pfmtln \"Too bad, you didn't guess the number in time, maybe next time.\") (pfmtln \"Hope you still had fun, have a nice day!\") (exit 0)) (defn quit (#nil) (pfmtln \"Bye!\") (exit 0)) (defn main (args) :export (println (ansi/rainbow \"Guess the number!!!\")) (println \"\") (println \"You have 10 tries, with every guess I will tell you if it was too high or too low, the number is in the range of 0 to 100\") (def guesses-left 10) (def number (random/int 100)) (while (> guesses-left 0) (def line (readline (fmt \"Your {} guess? \" (cond ((= guesses-left 1) (ansi/red \"final\")) (#t (- 11 guesses-left)))))) (when-not line (quit)) (def cur-guess (read/int line)) (when (= number cur-guess) (win guesses-left)) (if (< cur-guess number) (println \"Too low\") (println \"Too high\")) (set! guesses-left (- guesses-left 1))) (loose))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :help string/write (do (def *module* :help) (require :ansi) (defn main (args) :export (println (cat (ansi/rainbow \"Nujel\") \" - A Lisp dialect for games.\\n\")) (println (cat (ansi/green \"Usage:\") \" nujel (options) (command_string | file)\")) (println (cat \"\\nLow-level options - for work on the runtime itself\")) (println (cat \"  \" (ansi/yellow \"v\") \" - be verbose\")) (println (cat \"\\nHigh-level options - for working with/on Nujel code\")) (println (cat \"  \" (ansi/blue \"x\") \" - Run the expression following this argument directly\")) (println (cat \"  \" (ansi/blue \"h\") \" - Print this help screen\")) (println (cat \"\\nLong options - for working with/on Nujel code\")) (println (cat \"  \" (ansi/blue \"no-color\") \" - Disable ANSI color\")) (println (cat \"  \" (ansi/blue \"color   \") \" - Enable ANSI color\")))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :image/bmp string/write (do (def *module* :image/bmp) (defn buffer/view/le/set! (u8v offset bytes val) (while (> bytes 0) (buffer/set! u8v (inc! offset) (bit-and 255 val)) (dec! bytes) (set! val (bit-shift-right val 8))) offset) (defn calc-row-padding (width pixel-length) (def ret (- 4 (bit-and (* width pixel-length) 3))) (if (= ret 4) 0 ret)) (defn encode (image) :export (require :image) (def image-size (* (ref image :height) 3 (+ (ref image :width) (calc-row-padding (ref image :width) 3)))) (def header-size (+ 14 40)) (def file-size (+ image-size header-size)) (def out (buffer/allocate file-size)) (def b (buffer/u8* out)) (def i -1) (buffer/set! b (inc! i) 66) (buffer/set! b (inc! i) 77) (set! i (buffer/view/le/set! b i 4 file-size)) (set! i (buffer/view/le/set! b i 4 0)) (set! i (buffer/view/le/set! b i 4 header-size)) (set! i (buffer/view/le/set! b i 4 40)) (set! i (buffer/view/le/set! b i 4 (ref image :width))) (set! i (buffer/view/le/set! b i 4 (ref image :height))) (set! i (buffer/view/le/set! b i 2 1)) (set! i (buffer/view/le/set! b i 2 24)) (set! i (buffer/view/le/set! b i 4 0)) (set! i (buffer/view/le/set! b i 4 image-size)) (set! i (buffer/view/le/set! b i 4 8192)) (set! i (buffer/view/le/set! b i 4 8192)) (set! i (buffer/view/le/set! b i 4 0)) (set! i (buffer/view/le/set! b i 4 0)) (def row-padding (calc-row-padding (ref image :width) 3)) (def pixels (- header-size 1)) (let ((y (- (ref image :height) 1))) (while (>= y 0) (dotimes (x (ref image :width)) (set! pixels (buffer/view/le/set! b pixels 3 (image/ref image x y)))) (set! pixels (+ pixels row-padding)) (set! y (add/int y -1)))) (return out)) (defn init! (#nil) :export (require :image) (image/add-encoder! \"bmp\" image/bmp/encode)) (deftest 3149043687 (import hash :crypto/adler32) (import (test-image-xor) :image) (hash (image/bmp/encode (test-image-xor))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :image string/write (do (def *module* :image) (def image/decoders (tree/new #nil)) (def image/encoders (tree/new #nil)) (defn add-encoder! (ext enc) :export (def ext (string->keyword (lower-case ext))) (tree/set! image/encoders ext enc)) (defn add-decoder! (ext dec) :export (def ext (string->keyword (lower-case ext))) (tree/set! image/decoders ext dec)) (defn get-encoder (path) (def ext (string->keyword (lower-case (path/extension path)))) (ref image/encoders ext)) (defn get-decoder (path) (def ext (string->keyword (lower-case (path/extension path)))) (ref image/decoders ext)) (defn new (width height) :export (def buffer (buffer/allocate (* width height 4))) (tree/new :width width :height height :buffer buffer :pixels (buffer/u32* buffer))) (defn image/ref (img x y) :export-as ref (def i (+ (int x) (* (int y) (ref img :width)))) (ref (ref img :pixels) i)) (defn image/set! (img x y value) :export-as set! (def i (+ (int x) (* (int y) (ref img :width)))) (buffer/set! (ref img :pixels) i value)) (defn fill! (img value) :export (def p (ref img :pixels)) (dotimes (i (* (ref img :width) (ref img :height)) img) (buffer/set! p i value))) (defn map! (img fun) :export (def p (ref img :pixels)) (dotimes (i (* (ref img :width) (ref img :height)) img) (buffer/set! p i (fun (ref p i))))) (defn dup (img) :export (def ret (image/new (ref img :width) (ref img :height))) (def in (ref img :pixels)) (def out (ref ret :pixels)) (dotimes (i (* (ref img :width) (ref img :height)) img) (buffer/set! out i (ref in i)))) (defn save! (img path) :export (def enc (get-encoder path)) (if enc (file/write (enc img) path) (exception :missing-encoder \"Currently there is no encoder loaded for that image format\" path))) (defn adler32 (img) :export (import (hash) :crypto/adler32) (hash (ref img :buffer))) (defn test-image-xor (#nil) :export (def w 256) (def h 256) (def out (new w h)) (dotimes (x w out) (dotimes (y h) (image/set! out x y (bit-or x (bit-shift-left y 8) (bit-shift-left (bit-xor x y) 16)))))) (deftest 4040398435 (image/adler32 (image/test-image-xor)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :pretty/nujel string/write (do (def *module* :pretty/nujel) (import (fg-reset ansi-fg) :ansi) (def ansi-colors (array/new fg-reset (ref ansi-fg 1) (ref ansi-fg 2) (ref ansi-fg 3) (ref ansi-fg 4) (ref ansi-fg 5) (ref ansi-fg 6) (ref ansi-fg 7) (ref ansi-fg 8) (ref ansi-fg 9) (ref ansi-fg 10) (ref ansi-fg 11) (ref ansi-fg 12) (ref ansi-fg 13) (ref ansi-fg 14) (ref ansi-fg 15))) (def html-colors (array/new \"</span>\" \"<span class=\\\"nujel-hl-1\\\">\" \"<span class=\\\"nujel-hl-2\\\">\" \"<span class=\\\"nujel-hl-3\\\">\" \"<span class=\\\"nujel-hl-4\\\">\" \"<span class=\\\"nujel-hl-5\\\">\" \"<span class=\\\"nujel-hl-6\\\">\" \"<span class=\\\"nujel-hl-7\\\">\" \"<span class=\\\"nujel-hl-8\\\">\" \"<span class=\\\"nujel-hl-9\\\">\" \"<span class=\\\"nujel-hl-10\\\">\" \"<span class=\\\"nujel-hl-11\\\">\" \"<span class=\\\"nujel-hl-12\\\">\" \"<span class=\\\"nujel-hl-13\\\">\" \"<span class=\\\"nujel-hl-14\\\">\" \"<span class=\\\"nujel-hl-15\\\">\")) (defn comment-block (source i pp colors) (def len (buffer/length source)) (pp 'block-write (ref colors 8)) (pp 'block-write \"#|\") (set! i (+ i 2)) (while (< i len) (def c (ref source i)) (cond ((and (== c 35) (== (ref source (inc/int i)) 124)) (set! i (comment-block source i pp colors))) ((and (== c 124) (== (ref source (inc/int i)) 35)) (pp 'block-write \"|#\") (pp 'block-write (ref colors 0)) (return (+ 2 i))) (#t (pp 'char-write c) (set! i (inc/int i))))) (pp 'block-write (ref colors 0)) (return i)) (defn comment-eol (source i pp colors) (def len (buffer/length source)) (pp 'block-write (ref colors 8)) (while (< i len) (def c (ref source i)) (case c (10 (pp 'char-write c) (pp 'block-write (ref colors 0)) (return (inc/int i))) (otherwise (pp 'char-write c) (set! i (inc/int i))))) (pp 'block-write (ref colors 0)) (return i)) (defn continue-until-separator (source i pp colors) (def len (buffer/length source)) (while (< i len) (def c (ref source i)) (case c ((10 13 32 40 41 40 41 34) (pp 'block-write (ref colors 0)) (return i)) (otherwise (pp 'char-write c) (set! i (inc/int i))))) (pp 'block-write (ref colors 0)) (return i)) (defn literal-special (source i pp colors) (def n (ref source (inc i))) (case n (33 (return (comment-eol source i pp colors))) (124 (return (comment-block source i pp colors))) (110 (return (literal-nil source i pp colors))) ((116 102) (return (literal-bool source i pp colors))) (otherwise (pp 'block-write (ref colors 2)) (continue-until-separator source i pp colors)))) (defn literal-keyword (source i pp colors) (pp 'block-write (ref colors 4)) (return (continue-until-separator source i pp colors))) (defn literal-number (source i pp colors) (pp 'block-write (ref colors 5)) (return (continue-until-separator source i pp colors))) (defn literal-string (source i pp colors) (def len (buffer/length source)) (pp 'block-write (ref colors 3)) (def escaped-quote? #t) (while (< i len) (def c (ref source i)) (case c (92 (pp 'char-write c) (set! escaped-quote? #t) (set! i (inc/int i))) (34 (pp 'char-write c) (if escaped-quote? (do (set! i (inc/int i)) (set! escaped-quote? #f)) (do (pp 'block-write (ref colors 0)) (return (inc/int i))))) (otherwise (pp 'char-write c) (set! escaped-quote? #f) (set! i (inc/int i))))) (pp 'block-write (ref colors 0)) (return i)) (defn list-car (source i pp colors d) (pp 'block-write (ref colors 15)) (set! i (continue-until-separator source i pp colors)) (pp 'block-write (ref colors 0)) (return (top source i pp colors d))) (defn bracket-open (source i pp colors d) (pp 'block-write (ref colors (+ 1 (bit-and d 3)))) (pp 'char-write (ref source i)) (pp 'block-write (ref colors 0)) (list-car source (inc/int i) pp colors d)) (defn bracket-close (source i pp colors d) (pp 'block-write (ref colors (+ 1 (bit-and d 3)))) (pp 'char-write (ref source i)) (pp 'block-write (ref colors 0)) (return (inc/int i))) (defn literal-nil (source i pp colors) (pp 'block-write (ref colors 8)) (set! i (continue-until-separator source i pp colors)) (pp 'block-write (ref colors 0)) (return i)) (defn literal-bool (source i pp colors) (case (ref source (inc/int i)) (116 (pp 'block-write (ref colors 2))) (otherwise (pp 'block-write (ref colors 1)))) (set! i (continue-until-separator source i pp colors)) (pp 'block-write (ref colors 0)) (return i)) (defn start-quote (source i pp colors d) (pp 'block-write (ref colors 3)) (pp 'char-write (ref source i)) (continue-until-separator source (inc/int i) pp colors d)) (defn top (source i pp colors d) (def len (buffer/length source)) (while (< i len) (def c (ref source i)) (case c (35 (set! i (literal-special source i pp colors))) (59 (set! i (comment-eol source i pp colors))) (34 (set! i (literal-string source i pp colors))) (58 (set! i (literal-keyword source i pp colors))) (39 (set! i (start-quote source i pp colors d))) ((40 91) (set! i (bracket-open source i pp colors (inc/int d)))) ((41 93) (return (bracket-close source i pp colors d))) ((48 49 50 51 52 53 54 55 56 57) (set! i (literal-number source i pp colors))) (otherwise (pp 'char-write c) (set! i (inc/int i))))) (return i)) (defn pp-nujel (source output-format) :export (def pp (make-string-output-port)) (def colors (case output-format (:html html-colors) (otherwise ansi-colors))) (top source 0 pp colors 0) (pp 'return-string)) (defn main (args) :export (when-not (file/file? (car args)) (println \"Usage: (...FILES)\")) (doseq (file args) (println (pp-nujel (slurp file)))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :random string/write (do (def *module* :random) (def seed 0) (defn rng! (#nil) :export (set! seed (+ 12345 (* seed 1103515245))) (bit-or (bit-shift-left (bit-and seed 65535) 16) (bit-and (bit-shift-right seed 16) 65535))) (defn seed! (new-seed) :export \"Set a new seed value for the RNG\" (set! seed new-seed)) (defn seed (#nil) :export \"Return the current RNG seed value\" (return seed)) (defn random (max) :export-as int \"Return a value from 0 to MAX, or, if left out, a random int\" (if max (rem (abs (rng!)) max) (rng!))) (defn seed-initialize! (#nil) :export (set! seed (bit-xor (time) (time/milliseconds)))) (seed-initialize!) (deftest #t (int? (random/int))) (deftest #t (random/seed! 123) (def first-value (random/int)) (random/seed! 123) (= first-value (random/int))) (deftest #t (random/seed! 99) (not= (random/int) (random/int)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :repl string/write (do (def *module* :repl) (import (rainbow) :ansi) (def *1 #nil) (def *2 #nil) (def *3 #nil) (def line-history #nil) (def ctx (environment*)) (defn exception-handler (error) (print/error error)) (defn push-result (result) (set! *3 *2) (set! *2 *1) (set! *1 result) (return result)) (defn cmd/raw (line) :export (try (fn (err) (if (= (car err) :unmatched-opening-bracket) (cmd/raw ctx (cat line (readline \"... \"))) (throw err))) (def expr (read line)) (when (equal? '(#nil) expr) (print \"\\r\") (return)) (try exception-handler (def result (eval-in ctx (cons do expr))) (push-result result) (println (if (nil? result) \"\" (string/display result)))))) (defn cmd (#nil) (def buf \"\") (def line \"\") (while (not= (trim line) \"[/cmd]\") (set! buf (cat buf line)) (set! line (readline))) (def expr (cons do (read buf))) (def result (eval-in ctx expr)) (push-result result) (println (if (nil? result) \"\" (string/display result)))) (defn prompt (#nil) \"> \") (defn read-cmd (#nil) (def line (readline (prompt))) (cons! line line-history) (when (nil? line) (println \"Adios, cowboy...\") (exit 0)) (if (= (trim line) \"[cmd]\") (cmd) (cmd/raw line))) (defn welcome (#nil) (println (cat (rainbow \"Nujel\") \" REPL is ready for service!\"))) (defn main (args) :export (welcome) (while #t (try exception-handler (read-cmd))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :serialization/json string/write (do (def *module* :serialization/json) (defn tree->json (v) \"Converts a tree into a JSON encoded string, you should prefer VAL->JSON\" (cat \"{\" (join (map (tree/keys v) (fn (k) (cat \"\\\"\" (keyword->string k) \"\\\": \" (val->json (ref v k))))) \",\\n\") \"}\")) (defn val->json (v) :export-as serialize \"Return V as a JSON encoded string\" (case (type-of v) (:nil \"null\") ((:int :float) (string v)) (:bool (if v \"true\" \"false\")) ((:array :pair) (cat \"[\" (join (map v val->json) \",\") \"]\")) (:string (string/write v)) (:symbol (cat \"\\\"\" (string v) \"\\\"\")) (:keyword (cat \"\\\"\" (keyword->string v) \"\\\"\")) (:tree (tree->json v)) (otherwise (throw (list :type-error \"Can't encode the value into JSON\" v (current-lambda)))))) (deftest \"null\" (serialization/json/serialize #nil)) (deftest \"123\" (serialization/json/serialize 123)) (deftest \"123.123\" (serialization/json/serialize 123.123)) (deftest \"true\" (serialization/json/serialize #t)) (deftest \"false\" (serialization/json/serialize #f)) (deftest \"[1,2,3]\" (serialization/json/serialize (array/new 1 2 3))) (deftest \"[1,true,3.0]\" (serialization/json/serialize '(1 #t 3.0))) (deftest \"\\\"asd\\\"\" (serialization/json/serialize 'asd)) (deftest \"\\\"asd\\\"\" (serialization/json/serialize :asd)) (deftest \"\\\"asd\\\"\" (serialization/json/serialize \"asd\")) (deftest \"\\\"asd\\\"\" (serialization/json/serialize \"asd\"))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :test string/write (do (def *module* :test) (require :ansi) (def test-list #nil) (def test-count 0) (def nujel-start 0) (def success-count 0) (def error-count 0) (def print-errors #t) (def print-passes #f) (defn add* (result expr) :export (set! test-list (cons (cons result expr) test-list)) (set! test-count (+ test-count 1))) (defn reset! (#nil) :export (set! test-list (cons 4 '(+ 3 1))) (set! test-count 1)) (defn display-results (description) \"Prints the result Message\" (efmtln \"{} {} - [{} / {}] in {} ms\" (if (and (zero? error-count) (> test-count 0)) (if (zero? success-count) (ansi/yellow \"?\") (ansi/green \"✓\")) (ansi/red \"✗\")) description (if (zero? success-count) (ansi/yellow success-count) (ansi/green success-count)) (if (zero? error-count) (ansi/gray error-count) (ansi/red error-count)) (- (time/milliseconds) nujel-start))) (defn test-success (res-should res-is expr) \"Should be called after a test has finished successfully\" (when print-passes (efmtln \"{} == {}\\r\\n{}\\r\\n\\r\\n\" (ansi/green (string/write res-is)) (ansi/green (string/write res-should)) (string/write expr))) (set! success-count (+ 1 success-count))) (defn test-failure (res-should res-is expr) \"Should be called if EXPR does not equal RES\" (when print-errors (pfmtln \"{} != {}\\r\\n{}\\r\\n\\r\\n\" (ansi/red (string/write res-is)) (ansi/green (string/write res-should)) (string/write expr))) (set! error-count (+ 1 error-count))) (defn run-test! (result rawexpr) :export \"Tests that RAWEXPR evaluates to RESULT\" (try (fn (err) (test-failure result (list :exception-caught err) rawexpr)) (def expr (eval rawexpr)) (if (equal? result expr) (test-success result expr rawexpr) (test-failure result expr rawexpr)))) (defn init! (output-passes hide-errors) :export \"Initialize the testing framework\" (set! print-errors (not hide-errors)) (set! print-passes (boolean output-passes)) (set! nujel-start (time/milliseconds)) (set! success-count 0) (set! error-count 0)) (defn finish! (description) :export (display-results description) (return error-count)) (defn run (output-passes hide-errors) :export \"Run through all automated Tests\" (init!) (doseq (cur-test test-list) (run-test! (car cur-test) (cdr cur-test))) (finish! (fmt \"{} {} [{System/OS} {System/Architecture}]\" (ansi/blue \":core\") (ansi/rainbow \"Nujel\")))) (defn load-file (filename) :export (doseq (t (read (slurp filename)) test-list) (when (== (car t) 'test/add) (cdr! t)) (add* (eval (car t)) (cons 'do (cdr t))))) (reset!) (defn add-builtin-tests (#nil) :export (doseq (test-funs (-> (symbol-table) (map resolve-or-nil) (filter callable?) (map (fn (a) (meta a :tests))) (filter identity))) (doseq (fun test-funs) (add* (car fun) (cadr fun))))) (deftest #t (lambda? test/run))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :time string/write (do (def *module* :time) (defn seconds (timestamp) :export \"Return the seconds part of TIMESTAMP, defaults to current time\" (rem (or timestamp (time)) 60)) (defn minutes (timestamp) :export \"Return the minutes part of TIMESTAMP, defaults to current time\" (rem (div/int (or timestamp (time)) 60) 60)) (defn hours (timestamp) :export \"Return the hours part of TIMESTAMP, defaults to current time\" (rem (div/int (or timestamp (time)) 3600) 24)) (deftest 34 (time/seconds 1637755714)) (deftest 8 (time/minutes 1637755714)) (deftest 12 (time/hours 1637755714)) (deftest 59 (time/seconds 1637755739)) (deftest 0 (time/seconds 1637755740))))\n"
"0E001A010E021A030401040201\n"
"}";