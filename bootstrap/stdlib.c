/* This file is auto-generated, manual changes will be overwritten! */
unsigned char stdlib_no_data[] = "#{##((test-val bit-pos) #@(documentation: \"Test bit at position i\\n\\nWe check if test-val has a 1 at bit-pos and return #t if that is the case\\n\\ntest-val: The integer in which to look for the bit\\nbit-pos: Which bit to look for, with 0 being the least significant digit\\n\\nA boolean signifying whether the bit is set or not\" name: bit-test? cat: :bitwise-operations tests: ((#f (bit-test? 9 7)) (#f (bit-test? 9 1)) (#t (bit-test? 9 0)))) #{##(:type-name test-val :int :type-error \"Expected a value of type :int\" current-lambda bit-pos)\n"
"1A000E0104011A02200B0007240900101A031A040E010E0504002E042F0D1A00\n"
"0E0604011A02200B0007240900101A031A040E060E0504002E042F0D0E010201\n"
"0E0631332A0B00071C0900041B01\n"
"} bit-test? (cur-val bit-pos) #@(documentation: \"Set bit-pos within cur-val to 1\\n\\ncur-val: The integer where we set the bit in\\nbit-pos: The index of the bit we want to change, with 0 being the least significant digit\\n\\nAn integer cur-val but with a guaranteed 1 at bit-pos\" name: bit-set cat: :bitwise-operations tests: ((15 (bit-set 11 2)))) #{##(cur-val bit-pos)\n"
"0E0002010E01313401\n"
"} bit-set (cur-val bit-pos) #@(documentation: \"Flip the bit at bit-pos within cur-val\\n\\ncur-val: The integer where we flip the bit in\\nbit-pos: The index of the bit we want to flip, with 0 being the least significant digit\\n\\nAn integer cur-val but with the bit at position bit-pos flipped\" name: bit-flip cat: :bitwise-operations tests: ((11 (bit-flip 15 2)) (15 (bit-flip 11 2)))) #{##(cur-val bit-pos)\n"
"0E0002010E01313501\n"
"} bit-flip (cur-val bit-pos) #@(documentation: \"Clear the bit at bit-pos within cur-val\\n\\ncur-val: The integer where we clear the bit in\\nbit-pos: The index of the bit we want to clear, with 0 being the least significant digit\\n\\nAn integer cur-val but with the bit at position bit-pos forced to 0\" name: bit-clear cat: :bitwise-operations tests: ((11 (bit-clear 11 2)) (9 (bit-clear 11 1)))) #{##(cur-val bit-pos)\n"
"0E0002010E0131363301\n"
"} bit-clear)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A0C\n"
"1A0D1A0E17070F01\n"
"}#{##((a i v) #@(documentation: \"Add V to the value in A at position I and store the result in A returning A\" name: array/+=) #{##(a i v)\n"
"0E000E010E020E000E012B253701\n"
"} array/+= (a i) #@(documentation: \"Increment position I in A and return A\" name: array/++) #{##(array/+= a i)\n"
"0E000E010E020201040301\n"
"} array/++ (a v) #@(documentation: \"Fills array a with value v\" name: array/fill!) #{##(:length a len i v)\n"
"1A000E01040107020D020007030D240900110D0E010E030E04370D0E03230503\n"
"0E030E021E0AFFED0D0E0101\n"
"} array/fill! (a b) #@(documentation: \"Append array A to array B\" name: array/append) #{##(:array :type-name a b :type-error \"array/append expects two arrays as its arguments\" current-lambda :alloc Array :length ret i rl)\n"
"1A001A010E020401200C0B000D0D1A001A010E030401200B00072409000F1A04\n"
"1A05240E0604002E042F0D1A070E081A090E0204011A090E030401250402070A\n"
"0D0200070B0D240900140D0E0A0E0B0E020E0B2B370D0E0B23050B0E0B1A090E\n"
"0204011E0AFFE60D240D151A090E020401070B0D1A090E0A0401070C0D240900\n"
"1D0D0E0A0E0B0E030E0B1A090E020401262B370D0E0B020103050B0E0B0E0C1E\n"
"0AFFE1160D0E0A0101\n"
"} array/append (a) #@(documentation: \"Duplicate Array A\" name: array/dup) #{##(:alloc Array :length a ret i)\n"
"1A000E011A020E030401040207040D020007050D240900140D0E040E050E030E\n"
"052B370D0E052305050E051A020E0304011E0AFFE60D0E0401\n"
"} array/dup (arr fun α) #@(documentation: \"Reduce an array, (reduce) should be preferred\" name: array/reduce) #{##(:length arr len i fun α)\n"
"1A000E01040107020D020007030D240900170D0E040E050E010E032B04020505\n"
"0D0E032305030E030E021E0AFFE70D0E0501\n"
"} array/reduce (arr fun) #@(documentation: \"Map an array, (map) should be preferred\" name: array/map) #{##(:length arr len i fun)\n"
"1A000E01040107020D020007030D240900180D0E010E030E040E010E032B0401\n"
"370D0E032305030E030E021E0AFFE60D0E0101\n"
"} array/map (arr pred) #@(documentation: \"Filter an array, (filter) should be preferred\" name: array/filter) #{##(ri :length arr len :alloc Array ret ai pred :length!)\n"
"020007000D1A010E02040107030D1A040E050E03040207060D020007070D2409\n"
"002C0D0E080E020E072B04010B00180E060E000E020E072B370D0E0002012505\n"
"00090004240D0E072305070E070E031E0AFFD20D1A090E060E00040201\n"
"} array/filter (a b) #@(name: array/equal?) #{##(:array :type-name a b not= :length #f i equal?)\n"
"1A001A010E020401200B00071C0900041B0C0A00310D1A001A010E030401200B\n"
"00071C0900041B0C0A001B0D0E041A050E0204011A050E03040104020C0A0006\n"
"0D1A060B00081C01090038020007070D240900210D0E080E020E072B0E030E07\n"
"2B04020B0007240900051C010D0E072305070E071A050E0204011E0AFFD90D1B\n"
"01\n"
"} array/equal? (arr val) #@(documentation: \"Append VAL to ARR\" name: array/push) #{##(:length! arr :length val)\n"
"1A000E0102011A020E0104012504021A020E0104010201260E033701\n"
"} array/push (arr i j) #@(documentation: \"Swap values at I and J in ARR\" name: array/swap) #{##(arr i tmp j)\n"
"0E000E012B07020D0E000E010E000E032B370E030E023701\n"
"} array/swap (arr n at) #@(documentation: \"bubble up the element from index AT to until the max-heap property is satisfied\" name: array/heapify) #{##(at top looping l r n arr array/swap)\n"
"0E0007010D1B07020D240900790D0E0002013102012507030D0E000201310202\n"
"2507040D0E030E051E0C0B000F0D0E060E032B0E060E012B220B000A0E030501\n"
"090004240D0E040E051E0C0B000F0D0E060E042B0E060E012B220B000A0E0405\n"
"01090004240D0E010E00200B00091C05020900120E070E060E000E0104030D0E\n"
"0105000E020AFF880D0E060101\n"
"} array/heapify (arr) #@(name: array/make-heap) #{##(:length arr l div/int l2 array/heapify)\n"
"1A000E01040107020D0E030E020202040207040D240900160D0E050E010E020E\n"
"0404030D0E0402012605040E040200210AFFE80D0E010101\n"
"} array/make-heap (arr) #@(name: array/heap-sort) #{##(array/make-heap arr :length l array/swap array/heapify)\n"
"0E000E0104010D1A020E01040107030D240900210D0E0302012605030D0E040E\n"
"0102000E0304030D0E050E010E03020004030E030200220AFFDD0D0E010101\n"
"} array/heap-sort array/sort (arr start end) #@(documentation: \"Return a newly allocated array with the values of ARR from START to END\" name: array/cut) #{##(max start min :length arr end :alloc Array ret i)\n"
"0E0002000E01040205010D0E021A030E0404010E05040205050D1A060E070E00\n"
"02000E050E01260402040207080D0E0107090D240900190D0E080E090E01260E\n"
"040E092B370D0E0902010305090E090E051E0AFFE50D0E080101\n"
"} array/cut)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A0C\n"
"1A0D1A0E17070F0D1A101A111A121707130D1A141A151A161707170D1A181A19\n"
"1A1A17071B0D1A1C1A1D1A1E17071F0D1A201A211A221707230D1A241A251A26\n"
"1707270D1A281A291A2A17072B0D151A2C1A2D1A2E17072F0D1A301A311A3217\n"
"07330D1A341A351A361707371607370D0E3707380D1A391A3A1A3B17073C01\n"
"}#{##((collection) #@(documentation: \"Return the sum of every value in collection\\n\\ncollection: The collection to sum, can be a List, Vector or something else supported by reduce.\\n\\nThe numeric sum of all the elements of collection\" name: sum cat: :collection-operations tests: ((6 (sum '(1 2 3))) (15 (sum (array/new 1 2 3 4 5))) (10 (+ (sum '(1 2 3)) (apply (fn (α) (+ 1 α)) '(3)))) (:type-error (try car (sum 123))))) #{##(reduce collection +)\n"
"0E000E010E020200040301\n"
"} sum (collection predicate?) #@(documentation: \"Returns whether predicate? is #t for every member of the collection\\n\\ncollection: The collection to test, can be a List, Vector or something else supported by reduce.\\npredicate?: A function that takes a single argument and returns a bool.\\n\\nWhether every invocation returned #t or not\" name: every? cat: :collection-operations tests: ((#t (every? (array/new #nil) float?)) (#t (every? (array/new 1.0 6.0) float?)) (#f (every? (array/new 1 2 3 4 5 6.0) int?)) (#t (every? (array/new 1 2 3 4 5 6) int?)) (#f (every? '(#nil) float?)) (#t (every? '(1.0 6.0) float?)) (#f (every? '(1 2 3 4 5 6.0) int?)) (#t (every? '(1 2 3 4 5 6) int?)))) #{##(reduce collection (a b) #@(name: anonymous) #{##(a predicate? b)\n"
"0E000C0B000A0D0E010E02040101\n"
"})\n"
"0E000E011A021A031A04171B040301\n"
"} every? (collection predicate?) #@(documentation: \"Count the number of items in the collection where predicate? is #t.\\nIf no predicate is provided, it will count the number of elements instead.\\n\\ncollection: The collection to count in\\npredicate?: Optional, a function that takes a single argument which is then called for every item.\\n\\nThe number of times predicate? returned #t\" name: count cat: :collection-operations tests: ((0 (count '(1 2 3 4 5 6) float?)) (6 (count '(1 2 3 4 5 6) int?)) (3 (count '(1 2 3 4 5 6) even?)) (3 (count '(1 2 3 4 5 6) odd?)) (2 (count (array/new 1 2 3 4) even?)) (3 (count (array/new 1 2 3))) (3 (count '(1 2 3))) (1 (count (array/new 1))) (1 (count '(1))) (0 (count (array/new #nil))) (0 (count #nil)))) #{##(predicate? reduce collection (a b) #@(name: anonymous) #{##(a predicate? b)\n"
"0E000E010E0204010B0008020109000502002501\n"
"} (a b) #{##(a)\n"
"0E0002012501\n"
"})\n"
"0E000B00150E010E021A031A041A0517020004030900120E010E021A061A041A\n"
"07170200040301\n"
"} count (l e) #@(documentation: \"Returns a filtered list l with all elements equal to e omitted\" name: delete) #{##(filter l (a) #@(name: anonymous) #{##(a e)\n"
"0E000E01200B00071C0900041B01\n"
"})\n"
"0E000E011A021A031A0417040201\n"
"} delete (l p) #@(documentation: \"Returns a filtered list l with all elements where P equal true removed\" name: remove) #{##(filter l (a) #@(name: anonymous) #{##(p a)\n"
"0E000E0104010B00071C0900041B01\n"
"})\n"
"0E000E011A021A031A0417040201\n"
"} remove (a b) #@(name: flatten-λ) #{##(:type-name b ΓεnΣym-12 :pair :array :tree #f append reduce flatten-λ a)\n"
"151A000E01040107020D0E021A03200C0A001A0D0E021A04200C0A00100D0E02\n"
"1A05200C0A00060D1A060B00071B0900041C160B00150E070E080E010E092404\n"
"030E0A04020900101B0B000B0E010E0A140900042401\n"
"} flatten-λ (l) #@(documentation: \"Flatten a collection of collections into a simple list\" name: flatten) #{##(:type-name l ΓεnΣym-20 :pair :array :tree #f nreverse reduce flatten-λ)\n"
"151A000E01040107020D0E021A03200C0A001A0D0E021A04200C0A00100D0E02\n"
"1A05200C0A00060D1A060B00071B0900041C160B00130E070E080E010E092404\n"
"0304010900050E0101\n"
"} flatten (l glue) #@(documentation: \"Join every element of α together into a string with GLUE inbetween\" name: join) #{##(glue \"\" l reduce (a b) #@(name: anonymous) #{##(a cat glue b)\n"
"0E000B00100E010E000E020E0304030900050E0301\n"
"})\n"
"0E000B0007240900071A0105000D0E020B0007240900061A01010D0E030E021A\n"
"041A051A061724040301\n"
"} join (l f) #@(documentation: \"Runs F over every item in collection L\" name: for-each) #{##(ret l ΓεnΣym-30 i f)\n"
"2407000D150E0107020D240900180D0E021107030D0E040E03040105000D0E02\n"
"1205020E020AFFE90D0E001601\n"
"} for-each)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A0C\n"
"1A0D1A0E17070F0D1A101A111A121707130D151A141A151A161707170D1A181A\n"
"191A1A17071B16071B0D1A1C1A1D1A1E17071F0D1A201A211A2217072301\n"
"}#{##((l p) #@(documentation: \"Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true\" name: filter) #{##(:type-name l ΓεnΣym-1 :nil :pair list/filter p :array array/filter :tree tree/filter :type-error \"You can only filter collections\" current-lambda)\n"
"151A000E01040107020D0E021A03200B0007240900490E021A04200B000E0E05\n"
"0E010E0604020900360E021A07200B000E0E080E010E0604020900230E021A09\n"
"200B000E0E0A0E010E0604020900101A0B1A0C0E010E0D04002E042F1601\n"
"} filter (l f α) #@(documentation: \"Combine all elements in collection l using operation F and starting value α\" name: reduce) #{##(:type-name l ΓεnΣym-10 :nil α :tree tree/reduce f :array array/reduce :pair list/reduce :type-error \"You can only reduce collections\" current-lambda)\n"
"151A000E01040107020D0E021A03200B00080E0409004F0E021A05200B00100E\n"
"060E010E070E04040309003A0E021A08200B00100E090E010E070E0404030900\n"
"250E021A0A200B00100E0B0E010E070E0404030900101A0C1A0D0E010E0E0400\n"
"2E042F1601\n"
"} reduce (l f) #@(documentation: \"Runs f over every item in collection l and returns the resulting list\" name: map) #{##(:type-name l ΓεnΣym-19 :nil :pair list/map f :array array/map :type-error \"You can only use map with a collection\" current-lambda)\n"
"151A000E01040107020D0E021A03200B0007240900360E021A04200B000E0E05\n"
"0E010E0604020900230E021A07200B000E0E080E010E0604020900101A091A0A\n"
"0E010E0B04002E042F1601\n"
"} map (l) #@(documentation: \"Sorts the collection L\" name: sort) #{##(:type-name l ΓεnΣym-26 :nil :pair list/sort :array array/sort :type-error \"You can only use sort with a collection\" current-lambda)\n"
"151A000E01040107020D0E021A03200B0007240900320E021A04200B000C0E05\n"
"0E0104010900210E021A06200B000C0E070E0104010900101A081A090E010E0A\n"
"04002E042F1601\n"
"} sort (l start end) #@(documentation: \"Return a subcollection of L from START to END\" name: cut) #{##(:type-name l ΓεnΣym-33 :pair list/cut start end :array array/cut :string :cut :type-error \"You can only use member with a collection\" current-lambda)\n"
"151A000E01040107020D0E021A03200B00100E040E010E050E06040309003A0E\n"
"021A07200B00100E080E010E050E0604030900250E021A09200B00101A0A0E01\n"
"0E050E0604030900101A0B1A0C0E010E0D04002E042F1601\n"
"} cut)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A0C\n"
"1A0D1A0E17070F0D1A101A111A1217071301\n"
"}#{##((l) #@(documentation: \"(set! l (cdr l))\" name: cdr!) #{##(set! l cdr)\n"
"1A000E011A020E012414142414141401\n"
"} cdr! (l) #@(documentation: \"(set! l (cddr l))\" name: cddr!) #{##(set! l cddr)\n"
"1A000E011A020E012414142414141401\n"
"} cddr! (v l) #@(documentation: \"Cons V onto L and set! the value for L\" name: cons!) #{##(set! l cons v)\n"
"1A000E011A020E030E01241414142414141401\n"
"} cons! (list rest) #@(documentation: \"Iterator for except-last-pair\" name: except-last-pair/iter) #{##(nil? list reverse rest except-last-pair/iter)\n"
"0E000E011204010B000C0E020E0304010900100E040E01120E01110E03140402\n"
"01\n"
"} except-last-pair/iter (list) #@(documentation: \"Return a copy of LIST without the last pair\" name: except-last-pair) #{##(except-last-pair/iter list)\n"
"0E000E0124040201\n"
"} except-last-pair (list) #@(documentation: \"Return the last pair of LIST\" name: last-pair) #{##(list)\n"
"240900090D0E001205000E00120AFFF70D0E000101\n"
"} last-pair (end start step) #@(documentation: \"Return a list containing values from START (inclusive) to END (exclusive) by STEP\" name: range) #{##(end :arity-error \"(range) needs at least a specific end\" current-lambda start step number? 0.0 < > pred ret nreverse)\n"
"0E000B00072409000F1A011A02240E0304002E042F0D0E040B00072409000702\n"
"0005040D0E050B000724090007020105050D0E060E0504010C0B00090D0E051A\n"
"07210B00080E080900050E09070A0D24070B0D240900130D0E040E0B14050B0D\n"
"0E040E052505040E0A0E040E0004020AFFE80D0E0C0E0B040101\n"
"} range (l o s) #@(documentation: \"Combine all elements in l using operation o and starting value s\" name: list/reduce) #{##(l ΓεnΣym-16 e o s)\n"
"150E0007010D2409001A0D0E011107020D0E030E040E02040205040D0E011205\n"
"010E010AFFE70D0E041601\n"
"} list/reduce (l) #@(documentation: \"Return the list l in reverse order\" name: reverse) #{##(ret l ΓεnΣym-19 e)\n"
"2407000D150E0107020D240900170D0E021107030D0E030E001405000D0E0212\n"
"05020E020AFFEA0D0E001601\n"
"} reverse (l p) #@(documentation: \"Runs predicate p over every item in list l and returns a list consiting solely of items where p is true\" name: list/filter) #{##(ret l ΓεnΣym-22 e p nreverse)\n"
"2407000D150E0107020D240900240D0E021107030D0E040E0304010B000D0E03\n"
"0E00140500090004240D0E021205020E020AFFDD0D0E050E0004011601\n"
"} list/filter (l f) #@(documentation: \"Runs f over every item in list l and returns the resulting list\" name: list/map) #{##(ret l ΓεnΣym-27 e f nreverse)\n"
"2407000D150E0107020D2409001B0D0E021107030D0E040E0304010E00140500\n"
"0D0E021205020E020AFFE60D0E050E0004011601\n"
"} list/map (a b) #@(documentation: \"Appends two lists A and B together\" name: append) #{##(b ret reverse a ΓεnΣym-30 t)\n"
"0E0007010D0E020E03040105030D150E0307040D240900170D0E041107050D0E\n"
"050E011405010D0E041205040E040AFFEA0D0E011601\n"
"} append (l1 l2 pred) #@(name: list/merge-sorted-lists) #{##(nil? l1 l2 pred list/merge-sorted-lists)\n"
"0E000E0104010B00080E020900470E000E0204010B00080E010900391B0B0034\n"
"0E030E01110E021104020B00150E01110E040E01120E020E030403140900120E\n"
"02110E040E010E02120E030403140900042401\n"
"} list/merge-sorted-lists (l acc1 acc2) #@(name: list/split-half-rec) #{##(nil? l acc1 acc2 list/split-half-rec)\n"
"0E000E0104010B000B0E020E03140900350E000E011204010B000F0E01110E02\n"
"140E031409001F1B0B001A0E040E0112120E01110E02140E012C0E0314040309\n"
"00042401\n"
"} list/split-half-rec (l) #@(name: list/split-half) #{##(list/split-half-rec l)\n"
"0E000E012424040301\n"
"} list/split-half (l pred) #@(documentation: \"Sorts a list\" name: list/sort/merge) #{##(pred < nil? l list/split-half parts list/merge-sorted-lists list/sort/merge)\n"
"0E000B0007240900070E0105000D0E020E031204010B00080E030900240E040E\n"
"03040107050D0E060E070E05110E0004020E070E05120E0004020E00040301\n"
"} list/sort/merge list-merge-sort list/sort (a) #@(documentation: \"Return #t is A is a proper list\" name: list?) #{##(a :pair :type-name)\n"
"0E000B0007240900051C010D2409001C0D1A011A020E000401200B0007240900\n"
"051C010D0E001205000E000AFFE50D1B0101\n"
"} list? (a b) #@(documentation: \"#t if A and B are equal\" name: list/equal?) #{##(:pair :type-name a list/equal? b equal?)\n"
"1A001A010E020401200B001F0E030E02110E041104020C0B000E0D0E030E0212\n"
"0E0412040209000B0E050E020E04040201\n"
"} list/equal? (l count) #@(documentation: \"Take the first COUNT elements from list L\" name: list-take) #{##(count l list-take)\n"
"0E0002001F0B0007240900130E01110E020E01120E0002012604021401\n"
"} list-take (l count) #@(documentation: \"Drop the final COUNT elements from list L\" name: list-drop) #{##(count l list-drop)\n"
"0E0002001F0B00080E0109000F0E020E01120E00020126040201\n"
"} list-drop (l start end) #@(documentation: \"Return a subsequence of L from START to END\" name: list/cut) #{##(list-take list-drop l max start end)\n"
"0E000E010E020E0302000E04040204020E050E0302000E04040226040201\n"
"} list/cut (l search-for replace-with) #@(documentation: \"Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH\\n\\nUses (equal?) so we can search/replace lists/trees and other complex data structures\" name: list/replace) #{##(l equal? search-for replace-with list/replace :pair :type-name)\n"
"0E000B00071C0900041B0B0007240900620E010E000E0204020B00080E030900\n"
"520E010E00110E0204020B00140E030E040E00120E020E030403140900351B0B\n"
"00301A051A060E00110401200B00110E040E00110E020E0304030900060E0011\n"
"0E040E00120E020E030403140900042401\n"
"} list/replace)\n"
"1A001A011A021807030D1A041A051A061807070D1A081A091A0A18070B0D151A\n"
"0C1A0D1A0E17070F0D1A101A111A121707131607130D1A141A151A161707170D\n"
"1A181A191A1A17071B0D1A1C1A1D1A1E17071F0D1A201A211A221707230D1A24\n"
"1A251A261707270D1A281A291A2A17072B0D1A2C1A2D1A2E17072F0D151A301A\n"
"311A321707330D1A341A351A361707370D1A381A391A3A17073B0D1A3C1A3D1A\n"
"3E17073F1607400D0E4007410D1A421A431A441707450D1A461A471A48170749\n"
"0D1A4A1A4B1A4C17074D0D1A4E1A4F1A501707510D1A521A531A541707550D1A\n"
"561A571A5817075901\n"
"}#{##((keys values) #@(documentation: \"Return a tree where KEYS point to VALUES\" name: tree/zip) #{##(tree/new ret keys ΓεnΣym-1 key values)\n"
"0E0024040107010D150E0207030D2409001E0D0E031107040D0E010E040E0511\n"
"370D0E051205050D0E031205030E030AFFE30D0E011601\n"
"} tree/zip (t k v) #@(documentation: \"Increment value at K in T by V\" name: tree/+=) #{##(t k v int #f)\n"
"0E000E010E020E030E000E012B0C0A000D0D02000C0A00060D1A040401253701\n"
"} tree/+= (t k v) #@(documentation: \"Decrement value at K in T by V\" name: tree/-=) #{##(tree/+= t k - v)\n"
"1A000E010E021A030E04241414241414141401\n"
"} tree/-= (t k) #@(documentation: \"Increment value at K in T by 1\" name: tree/++) #{##(tree/+= t k)\n"
"1A000E010E020201241414141401\n"
"} tree/++ (t k) #@(documentation: \"Increment value at K in T by 1\" name: tree/--) #{##(tree/-= t k)\n"
"1A000E010E020201241414141401\n"
"} tree/-- (a b) #@(documentation: \"Compares two trees for equality\" name: tree/equal?) #{##(:tree :type-name a b :key* equal? :value* tree/equal? :left* :right*)\n"
"1A001A010E020401200C0B000D0D1A001A010E030401200B00521A040E020401\n"
"1A040E030401200C0B003E0D0E051A060E0204011A060E03040104020C0B0029\n"
"0D0E071A080E0204011A080E03040104020C0B00140D0E071A090E0204011A09\n"
"0E030401040209000B0E050E020E03040201\n"
"} tree/equal? (l o s) #@(documentation: \"Combine all elements in l using operation o and starting value s\" name: tree/reduce) #{##(list/reduce :values l o s)\n"
"0E001A010E0204010E030E04040301\n"
"} tree/reduce (l f) #@(documentation: \"Return a new tree with all elements from L where F returns true\" name: tree/filter) #{##(tree/new ret :keys l ΓεnΣym-9 e t f)\n"
"0E0024040107010D151A020E03040107040D2409002C0D0E041107050D0E030E\n"
"052B07060D0E070E0604010B000D0E010E050E0637090004240D0E041205040E\n"
"040AFFD50D0E011601\n"
"} tree/filter (a b) #@(documentation: \"Merge two trees together, if a key is contained in both trees the on in B gets priority\" name: tree/merge) #{##(b a :clone tree/new ret :keys ΓεnΣym-14 k)\n"
"0E000B0007240900170E010B000C1A020E0104010900080E03240401010D0E01\n"
"0B00072409000A1A020E000401010D1A020E01040107040D151A050E00040107\n"
"060D2409001A0D0E061107070D0E040E070E000E072B370D0E061205060E060A\n"
"FFE70D0E041601\n"
"} tree/merge)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A18070B0D1A0C\n"
"1A0D1A0E18070F0D1A101A111A121807130D1A141A151A161707170D1A181A19\n"
"1A1A17071B0D1A1C1A1D1A1E17071F0D1A201A211A2217072301\n"
"}#{##((#nil) #@(documentation: \"() -> () --- Do Nothing\" name: $nop source: ('(0)) cat: :bytecode internal: #t inline: #t) #{##((0))\n"
"1A0001\n"
"} $nop (#nil) #@(documentation: \"(a) -> () --- Return top of value stack\" name: $ret source: ('(1)) cat: :bytecode internal: #t inline: #t) #{##((1))\n"
"1A0001\n"
"} $ret (#nil) #@(documentation: \"(a b) -> (result) --- Adds the two topmost values and pushes the result\" name: $add/int source: ('(3)) cat: :bytecode internal: #t inline: #t) #{##((3))\n"
"1A0001\n"
"} $add/int (#nil) #@(documentation: \"(col key) -> (result) --- Looks up key in col\" name: $ref source: ('(43)) cat: :bytecode internal: #t inline: #t) #{##((43))\n"
"1A0001\n"
"} $ref (#nil) #@(documentation: \"(a) -> (a a) --- Duplicates the value that is on the top of the stack\" name: $dup source: ('(12)) cat: :bytecode internal: #t inline: #t) #{##((12))\n"
"1A0001\n"
"} $dup (#nil) #@(documentation: \"(a) -> () --- Drop whatever is on top of the stack\" name: $drop source: ('(13)) cat: :bytecode internal: #t inline: #t) #{##((13))\n"
"1A0001\n"
"} $drop (#nil) #@(documentation: \"() -> (closure) --- Push the current closure as a λ on the stack\" name: $closure/push source: ('(19)) cat: :bytecode internal: #t inline: #t) #{##((19))\n"
"1A0001\n"
"} $closure/push (#nil) #@(documentation: \"() -> () --- Create a new let closure and switch to it\" name: $let source: ('(21)) cat: :bytecode internal: #t inline: #t) #{##((21))\n"
"1A0001\n"
"} $let (#nil) #@(documentation: \"() -> () --- Leave the current closure and return to the parent one\" name: $closure/pop source: ('(22)) cat: :bytecode internal: #t inline: #t) #{##((22))\n"
"1A0001\n"
"} $closure/pop (#nil) #@(documentation: \"(a b) -> (bool) --- Compare A and B and push the result on the stack\" name: $< source: ('(30)) cat: :bytecode internal: #t inline: #t) #{##((30))\n"
"1A0001\n"
"} $< (#nil) #@(documentation: \"(a b) -> (bool) --- Compare A and B and push the result on the stack\" name: $<= source: ('(31)) cat: :bytecode internal: #t inline: #t) #{##((31))\n"
"1A0001\n"
"} $<= (#nil) #@(documentation: \"(a b) -> (bool) --- Compare A and B and push the result on the stack\" name: $= source: ('(32)) cat: :bytecode internal: #t inline: #t) #{##((32))\n"
"1A0001\n"
"} $= (#nil) #@(documentation: \"(a b) -> (bool) --- Compare A and B and push the result on the stack\" name: $>= source: ('(33)) cat: :bytecode internal: #t inline: #t) #{##((33))\n"
"1A0001\n"
"} $>= (#nil) #@(documentation: \"(a b) -> (bool) --- Compare A and B and push the result on the stack\" name: $> source: ('(34)) cat: :bytecode internal: #t inline: #t) #{##((34))\n"
"1A0001\n"
"} $> (#nil) #@(documentation: \"() -> (nil) --- Push a #nil on the stack\" name: $push/nil source: ('(36)) cat: :bytecode internal: #t inline: #t) #{##((36))\n"
"1A0001\n"
"} $push/nil (#nil) #@(documentation: \"(l) -> (car) --- Replace L with its car\" name: $car source: ('(17)) cat: :bytecode internal: #t inline: #t) #{##((17))\n"
"1A0001\n"
"} $car (#nil) #@(documentation: \"(l) -> (cdr) --- Replace L with its cdr\" name: $cdr source: ('(18)) cat: :bytecode internal: #t inline: #t) #{##((18))\n"
"1A0001\n"
"} $cdr (#nil) #@(documentation: \"(l) -> (cadr) --- Replace L with its cadr\" name: $cadr source: ('(44)) cat: :bytecode internal: #t inline: #t) #{##((44))\n"
"1A0001\n"
"} $cadr (#nil) #@(documentation: \"(car cdr) -> (pair) --- Cons CAR and CDR together and put it on the stack\" name: $cons source: ('(20)) cat: :bytecode internal: #t inline: #t) #{##((20))\n"
"1A0001\n"
"} $cons (#nil) #@(documentation: \"(args meta body) -> (λ) --- Create a new λ\" name: $fn/new source: ('(23)) cat: :bytecode internal: #t inline: #t) #{##((23))\n"
"1A0001\n"
"} $fn/new (#nil) #@(documentation: \"(args meta body) -> (μ) --- Create a new μ\" name: $macro/new source: ('(24)) cat: :bytecode internal: #t inline: #t) #{##((24))\n"
"1A0001\n"
"} $macro/new (#nil) #@(documentation: \"(name args docs body) -> (λ) --- Create a new λ\" name: $fn/dynamic source: ('(47)) cat: :bytecode internal: #t inline: #t) #{##((47))\n"
"1A0001\n"
"} $fn/dynamic (#nil) #@(documentation: \"(name args docs body) -> (μ) --- Create a new μ\" name: $macro/dynamic source: ('(48)) cat: :bytecode internal: #t inline: #t) #{##((48))\n"
"1A0001\n"
"} $macro/dynamic (#nil) #@(documentation: \"(a b) -> (result)\" name: $add source: ('(37)) cat: :bytecode internal: #t inline: #t) #{##((37))\n"
"1A0001\n"
"} $add (#nil) #@(documentation: \"(a b) -> (result)\" name: $sub source: ('(38)) cat: :bytecode internal: #t inline: #t) #{##((38))\n"
"1A0001\n"
"} $sub (#nil) #@(documentation: \"(a b) -> (result)\" name: $mul source: ('(39)) cat: :bytecode internal: #t inline: #t) #{##((39))\n"
"1A0001\n"
"} $mul (#nil) #@(documentation: \"(a b) -> (result)\" name: $div source: ('(40)) cat: :bytecode internal: #t inline: #t) #{##((40))\n"
"1A0001\n"
"} $div (#nil) #@(documentation: \"(a b) -> (result)\" name: $rem source: ('(41)) cat: :bytecode internal: #t inline: #t) #{##((41))\n"
"1A0001\n"
"} $rem (#nil) #@(documentation: \"() -> (#t)\" name: $push/true source: ('(27)) cat: :bytecode internal: #t inline: #t) #{##((27))\n"
"1A0001\n"
"} $push/true (#nil) #@(documentation: \"() -> (#f)\" name: $push/false source: ('(28)) cat: :bytecode internal: #t inline: #t) #{##((28))\n"
"1A0001\n"
"} $push/false (#nil) #@(documentation: \"(bc env) -> (return-val)\" name: $eval source: ('(29)) cat: :bytecode internal: #t inline: #t) #{##((29))\n"
"1A0001\n"
"} $eval (#nil) #@(documentation: \"(bc env) -> (return-val)\" name: $mutable-eval source: ('(45)) cat: :bytecode internal: #t inline: #t) #{##((45))\n"
"1A0001\n"
"} $mutable-eval (#nil) #@(documentation: \"(a) -> (result)\" name: $zero? source: ('(42)) cat: :bytecode internal: #t inline: #t) #{##((42))\n"
"1A0001\n"
"} $zero? (#nil) #@(documentation: \"(a) -> (result) --- Adds 1 to the topmost int\" name: $inc/int source: ('(35)) cat: :bytecode internal: #t inline: #t) #{##((35))\n"
"1A0001\n"
"} $inc/int (#nil) #@(documentation: \"(a b) -> (result)\" name: $bit-shift-left source: ('(49)) cat: :bytecode internal: #t inline: #t) #{##((49))\n"
"1A0001\n"
"} $bit-shift-left (#nil) #@(documentation: \"(a b) -> (result)\" name: $bit-shift-right source: ('(50)) cat: :bytecode internal: #t inline: #t) #{##((50))\n"
"1A0001\n"
"} $bit-shift-right (#nil) #@(documentation: \"(a b) -> (result)\" name: $bit-and source: ('(51)) cat: :bytecode internal: #t inline: #t) #{##((51))\n"
"1A0001\n"
"} $bit-and (#nil) #@(documentation: \"(a b) -> (result)\" name: $bit-or source: ('(52)) cat: :bytecode internal: #t inline: #t) #{##((52))\n"
"1A0001\n"
"} $bit-or (#nil) #@(documentation: \"(a b) -> (result)\" name: $bit-xor source: ('(53)) cat: :bytecode internal: #t inline: #t) #{##((53))\n"
"1A0001\n"
"} $bit-xor (#nil) #@(documentation: \"(a) -> (result)\" name: $bit-not source: ('(54)) cat: :bytecode internal: #t inline: #t) #{##((54))\n"
"1A0001\n"
"} $bit-not (a) #@(name: int-fit-in-byte?) #{##(a)\n"
"0E00027F1F0C0B00090D0E0002802101\n"
"} int-fit-in-byte? (a) #@(documentation: \"() -> (a) --- Push A on the stack as an :int\" name: $push/int cat: :bytecode internal: #t) #{##(int-fit-in-byte? a $push/int/byte $push/val)\n"
"0E000E0104010B000C0E020E0104010900090E030E01040101\n"
"} $push/int (a) #@(documentation: \"() -> (a) --- Push A on the stack as an :int that fits within a byte\" name: $push/int/byte cat: :bytecode internal: #t) #{##(int-fit-in-byte? a :invalid-bc-op \"$push/int/byte can only push a signed 8-bit value\" current-lambda)\n"
"0E000E0104010B0007240900101A021A030E010E0404002E042F0D02020E012E\n"
"0201\n"
"} $push/int/byte (arg-count fun) #@(documentation: \"arguments -> (result) --- Read arg-count arguments from the stack, apply the to fun and push the result on the stack\" name: $apply/optimized cat: :bytecode internal: #t) #{##(fun list $list arg-count ΓεnΣym-6 ΓεnΣym-7 car (17) cdr (18) cadr (44) zero? (42) inc/int (35) throw $throw bit-not (54) ΓεnΣym-8 add/int (3) ref (43) + (37) - (38) * (39) / (40) rem (41) cons (20) < (30) <= (31) = (32) >= (33) > (34) bytecode-eval* (29) mutable-eval* (45) bit-shift-left (49) bit-shift-right (50) bit-and (51) bit-or (52) bit-xor (53))\n"
"0E000E01200B000D0E020E03040101090004240D150E0307040D0E040201200B\n"
"006B150E0007050D0E050E06200B00081A070900540E050E08200B00081A0909\n"
"00470E050E0A200B00081A0B09003A0E050E0C200B00081A0D09002D0E050E0E\n"
"200B00081A0F0900200E050E10200B000A0E1104000900110E050E12200B0008\n"
"1A13090004241609011B0E040202200B0112150E0007140D0E140E15200B0008\n"
"1A160900FB0E140E17200B00081A180900EE0E140E19200B00081A1A0900E10E\n"
"140E1B200B00081A1C0900D40E140E1D200B00081A1E0900C70E140E1F200B00\n"
"081A200900BA0E140E21200B00081A220900AD0E140E23200B00081A240900A0\n"
"0E140E25200B00081A260900930E140E27200B00081A280900860E140E29200B\n"
"00081A2A0900790E140E2B200B00081A2C09006C0E140E2D200B00081A2E0900\n"
"5F0E140E2F200B00081A300900520E140E31200B00081A320900450E140E3320\n"
"0B00081A340900380E140E35200B00081A3609002B0E140E37200B00081A3809\n"
"001E0E140E39200B00081A3A0900110E140E3B200B00081A3C09000424160900\n"
"04241601\n"
"} $apply/optimized (arg-count fun) #@(documentation: \"arguments -> (result) --- Read arg-count arguments from the stack, apply the to fun and push the result on the stack\" name: $apply cat: :bytecode internal: #t) #{##(arg-count 255 :arity-error \"Functions can only take up to 255 arguments directly, try to pass a list/array/map instead\" current-lambda)\n"
"0E001A01220B00131A021A030E000E0404002E042F090004240D02040E002E02\n"
"01\n"
"} $apply (#nil) #@(documentation: \"(arguments function) -> (result) --- Read arg-count arguments from the stack, apply the to fun and push the result on the stack\" name: $apply/collection cat: :bytecode internal: #t) #{##()\n"
"02302E0101\n"
"} $apply/collection (count) #@(documentation: \"arguments -> (result) --- Read count arguments from the stack and put a list of those on the stack instead.\" name: $list cat: :bytecode internal: #t) #{##(count 255 :arity-error \"$list can only generate lists with up to 255 arguments in one go, try and use cons instead\" current-lambda)\n"
"0E001A01220B00131A021A030E000E0404002E042F090004240D022E0E002E02\n"
"01\n"
"} $list (target) #@(documentation: \"() -> () --- Try something, jumping to target if an exception occurs\" name: $try cat: :bytecode internal: #t) #{##(:relocate target)\n"
"02191A000E010208020002002E051A000E010200020102002E052E0301\n"
"} $try (#nil) #@(documentation: \"(v) -> () --- Throw an exception\" name: $throw cat: :bytecode internal: #t) #{##()\n"
"022F01\n"
"} $throw (target) #@(name: $jmp cat: :bytecode internal: #t) #{##(:relocate target)\n"
"02091A000E010208020002002E051A000E010200020102002E052E0301\n"
"} $jmp (v) #@(documentation: \"() -> (v) --- Pushes v onto the stack\" name: $push/val cat: :bytecode internal: #t) #{##(nil? v :invalid-bc-op \"Can't push #nil as a normal lVal\" current-lambda :literal)\n"
"0E000E0104010B00131A021A030E010E0404002E042F090004240D021A1A050E\n"
"012E022E0201\n"
"} $push/val (v) #@(documentation: \"() -> (v) --- Resolve V and get the associated value on the stack\" name: $get/val cat: :bytecode internal: #t) #{##(:symbol :type-name v :invalid-bc-op \"Can only get symbol\" current-lambda :literal)\n"
"1A001A010E020401200B0007240900101A031A040E020E0504002E042F0D020E\n"
"1A060E022E022E0201\n"
"} $get/val (v) #@(documentation: \"(v) -> (v) --- Resolve V and get the associated value on the stack\" name: $set/val cat: :bytecode internal: #t) #{##(:symbol :type-name v :invalid-bc-op \"Can only get symbol\" current-lambda :literal)\n"
"1A001A010E020401200B0007240900101A031A040E020E0504002E042F0D0205\n"
"1A060E022E022E0201\n"
"} $set/val (#nil) #@(documentation: \"(v v v) -> (v) --- Resolve V and get the associated value on the stack\" name: $set/gen cat: :bytecode internal: #t) #{##()\n"
"02372E0101\n"
"} $set/gen (v) #@(documentation: \"(v) -> (v) --- Resolve V and get the associated value on the stack\" name: $def/val cat: :bytecode internal: #t) #{##(:symbol :type-name v :invalid-bc-op \"Can only get symbol\" current-lambda :literal)\n"
"1A001A010E020401200B0007240900101A031A040E020E0504002E042F0D0207\n"
"1A060E022E022E0201\n"
"} $def/val (target) #@(name: $jt cat: :bytecode internal: #t) #{##(:relocate target)\n"
"020A1A000E010208020002002E051A000E010200020102002E052E0301\n"
"} $jt (target) #@(name: $jf cat: :bytecode internal: #t) #{##(:relocate target)\n"
"020B1A000E010208020002002E051A000E010200020102002E052E0301\n"
"} $jf (name args docs body) #@(name: $fn cat: :bytecode internal: #t) #{##(val->bytecode-op name args docs body)\n"
"02250E000E0104010E000E0204010E000E0304010E000E0404012E0501\n"
"} $fn (name args docs body) #@(name: $macro* cat: :bytecode internal: #t) #{##(val->bytecode-op name args docs body)\n"
"02260E000E0104010E000E0204010E000E0304010E000E0404012E0501\n"
"} $macro* (code sym-map pos) #@(name: assemble/build-sym-map) #{##(:type-name code ΓεnΣym-81 :int sym-map :last-op pos :keyword ΓεnΣym-82 :label :relocate :literal :pair assemble/build-sym-map)\n"
"2409009A0D151A000E0111040107020D0E021A03200B00120E041A050E060201\n"
"250506370900700E021A07200B004F150E011107080D0E081A09200B00120E04\n"
"0E012C0E06370D0E060109002D0E081A0A200B00160E041A050E060201250506\n"
"370D0E06010900120E081A0B200B00090E0601090004241609001C0E021A0C20\n"
"0B00130E0D0E01110E040E060403050609000424160D0E011205010E010AFF67\n"
"0D0E060101\n"
"} assemble/build-sym-map (code sym-map pos out) #@(name: assemble/relocate-op) #{##(sym-map code target pos off out 255)\n"
"0E000E012C2B07020D0E020E0112121211250E032607040D0E050E0302012505\n"
"030E040E01121211321A0633370D0E030101\n"
"} assemble/relocate-op (code sym-map pos out) #@(name: assemble/emit-relocated-ops) #{##(code :relocate assemble/relocate-op sym-map pos out ΓεnΣym-97 op :type-name ΓεnΣym-98 :int :pair assemble/emit-relocated-ops)\n"
"0E00111A01200B00140E020E000E030E040E050404050409005F150E0007060D\n"
"2409004C0D0E061107070D151A080E07040107090D0E091A0A200B00120E050E\n"
"0402012505040E073709001D0E091A0B200B00140E0C0E070E030E040E050404\n"
"050409000424160D0E061205060E060AFFB50D0E041601\n"
"} assemble/emit-relocated-ops (i) #@(name: literal-index->bytecode-op) #{##(i 256 255)\n"
"0E001A011E0B00080E000900120E000208321A02330E001A02332E0201\n"
"} literal-index->bytecode-op *max-literal-arr* (lit lit-arr) #@(name: assemble/add-literal) #{##(:length lit-arr 65535 :out-of-bounds \"Can only store up to 255 literals per bytecode-arr\" code current-lambda not= :type-name lit :pair i equal? literal-index->bytecode-op :length!)\n"
"1A000E0104011A02210B00131A031A040E050E0604002E042F090004240D0E07\n"
"1A080E0904011A0A04020B003D0200070B0D240900230D0E0C0E010E0B2B0E09\n"
"04020B000D0E0D0E0B040101090004240D0E0B23050B0E0B1A000E0104011E0A\n"
"FFD70D24090004240D1A0E0E0102011A000E0104012504020D0E011A000E0104\n"
"010201260E09370D0E0D1A000E010401020126040101\n"
"} assemble/add-literal (code lit-arr) #@(name: assemble/build-lit-arr) #{##(code :pair :type-name assemble/build-lit-arr lit-arr :literal assemble/add-literal index-op otherwise)\n"
"0E000B00072409000524010D1A011A020E00110401200B00190E030E00110E04\n"
"04020E030E00120E0404021409016E0E0011021A200C0B000B0D0E002C111A05\n"
"200B003A0E001205000D0E060E001112110E04040207070D1A011A020E070401\n"
"200B00080206090005021A0E070E030E00120E04040214140901220E0011020E\n"
"200C0B000B0D0E002C111A05200B003A0E001205000D0E060E001112110E0404\n"
"0207070D1A011A020E070401200B0008020F090005020E0E070E030E00120E04\n"
"040214140900D60E00110205200C0B000B0D0E002C111A05200B003A0E001205\n"
"000D0E060E001112110E04040207070D1A011A020E070401200B000802100900\n"
"0502050E070E030E00120E040402141409008A0E00110207200C0B000B0D0E00\n"
"2C111A05200B003A0E001205000D0E060E001112110E04040207070D1A011A02\n"
"0E070401200B0008020809000502070E070E030E00120E040402141409003E1A\n"
"050E0011200B001F0E001205000D0E060E00110E0404020E030E00120E040402\n"
"140900190E080B00130E00110E030E00120E040402140900042401\n"
"} assemble/build-lit-arr (code ret) #@(name: assemble/flatten) #{##(code ret :pair :type-name assemble/flatten :keyword)\n"
"0E000B0007240900060E01010D1A021A030E000401200B0007240900060E0101\n"
"0D0E040E00120E01040205010D1A021A030E00110401200C0B00170D1A051A03\n"
"0E0011110401200B00071C0900041B0B000F0E040E00110E0104020900090E00\n"
"110E011401\n"
"} assemble/flatten (code) #@(documentation: \"Assemble all arguments into a single :bytecode-array\" name: assemble* cat: :bytecode internal: #t) #{##(tree/new sym-map array/new lit-arr assemble/build-lit-arr assemble/flatten code tmp assemble/build-sym-map :alloc Array :last-op out assemble/emit-relocated-ops :bytecode-array)\n"
"0E0024040107010D0E0224040107030D0E040E050E0604010E03040207070D0E\n"
"080E070E01020004030D1A090E0A0E011A0B2B0402070C0D0E0D0E070E0102FF\n"
"0E0C04040D1A0E0E0C0E03040201\n"
"} assemble* l #@(documentation: \"Assemble all arguments into a single :bytecode-array\" name: assemble cat: :bytecode internal: #t) #{##(assemble* l)\n"
"0E000E01040101\n"
"} assemble ops #@(documentation: \"Assemble and evaluate all bytecode arguments\" name: asmrun cat: :bytecode internal: #t) #{##(bytecode-eval* assemble append ops current-closure)\n"
"1A001A010E020E03240402141A0424142414141401\n"
"} asmrun)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A0C\n"
"1A0D1A0E17070F0D1A101A111A121707130D1A141A151A161707170D1A181A19\n"
"1A1A17071B0D1A1C1A1D1A1E17071F0D1A201A211A221707230D1A241A251A26\n"
"1707270D1A281A291A2A17072B0D1A2C1A2D1A2E17072F0D1A301A311A321707\n"
"330D1A341A351A361707370D1A381A391A3A17073B0D1A3C1A3D1A3E17073F0D\n"
"1A401A411A421707430D1A441A451A461707470D1A481A491A4A17074B0D1A4C\n"
"1A4D1A4E17074F0D1A501A511A521707530D1A541A551A561707570D1A581A59\n"
"1A5A17075B0D1A5C1A5D1A5E17075F0D1A601A611A621707630D1A641A651A66\n"
"1707670D1A681A691A6A17076B0D1A6C1A6D1A6E17076F0D1A701A711A721707\n"
"730D1A741A751A761707770D1A781A791A7A17077B0D1A7C1A7D1A7E17077F0D\n"
"1A801A811A821707830D1A841A851A861707870D1A881A891A8A17078B0D1A8C\n"
"1A8D1A8E17078F0D1A901A911A921707930D1A941A951A961707970D1A981A99\n"
"1A9A17079B0D1A9C1A9D1A9E17079F0D1AA01AA11AA21707A30D1AA41AA51AA6\n"
"1707A70D1AA81AA91AAA1707AB0D1AAC1AAD1AAE1707AF0D1AB01AB11AB21707\n"
"B30D1AB41AB51AB61707B70D1AB81AB91ABA1707BB0D1ABC1ABD1ABE1707BF0D\n"
"1AC01AC11AC21707C30D1AC41AC51AC61707C70D1AC81AC91ACA1707CB0D1ACC\n"
"1ACD1ACE1707CF0D1AD01AD11AD21707D30D1AD41AD51AD61707D70D1AD81AD9\n"
"1ADA1707DB0D1ADC1ADD1ADE1707DF0D1AE01AE11AE21707E30D1AE41AE51AE6\n"
"1707E70D1AE81AE91AEA1707EB0D151AEC1AED1AEE1707EF0D1AF01AF11AF217\n"
"07F30D1AF41AF51AF61707F70D1AF81AF91AFA1707FB0D020007FC0D1AFD1AFE\n"
"1AFF170801000D060101060102060103170801040D0601050601060601071708\n"
"01080D06010906010A06010B1708010C1608010C0D06010D06010E06010F1708\n"
"01100D0601110601120601131808011401\n"
"}#{##((source) #@(name: bytecompile/literal) #{##(:type-name source ΓεnΣym-1 :int $push/int :nil (36) :bool (27) (28) :symbol $get/val :native-function :lambda #f bytecompile/literal closure/name $push/val)\n"
"151A000E01040107020D0E021A03200B000C0E040E0104010900660E021A0520\n"
"0B00081A060900590E021A07200B00120E010B00081A080900051A090900420E\n"
"021A0A200B000E0E0B0E0104012E0109002F0E021A0C200C0A00100D0E021A0D\n"
"200C0A00060D1A0E0B00100E0F0E100E01040104010900090E110E0104011601\n"
"} bytecompile/literal (source) #@(name: bytecompile/quote) #{##(:type-name source ΓεnΣym-15 :nil (36) :int $push/int $push/val)\n"
"151A000E01040107020D0E021A03200B00081A0409001A0E021A05200B000C0E\n"
"060E0104010900090E070E0104011601\n"
"} bytecompile/quote (source env) #@(name: bytecompile/do/form) #{##(source bytecompile* env nil? (13) bytecompile/do/form)\n"
"0E000B002C0E010E00110E0204020E030E001204010B0007240900071A042414\n"
"140E050E00120E020402140900042401\n"
"} bytecompile/do/form (source env) #@(name: bytecompile/do) #{##(bytecompile/do/form source env)\n"
"0E000E01120E0204022E0101\n"
"} bytecompile/do (source env) #@(name: bytecompile/def) #{##(:symbol :type-name source #f :type-error \"(def) needs a symbol name and a value as arguments\" env bytecompile* $def/val)\n"
"1A001A010E022C0401200B00071C0900041B0C0A00170D0E0212120B00071C09\n"
"00041B0C0A00060D1A030B00101A041A05240E062E042F090004240D0E070E02\n"
"1212110E0604020E080E022C04012E0201\n"
"} bytecompile/def (source env) #@(name: bytecompile/set!) #{##(:length source ΓεnΣym-31 :symbol :type-name :type-error \"(set!) needs a symbol name and a value as arguments\" env bytecompile* $set/val $set/gen :arity-error \"(set!) needs 2 or 3 arguments\")\n"
"151A000E0112040107020D0E020202200B003E1A031A040E012C0401200B0007\n"
"1C0900041B0B00101A051A06240E072E042F090004240D0E080E011212110E07\n"
"04020E090E012C04012E0209003E0E020203200B002C0E080E012C0E0704020E\n"
"080E011212110E0704020E080E01121212110E0704020E0A04002E0409000D1A\n"
"0B1A0C240E072E042F1601\n"
"} bytecompile/set! (source env) #@(name: bytecompile/if) #{##(gensym sym-else sym-after bytecompile* source env $jf $jmp :label)\n"
"150E00040007010D0E00040007020D0E030E042C0E0504020E060E0104010E03\n"
"0E041212110E0504020E070E0204011A080E012E020E030E04121212110E0504\n"
"021A080E022E022E071601\n"
"} bytecompile/if (source env) #@(name: bytecompile/while) #{##(gensym sym-start sym-end (36) $jmp :label (13) bytecompile/do/form source env bytecompile* $jt)\n"
"0E00040007010D0E00040007020D1A030E040E0204011A050E012E021A060E07\n"
"0E0812120E0904021A050E022E020E0A0E082C0E0904020E0B0E0104012E0801\n"
"} bytecompile/while (source env) #@(name: bytecompile/procedure/arg) #{##(nil? source bytecompile* env bytecompile/procedure/arg)\n"
"0E000E011204010B000F0E020E01110E0304020900160E020E01110E0304020E\n"
"040E01120E0304021401\n"
"} bytecompile/procedure/arg (op) #@(name: bytecompile/procedure/inline?) #{##(:meta op :inline)\n"
"1A000E011A02040201\n"
"} bytecompile/procedure/inline? (op args env) #@(name: bytecompile/procedure/inline) #{##(:length args arg-count :compiler-error \"For now only monadic functions can be inlined\" op env macroexpand do :meta :source form closure/arguments arg-name bytecompile* list/replace)\n"
"1A000E01040107020D0E020201220B00111A031A040E050E062E042F09000424\n"
"0D0E071A081A090E051A0A0402140E060402070B0D0E0C0E05040111070D0D0E\n"
"010B00170E0E0E0F0E0B0E0D0E011104030E06040209000B0E0E0E0B0E060402\n"
"01\n"
"} bytecompile/procedure/inline (op args env op-raw) #@(name: bytecompile/procedure) #{##(bytecompile/procedure/inline? op bytecompile/procedure/inline args env bytecompile/procedure/default op-raw)\n"
"0E000E0104010B00100E020E010E030E04040309000F0E050E010E030E040E06\n"
"040401\n"
"} bytecompile/procedure (op args env op-raw) #@(name: bytecompile/procedure/default) #{##(procedure? op :symbol :type-name :pair :keyword :type-error \"Can't apply to that\" current-lambda :length args arg-count $apply/optimized optimized bytecompile/procedure/arg bytecompile* op-raw env $apply)\n"
"0E000E0104010B00071C0900041B0C0B00410D1A021A030E010401200B00071C\n"
"0900041B0C0B002B0D1A041A030E010401200B00071C0900041B0C0B00150D1A\n"
"051A030E010401200B00071C0900041B0B00131A061A070E010E0804002E042F\n"
"090004240D1A090E0A0401070B0D0E0C0E0B0E010402070D0D0E0D0B00190E0A\n"
"0B000C0E0E0E0A0401090004240E0D2E020900220E0F0E100E1104020E0A0B00\n"
"0C0E0E0E0A0401090004240E120E0B04012E0301\n"
"} bytecompile/procedure/default (source env label-end) #@(name: bytecompile/and/rec) #{##(bytecompile* source env (12) $jf label-end (13) bytecompile/and/rec)\n"
"0E000E01110E0204020E01120B001D1A030E040E0504011A060E070E01120E02\n"
"0E0504032E04090004242E0201\n"
"} bytecompile/and/rec (source env) #@(name: bytecompile/and) #{##(gensym label-end bytecompile/and/rec source env :label)\n"
"0E00040007010D0E020E03120E040E0104031A050E012E022E0201\n"
"} bytecompile/and (source env label-end) #@(name: bytecompile/or/rec) #{##(source bytecompile* env (12) $jt label-end (13) bytecompile/or/rec)\n"
"0E000B00260E010E00110E0204021A030E040E0504011A060E070E00120E020E\n"
"0504032E050900042401\n"
"} bytecompile/or/rec (source env) #@(name: bytecompile/or) #{##(gensym label-end bytecompile/or/rec source env $push/val :label)\n"
"0E00040007010D0E020E03120E040E0104030E051C04011A060E012E022E0301\n"
"} bytecompile/or (source env) #@(name: bytecompile/fn*) #{##(:length source arg-count not= :arity-error \"(fn*) needs exactly 4 arguments\" current-lambda bytecompile* env (23))\n"
"1A000E0112040107020D0E030E02020504020B00131A041A050E010E0604002E\n"
"042F090004240D0E011205010D0E070E01110E0804020E070E012C0E0804020E\n"
"070E011212110E0804021A092E0401\n"
"} bytecompile/fn* (source env) #@(name: bytecompile/macro*) #{##(:length source arg-count not= :arity-error \"(macro*) needs exactly 4 arguments\" current-lambda bytecompile* env (24))\n"
"1A000E0112040107020D0E030E02020504020B00131A041A050E010E0604002E\n"
"042F090004240D0E011205010D0E070E01110E0804020E070E012C0E0804020E\n"
"070E011212110E0804021A092E0401\n"
"} bytecompile/macro* (source env) #@(name: bytecompile/environment*) #{##((21) bytecompile/do/form source env (13) (19) (22))\n"
"1A000E010E02120E0304021A041A051A062E0501\n"
"} bytecompile/environment* (source env) #@(name: bytecompile/let*) #{##((21) bytecompile/do source env (22))\n"
"1A000E010E022C0E0304021A042E0301\n"
"} bytecompile/let* (source env) #@(name: bytecompile/return) #{##(bytecompile* source env (1))\n"
"0E000E012C0E0204021A032E0201\n"
"} bytecompile/return (source env) #@(name: bytecompile/try) #{##(gensym end-sym bytecompile* source env $try bytecompile/do/form (22) :label)\n"
"0E00040007010D0E020E032C0E0404020E050E0104010E060E0312120E040402\n"
"1A071A080E012E022E0501\n"
"} bytecompile/try (source env) #@(name: bytecompile/apply) #{##(:length source arg-count bytecompile* env $list $apply/collection)\n"
"1A000E0112040107020D0E020201200B001B0E030E012C0E0404020E05020004\n"
"010E0604002E030900290E020202200B00200E030E012C0E0404020E030E0112\n"
"12110E0404020E0604002E030900042401\n"
"} bytecompile/apply (source env) #@(documentation: \"Compile the forms in source\" name: bytecompile* cat: :bytecode internal: #t) #{##(resolves? source env resolve op :type-name ΓεnΣym-77 :lambda :native-function :pair :symbol :keyword #f ΓεnΣym-78 do bytecompile/do let* bytecompile/let* def bytecompile/def set! bytecompile/set! if bytecompile/if while bytecompile/while and bytecompile/and or bytecompile/or fn* bytecompile/fn* macro* bytecompile/macro* environment* bytecompile/environment* try bytecompile/try return bytecompile/return apply bytecompile/apply quote bytecompile/quote bytecompile/procedure :type-error \"Can't evaluate that\" current-lambda bytecompile/literal)\n"
"0E000E01110E0204020B000F0E030E01110E0204020900060E011107040D151A\n"
"050E04040107060D0E061A07200C0A002E0D0E061A08200C0A00240D0E061A09\n"
"200C0A001A0D0E061A0A200C0A00100D0E061A0B200C0A00060D1A0C0B013715\n"
"0E04070D0D0E0D0E0E200B000E0E0F0E010E02040209011A0E0D0E10200B000E\n"
"0E110E010E0204020901070E0D0E12200B000E0E130E010E0204020900F40E0D\n"
"0E14200B000E0E150E010E0204020900E10E0D0E16200B000E0E170E010E0204\n"
"020900CE0E0D0E18200B000E0E190E010E0204020900BB0E0D0E1A200B000E0E\n"
"1B0E010E0204020900A80E0D0E1C200B000E0E1D0E010E0204020900950E0D0E\n"
"1E200B000E0E1F0E010E0204020900820E0D0E20200B000E0E210E010E020402\n"
"09006F0E0D0E22200B000E0E230E010E02040209005C0E0D0E24200B000E0E25\n"
"0E010E0204020900490E0D0E26200B000E0E270E010E0204020900360E0D0E28\n"
"200B000E0E290E010E0204020900230E0D0E2A200B000D0E2B0E012C04010900\n"
"110E2C0E040E01120E020E01110404160900251A091A050E010401200B00131A\n"
"2D1A2E0E010E2F04002E042F0900090E300E0104011601\n"
"} bytecompile* (form environment) #@(name: bytecompile cat: :bytecode internal: #t) #{##(bytecompile* form environment (1))\n"
"0E000E010E0204021A032E0201\n"
"} bytecompile)\n"
"151A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A\n"
"0C1A0D1A0E17070F0D1A101A111A121707130D1A141A151A161707170D1A181A\n"
"191A1A17071B0D1A1C1A1D1A1E17071F0D1A201A211A221707230D1A241A251A\n"
"261707270D1A281A291A2A17072B0D1A2C1A2D1A2E17072F0D1A301A311A3217\n"
"07330D1A341A351A361707370D1A381A391A3A17073B0D1A3C1A3D1A3E17073F\n"
"0D1A401A411A421707430D1A441A451A461707470D1A481A491A4A17074B0D1A\n"
"4C1A4D1A4E17074F0D1A501A511A521707530D1A541A551A561707570D1A581A\n"
"591A5A17075B0D1A5C1A5D1A5E17075F0D1A601A611A621707631607630D1A64\n"
"1A651A6617076701\n"
"}#{##((op) #@(documentation: \"Return the length in bytes of a bytecode operation and all its arguments\" name: disassemble/length) #{##(op ΓεnΣym-1 #f :unknown-op \"This op needs its length specified for disassembly to work\" current-lambda)\n"
"150E0007010D0E010200200C0A01A00D0E010201200C0A01960D0E010203200C\n"
"0A018C0D0E01020C200C0A01820D0E01020D200C0A01780D0E010211200C0A01\n"
"6E0D0E010212200C0A01640D0E010213200C0A015A0D0E010214200C0A01500D\n"
"0E010215200C0A01460D0E010216200C0A013C0D0E010217200C0A01320D0E01\n"
"0218200C0A01280D0E010219200C0A011E0D0E01021B200C0A01140D0E01021C\n"
"200C0A010A0D0E01021D200C0A01000D0E01021E200C0A00F60D0E01021F200C\n"
"0A00EC0D0E010220200C0A00E20D0E010221200C0A00D80D0E010222200C0A00\n"
"CE0D0E010223200C0A00C40D0E010224200C0A00BA0D0E010225200C0A00B00D\n"
"0E010226200C0A00A60D0E010227200C0A009C0D0E010228200C0A00920D0E01\n"
"0229200C0A00880D0E01022A200C0A007E0D0E01022B200C0A00740D0E01022C\n"
"200C0A006A0D0E01022D200C0A00600D0E01022F200C0A00560D0E010230200C\n"
"0A004C0D0E010231200C0A00420D0E010232200C0A00380D0E010233200C0A00\n"
"2E0D0E010234200C0A00240D0E010235200C0A001A0D0E010236200C0A00100D\n"
"0E010237200C0A00060D1A020B000802010900B00E010202200C0A00420D0E01\n"
"0204200C0A00380D0E010205200C0A002E0D0E010207200C0A00240D0E01020E\n"
"200C0A001A0D0E01021A200C0A00100D0E01022E200C0A00060D1A020B000802\n"
"020900600E010206200C0A00420D0E010208200C0A00380D0E010209200C0A00\n"
"2E0D0E01020A200C0A00240D0E01020B200C0A001A0D0E01020F200C0A00100D\n"
"0E010210200C0A00060D1A020B000802030900101A031A040E000E0504002E04\n"
"2F1601\n"
"} disassemble/length (error) #@(name: bytecode/nil-catcher) #{##(error :type-error)\n"
"0E00111A01200B0007240900060E002F01\n"
"} bytecode/nil-catcher (a i) #@(documentation: \"Read a bytecode encoded value in A at I and return it\" name: bytecode-arr->val) #{##(bytecode/nil-catcher bytecode-op->val a i)\n"
"0E0019001D0E010E020E032B0E0202010E03252B0E0202020E03252B04031601\n"
"} bytecode-arr->val (a i) #@(documentation: \"Read a bytecode encoded symbol in A at I and return it\" name: bytecode-arr->sym) #{##(bytecode/nil-catcher bytecode-op->sym a i)\n"
"0E0019001D0E010E020E032B0E0202010E03252B0E0202020E03252B04031601\n"
"} bytecode-arr->sym (a b) #@(documentation: \"Turn two bytecode ops encoding an offset into the integer representation\" name: bytecode-op->offset) #{##(a b t 32768 - 65536)\n"
"0E000208310E013407020D0E021A03220B000F0E041A050E022604010900050E\n"
"0201\n"
"} bytecode-op->offset (a i) #@(documentation: \"Read a bytecode encoded offset in A at I and return it as a signed integer\" name: bytecode-arr->offset) #{##(bytecode-op->offset a i)\n"
"0E000E010E022B0E0102010E02252B040201\n"
"} bytecode-arr->offset (v) #@(documentation: \"Quotes symbols but just passes through every other value\" name: disassemble/maybe-quote) #{##(:symbol :type-name v quote :bytecode-array disassemble/bytecode-array)\n"
"1A001A010E020401200B000C1A030E022E020900221A041A010E020401200B00\n"
"0C0E050E02040109000D1B0B00080E020900042401\n"
"} disassemble/maybe-quote (a i literals) #@(documentation: \"Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval\" name: disassemble/op) #{##(a i ΓεnΣym-23 ($nop) ($ret) $push/int/byte ($add/int) $apply $set/val disassemble/maybe-quote literals $push/val/ext bit-shift-left $def/val $def/val/ext $jmp* bytecode-arr->offset $jt* $jf* ($dup) ($drop) $get/val $get/val/ext $set/val/ext ($car) ($cdr) ($closure/push) ($cons) ($let) ($closure/pop) ($fn/dynamic) ($macro/dynamic) $try $push/val ($push/true) ($push/false) ($eval) ($<) ($<=) ($=) ($>=) ($>) ($inc/int) ($push/nil) ($add) ($sub) ($mul) ($div) ($rem) ($zero?) ($ref) ($cadr) ($mutable-eval) $list ($throw) ($apply/collection) ($bit-shift-left) ($bit-shift-right) ($bit-and) ($bit-or) ($bit-xor) ($bit-not) ($set/gen) :unknown-op)\n"
"150E000E012B07020D0E020200200B00081A030903DD0E020201200B00081A04\n"
"0903D00E020202200B00131A050E000E010201252B2414140903B80E02020320\n"
"0B00081A060903AB0E020204200B00131A070E000E010201252B241414090393\n"
"0E020205200B001A1A080E090E0A0E000E010201252B2B04012414140903740E\n"
"020206200B00261A0B0E0A0E000E010201252B0E0C0E000E010202252B040134\n"
"0208342B2414140903490E020207200B001A1A0D0E090E0A0E000E010201252B\n"
"2B040124141409032A0E020208200B00221A0E0E0A0E000E010201252B0E000E\n"
"010202252B020831342B2414140903030E020209200B00161A0F0E100E000E01\n"
"02012504022414140902E80E02020A200B00161A110E100E000E010201250402\n"
"2414140902CD0E02020B200B00161A120E100E000E0102012504022414140902\n"
"B20E02020C200B00081A130902A50E02020D200B00081A140902980E02020E20\n"
"0B001A1A150E090E0A0E000E010201252B2B04012414140902790E02020F200B\n"
"00221A160E0A0E000E010201252B0E000E010202252B020831342B2414140902\n"
"520E020210200B00221A170E0A0E000E010201252B0E000E010202252B020831\n"
"342B24141409022B0E020211200B00081A1809021E0E020212200B00081A1909\n"
"02110E020213200B00081A1A0902040E020214200B00081A1B0901F70E020215\n"
"200B00081A1C0901EA0E020216200B00081A1D0901DD0E020217200B00081A1E\n"
"0901D00E020218200B00081A1F0901C30E020219200B00161A200E100E000E01\n"
"02012504022414140901A80E02021A200B001A1A210E090E0A0E000E01020125\n"
"2B2B04012414140901890E02021B200B00081A2209017C0E02021C200B00081A\n"
"2309016F0E02021D200B00081A240901620E02021E200B00081A250901550E02\n"
"021F200B00081A260901480E020220200B00081A2709013B0E020221200B0008\n"
"1A2809012E0E020222200B00081A290901210E020223200B00081A2A0901140E\n"
"020224200B00081A2B0901070E020225200B00081A2C0900FA0E020226200B00\n"
"081A2D0900ED0E020227200B00081A2E0900E00E020228200B00081A2F0900D3\n"
"0E020229200B00081A300900C60E02022A200B00081A310900B90E02022B200B\n"
"00081A320900AC0E02022C200B00081A3309009F0E02022D200B00081A340900\n"
"920E02022E200B00131A350E000E010201252B24141409007A0E02022F200B00\n"
"081A3609006D0E020230200B00081A370900600E020231200B00081A38090053\n"
"0E020232200B00081A390900460E020233200B00081A3A0900390E020234200B\n"
"00081A3B09002C0E020235200B00081A3C09001F0E020236200B00081A3D0900\n"
"120E020237200B00081A3E0900051A3F1601\n"
"} disassemble/op (a i literals) #@(documentation: \"Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression\" name: disassemble/array) #{##(ret i disassemble/op a literals disassemble/length :length nreverse)\n"
"2407000D240900250D0E010E020E030E010E040403140E001405000D0E010E05\n"
"0E030E012B04012505010E011A060E0304011E0AFFD50D0E070E00040101\n"
"} disassemble/array (code) #@(documentation: \"Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions,\" name: disassemble/bytecode-array) #{##(disassemble/array :array code :literals)\n"
"0E001A010E02040102001A030E020401040301\n"
"} disassemble/bytecode-array (bc) #@(name: disassemble/to-string) #{##(disassemble/bytecode-array bc)\n"
"0E000E01040101\n"
"} disassemble/to-string (bc) #@(documentation: \"Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions,\" name: disassemble cat: :bytecode internal: #t) #{##(:type-name bc ΓεnΣym-138 :lambda :macro #f disassemble/to-string closure/code :bytecode-array :type-error \"Can't disassemble that\" current-lambda)\n"
"151A000E01040107020D0E021A03200C0A00100D0E021A04200C0A00060D1A05\n"
"0B00100E060E070E01040104010900210E021A08200B000C0E060E0104010900\n"
"101A091A0A0E010E0B04002E042F1601\n"
"} disassemble)\n"
"151A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A\n"
"0C1A0D1A0E17070F0D1A101A111A121707130D1A141A151A161707170D1A181A\n"
"191A1A17071B0D1A1C1A1D1A1E17071F0D1A201A211A221707230D1A241A251A\n"
"261707270D1A281A291A2A17072B0D1A2C1A2D1A2E17072F16072F01\n"
"}#{##((expr) #@(name: compile/backend/none cat: :compiler internal: #t) #{##(expr)\n"
"0E0001\n"
"} compile/backend/none (expr) #@(name: compile/backend/bytecode cat: :compiler internal: #t) #{##(assemble* bytecompile expr)\n"
"0E000E010E020401040101\n"
"} compile/backend/bytecode :bytecode *active-backend* tree/new :none backend/tree (expr) #@(name: backend cat: :compiler internal: #t) #{##(backend/tree *active-backend* expr)\n"
"0E000E012B0E02040101\n"
"} backend (backend expr environment) #@(name: compile/for) #{##(*active-backend* last-backend ret (e) #@(name: anonymous) #{##(last-backend *active-backend* e)\n"
"0E0005010D0E022F01\n"
"} backend compile* expr current-closure)\n"
"0E0007010D2407020D1A031A041A051719001E0E0605000D0E070E080E090400\n"
"040205020D0E0105000D0E02011601\n"
"} compile/for)\n"
"1A001A011A021707030D1A041A051A061707070D1A0807090D0E0A1A080E071A\n"
"0B0E030404070C0D1A0D1A0E1A0F1707100D1A111A121A1317071401\n"
"}#{##((source environment) #@(documentation: \"Compile SOURCE so it can be evaluated/applied\" name: compile* cat: :compiler internal: #t) #{##(backend constant-fold macroexpand source environment)\n"
"0E000E010E020E030E0404020401040101\n"
"} compile* (source environment) #@(name: compile/do* cat: :compiler internal: #t) #{##(:pair :type-name source compile* do environment)\n"
"1A001A010E020401200B00110E030E040E02140E0504020900050E0201\n"
"} compile/do* (source) #@(documentation: \"Compile SOURCE so it can be evaluated/applied\" name: compile cat: :compiler internal: #t) #{##(compile* source current-closure)\n"
"1A000E011A0224142414141401\n"
"} compile (name args body) #@(name: meta/parse/body cat: :compiler internal: #t) #{##(body source nil? not= :type-name :pair deftest #f tree/new :name name meta v ΓεnΣym-3 :tests :string :documentation cat \"\\n\" :keyword ΓεnΣym-4 :inline :source :related :export-as :export :cat trim join map split)\n"
"0E0007010D240900090D0E011205010E020E011204010B00071C0900041B0C0B\n"
"00240D0E031A040E011104011A0504020C0A00120D0E0111111A06200C0A0006\n"
"0D1A070AFFC60D0E081A090E0A0402070B0D240900E70D0E0011070C0D151A04\n"
"0E0C0401070D0D0E0D1A05200B00230E0C111A06200B00140E0B1A0E0E0C120E\n"
"0B1A0E2B14370900062405000900A70E0D1A0F200B001C0E0B1A100E111A0F0E\n"
"0B1A102B04011A120E0C0403370900860E0D1A13200B007D150E0C07140D0E14\n"
"1A15200B00140E0B0E0C1B370D0E0B1A160E013709005A0E141A17200B001A0E\n"
"0B1A170E002C0E0B1A172B14370D0E0012050009003B0E141A18200B00140E0B\n"
"1A190E002C370D0E001205000900220E141A1A200B00140E0B1A1A0E002C370D\n"
"0E001205000900090E0B0E0C1B371609000424160D0E001205000E000AFF1A0D\n"
"0E0B1A102B0B00260E0B1A100E1B0E1C0E1D0E1E0E0B1A102B1A1204020E1B04\n"
"021A120402040137090004240D0E0B0101\n"
"} meta/parse/body (name args . body) #@(documentation: \"Define a new macro\" name: defmacro) #{##(def name macro* quote args meta/parse/body body compile/do* current-closure)\n"
"1A000E011A021A030E042414140E050E010E040E0604031A030E070E060E0804\n"
"00040224141424141414142414141401\n"
"} defmacro (args body) #@(name: fn/check cat: :compiler internal: #t) #{##(args :type-error \"Every function needs an argument list\" current-lambda :symbol :type-name :pair #f \"Wrong type for argument list\" body \"Every function needs a body\")\n"
"0E000B0007240900101A011A020E000E0304002E042F0D2409003C0D1A041A05\n"
"0E000401200C0A00140D1A061A050E000401200C0A00060D1A070B0007240900\n"
"101A011A080E000E0304002E042F0D0E001205000E000AFFC50D0E090B000724\n"
"0900101A011A0A0E090E0304002E042F01\n"
"} fn/check (args . body) #@(documentation: \"Define an anonymous function\" name: fn) #{##(fn/check args body fn* quote meta/parse/body anonymous compile/do* current-closure)\n"
"0E000E010E0204020D1A031A040E012414140E051A060E010E0204031A040E07\n"
"0E020E0804000402241414241414141401\n"
"} fn (name args . body) #@(documentation: \"Define a new function\" name: defn) #{##(fn/check args body meta/parse/body name fn-meta def fn* quote compile/do* current-closure def-form :export export :symbol :type-name)\n"
"0E000E010E0204020D0E030E040E010E02040307050D1A060E041A071A080E01\n"
"2414140E051A080E090E020E0A04000402241414241414141424141414070B0D\n"
"0E051A0C2B0B00251A0D1A0E1A0F0E051A0C2B0401200B000B0E051A0C2B0900\n"
"050E040E0B2E030900050E0B01\n"
"} defn (env form) #@(documentation: \"Compile and immediatly evaluate the result directly in environment\" name: eval-in) #{##(compile* form env)\n"
"0E000E010E0204020E022D01\n"
"} eval-in (expr) #@(documentation: \"Compile, Evaluate and then return the result of EXPR\" name: eval) #{##(bytecode-eval* compile* expr current-closure)\n"
"1A001A010E021A032414241414141A0324142414141401\n"
"} eval (v t) #@(name: typecheck/only) #{##(when-not = :type-name v t throw list :type-error cat \"Expected a value of type \" current-lambda)\n"
"1A001A011A020E032414140E04241414141A051A061A070E081A090E0404020E\n"
"031A0A24142414141414142414142414141401\n"
"} typecheck/only gensym/counter (prefix) #@(name: gensym) #{##(gensym/counter :symbol cat prefix \"ΓεnΣym-\")\n"
"0E0002012505000D1A010E020E031A040E000403040101\n"
"} gensym)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A18070B0D1A0C\n"
"1A0D1A0E17070F0D1A101A111A121807130D1A141A151A161707170D1A181A19\n"
"1A1A18071B0D1A1C1A1D1A1E18071F0D1A201A211A221707230D1A241A251A26\n"
"1807270D1A281A291A2A18072B0D150200072C0D1A2D1A2E1A2F170730160730\n"
"01\n"
"}#{##((expr) #@(name: constant-fold/constant?) #{##(:pair :type-name expr :symbol)\n"
"1A001A010E020401200B00071C0900041B0C0B001B0D1A031A010E020401200B\n"
"00071C0900041B0C0B00050D1B01\n"
"} constant-fold/constant? (fun) #@(name: constant-fold/pure?) #{##(:meta fun :pure)\n"
"1A000E011A02040201\n"
"} constant-fold/pure? (sym) #@(name: constant-fold/resolve) #{##(:symbol :type-name sym resolve)\n"
"1A001A010E020401200B0007240900060E02010D0E030E02040101\n"
"} constant-fold/resolve (expr) #@(name: constant-fold/args) #{##(expr :pair :type-name constant-fold constant-fold/args)\n"
"0E000B0007240900060E00010D1A011A020E00110401200B00150E030E001104\n"
"010E040E001204011409000E0E00110E040E001204011401\n"
"} constant-fold/args (expr) #@(documentation: \"Will try and evaluate as many constant as possible to make the expression simpler.\" name: constant-fold cat: :compiler internal: #t) #{##(:pair :type-name expr folded-fun quote constant-fold/args folded-args constant-fold/pure? every? constant-fold/constant? (#nil) #@(name: anonymous) #{##(folded-fun folded-args)\n"
"0E000E011401\n"
"} constant-fold/resolve)\n"
"1A001A010E020401200B0007240900060E02010D0E021107030D1A040E03200B\n"
"00090E0201090004240D0E050E0212040107060D0E070E0304010C0B000C0D0E\n"
"080E060E0904020B001A1A0A1A0B1A0C1719000D0E0D0E0304010E0630160900\n"
"080E030E061401\n"
"} constant-fold)\n"
"151A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A\n"
"0C1A0D1A0E17070F0D1A101A111A1217071316071301\n"
"}#{##((args env) #@(name: macroexpand-do-args) #{##(nil? args macroexpand* env :pair :type-name ocar macroexpand-do-args)\n"
"0E000E011204010B00110E020E01110E030402241409004E1A041A050E011104\n"
"01200B0038150E020E01110E03040207060D1A041A050E060401200B00120E06\n"
"0E070E01120E0304021409000C0E070E01120E0304021609000C0E070E01120E\n"
"03040201\n"
"} macroexpand-do-args (source env) #@(name: macroexpand-do) #{##(macroexpand-do-args source env args nil? do)\n"
"0E000E010E02040207030D0E040E031204010B00090E03110900081A050E0314\n"
"01\n"
"} macroexpand-do (source env op arity implicit-do? no-expand-bitmap) #@(name: macroexpand-form) #{##(op ret source l i bit-test? no-expand-bitmap macroexpand* env arity implicit-do? macroexpand-do :arity-error cat \" form contains more than \" \" arguments\" nreverse)\n"
"0E00241407010D0E021207030D020007040D2409002F0D0E050E060E0404020B\n"
"00090E031109000C0E070E03110E0804020E011405010D0E031205030D0E0423\n"
"05040E040E091E0AFFCF0D240D0E0A0B00130E0B0E030E0804020E0114050109\n"
"00210E030B001B1A0C0E0D0E001A0E0E091A0F04040E020E082E042F09000424\n"
"0D0E100E0104010101\n"
"} macroexpand-form (op source env) #@(name: macroexpand-fold) #{##(source op macroexpand-fold except-last-pair env macroexpand* last-pair)\n"
"0E00120B00450E0012120B00250E010E020E010E030E0004010E0404030E050E\n"
"060E000401110E0404022E030900190E010E050E00110E0404020E050E002C0E\n"
"0404022E030900100E010E050E00110E0404022E0201\n"
"} macroexpand-fold (source env) #@(name: macroexpand-set) #{##(:length source macroexpand-form env set!)\n"
"02031A000E01120401200B00150E020E010E030E0402031C020004060900120E\n"
"020E010E030E0402021C0201040601\n"
"} macroexpand-set (source env) #@(documentation: \"Expand all macros within source\" name: macroexpand* cat: :compiler internal: #t) #{##(resolves? source env resolve op :type-name ΓεnΣym-23 :nil :macro macroexpand* :native-function ΓεnΣym-24 quote do macroexpand-do return macroexpand-form try while #f set! macroexpand-set def if fn* macro* let* environment* :meta :fold macroexpand-fold map (α) #@(name: anonymous) #{##(macroexpand* α env)\n"
"0E000E010E02040201\n"
"} (α) #{##(macroexpand* α env)\n"
"0E000E010E02040201\n"
"})\n"
"0E000E01110E0204020B000F0E030E01110E0204020900060E011107040D151A\n"
"050E04040107060D0E061A07200B00080E0109015D0E061A08200B00120E090E\n"
"040E0112300E0204020901460E061A0A200B0131150E04070B0D0E0B0E0C200B\n"
"00080E0109011A0E0B0E0D200B000E0E0E0E010E0204020901070E0B0E0F200B\n"
"00150E100E010E020E0402011C020004060900ED0E0B0E11200C0A00100D0E0B\n"
"0E12200C0A00060D1A130B00150E100E010E020E0402011B020004060900C20E\n"
"0B0E14200B000E0E150E010E0204020900AF0E0B0E16200B00150E100E010E02\n"
"0E0402021C020104060900950E0B0E17200B00150E100E010E020E0402031C02\n"
"00040609007B0E0B0E18200C0A00100D0E0B0E19200C0A00060D1A130B00150E\n"
"100E010E020E0402041B020704060900500E0B0E1A200C0A00100D0E0B0E1B20\n"
"0C0A00060D1A130B00130E040E0E0E01120E0204022E020900271A1C0E041A1D\n"
"04020B000F0E1E0E040E011204020900100E1F0E011A201A211A221704021609\n"
"00100E1F0E011A231A211A241704021601\n"
"} macroexpand* (source env) #@(documentation: \"Macroexpand the forms in source\" name: macroexpand) #{##(macroexpand* source env root-closure #f)\n"
"0E000E010E020C0A000D0D0E030C0A00060D1A04040201\n"
"} macroexpand)\n"
"151A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A\n"
"0C1A0D1A0E17070F0D1A101A111A121707130D1A141A151A161707171607170D\n"
"1A181A191A1A17071B01\n"
"}#{##((name . body) #@(name: defclass) #{##(meta/parse/body name (#nil) body fn-meta def closure/data let* append meta* current-closure def-form :export export :symbol :type-name)\n"
"0E000E011A020E03040307040D1A050E011A061A070E080E031A051A090E0424\n"
"1414141A0A241424141404021424141424141414070B0D0E041A0C2B0B00310E\n"
"041A0C2B0B00251A0D1A0E1A0F0E041A0C2B0401200B000B0E041A0C2B090005\n"
"0E010E0B2E03090004240900050E0B01\n"
"} defclass)\n"
"1A001A011A0218070301\n"
"}#{##(otherwise (val inc) #@(name: +=) #{##(set! val + inc)\n"
"1A000E011A020E010E03241414142414141401\n"
"} += (arg) #@(name: let/arg) #{##(arg :pair :type-name :symbol #f :invalid-let-form \"Please fix the structure of the let form\" def)\n"
"0E000B00521A011A020E000401200B00071C0900041B0C0A001D0D1A031A020E\n"
"00110401200B00071C0900041B0C0A00060D1A040B000F1A051A060E002E032F\n"
"090004240D1A070E00110E002C241414140900042401\n"
"} let/arg (args) #@(name: let/args) #{##(args let/arg let/args)\n"
"0E000B00150E010E001104010E020E00120401140900042401\n"
"} let/args (bindings . body) #@(documentation: \"Evalutes to BODY if PRED is true\" name: let) #{##(let* do append let/args bindings body)\n"
"1A001A010E020E030E0404010E020E0524040204021424141401\n"
"} let (v) #@(documentation: \"Coerce to boolean\" name: boolean source: ((if v #t #f)) cat: :boolean-operations tests: ((#t (boolean \"a\")) (#t (boolean \"\")) (#t (boolean 0.1)) (#t (boolean 1)) (#t (boolean 0)) (#f (boolean #f)) (#f (boolean #nil)) (#t (boolean #t))) inline: #t related: (not)) #{##(v)\n"
"0E000B00071B0900041C01\n"
"} boolean (v) #@(documentation: \"Return true if V is false\" name: not source: ((if v #f #t)) cat: :boolean-operations tests: ((#t (not (< 3 2))) (#t (not (= #f #t))) (#t (not (< 5 1))) (#t (not #f)) (#f (not #t))) inline: #t related: (boolean)) #{##(v)\n"
"0E000B00071C0900041B01\n"
"} not (α) #@(documentation: \"Returns its argument\" name: identity source: (α) inline: #t) #{##(α)\n"
"0E0001\n"
"} identity (p) #@(documentation: \"(car (car p))\" name: caar source: ((car (car p))) cat: :list-manipulation tests: ((#t (caar '((#t) #f)))) inline: #t related: (cdr car cadr)) #{##(p)\n"
"0E00111101\n"
"} caar (p) #@(documentation: \"(cdr (car p))\" name: cdar source: ((cdr (car p))) cat: :list-manipulation tests: (((#t) (cdar '((#f #t) #f))) (#t (cdar '((#f . #t) #f)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E00111201\n"
"} cdar (p) #@(documentation: \"(cdr (cdr p))\" name: cddr source: ((cdr (cdr p))) cat: :list-manipulation tests: (((#t) (cddr '(#f #f #t))) (#t (cddr '(#f #f . #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E00121201\n"
"} cddr (p) #@(documentation: \"(car (cdr (car p)))\" name: cadar source: ((car (cdr (car p)))) cat: :list-manipulation tests: ((#t (cadar '((#f #t) #f)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E0011121101\n"
"} cadar (p) #@(documentation: \"(car (cdr (cdr p)))\" name: caddr source: ((car (cdr (cdr p)))) cat: :list-manipulation tests: ((#t (caddr '(#f #f #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E0012121101\n"
"} caddr (p) #@(documentation: \"(cdr (cdr (cdr p)))\" name: cdddr source: ((cdr (cdr (cdr p)))) cat: :list-manipulation tests: (((#t) (cdddr '(#f #f #f #t))) (#t (cdddr '(#f #f #f . #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E0012121201\n"
"} cdddr (p) #@(documentation: \"(car (cdr (cdr (cdr p))))\" name: cadddr source: ((car (cdr (cdr (cdr p))))) cat: :list-manipulation tests: ((#t (cadddr '(#f #f #f #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E001212121101\n"
"} cadddr (p) #@(documentation: \"(cdr (cdr (cdr (cdr p))))\" name: cddddr source: ((cdr (cdr (cdr (cdr p))))) cat: :list-manipulation tests: ((#t (cddddr '(#f #f #f #f . #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E001212121201\n"
"} cddddr (p) #@(documentation: \"(car (cdr (cdr (cdr (cdr p)))))\" name: caddddr source: ((car (cdr (cdr (cdr (cdr p)))))) cat: :list-manipulation tests: ((#t (caddddr '(#f #f #f #f #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E00121212121101\n"
"} caddddr (p) #@(documentation: \"(cdr (cdr (cdr (cdr (cdr p)))))\" name: cdddddr source: ((cdr (cdr (cdr (cdr (cdr p)))))) cat: :list-manipulation tests: ((#t (cdddddr '(#f #f #f #f #f . #t)))) inline: #t related: (cdr car caar)) #{##(p)\n"
"0E00121212121201\n"
"} cdddddr (type description value) #@(name: exception) #{##(throw list type description value current-lambda)\n"
"1A001A010E020E030E041A05241424141414141424141401\n"
"} exception)\n"
"1B07000D1A011A021A031807040D151A051A061A071707080D1A091A0A1A0B17\n"
"070C0D1A0D1A0E1A0F1807101607100D1A111A121A131707140D1A151A161A17\n"
"1707180D1A191A1A1A1B17071C0D1A1D1A1E1A1F1707200D1A211A221A231707\n"
"240D1A251A261A271707280D1A291A2A1A2B17072C0D1A2D1A2E1A2F1707300D\n"
"1A311A321A331707340D1A351A361A371707380D1A391A3A1A3B17073C0D1A3D\n"
"1A3E1A3F1707400D1A411A421A431707440D1A451A461A4718074801\n"
"}#{##((pred then else) #@(name: if-not) #{##(if pred else then)\n"
"1A000E010E020E03241414141401\n"
"} if-not (pred . body) #@(documentation: \"Evalutes to BODY if PRED is false\" name: when-not) #{##(if pred do append body)\n"
"1A000E01241A020E030E0424040214241414141401\n"
"} when-not (pred . body) #@(documentation: \"Evalutes to BODY if PRED is true\" name: when) #{##(if pred do append body)\n"
"1A000E011A020E030E042404021424241414141401\n"
"} when (key-sym cases) #@(name: case/clauses/multiple internal: #t) #{##(cases = key-sym case/clauses/multiple)\n"
"0E000B00191A010E020E00112E030E030E020E00120402140900042401\n"
"} case/clauses/multiple (key-sym clauses) #@(name: case/clauses internal: #t) #{##(clauses otherwise do if :pair :type-name quote nil? :symbol = key-sym or case/clauses/multiple case/clauses)\n"
"0E000B008E0E0011111A01200B000D1A020E001112140900771A031A041A050E\n"
"0011110401200B004B0E001111111A06200C0B001F0D0E070E00111112120401\n"
"0C0B00100D1A081A050E0011112C0401200B00101A090E0A0E0011112E030900\n"
"101A0B0E0C0E0A0E00111104021409000D1A090E0A0E0011112E031A020E0011\n"
"12140E0D0E0A0E001204022E040900042401\n"
"} case/clauses (key-form . clauses) #@(name: case) #{##(gensym key-sym let* def key-form case/clauses clauses)\n"
"0E00040007010D1A021A030E010E042E030E050E010E0604022E0301\n"
"} case (body) #@(name: cond/fn internal: #t) #{##(body if do cond/fn)\n"
"0E000C0B00080D0E0011110B001C1A010E0011111A020E001112140E030E0012\n"
"04012E040900042401\n"
"} cond/fn body #@(documentation: \"Contains multiple cond clauses\" name: cond) #{##(cond/fn body)\n"
"0E000E01040101\n"
"} cond (binding . body) #@(documentation: \"binding => (name n result-form)\\nRepeatedly executes body with name bound to integers from 0 through n-1. Returns result-form or #nil.\" name: dotimes) #{##(binding sym :type-name :symbol :type-error \"Expected a value of type :symbol\" current-lambda times result-form do def while < append body set! inc/int)\n"
"0E001107010D1A020E0104011A03200B0007240900101A041A050E010E060400\n"
"2E042F0D0E002C07070D0E0012121107080D1A091A0A0E010200241414141A0B\n"
"1A0C0E010E07241414140E0D0E0E1A0F0E011A100E0124141424141414241404\n"
"0214140E08241414141401\n"
"} dotimes (for-loop . body) #@(documentation: \"(doseq (l (list 1 2 3 4) result-form) (println l))\" name: doseq) #{##(gensym symbol-name let for-loop while def car append body cdr!)\n"
"0E00040007010D1A020E010E032C24141424141A040E011A050E03111A060E01\n"
"241414241414140E070E081A090E01241414241404021414140E031212112414\n"
"14141401\n"
"} doseq (init fun) #@(name: thread/-> internal: #t) #{##(fun :pair :type-name thread/-> init append)\n"
"0E000B003C1A011A020E00110401200B001E0E0011110E030E040E001204020E\n"
"050E00111224040214140900110E00110E030E040E001204022E020900050E04\n"
"01\n"
"} thread/-> (init . fun) #@(documentation: \"Thread init as the first argument through every function in fun\" name: ->) #{##(thread/-> init reverse fun)\n"
"0E000E010E020E030401040201\n"
"} ->)\n"
"1A001A011A021807030D1A041A051A061807070D1A081A091A0A18070B0D151A\n"
"0C1A0D1A0E17070F0D1A101A111A121707130D1A141A151A161807171607170D\n"
"1A181A191A1A17071B0D1A1C1A1D1A1E18071F0D1A201A211A221807230D1A24\n"
"1A251A261807270D151A281A291A2A17072B0D1A2C1A2D1A2E18072F16072F01\n"
"}#{##(tree/new module/cache module/store module/loader (#nil) #@(name: module/save-state cat: :modules internal: #t) #{##(tree/new :cache module/cache :loader module/loader)\n"
"0E001A010E021A030E04040401\n"
"} module/save-state (c) #@(name: module/restore-state cat: :modules internal: #t) #{##(c :cache module/cache :loader module/loader)\n"
"0E001A012B05020D0E001A032B050401\n"
"} module/restore-state (module-name symbol) #@(name: module/qualify-symbol cat: :modules internal: #t) #{##(:type-name module-name ΓεnΣym-1 :string module/qualify-symbol :keyword symbol :symbol cat \"/\" \"Can't qualify that\" current-lambda)\n"
"151A000E01040107020D0E021A03200B00120E041A050E0104010E0604020900\n"
"300E021A05200B001C1A070E081A070E0104011A091A030E0604010403040109\n"
"000F1A0A0E01240E0B04002E042F1601\n"
"} module/qualify-symbol (module env qualify?) #@(name: require* cat: :modules internal: #t) #{##(module/load module env mod \"Can't load that module\" current-lambda resolve exports :keys ΓεnΣym-6 k def-in! qualify? module/qualify-symbol :symbol)\n"
"0E000E010E02040207030D0E030B00072409000F1A040E01240E0504002E042F\n"
"0D0E061A070E03040207070D151A080E07040107090D240900350D0E0911070A\n"
"0D0E0B0E020E0C0B00120E0D0E011A0E0E0A040104020900091A0E0E0A04010E\n"
"070E0A2B04030D0E091205090E090AFFCC0D241601\n"
"} require* (name) #@(name: module/load/cache cat: :modules internal: #t) #{##(module/cache name)\n"
"0E000E012B01\n"
"} module/load/cache (name) #@(name: module/load/store cat: :modules internal: #t) #{##(module/store name source eval-in defmodule append read module/load/cache)\n"
"0E000E012B07020D0E020B00270E0315240D13161A040E010E050E060E020401\n"
"240402141404020D0E070E0104010900042401\n"
"} module/load/store (name) #@(name: module/load/external cat: :modules internal: #t) #{##(module/loader ΓεnΣym-15 loader name mod module/cache)\n"
"150E0007010D2409002D0D0E011107020D0E020E03040107040D0E040B00110E\n"
"050E030E04370D0E0401090004240D0E011205010E010AFFD40D241601\n"
"} module/load/external (name module-source) #@(name: module/insert/defer cat: :modules internal: #t) #{##(module/store name module-source)\n"
"0E000E010E023701\n"
"} module/insert/defer (name module) #@(name: module/insert cat: :modules internal: #t) #{##(module/cache name module)\n"
"0E000E010E023701\n"
"} module/insert (parts ret) #@(name: module/resolve-string/join cat: :modules internal: #t) #{##(parts ret \"\" \".\" #f module/resolve-string/join \"..\" \"Invalid path\" current-lambda otherwise)\n"
"0E000B00071C0900041B0B00080E0109006D1A020E0011200C0A00110D1A030E\n"
"0011200C0A00060D1A040B000F0E050E00120E0104020900461A060E0011200B\n"
"00270E002C0B00072409000F1A070E00240E0804002E042F0D0E050E0012120E\n"
"0104020900190E090B00130E050E00120E00110E011404020900042401\n"
"} module/resolve-string/join (name wd) #@(name: module/resolve-string cat: :modules internal: #t) #{##(wd mod-path module/resolve-string/join nreverse append split \"/\" name parts :keyword join \"\")\n"
"0E0007010D0E020E030E040E050E011A0604020E050E071A0604020402040124\n"
"040207080D1A090E0A1A0B0E08141A060402040101\n"
"} module/resolve-string (name env) #@(name: module/load cat: :modules internal: #t) #{##(:type-name name ΓεnΣym-33 :environment :string module/load module/resolve-string resolve *module-path* env :keyword module/load/cache module/load/store module/load/external #f \"Can't load that value as a module\" current-lambda)\n"
"151A000E01040107020D0E021A03200B00080E0109005C0E021A04200B001A0E\n"
"050E060E010E071A080E09040204020E09040209003D0E021A0A200B00290E0B\n"
"0E0104010C0A001C0D0E0C0E0104010C0A00110D0E0D0E0104010C0A00060D1A\n"
"0E09000F1A0F0E01240E1004002E042F1601\n"
"} module/load (module symbol) #@(name: module/import-all cat: :modules internal: #t) #{##(resolve exports module :type-name :tree :type-error \"Expected a value of type :tree\" current-lambda)\n"
"0E001A010E02040207010D1A030E0104011A04200B0007240900101A051A060E\n"
"010E0704002E042F0D0E010101\n"
"} module/import-all (module symbol) #@(name: module/import cat: :modules internal: #t) #{##(module/import-all module symbol exports :has? :import-error resolves? \"That symbol was not exported\" \"That symbol does not exist in that module\" current-lambda)\n"
"0E000E010E02040207030D1A040E030E0204020B00072409001F1A050E060E02\n"
"0E0104020B00081A070900051A08240E0904002E042F0D0E030E022B01\n"
"} module/import (f) #@(name: module/add-loader) #{##(f module/loader)\n"
"0E000E0114050101\n"
"} module/add-loader body #@(documentation: \"Define a new module and return it\" name: module) #{##(macroexpand environment* (def exports (tree/new #nil)) body)\n"
"0E001A011A020E031414040101\n"
"} module (name . body) #@(documentation: \"Define a new named module\" name: defmodule) #{##(module/insert name module def *module* append body)\n"
"1A000E011A021A031A040E01241414140E050E0624040214142414141401\n"
"} defmodule (name . body) #@(documentation: \"Define a new named module\" name: defmodule/defer) #{##(module/insert/defer name string/write quote do body)\n"
"1A000E011A021A031A040E05142E022414142414141401\n"
"} defmodule/defer (name value) #@(name: export) #{##(set! exports quote name value)\n"
"1A001A011A020E032414140E04241414141401\n"
"} export (module) #@(name: use) #{##(require* module current-closure)\n"
"1A000E011A02241424241414141401\n"
"} use (module) #@(name: require) #{##(require* module current-closure)\n"
"1A000E011A0224141B241414141401\n"
"} require (local-symbol module module-symbol) #@(name: import*) #{##(def local-symbol module/import module quote module-symbol)\n"
"1A000E011A020E031A040E05241414241414142414141401\n"
"} import* (names module) #@(name: import) #{##(list? names import* module/load module current-closure ret :as do nreverse)\n"
"0E000E0104010B00072409001B1A020E011A030E041A052414241414140E0124\n"
"14141414010D2407060D2409005B0D0E012C1A07200B002D1A020E011212111A\n"
"030E041A052414241414140E011124141414140E061405060D0E011212050109\n"
"00211A020E01111A030E041A052414241414140E011124141414140E06140506\n"
"0D0E011205010E010AFFA60D0E080E090E0604011401\n"
"} import (module args) #@(documentation: \"Import and run MODULE's main function with ARGS\" name: module/main) #{##(module/load module current-closure mod \"Module not found\" current-lambda resolve exports \"Invalid module, can't resolve exports\" :main main \"There is no symbol exported as main\" procedure? \"main is not a callable value\" args)\n"
"0E000E010E020400040207030D0E030B00072409000F1A040E01240E0504002E\n"
"042F0D0E061A070E03040207070D0E070B00072409000F1A080E01240E050400\n"
"2E042F0D0E071A092B070A0D0E0A0B00072409000F1A0B0E01240E0504002E04\n"
"2F0D0E0C0E0A04010B00072409000F1A0D0E01240E0504002E042F0D0E0A0E0E\n"
"040101\n"
"} module/main)\n"
"0E0024040107010D0E0024040107020D2407030D1A041A051A061707070D1A08\n"
"1A091A0A17070B0D1A0C1A0D1A0E17070F0D1A101A111A121707130D1A141A15\n"
"1A161707170D1A181A191A1A17071B0D1A1C1A1D1A1E17071F0D1A201A211A22\n"
"1707230D1A241A251A261707270D1A281A291A2A17072B0D1A2C1A2D1A2E1707\n"
"2F0D1A301A311A321707330D1A341A351A361707370D1A381A391A3A17073B0D\n"
"1A3C1A3D1A3E17073F0D1A401A411A421807430D1A441A451A461807470D1A48\n"
"1A491A4A18074B0D1A4C1A4D1A4E18074F0D1A501A511A521807530D1A541A55\n"
"1A561807570D1A581A591A5A18075B0D1A5C1A5D1A5E18075F0D1A601A611A62\n"
"17076301\n"
"}#{##((a) #@(documentation: \"Return #t if a is the last pair in a list\" name: last? source: ((nil? (cdr a))) inline: #t) #{##(nil? a)\n"
"0E000E0112040101\n"
"} last? (a) #@(documentation: \"Return #t if a is positive\" name: pos? source: ((and (number? a) (>= a 0.0))) inline: #t) #{##(number? a 0.0)\n"
"0E000E0104010C0B00090D0E011A022101\n"
"} pos? (a) #@(documentation: \"Return #t if a is zero or negative\" name: zero-neg? source: ((<= a 0.0)) inline: #t) #{##(a 0.0)\n"
"0E001A011F01\n"
"} zero-neg? (a) #@(documentation: \"Returns #t if a is negative\" name: neg? source: ((< a 0.0)) inline: #t) #{##(a 0.0)\n"
"0E001A011E01\n"
"} neg? (a) #@(documentation: \"Predicate that returns #t if a is odd\" name: odd?) #{##(int a)\n"
"0E000E01040102022902012001\n"
"} odd? (a) #@(documentation: \"Predicate that returns #t if a is even\" name: even?) #{##(mod/int int a)\n"
"0E000E010E0204010202040202002001\n"
"} even? (val) #@(documentation: \"#t if VAL is not zero\" name: not-zero? source: ((not= 0 val)) inline: #t) #{##(not= val)\n"
"0E0002000E01040201\n"
"} not-zero? (val-a val-b) #@(documentation: \"Test whether two values are equal\\n\\nUnlike = this is actually comparing the contents of compound data,\\nwhich can be very slow.\\n\\nval-a: The first argument\\nval-b: The second argument\\n\\nWhether the two arguments are equal?\" name: equal? cat: :predicate tests: ((#t (equal? (array/new '(1 2 3) '(4.0 5.0 (tree/new :a 1 :b 2)) '(\"7\" (array/new 8 88) :9)) (array/new '(1 2 3) '(4.0 5.0 (tree/new :a 1 :b 2)) '(\"7\" (array/new 8 88) :9)))) (#t (equal? '(1 :b \"c\" (array/new 4.0)) '(1 :b \"c\" (array/new 4.0)))) (#f (equal? '(1 :b \"c\" (array/new 4.0)) '(1 :b \"c\"))) (#t (equal? '(1 :b \"c\") '(1 :b \"c\"))) (#f (equal? :a :b)) (#t (equal? :a :a)) (#f (equal? 2.0 2.1)) (#t (equal? 2.0 2.0)) (#t (equal? 1 1)))) #{##(:type-name val-a cur-type not= val-b ΓεnΣym-2 :array array/equal? :tree tree/equal? :pair list/equal?)\n"
"1A000E01040107020D0E030E021A000E04040104020B00071C090048150E0207\n"
"050D0E051A06200B000E0E070E010E04040209002E0E051A08200B000E0E090E\n"
"010E04040209001B0E051A0A200B000E0E0B0E010E0404020900080E010E0420\n"
"1601\n"
"} equal? (val-a val-b) #@(documentation: \"Test whether two values are not equal\\n\\nThis is using equal? under the hood, meaning it can be quite slow since\\nit actually compares the contents of complex data structures.\\n\\nval-a: The first argument\\nval-b: The second argument\\n\\nWhether the two arguments are not equal?\" name: not-equal? cat: :predicate tests: ((#t (not-equal? (array/new '(1 2 3) '(4.0 5.0 6.0) '(\"7\" (array/new 8 88) :9)) (array/new '(1 2 3) '(4.0 5.0 6.0) '(\"7\" (array/new 8 88) :99)))) (#t (not-equal? '(1 :b \"c\" (array/new 4.0)) '(1 :b \"c\"))) (#t (not-equal? :a :b)) (#f (not-equal? :a :a)) (#t (not-equal? (array/new '(1 2 3) '(4.0 5.0 (tree/new :a 1 :b 2)) '(\"7\" (array/new 8 88) :9)) (array/new '(1 2 3) '(4.0 5.0 (tree/new :a 1 :a 2)) '(\"7\" (array/new 8 88) :9)))))) #{##(equal? val-a val-b)\n"
"0E000E010E0204020B00071C0900041B01\n"
"} not-equal? (val) #@(documentation: \"Test whether val is an integer\\n\\nInteger are sometimes called fixnum's as well\\n\\nval: This argument is going to be tested\\n\\nWhether val is an integer\" name: int? source: ((= :int (:type-name val))) cat: :type-predicate tests: ((#f (int? 'asd)) (#f (int? 123.123)) (#t (int? 123))) inline: #t) #{##(:int :type-name val)\n"
"1A001A010E0204012001\n"
"} int? (val) #@(documentation: \"Test whether val is a floating-point number\\n\\nFloat's are sometimes called flonum's as well\\n\\nval: This argument is going to be tested\\n\\nWhether val is a floating-point number\" name: float? source: ((= :float (:type-name val))) cat: :type-predicate tests: ((#f (float? 'abc)) (#t (float? 123.123)) (#f (float? 123))) inline: #t) #{##(:float :type-name val)\n"
"1A001A010E0204012001\n"
"} float? (val) #@(documentation: \"Test whether val is a number\\n\\nRight now this means either a floating-point or integer number.\\n\\nval: This argument is going to be tested\\n\\nWhether val is a number\" name: number? cat: :type-predicate tests: ((#f (number? \"123\")) (#f (number? 'abc)) (#t (number? 123.123)) (#t (number? 123)))) #{##(:int :type-name val :float #f)\n"
"1A001A010E020401200C0A00140D1A031A010E020401200C0A00060D1A0401\n"
"} number? (val) #@(documentation: \"Test whether val is a boolean\\n\\nval: This argument is going to be tested\\n\\nWhether val is a boolean\" name: bool? source: ((= :bool (:type-name val))) cat: :type-predicate tests: ((#f (bool? 'qwe)) (#f (bool? 123.123)) (#f (bool? 123)) (#f (bool? #nil)) (#t (bool? #f)) (#t (bool? #t))) inline: #t) #{##(:bool :type-name val)\n"
"1A001A010E0204012001\n"
"} bool? (val) #@(documentation: \"Test whether val is a pair\\n\\nA pair is sometimes also called a cons cell, which can be used to build lists and much more.\\n\\nval: This argument is going to be tested\\n\\nWhether val is a pair\" name: pair? source: ((= :pair (:type-name val))) cat: :type-predicate tests: ((#f (pair? 'qwe)) (#f (pair? 123.123)) (#f (pair? 123)) (#t (pair? '(123))) (#t (pair? '(#nil)))) inline: #t) #{##(:pair :type-name val)\n"
"1A001A010E0204012001\n"
"} pair? (val) #@(documentation: \"Test whether val is an array\\n\\nSometimes also called a vector.\\n\\nval: This argument is going to be tested\\n\\nWhether val is an array\" name: array? source: ((= :array (:type-name val))) cat: :type-predicate tests: ((#f (array? 'abc)) (#f (array? 123.123)) (#f (array? 123)) (#f (array? '(123))) (#t (array? (array/new #nil)))) inline: #t) #{##(:array :type-name val)\n"
"1A001A010E0204012001\n"
"} array? (val) #@(documentation: \"Test whether val is a string\\n\\nval: This argument is going to be tested\\n\\nWhether val is a string\" name: string? source: ((= :string (:type-name val))) cat: :type-predicate tests: ((#f (string? 'abc)) (#f (string? 123.123)) (#f (string? 123)) (#f (string? '(123))) (#f (string? (array/new #nil))) (#t (string? \"asd\"))) inline: #t) #{##(:string :type-name val)\n"
"1A001A010E0204012001\n"
"} string? (val) #@(documentation: \"Test whether val is a symbol\\n\\nval: This argument is going to be tested\\n\\nWhether val is a symbol\" name: symbol? source: ((= :symbol (:type-name val))) cat: :type-predicate tests: ((#f (symbol? 123.123)) (#f (symbol? 123)) (#f (symbol? '(123))) (#f (symbol? \"asd\")) (#t (symbol? 'abc))) inline: #t) #{##(:symbol :type-name val)\n"
"1A001A010E0204012001\n"
"} symbol? (val) #@(documentation: \"Test whether val is an environment\\n\\nSometimes also called a closure\\n\\nval: This argument is going to be tested\\n\\nWhether val is an environment\" name: environment? source: ((= :environment (:type-name val))) cat: :type-predicate tests: ((#f (environment? '(123))) (#f (environment? (array/new #nil))) (#t (environment? (current-closure)))) inline: #t) #{##(:environment :type-name val)\n"
"1A001A010E0204012001\n"
"} environment? (val) #@(documentation: \"Test whether val is a binary tree\\n\\nTrees can also be used as maps, tuples or '\\n\\nval: This argument is going to be tested\\n\\nWhether val is a tree\" name: tree? source: ((= :tree (:type-name val))) cat: :type-predicate tests: ((#f (tree? 'abc)) (#f (tree? 123.123)) (#f (tree? 123)) (#f (tree? '(123))) (#f (tree? (array/new #nil))) (#f (tree? (current-closure))) (#t (tree? (tree/new #nil)))) inline: #t) #{##(:tree :type-name val)\n"
"1A001A010E0204012001\n"
"} tree? (l) #@(documentation: \"Test whether val is a collection\\n\\nval: This argument is going to be tested\\n\\nWhether val is a collection\" name: collection? source: ((case (:type-name l) ((:pair :array :tree) #t) (otherwise #f))) cat: :type-predicate tests: ((#f (collection? 'abc)) (#f (collection? 123.123)) (#f (collection? 123)) (#f (collection? (current-closure))) (#t (collection? '(123))) (#t (collection? (array/new #nil))) (#t (collection? (tree/new #nil)))) inline: #t) #{##(:type-name l ΓεnΣym-14 :pair :array :tree #f)\n"
"151A000E01040107020D0E021A03200C0A001A0D0E021A04200C0A00100D0E02\n"
"1A05200C0A00060D1A060B00071B0900041C1601\n"
"} collection? (v) #@(documentation: \"Test whether val is a keyword\\n\\nval: This argument is going to be tested\\n\\nWhether val is a keyword\" name: keyword? source: ((= :keyword (:type-name v))) cat: :type-predicate tests: ((#f (keyword? 123.123)) (#f (keyword? 123)) (#f (keyword? '(123))) (#f (keyword? (array/new #nil))) (#f (keyword? \"asd\")) (#f (keyword? 'abc)) (#t (keyword? :abc))) inline: #t) #{##(:keyword :type-name v)\n"
"1A001A010E0204012001\n"
"} keyword? (val) #@(documentation: \"Test whether val is a macro\\n\\nval: This argument is going to be tested\\n\\nWhether val is a macro\" name: macro? source: ((= :macro (:type-name val))) cat: :type-predicate tests: ((#f (macro? :abc)) (#t (macro? case))) inline: #t) #{##(:macro :type-name val)\n"
"1A001A010E0204012001\n"
"} macro? (val) #@(documentation: \"Test whether val is a function\\n\\nSometimes also called lambda or subroutine\\n\\nval: This argument is going to be tested\\n\\nWhether val is a function\" name: lambda? source: ((or (= :lambda (:type-name val)))) cat: :type-predicate tests: ((#f (lambda? 'abc)) (#f (lambda? (current-closure))) (#f (lambda? case)) (#t (lambda? min))) inline: #t) #{##(:lambda :type-name val #f)\n"
"1A001A010E020401200C0A00060D1A0301\n"
"} lambda? (val) #@(documentation: \"Test whether val is a native function\\n\\nSometimes also called lambda or subroutine\\n\\nval: This argument is going to be tested\\n\\nWhether val is a native function\" name: native? source: ((= :native-function (:type-name val))) cat: :type-predicate tests: ((#f (native? (defmacro +123 (a) (+ a 123)))) (#f (native? (defn +123 (a) (+ a 123)))) (#t (native? sin))) inline: #t) #{##(:native-function :type-name val)\n"
"1A001A010E0204012001\n"
"} native? (v) #@(documentation: \"Test whether val is a buffer\\n\\nBuffers are just modifiable chunks of memory\\n\\nval: This argument is going to be tested\\n\\nWhether val is a buffer\" name: buffer? source: ((= :buffer (:type-name v))) cat: :type-predicate tests: ((#f (buffer? (array/new #nil))) (#f (buffer? \"asd\")) (#t (buffer? #m00))) inline: #t) #{##(:buffer :type-name v)\n"
"1A001A010E0204012001\n"
"} buffer? (v) #@(documentation: \"Test whether val is a buffer view\\n\\nval: This argument is going to be tested\\n\\nWhether val is a buffer view\" name: buffer-view? source: ((= :buffer-view (:type-name v))) cat: :type-predicate tests: ((#f (buffer-view? (array/new #nil))) (#f (buffer-view? \"asd\")) (#f (buffer-view? #m00)) (#t (buffer-view? (:u8 #m00)))) inline: #t) #{##(:buffer-view :type-name v)\n"
"1A001A010E0204012001\n"
"} buffer-view? (v) #@(documentation: \"Test whether val is a bytecode-array\\n\\nval: This argument is going to be tested\\n\\nWhether val is a buffer view\" name: bytecode-array? source: ((= :bytecode-array (:type-name v))) cat: :type-predicate tests: ((#f (bytecode-array? (array/new #nil))) (#f (bytecode-array? \"asd\")) (#f (bytecode-array? #m00)) (#f (bytecode-array? (:u8 #m00))) (#t (bytecode-array? #{##()\n"
"01\n"
"}))) inline: #t) #{##(:bytecode-array :type-name v)\n"
"1A001A010E0204012001\n"
"} bytecode-array? (val) #@(documentation: \"Test whether val is a procedure\\n\\nProcedures in this context mean something you can use with map or put at the beginning of an expression.\\n\\nval: This argument is going to be tested\\n\\nWhether val is a procedure\" name: procedure? cat: :type-predicate tests: ((#f (procedure? (current-closure))) (#f (procedure? case)) (#t (procedure? sin)) (#t (procedure? min)) (#t (and (lambda? min) (procedure? min))) (#t (and (native? sin) (procedure? sin))))) #{##(:lambda :type-name val #f :native-function)\n"
"1A001A010E020401200C0A00060D1A030C0A00140D1A041A010E020401200C0A\n"
"00060D1A0301\n"
"} procedure? (val) #@(documentation: \"Test whether val is callable\\n\\nThis means basically anything where procedure? returns true, as well as macros, since they are\\njust standard procedures, but ones who run during compile time.\\n\\nval: This argument is going to be tested\\n\\nWhether val is callable\" name: callable? cat: :type-predicate tests: ((#f (callable? (current-closure))) (#t (callable? sin)) (#t (callable? min)) (#t (and (macro? case) (callable? case))))) #{##(:macro :type-name val procedure? #f)\n"
"1A001A010E020401200C0A00110D0E030E0204010C0A00060D1A0401\n"
"} callable? (v min max) #@(name: in-range?) #{##(v min max)\n"
"0E000E01210C0B00090D0E000E021F01\n"
"} in-range?)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A0C\n"
"1A0D1A0E17070F0D1A101A111A121707130D1A141A151A161707170D1A181A19\n"
"1A1A17071B0D1A1C1A1D1A1E17071F0D1A201A211A221707230D1A241A251A26\n"
"1707270D1A281A291A2A17072B0D1A2C1A2D1A2E17072F0D1A301A311A321707\n"
"330D1A341A351A361707370D1A381A391A3A17073B0D1A3C1A3D1A3E17073F0D\n"
"1A401A411A421707430D1A441A451A461707470D1A481A491A4A17074B0D1A4C\n"
"1A4D1A4E17074F0D1A501A511A521707530D1A541A551A561707570D1A581A59\n"
"1A5A17075B0D1A5C1A5D1A5E17075F0D1A601A611A621707630D1A641A651A66\n"
"1707670D1A681A691A6A17076B0D1A6C1A6D1A6E17076F0D1A701A711A721707\n"
"730D1A741A751A7617077701\n"
"}#{##((l depth) #@(name: quasiquote-real) #{##(l :pair :type-name unquote-splicing depth append quasiquote-real unquote quasiquote cons :symbol quote)\n"
"0E000B00072409000524010D1A011A020E000401200B00B50E0011111A03200B\n"
"00300E042A0B00171A050E00112C0E060E00120E0404022E030900131A030E06\n"
"0E002C02FF0E042504022E0209007B0E00111A07200B00220E042A0B00090E00\n"
"2C0900131A070E060E002C02FF0E042504022E020900530E00111A08200B0018\n"
"0E060E060E002C02010E042504020E0404020900350E042A0B001C1A090E060E\n"
"00110E0404020E060E00120E0404022E030900160E060E00110E0404020E060E\n"
"00120E040402140900230E042A0C0B000D0D1A0A1A020E000401200B000D1A0B\n"
"0E002414140900050E0001\n"
"} quasiquote-real (l) #@(name: quasiquote) #{##(quasiquote-real l)\n"
"0E000E010200040201\n"
"} quasiquote (expr) #@(name: unquote) #{##(:unquote-without-quasiquote \"unquote should only occur inside a quasiquote, never evaluated directly\")\n"
"1A001A012E022F01\n"
"} unquote (expr) #@(name: unquote-splicing) #{##(:unquote-splicing-without-quasiquote \"unquote-splicing should only occur inside a quasiquote, never evaluated directly\")\n"
"1A001A012E022F01\n"
"} unquote-splicing)\n"
"151A001A011A021707030D1A041A051A061807071607070D1A081A091A0A1707\n"
"0B0D1A0C1A0D1A0E17070F01\n"
"}#{##(3.141593 PI π (x) #@(documentation: \"Return a number 1 greater than x\" name: inc source: ((+ 1 x)) inline: #t) #{##(x)\n"
"02010E002501\n"
"} inc (x) #@(documentation: \"Return a number 1 less than x\" name: dec source: ((- x 1)) inline: #t) #{##(x)\n"
"0E0002012601\n"
"} dec (i v) #@(documentation: \"Decrement I by V (defaults to 1) and store the result in I\" name: inc!) #{##(set! i + v #f)\n"
"1A000E011A020E010E030C0A000D0D02010C0A00060D1A042414141424141414\n"
"01\n"
"} inc! (i v) #@(documentation: \"Decrement I by V and store the result in I\" name: dec!) #{##(set! i - v #f)\n"
"1A000E011A020E010E030C0A000D0D02010C0A00060D1A042414141424141414\n"
"01\n"
"} dec! (α) #@(documentation: \"Return a function that adds α to it's argument, useful for mapping\" name: +x) #{##((β) #@(name: anonymous) #{##(α β)\n"
"0E000E012501\n"
"})\n"
"1A001A011A021701\n"
"} +x (degrees) #@(documentation: \"Convert a quantity in degrees to radians\" name: radians) #{##(π degrees 180.0)\n"
"0E000E01271A022801\n"
"} radians args #@(documentation: \"Returns the minimum value of its arguments\\n\\nargs: A varible amount of numbers\\n\\nThe smallest value\" name: min cat: :math tests: ((4 (min 4 9)) (4 (min 4)) (#nil (min)) (1 (reduce (array/new 25 4 9 1) min)) (1 (apply min '(25 4 9 1))) (4 (min 25.3 4 9.1)) (8.2 (reduce (array/new 32 9 8.2) min)) (1 (apply min '(1 4 9 25))) (2 (min 2 4 9 25)))) #{##(reduce args (a b) #@(name: anonymous) #{##(a b)\n"
"0E000E011E0B00080E000900050E0101\n"
"})\n"
"0E000E011A021A031A0417040201\n"
"} min #@(documentation: \"Returns the maximum value of its arguments\\n\\nargs: A variable amount of numbers\\n\\nThe biggest value\" name: max cat: :math tests: ((25 (reduce (array/new 25 4 9 1) max)) (25 (apply max '(25 4 9 1))) (31.0 (max 31.0 4 9 1)) (25 (reduce (array/new 1 4 9 25) max)) (25 (apply max '(1 4 9 25))) (25 (max 1 4 9 25)) (9.1 (max 4 9.1)) (1 (max 1)) (#nil (max)))) #{##(reduce args (a b) #@(name: anonymous) #{##(a b)\n"
"0E000E01220B00080E000900050E0101\n"
"})\n"
"0E000E011A021A031A0417040201\n"
"} max)\n"
"1A0007010D0E0107020D1A031A041A051707060D1A071A081A0917070A0D1A0B\n"
"1A0C1A0D18070E0D1A0F1A101A111807120D1A131A141A151707160D1A171A18\n"
"1A1917071A0D1A1B1A1C1A1D17071E0D1A1B1A1F1A2017072101\n"
"}#{##((c i) #@(name: describe/closure cat: :compiler internal: #t) #{##(c root-closure cat i \"# <root environment>\" closure/data data :length l int #f \"# \" string/write \" - \" resolve *module* \"-+- Very big tree structure -+-\")\n"
"0E000B006A0E000E01200B000E0E020E031A0404020900540E050E0004010706\n"
"0D1A070E06040107080D0E020E090E030C0A000D0D02000C0A00060D1A0A0401\n"
"1A0B0E0C0E0004011A0D0E0E1A0F0E0004021A0D0E0802081E0B000C0E0C0E06\n"
"04010900051A1004070900042401\n"
"} describe/closure (trace) #@(name: print/stacktrace) #{##(i (e) #@(documentation: \"#<Error-in-Stacktrace>\" name: anonymous) #{##(\"#<Error-in-Stacktrace>\")\n"
"1A0001\n"
"} join map trace (c) #@(name: anonymous) #{##(describe/closure c i)\n"
"0E000E010E020201250502040201\n"
"} \"\\r\\n\")\n"
"02FF07000D1A011A021A03171900170E040E050E061A071A081A091704021A0A\n"
"04021601\n"
"} print/stacktrace (i v) #@(name: print/error/wrap) #{##((e) #@(documentation: \"#<Error>\" name: anonymous) #{##(\"#<Error>\")\n"
"1A0001\n"
"} i ΓεnΣym-9 v string/write print/stacktrace :string)\n"
"1A001A011A0217190040150E0307040D0E040200200B00080E0509002B0E0402\n"
"02200B000C0E060E05040109001A0E040203200B000C0E070E0504010900091A\n"
"080E050401161601\n"
"} print/error/wrap (error i) #@(name: print/error/iter) #{##(error print/error/wrap i print/error/iter \"\")\n"
"0E000B001C0E010E020E001104020E030E001202010E02250402140900071A04\n"
"241401\n"
"} print/error/iter (error) #@(documentation: \"Display ERROR in a nice, human readable way\" name: print/error) #{##(print join print/error/iter error \"\\r\\n\")\n"
"0E000E010E020E03020004021A040402040101\n"
"} print/error (o) #@(name: closure/documentation) #{##(:meta o :documentation)\n"
"1A000E011A02040201\n"
"} closure/documentation (o) #@(name: closure/cat) #{##(:meta o :cat :unsorted #f)\n"
"1A000E011A0204020C0A000D0D1A030C0A00060D1A0401\n"
"} closure/cat (o) #@(name: closure/name) #{##(procedure? o :meta :name closure/name closure/parent #f unknown)\n"
"0E000E0104010B00241A020E011A0304020C0A00150D0E040E050E0104010401\n"
"0C0A00060D1A060900051A0701\n"
"} closure/name (o) #@(documentation: \"Describe a specific value O\" name: describe/thing) #{##(closure/documentation o documentation closure/name name print fmt-arg-0 cat \"(\" closure/arguments arguments :pair :type-name ΓεnΣym-23 arg \" \" println \")\" \" . \" \"\\n\")\n"
"0E000E01040107020D0E030E01040107040D0E05150E030E01040107060D0E07\n"
"1A080E0604021604010D0E090E010401070A0D1A0B1A0C0E0A0401200B003F15\n"
"0E0A070D0D240900250D0E0D11070E0D0E0E0B00120E050E071A0F0E0E040204\n"
"01090004240D0E0D12050D0E0D0AFFDC0D0E101A110401160900110E050E071A\n"
"120E0A1A11040304010D0E100E071A130E02040204010D2401\n"
"} describe/thing (a) #@(documentation: \"Descibe whatever value string A resolves to\" name: describe/string) #{##(describe/thing resolve :symbol a)\n"
"0E000E011A020E0304010401040101\n"
"} describe/string (fun) #@(documentation: \"Describe FUN, if there is documentation available\" name: describe) #{##(:string :type-name fun describe/string describe/thing)\n"
"1A001A010E020401200B000C0E030E0204010900090E040E02040101\n"
"} describe current-closure root-closure l #@(name: deftest) #{##()\n"
"2401\n"
"} deftest body #@(documentation: \"Does nothing, mainly used for commenting out\\nparts of an expression, but having the sub expressions\\nbe available so you can use them easily via nujel-mode.\" name: comment cat: :documentation tests: ((#f (let ((x #f)) (comment (set! x #t)) x)))) #{##()\n"
"2401\n"
"} comment)\n"
"1A001A011A021707030D1A041A051A061707070D151A081A091A0A17070B0D1A\n"
"0C1A0D1A0E17070F0D1A101A111A121707131607130D1A141A151A161707170D\n"
"1A181A191A1A17071B0D1A1C1A1D1A1E17071F0D151A201A211A221707230D1A\n"
"241A251A261707270D1A281A291A2A17072B16072B0D0E2C0400072D0D1A2E1A\n"
"2F1A301807310D1A321A331A3418073501\n"
"}#{##((c) #@(name: lower-case-char) #{##(c)\n"
"0E0002411E0B00080E000900150E00025A220B00080E000900080E0002202501\n"
"} lower-case-char (c) #@(name: upper-case-char) #{##(c)\n"
"0E0002611E0B00080E000900150E00027A220B00080E000900080E0002E02501\n"
"} upper-case-char (c) #@(documentation: \"Return #t if C is a whitespace char\" name: whitespace?) #{##(c #f)\n"
"0E000220200C0A00240D0E000209200C0A001A0D0E00020A210C0B00090D0E00\n"
"020D1F0C0A00060D1A0101\n"
"} whitespace? l #@(documentation: \"Turn the provided char codes into a string and return it\" name: from-char-code) #{##(buffer/allocate :length l buf i :int :type-name 255 #f :type-error \"(from-char-code) expects :int arguments from 0 to 255, not: \" current-lambda buffer->string)\n"
"0E001A010E020401040107030D020007040D2409005D0D1A051A060E02110401\n"
"200B00071C0900041B0C0A001C0D0E02111A07220C0A00110D0E021102001E0C\n"
"0A00060D1A080B00141A091A0A0E02110E0B04002E042F090004240D0E030E04\n"
"0E0211370D0E021205020D0E042305040E041A010E0304011E0AFF9D0D0E0C0E\n"
"03040101\n"
"} from-char-code)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A0C\n"
"1A0D1A0E17070F01\n"
"}#{##(tree/new :align :right :debug :base :width :padding-char \" \" fmt/format-arg/default (s i) #@(name: fmt/find-non-digit-from-right) #{##(i s char fmt/find-non-digit-from-right)\n"
"0E0002001E0B000802FF09002D0E010E002B07020D0E020230210C0B00090D0E\n"
"0202391F0B00110E030E010E0002012604020900050E0001\n"
"} fmt/find-non-digit-from-right (opts spec) #@(name: fmt/parse-spec) #{##(:length spec opts ΓεnΣym-6 #f fmt/find-non-digit-from-right next-non-digit :cut number :width read/single :padding-char \"0\" fmt/parse-spec :debug :base :HEXADECIMAL :hexadecimal :decimal :octal :binary :align :left :center :right :precision :format-error \"Unknown form-spec option\" current-closure)\n"
"1A000E0104012A0B00080E02090271150E011A000E0104010201262B07030D0E\n"
"030230200C0A00600D0E030231200C0A00560D0E030232200C0A004C0D0E0302\n"
"33200C0A00420D0E030234200C0A00380D0E030235200C0A002E0D0E03023620\n"
"0C0A00240D0E030237200C0A001A0D0E030238200C0A00100D0E030239200C0A\n"
"00060D1A040B00620E050E011A000E010401020126040207060D1A070E010201\n"
"0E06251A000E010401040307080D0E021A090E0A0E080401370D02300E080200\n"
"2B200B000D0E021A0B1A0C37090004240D0E0D0E021A070E01020002010E0625\n"
"040304020901980E03023F200B00210E0D0E021A0E1B371A070E0102001A000E\n"
"010401020126040304020901720E030258200B00220E0D0E021A0F1A10371A07\n"
"0E0102001A000E0104010201260403040209014B0E030278200B00220E0D0E02\n"
"1A0F1A11371A070E0102001A000E010401020126040304020901240E03026420\n"
"0B00220E0D0E021A0F1A12371A070E0102001A000E0104010201260403040209\n"
"00FD0E03026F200B00220E0D0E021A0F1A13371A070E0102001A000E01040102\n"
"0126040304020900D60E030262200B00220E0D0E021A0F1A14371A070E010200\n"
"1A000E010401020126040304020900AF0E03023C200B00220E0D0E021A151A16\n"
"371A070E0102001A000E010401020126040304020900880E03025E200B00220E\n"
"0D0E021A151A17371A070E0102001A000E010401020126040304020900610E03\n"
"023E200B00220E0D0E021A151A18371A070E0102001A000E0104010201260403\n"
"040209003A0E03022E200B00250E0D0E021A190E021A092B371A070E0102001A\n"
"000E010401020126040304020900101A1A1A1B0E010E1C04002E042F1601\n"
"} fmt/parse-spec (opts) #@(name: fmt/debug) #{##(opts :debug :argument string/write)\n"
"0E001A012B0B00140E001A020E030E001A022B2E02370900050E0001\n"
"} fmt/debug (opts) #@(name: fmt/number-format) #{##(opts :base ΓεnΣym-36 :binary :argument int->string/binary :octal int->string/octal :decimal int->string/decimal :hexadecimal int->string/hex :HEXADECIMAL int->string/HEX)\n"
"150E001A012B07020D0E021A03200B00140E001A040E050E001A042B2E023709\n"
"00690E021A06200B00140E001A040E070E001A042B2E02370900500E021A0820\n"
"0B00140E001A040E090E001A042B2E02370900370E021A0A200B00140E001A04\n"
"0E0B0E001A042B2E023709001E0E021A0C200B00140E001A040E0D0E001A042B\n"
"2E02370900050E001601\n"
"} fmt/number-format :binary \"#b\" :octal \"#o\" :decimal \"#d\" :hexadecimal \"#x\" :HEXADECIMAL fmt/number-format-prefixex (opts) #@(name: fmt/number-format-prefix) #{##(opts :debug :base #f fmt/number-format-prefixex :argument cat)\n"
"0E001A012B0B00071C0900041B0C0A00180D0E001A022B0B00071C0900041B0C\n"
"0A00060D1A030B00080E0009002D0E040E001A022B2B0B001C0E001A050E060E\n"
"040E001A022B2B0E001A052B2E03370900050E001A011C3701\n"
"} fmt/number-format-prefix (opts) #@(name: fmt/add-padding) #{##(opts :width :argument :align ΓεnΣym-56 :right pad-start :center pad-middle :left pad-end :debug :base :padding-char)\n"
"0E001A012B0B006B0E001A02150E001A032B07040D0E041A05200B00080E0609\n"
"001E0E041A07200B00080E080900110E041A09200B00080E0A09000424160E00\n"
"1A022B0E001A0B2B0C0B00090D0E001A0C2B0B000E0E001A012B020226090008\n"
"0E001A012B0E001A0D2B2E04370900050E0001\n"
"} fmt/add-padding (opts) #@(name: fmt/precision) #{##(opts :precision :argument string/round)\n"
"0E001A012B0B00190E001A020E030E001A022B0E001A012B2E03370900050E00\n"
"01\n"
"} fmt/precision (opts) #@(name: fmt/truncate) #{##(opts :width :argument :cut)\n"
"0E001A012B0B001E0E001A021A030E001A022B020002010E001A012B252E0437\n"
"0900050E0001\n"
"} fmt/truncate (opts) #@(name: fmt/output) #{##(opts :argument)\n"
"0E001A012B01\n"
"} fmt/output (spec argument) #@(name: fmt/format-arg) #{##(fmt/output fmt/debug fmt/number-format-prefix fmt/truncate fmt/add-padding fmt/precision fmt/number-format fmt/parse-spec :clone fmt/format-arg/default spec :argument argument)\n"
"0E000E010E020E030E040E050E060E071A080E0904010E0A04021A0B0E0C3704\n"
"0104010401040104010401040101\n"
"} fmt/format-arg (argument) #@(name: fmt/valid-argument?) #{##(:int :type-name argument :symbol #f)\n"
"1A001A010E020401200C0A00140D1A031A010E020401200C0A00060D1A0401\n"
"} fmt/valid-argument? (v) #@(name: fmt/arg-sym) #{##(:type-name v ΓεnΣym-73 :int fmt/arg-sym cat \"fmt-arg-\" :string :symbol :type-error \"Invalid fmt argument name\" current-lambda)\n"
"151A000E01040107020D0E021A03200B00160E040E051A061A070E0104010402\n"
"040109002E0E021A08200B00080E010900210E021A07200B000C1A080E010401\n"
"0900101A091A0A0E010E0B04002E042F1601\n"
"} fmt/arg-sym (expr arguments-used opts) #@(name: fmt/expr) #{##(:string :type-name expr :format-error \"fmt needs a string literal as a first argument, since it is implemented as a macro\" current-lambda split \":\" split-expr argument \"\" #f format-spec tree/+= opts :expr-count arguments-used fmt/format-arg fmt/arg-sym read read-vals \"Format argument specifier contains more than a single atom\" fmt/valid-argument? \"Format argument specifier should be either an integer or a symbol\" :int :length \"fmt numbered argument is out of bounds\")\n"
"1A001A010E020401200B0007240900101A031A040E020E0504002E042F0D0E06\n"
"0E021A07040207080D0E081107090D0E082C0C0A000D0D1A0A0C0A00060D1A0B\n"
"070C0D1A0A0E09200B002A0E0D0E0E1A0F02FF04030D0E100E0E1A0F2B1B370D\n"
"0E110E0C0E120E0E1A0F2B04010402090099150E130E09040107140D0E14120B\n"
"00131A031A150E090E0504002E042F090004240D0E160E141104010B00072409\n"
"00101A031A170E090E0504002E042F0D1A181A010E14110401200B003E0E1411\n"
"02001E0C0A00150D0E14111A190E100401210C0A00060D1A0B0B00131A031A1A\n"
"0E090E0504002E042F090004240D0E100E14111B37090004240D0E110E0C0E12\n"
"0E1411040104021601\n"
"} fmt/expr (format-string . args) #@(documentation: \"Return a formatted string\" name: fmt) #{##(:string :type-name format-string :type-error \"fmt needs a string literal as a first argument, since it is implemented as a macro\" current-lambda cuts i ΓεnΣym-94 :int :format-error \"fmt placeholders can't be nested\" \"fmt expects all brackets to be closed\" :length expr-list last-pos array/fill! :alloc Array args arguments-used tree/new :expr-count opts ΓεnΣym-95 c :cut lit \"\" fmt/expr expr \"fmt expects all arguments to be used\" cat string/display fmt/args/map-fun/count (arg) #@(name: fmt/args/map-fun) #{##(:symbol cat \"fmt-arg-\" :string fmt/args/map-fun/count s def arg)\n"
"1A000E011A021A030E0404010402040107050D0E0402012505040D1A060E050E\n"
"072E0301\n"
"} fmt/args/map-fun let* append map)\n"
"1A001A010E020401200B0007240900101A031A040E020E0504002E042F0D2407\n"
"060D020007070D2409007C0D150E020E072B07080D0E08027B200B002C1A091A\n"
"010E06110401200B00131A0A1A0B0E020E0504002E042F090004240D0E070E06\n"
"14050609003A0E08027D200B00311A091A010E06110401200B0007240900101A\n"
"0A1A0C0E020E0504002E042F0D0E06110E07140E061214050609000424160D0E\n"
"072305070E071A0D0E0204011E0AFF7E0D240D1A091A010E06110401200B0013\n"
"1A0A1A0B0E020E0504002E042F090004240D24070E0D1A0D0E020401070F0D0E\n"
"101A110E121A0D0E13040104021C040207140D0E151A161A0D0E140401040207\n"
"170D150E0607180D2409005C0D0E181107190D1A1A0E020E19120201250E0F04\n"
"03071B0D1A1C0E1B200B00072409000A0E1B0E0E14050E0D0E1D1A1A0E020201\n"
"0E1911250E191204030E140E170403071E0D0E1E0E0E14050E0D0E1911050F0D\n"
"0E181205180E180AFFA50D24160D0E0F0200220B001A1A1A0E0202000E0F0403\n"
"071B0D0E1B0E0E14050E090004240D020007070D2409002A0D0E140E072B0B00\n"
"07240900171A0A1A1F0E020E130E072B2E020E0504002E042F0D0E072305070E\n"
"071A0D0E1404011E0AFFD00D240D0E0E120B000B1A200E0E1409001B1A001A01\n"
"0E0E110401200B00090E0E110900081A210E0E14071E0D020007220D1A231A24\n"
"1A251707260D0E130B00191A270E280E290E130E2604020E1E24140402140900\n"
"050E1E01\n"
"} fmt (format-string . args) #@(documentation: \"Print a formatted string\" name: pfmt) #{##(print fmt format-string append args)\n"
"1A001A010E020E030E04240402141424141401\n"
"} pfmt (format-string . args) #@(documentation: \"Print a formatted string\" name: efmt) #{##(error fmt format-string append args)\n"
"1A001A010E020E030E04240402141424141401\n"
"} efmt (format-string . args) #@(documentation: \"Print a formatted string\" name: pfmtln) #{##(println fmt format-string append args)\n"
"1A001A010E020E030E04240402141424141401\n"
"} pfmtln (format-string . args) #@(documentation: \"Print a formatted string\" name: efmtln) #{##(errorln fmt format-string append args)\n"
"1A001A010E020E030E04240402141424141401\n"
"} efmtln)\n"
"150E001A011A021A031C1A041C1A05241A061A07040A07080D1A091A0A1A0B17\n"
"070C0D1A0D1A0E1A0F1707100D1A111A121A131707140D1A151A161A17170718\n"
"0D0E001A191A1A1A1B1A1C1A1D1A1E1A1F1A201A211A20040A07220D1A231A24\n"
"1A251707260D1A271A281A2917072A0D1A2B1A2C1A2D17072E0D1A2F1A301A31\n"
"1707320D1A331A341A351707360D1A371A381A3917073A0D1A3B1A3C1A3D1707\n"
"3E0D1A3F1A401A411707420D1A431A441A451707460D1A471A481A4918074A16\n"
"074A0D1A4B1A4C1A4D18074E0D1A4F1A501A511807520D1A531A541A55180756\n"
"0D1A571A581A5918075A01\n"
"}#{##((ext) #@(documentation: \"Return a predicate that checks if a path ends on EXT\" name: path/ext?!) #{##(:type-name ext ΓεnΣym-1 :string (path) #@(name: anonymous) #{##(ext lower-case path/extension path)\n"
"0E000E010E020E03040104012001\n"
"} :pair (path) #{##(lower-case path/extension path cext reduce ext (α β) #@(name: anonymous) #{##(α β cext #f)\n"
"0E000C0A00100D0E010E02200C0A00060D1A0301\n"
"})\n"
"0E000E010E020401040107030D0E040E051A061A071A0817040201\n"
"} :type-error \"Expected a :string or :list\" current-lambda)\n"
"151A000E01040107020D0E021A03200B000D1A041A051A06170900220E021A07\n"
"200B000D1A081A051A09170900101A0A1A0B0E010E0C04002E042F1601\n"
"} path/ext?! (path) #@(documentation: \"Return the extension of PATH\" name: path/extension) #{##(:last-index-of path \".\" last-period :cut :length)\n"
"1A000E011A02040207030D0E030200210B00171A040E0102010E03251A050E01\n"
"040104030900050E0101\n"
"} path/extension (path) #@(documentation: \"Return PATH, but without the extension part\" name: path/without-extension) #{##(:last-index-of path \".\" last-period :cut)\n"
"1A000E011A02040207030D0E030200210B00101A040E0102000E030403090005\n"
"0E0101\n"
"} path/without-extension (path) #@(documentation: \"Return the directory part of a PATH\" name: path/dirname) #{##(:last-index-of path \"/\" last-slash :cut \"\")\n"
"1A000E011A02040207030D0E030200210B00101A040E0102000E030403090005\n"
"1A0501\n"
"} path/dirname (path) #@(documentation: \"Return the path without the directory part\" name: path/basename) #{##(:last-index-of path \"/\" last-slash :cut)\n"
"1A000E011A02040207030D0E030200210B00111A040E0102010E032504020900\n"
"050E0101\n"
"} path/basename)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A0C\n"
"1A0D1A0E17070F0D1A101A111A1217071301\n"
"}#{##(make-output-port make-string-output-port make-input-port buffer/allocate temporary-buffer :u8 temporary-buffer-view tree/new :flush-output (handle) #@(name: anonymous) #{##(file/flush* handle)\n"
"0E000E01040101\n"
"} :block-write (handle buffer size) #{##(file/write* handle buffer size)\n"
"0E000E010E020E03040301\n"
"} :char-write (handle char) #{##(temporary-buffer-view char file/write* handle)\n"
"0E0002000E01370D0E020E030E00040201\n"
"} :close! (handle) #{##(file/close* handle)\n"
"0E000E01040101\n"
"} :position (handle) #{##(file/tell* handle)\n"
"0E000E01040101\n"
"} :position! (handle new-position) #{##(file/seek* handle new-position)\n"
"0E000E010E020200040301\n"
"} :file-handle (handle) #{##(handle)\n"
"0E0001\n"
"} :methods (handle) #{##(output-port-method-table)\n"
"0E0001\n"
"} output-port-method-table (self buffer size) #{##(:meta self :buffer buf size :length buffer :position :length! 128 buffer/copy :meta!)\n"
"1A000E011A02040207030D0E040B00072409000B1A050E06040105040D0E041A\n"
"050E0304011A000E011A07040226220B001B1A080E031A091A050E0304010E04\n"
"25028033250402090004240D0E0A0E030E061A000E011A0704020E0404040D1A\n"
"0B0E011A071A000E011A0704020E0425040301\n"
"} (self char) #{##(:meta self :buffer buf :length :position :length! 128 char :meta!)\n"
"1A000E011A02040207030D1A040E0304011A000E011A0504022602011E0B0015\n"
"1A060E031A071A040E030401250402090004240D0E031A000E011A0504020E08\n"
"370D1A090E011A051A000E011A050402020125040301\n"
"} :write (self . buffers) #{##(buffers ΓεnΣym-7 buf self :block-write)\n"
"150E0007010D240900180D0E011107020D0E031A040E0204020D0E011205010E\n"
"010AFFE90D0E031601\n"
"} (self) #{##(self)\n"
"0E0001\n"
"} :return-string (self) #{##(buffer->string :meta self :buffer :position)\n"
"0E001A010E021A0304021A010E021A040402040201\n"
"} (self) #{##(string-out-methods)\n"
"0E0001\n"
"} string-out-methods :block-read (handle buffer size) #{##(file/eof*? handle :end-of-file file/read* buffer size)\n"
"0E000E0104010B00091A0201090004240D0E030E010E040E05040301\n"
"} :char-read (handle char) #{##(file/eof*? handle :end-of-file file/read* temporary-buffer-view)\n"
"0E000E0104010B00091A0201090004240D0E030E010E04020104030B00072409\n"
"00061A02010D0E0402002B01\n"
"} :raw! (handle) #{##(file/raw* handle)\n"
"0E000E011B040201\n"
"} (handle) #{##(input-port-method-table)\n"
"0E0001\n"
"} input-port-method-table (handle) #@(documentation: \"Create a new output port for HANDLE\" name: anonymous) #{##((method . args) #@(name: anonymous) #{##(output-port-method-table method handle args)\n"
"0E000E012B0E020E03143001\n"
"})\n"
"1A001A011A021701\n"
"} (#nil) #@(documentation: \"Create a new string output port\" name: anonymous) #{##(self (method . args) #@(name: anonymous) #{##(string-out-methods method self args)\n"
"0E000E012B0E020E03143001\n"
"} :meta! :buffer buffer/allocate 128 :position)\n"
"2407000D1A011A021A031705000D1A040E001A050E061A07040104030D1A040E\n"
"001A080200040301\n"
"} (handle) #@(documentation: \"Create a new input port for HANDLE\" name: anonymous) #{##((method . args) #@(name: anonymous) #{##(input-port-method-table method handle args)\n"
"0E000E012B0E020E03143001\n"
"})\n"
"1A001A011A021701\n"
"} (name . body) #@(name: with-string-port) #{##(let name make-string-output-port append body quote return-string)\n"
"1A000E011A02241424141424140E030E040E011A051A06241414241414241404\n"
"02141401\n"
"} with-string-port l #@(documentation: \"ConCATenates all arguments into a single string\" name: cat) #{##(make-string-output-port p l ΓεnΣym-16 c block-write string/display return-string)\n"
"0E00040007010D150E0207030D2409001C0D0E031107040D0E011A050E060E04\n"
"040104020D0E031205030E030AFFE50D0E011A0704011601\n"
"} cat)\n"
"2407000D2407010D2407020D150E030201040107040D1A050E04040107060D0E\n"
"071A081A091A0A1A0B171A0C1A0D1A0A1A0E171A0F1A101A0A1A11171A121A13\n"
"1A0A1A14171A151A161A0A1A17171A181A191A0A1A1A171A1B1A1C1A0A1A1D17\n"
"1A1E1A1F1A0A1A2017041007210D0E071A0C1A221A0A1A23171A0F1A241A0A1A\n"
"25171A261A271A0A1A28171A121A291A0A1A2A171A2B1A2C1A0A1A2D171A1E1A\n"
"2E1A0A1A2F17040C07300D0E071A311A321A0A1A33171A341A351A0A1A36171A\n"
"371A381A0A1A39171A120E211A122B1A150E211A152B1A180E211A182B1A1B0E\n"
"211A1B2B1A1E1A3A1A0A1A3B170410073C0D1A3D1A3E1A3F1705000D1A401A41\n"
"1A421705010D1A431A441A45170502160D1A461A471A481807490D1A4A1A4B1A\n"
"4C17074D01\n"
"}#{##((α) #@(documentation: \"Turn α into a its **binary** string representation\" name: int->string/binary) #{##(\"\" ret α #f \"0\" cat from-char-code not=)\n"
"1A0007010D0E020B00071C0900041B0C0A000E0D0E022A0C0A00060D1A030B00\n"
"091A0401090004240D240900200D0E050E0602300E020201332504010E010402\n"
"05010D0E0202013205020E0702000E0204020AFFDB0D0E0101\n"
"} int->string/binary (α) #@(documentation: \"Turn α into a its **octal** string representation\" name: int->string/octal) #{##(\"\" ret α #f \"0\" cat from-char-code not=)\n"
"1A0007010D0E020B00071C0900041B0C0A000E0D0E022A0C0A00060D1A030B00\n"
"091A0401090004240D240900200D0E050E0602300E020207332504010E010402\n"
"05010D0E0202033205020E0702000E0204020AFFDB0D0E0101\n"
"} int->string/octal ##(\"0\" \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"A\" \"B\" \"C\" \"D\" \"E\" \"F\") int->string/hex/conversion-arr (α) #@(documentation: \"Turn α into a its **hexadecimal** string representation\" name: int->string/HEX) #{##(\"\" ret α #f \"0\" :type-error \"Can't print negative numbers in hex for now\" current-lambda cat int->string/hex/conversion-arr not=)\n"
"1A0007010D0E020B00071C0900041B0C0A000E0D0E022A0C0A00060D1A030B00\n"
"091A0401090004240D0E0202001E0B00131A051A060E020E0704002E042F0900\n"
"04240D2409001C0D0E080E090E02020F332B0E01040205010D0E020204320502\n"
"0E0A02000E0204020AFFDF0D0E0101\n"
"} int->string/HEX (α) #@(documentation: \"Turn α into a its **hexadecimal** string representation\" name: int->string/hex) #{##(lower-case int->string/HEX α)\n"
"0E000E010E020401040101\n"
"} int->string/hex (α) #@(documentation: \"Turn α into a its **decimal** string representation\" name: int->string/decimal) #{##(:string α)\n"
"1A000E01040101\n"
"} int->string/decimal int->string (v port hr?) #@(name: write/raw/array) #{##(port block-write \"##(\" i write/raw v hr? :length \" \" \")\")\n"
"0E001A011A0204020D020007030D240900330D0E040E050E032B0E000E060403\n"
"0D0E031A070E0504010201261E0B000E0E001A011A080402090004240D0E0323\n"
"05030E031A070E0504011E0AFFC70D240D0E001A011A09040201\n"
"} write/raw/array (v port hr?) #@(name: write/raw/buffer) #{##(hr? port write \"#<buffer :id \" int->string/decimal val->id v \" :size \" int->string/hex :length \">\" block-write \"#m\" :u8 view i pad-start int->string/HEX \"0\")\n"
"0E000B00260E011A021A030E040E050E06040104011A070E081A090E06040104\n"
"011A0A040609004A0E011A0B1A0C04020D1A0D0E060401070E0D0200070F0D24\n"
"0900210D0E011A0B0E100E110E0E0E0F2B040102021A12040304020D0E0F2305\n"
"0F0E0F1A090E0604011E0AFFD90D2401\n"
"} write/raw/buffer (v port hr?) #@(name: write/raw/bytecode-array) #{##(port block-write \"#{\" write/raw/array :literals v i \"\\n\" pad-start int->string/HEX \"0\" :length \"\\n}\")\n"
"0E001A011A0204020D0E031A040E0504010E001C04030D020007060D24090037\n"
"0D0E06021F332A0B000E0E001A011A070402090004240D0E001A010E080E090E\n"
"050E062B040102021A0A040304020D0E062305060E061A0B0E0504011E0AFFC3\n"
"0D240D0E001A011A0C040201\n"
"} write/raw/bytecode-array (v port hr? always-space?) #@(name: write/raw/tree/rec) #{##(v :key* #f always-space? write/raw/tree/rec :left* port hr? block-write \" \" :string \": \" write/raw :value* :right*)\n"
"0E000B00071C0900041B0C0A00190D1A010E0004010B00071C0900041B0C0A00\n"
"060D1A020B00090E0301090004240D0E041A050E0004010E060E070E0304040B\n"
"000E0E061A081A090402090004240D0E061A081A0A1A010E000401040104020D\n"
"0E061A081A0B04020D0E0C1A0D0E0004010E060E0704030D0E041A0E0E000401\n"
"0E060E071B040401\n"
"} write/raw/tree/rec (v port hr?) #@(name: write/raw/tree) #{##(port block-write \"#@(\" write/raw/tree/rec v hr? \")\")\n"
"0E001A011A0204020D0E030E040E000E051C04040D0E001A011A06040201\n"
"} write/raw/tree (v port hr?) #@(name: write/raw/pair) #{##(quote v nil? :pair :type-name port block-write \"'\" write/raw hr? \"(\" first? \" \" \". \" \")\")\n"
"1A000E0111200C0B001B0D0E020E01121204010C0B000E0D1A031A040E011204\n"
"01200B001B0E051A061A0704020D0E080E012C0E050E09040301090004240D0E\n"
"051A061A0A04020D1C070B0D2409004B0D0E0B0B000E0E051A061A0C04020900\n"
"061B050B0D1A031A040E010401200B00110E080E01110E050E0904030900160E\n"
"051A061A0D04020D0E080E010E050E0904030D0E011205010E010AFFB60D0E05\n"
"1A061A0E040201\n"
"} write/raw/pair (v port hr?) #@(name: write/raw/string) #{##(hr? port block-write v \"\\\"\" i c ΓεnΣym-54 \"\\\\a\" \"\\\\b\" \"\\\\t\" \"\\\\n\" \"\\\\v\" \"\\\\f\" \"\\\\r\" \"\\\\e\" \"\\\\\\\"\" \"\\\\\\\\\" char-write :length)\n"
"0E000B000F0E011A020E03040201090004240D0E011A021A0404020D02000705\n"
"0D240900F30D0E030E052B07060D150E0607070D0E070200200B000F0E011A02\n"
"1A040402010900C90E070207200B000E0E011A021A0804020900B60E07020820\n"
"0B000E0E011A021A0904020900A30E070209200B000E0E011A021A0A04020900\n"
"900E07020A200B000E0E011A021A0B040209007D0E07020B200B000E0E011A02\n"
"1A0C040209006A0E07020C200B000E0E011A021A0D04020900570E07020D200B\n"
"000E0E011A021A0E04020900440E07021B200B000E0E011A021A0F0402090031\n"
"0E070222200B000E0E011A021A10040209001E0E07025C200B000E0E011A021A\n"
"11040209000B0E011A120E060402160D0E052305050E051A130E0304011E0AFF\n"
"070D240D0E011A021A04040201\n"
"} write/raw/string (v port hr?) #@(name: write/raw) #{##(:type-name v ΓεnΣym-81 :nil hr? port block-write \"#nil\" :bool \"#t\" \"#f\" :environment write \"#<environment \" int->string/hex val->id \">\" :file-handle \"#<file-handle \" :buffer-view \"#<buffer-view \" :lambda :macro :native-function #f :string closure/name anonymous :int int->string/decimal :float :keyword \":\" :symbol :array write/raw/array :buffer write/raw/buffer :bytecode-array write/raw/bytecode-array write/raw/string :tree write/raw/tree :pair write/raw/pair :type capitalize :name \"#<unprintable>\")\n"
"151A000E01040107020D0E021A03200B00170E040B00072409000B0E051A061A\n"
"0704020901C40E021A08200B00180E051A060E010B00081A090900051A0A0402\n"
"0901A70E021A0B200B001A0E051A0C1A0D0E0E0E0F0E01040104011A10040409\n"
"01880E021A11200B001A0E051A0C1A120E0E0E0F0E01040104011A1004040901\n"
"690E021A13200B001A0E051A0C1A140E0E0E0F0E01040104011A10040409014A\n"
"0E021A15200C0A001A0D0E021A16200C0A00100D0E021A17200C0A00060D1A18\n"
"0B00240E051A061A190E1A0E0104010C0A000D0D1A1B0C0A00060D1A18040104\n"
"020901060E021A1C200B00120E051A060E1D0E01040104020900EF0E021A1E20\n"
"0B00120E051A061A190E01040104020900D80E021A1F200B00140E051A0C1A20\n"
"1A190E01040104030900BF0E021A21200B00120E051A061A190E010401040209\n"
"00A80E021A22200B00100E230E010E050E0404030900930E021A24200B00100E\n"
"250E010E050E04040309007E0E021A26200B00100E270E010E050E0404030900\n"
"690E021A19200B00100E280E010E050E0404030900540E021A29200B00100E2A\n"
"0E010E050E04040309003F0E021A2B200B00100E2C0E010E050E04040309002A\n"
"0E021A2D200B001A0E051A0C0E2E1A191A2F0E01040104010401040209000B0E\n"
"051A061A3004021601\n"
"} write/raw (v port) #@(name: write) #{##(write/raw v port stdout #f)\n"
"0E000E010E020C0A000D0D0E030C0A00060D1A041C04030D2401\n"
"} write (v port) #@(name: display) #{##(write/raw v port stdout #f)\n"
"0E000E010E020C0A000D0D0E030C0A00060D1A041B04030D2401\n"
"} display (v) #@(name: string/write) #{##(make-string-output-port p write/raw v :return-string)\n"
"0E00040007010D0E020E030E011C04030D0E011A04040101\n"
"} string/write (v) #@(name: string/display) #{##(make-string-output-port p write/raw v :return-string)\n"
"0E00040007010D0E020E030E011B04030D0E011A04040101\n"
"} string/display)\n"
"1A001A011A021707030D1A041A051A061707070D1A0807090D1A0A1A0B1A0C17\n"
"070D0D1A0E1A0F1A101707110D1A121A131A141707150D0E1507160D151A171A\n"
"181A1917071A0D1A1B1A1C1A1D17071E0D1A1F1A201A211707220D1A231A241A\n"
"251707260D1A271A281A2917072A0D1A2B1A2C1A2D17072E0D1A2F1A301A3117\n"
"07320D1A331A341A351707361607360D1A371A381A3917073A0D1A3B1A3C1A3D\n"
"17073E0D1A3F1A401A411707420D1A431A441A4517074601\n"
"}#{##((text pad-length padding) #@(documentation: \"Pad a string to a certain length by prepending another string.\\n\\nThis function will, if necessary, prepend padding on to the beginning of\\ntext repeatedly until the desired pad-length is reached.\\n\\nBecause of this the string in padding can be truncated if the amount of\\ncharacters that need to be added can't be evenly divided through the length of padding.\\n\\nThis means that you have to be careful not to use unicode characters as a padding, or make sure that it can be used without truncation.\\n\\ntext: The input string\\npad-length: The minimum length of the result\\npadding: A string that will be used to pad text, defaults to a single space\\n\\nReturns the padded string\" name: pad-start cat: :string-manipulation tests: ((\"-.-123\" (pad-start '123 6 \".-\")) (\"000123\" (pad-start 123 6 \"0\")) (\"   123\" (pad-start \"123\" 6))) related: (trim pad-end pad-middle)) #{##(padding \" \" :string :type-name text :type-error \"pad-start needs char as a string, so that one can pad with multiple characters\" current-lambda cat :length pad-length :cut)\n"
"0E000B0007240900071A0105000D1A021A030E040401200B00072409000B1A02\n"
"0E04040105040D1A021A030E000401200B0007240900101A051A060E000E0704\n"
"002E042F0D2409000E0D0E080E000E04040205041A090E0404010E0A1E0AFFEC\n"
"0D1A090E0404010E0A220B001B1A0B0E041A090E0404010E0A261A090E040401\n"
"04030900050E0401\n"
"} pad-start (text pad-length padding) #@(documentation: \"Pad a string to a certain length by appending another string.\\n\\nThis function will, if necessary, append padding on to the end of\\ntext repeatedly until the desired pad-length is reached.\\n\\nBecause of this the string in padding can be truncated if the amount of\\ncharacters that need to be added can't be evenly divided through the length of padding.\\n\\nThis means that you have to be careful not to use unicode characters as a padding, or make sure that it can be used without truncation.\\n\\ntext: The input string\\npad-length: The minimum length of the result\\npadding: A string that will be used to pad text, defaults to a single space\\n\\nReturns the padded string\" name: pad-end cat: :string-manipulation tests: ((\"123.-.\" (pad-end '123 6 \".-\")) (\"123000\" (pad-end 123 6 \"0\")) (\"123   \" (pad-end \"123\" 6))) related: (trim pad-start pad-middle)) #{##(padding \" \" :string :type-name text :type-error \"pad-end needs char as a string, so that one can pad with multiple characters\" current-lambda cat :length pad-length :cut)\n"
"0E000B0007240900071A0105000D1A021A030E040401200B00072409000B1A02\n"
"0E04040105040D1A021A030E000401200B0007240900101A051A060E000E0704\n"
"002E042F0D2409000E0D0E080E040E00040205041A090E0404010E0A1E0AFFEC\n"
"0D1A090E0404010E0A220B00101A0B0E0402000E0A04030900050E0401\n"
"} pad-end (text pad-length padding) #@(documentation: \"Pad a string to a certain length by surrounding it with another string.\\n\\nThis function will, if necessary, append and prepend padding to the\\nbeginning and end of text repeatedly until the desired pad-length is reached.\\n\\nBecause of this the string in padding can be truncated if the amount of\\ncharacters that need to be added can't be evenly divided through the length of padding.\\n\\nThis means that you have to be careful not to use unicode characters as a padding, or make sure that it can be used without truncation.\\n\\ntext: The input string\\npad-length: The minimum length of the result\\npadding: A string that will be used to pad text, defaults to a single space\\n\\nReturns the padded string\" name: pad-middle cat: :string-manipulation tests: ((\"-123.-\" (pad-middle '123 6 \".-\")) (\"012300\" (pad-middle 123 6 \"0\")) (\" 123  \" (pad-middle \"123\" 6))) related: (trim pad-end pad-start)) #{##(padding \" \" :string :type-name text :type-error \"string/pad-middle needs char as a string, so that one can pad with multiple characters\" current-lambda cat :length pad-length div/int end-overflow start-overflow :cut)\n"
"0E000B0007240900071A0105000D1A021A030E040401200B00072409000B1A02\n"
"0E04040105040D1A021A030E000401200B0007240900101A051A060E000E0704\n"
"002E042F0D240900100D0E080E000E040E00040305041A090E0404010E0A1E0A\n"
"FFEA0D1A090E0404010E0A220B0036150E0B1A090E0404010E0A260202040207\n"
"0C0D1A090E0404010E0A260E0C26070D0D1A0E0E040E0D0E0D0E0A2504031609\n"
"00050E0401\n"
"} pad-middle (text) #@(documentation: \"Remove all whitespace from the start and end of text\\n\\nWhitespace is determined by the whitespace? predicate.\\n\\ntext: The input string\\n\\nReturns a trimmed version of text\" name: trim cat: :string-manipulation tests: ((\"Trim Test\" (trim \"   Trim Test    \\n\")) (\"Test\" (trim \"   Test\\t\\n\")) (\"\" (trim \"\")) (\"Test\" (trim \"Test\")) (\"Test\" (trim \"Test \")) (\"Test\" (trim \" Test\"))) related: (trim pad-end pad-middle pad-start)) #{##(start :length text end whitespace? :cut)\n"
"020007000D1A010E02040107030D2409000B0D0E0002012505000E000E031E0C\n"
"0B000D0D0E040E020E002B04010AFFE50D2409000B0D0E0302012605030E0302\n"
"00220C0B00100D0E040E020E030201262B04010AFFE20D1A050E020E000E0304\n"
"0301\n"
"} trim (text) #@(documentation: \"Convert text into a version using only capitals or uppercase letters.\\n\\ntext: The input string\\n\\nReturns the resulting upper-case version\" name: upper-case cat: :string-manipulation tests: ((\"TESTING THE CAPITALIZATION!\" (upper-case \"Testing THE Capitalization!\"))) related: (capitalize lower-case)) #{##(buffer/allocate :length text ret i upper-case-char buffer->string)\n"
"0E001A010E020401040107030D020007040D240900180D0E030E040E050E020E\n"
"042B0401370D0E042305040E041A010E0204011E0AFFE20D0E060E03040101\n"
"} upper-case (text) #@(documentation: \"Convert text into a version using only lowercase letters.\\n\\ntext: The input string\\n\\nReturns the resulting lower-case version\" name: lower-case cat: :string-manipulation tests: ((\"testing the capitalization!\" (lower-case \"Testing THE Capitalization!\"))) related: (capitalize upper-case)) #{##(buffer/allocate :length text ret i lower-case-char buffer->string)\n"
"0E001A010E020401040107030D020007040D240900180D0E030E040E050E020E\n"
"042B0401370D0E042305040E041A010E0204011E0AFFE20D0E060E03040101\n"
"} lower-case (text) #@(documentation: \"Convert text into a capitalized version.\\n\\nThis is simplified by having the first character be an upper-case version, as well\\nas any character following a whitespace character, and all other characters be in lower-case.\\n\\ntext: The input string\\n\\nReturns the capitalized version\" name: capitalize cat: :string-manipulation tests: ((\"Testing The Capitalization!\" (capitalize \"Testing THE Capitalization!\"))) related: (lower-case upper-case)) #{##(buffer/allocate :length text ret caps? i upper-case-char lower-case-char whitespace? buffer->string)\n"
"0E001A010E020401040107030D1B07040D020007050D240900360D0E030E050E\n"
"040B00080E060900050E070E020E052B0401370D0E080E020E052B04010B0007\n"
"1B0900041C05040D0E052305050E051A010E0204011E0AFFC40D0E090E030401\n"
"01\n"
"} capitalize (text decimal-digits) #@(documentation: \"Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period\" name: string/round) #{##(:last-index-of text \".\" pos :cut decimal-digits)\n"
"1A000E011A02040207030D0E030200210B00161A040E0102000E030201250E05\n"
"2504030900050E0101\n"
"} string/round (str separator) #@(name: split/empty) #{##(:length str slen start ret :cut reverse)\n"
"1A000E01040107020D020007030D2407040D2409001E0D1A050E010E0302010E\n"
"032504030E041405040D0E0302012505030E030E021E0AFFE00D0E060E040401\n"
"01\n"
"} split/empty (str separator start) #@(name: split/string) #{##(start :index-of str separator pos-found :cut split/string :length)\n"
"0E000B000724090007020005000D1A010E020E030E00040307040D0E04020021\n"
"0B00221A050E020E000E0404030E060E020E030E041A070E0304012504031409\n"
"00131A050E020E001A070E0204010403241401\n"
"} split/string (str separator) #@(documentation: \"Splits STR into a list at every occurunse of SEPARATOR\" name: split) #{##(:type-name str :string :type-error \"Expected a value of type :string\" current-lambda separator :length ΓεnΣym-55 split/empty split/string)\n"
"1A000E0104011A02200B0007240900101A031A040E010E0504002E042F0D1A00\n"
"0E0604011A02200B0007240900101A031A040E060E0504002E042F0D151A070E\n"
"06040107080D0E080200200B000C0E090E01040109000D0E0A0E010E06020004\n"
"031601\n"
"} split (text) #@(documentation: \"Uses the reader and returns the first single value read from string TEXT\" name: read/single) #{##(:type-name text :string :type-error \"Expected a value of type :string\" current-lambda read)\n"
"1A000E0104011A02200B0007240900101A031A040E010E0504002E042F0D0E06\n"
"0E0104011101\n"
"} read/single (text) #@(documentation: \"Reads the first string from TEXT\" name: read/int) #{##(int read/single text)\n"
"0E000E010E020401040101\n"
"} read/int (text) #@(documentation: \"Reads the first float from TEXT\" name: read/float) #{##(float read/single text)\n"
"0E000E010E020401040101\n"
"} read/float (str) #@(documentation: \"Print STR on a single line\" name: println) #{##(print cat str \"\\r\\n\")\n"
"0E000E010E021A030402040101\n"
"} println (str) #@(documentation: \"Print to stderr STR on a single line\" name: errorln) #{##(error cat str \"\\r\\n\")\n"
"0E000E010E021A030402040101\n"
"} errorln)\n"
"1A001A011A021707030D1A041A051A061707070D1A081A091A0A17070B0D1A0C\n"
"1A0D1A0E17070F0D1A101A111A121707130D1A141A151A161707170D1A181A19\n"
"1A1A17071B0D1A1C1A1D1A1E17071F0D151A201A211A221707230D1A241A251A\n"
"261707270D1A281A291A2A17072B16072B0D1A2C1A2D1A2E17072F0D1A301A31\n"
"1A321707330D1A341A351A361707370D1A381A391A3A17073B0D1A3C1A3D1A3E\n"
"17073F01\n"
"}#{##(module/insert/defer :ansi string/write (do (def *module* :ansi) (def disabled #f) (defn disable! (v) :export (set! disabled (if (nil? v) #t v))) (export reset (def reset \"\\e[0m\")) (export fg-reset (def fg-reset \"\\e[0;39m\")) (export bg-reset (def bg-reset \"\\e[49m\")) (export ansi-fg (def ansi-fg (array/new \"\\e[0;30m\" \"\\e[0;31m\" \"\\e[0;32m\" \"\\e[0;33m\" \"\\e[0;34m\" \"\\e[0;35m\" \"\\e[0;36m\" \"\\e[0;37m\" \"\\e[1;30m\" \"\\e[1;31m\" \"\\e[1;32m\" \"\\e[1;33m\" \"\\e[1;34m\" \"\\e[1;35m\" \"\\e[1;36m\" \"\\e[1;37m\"))) (export ansi-bg (def ansi-bg (array/new \"\\e[40m\" \"\\e[41m\" \"\\e[42m\" \"\\e[43m\" \"\\e[44m\" \"\\e[45m\" \"\\e[46m\" \"\\e[47m\"))) (defn wrap (code string) \"Wrap STRING in the ansi color CODE\" :export (cat (or disabled (ref ansi-fg code)) string (or disabled reset))) (defn black args :export (wrap 0 (join args))) (defn dark-red args :export (wrap 1 (join args))) (defn dark-green args :export (wrap 2 (join args))) (defn brown args :export (wrap 3 (join args))) (defn dark-blue args :export (wrap 4 (join args))) (defn purple args :export (wrap 5 (join args))) (defn teal args :export (wrap 6 (join args))) (defn dark-gray args :export (wrap 7 (join args))) (defn gray args :export (wrap 8 (join args))) (defn red args :export (wrap 9 (join args))) (defn green args :export (wrap 10 (join args))) (defn yellow args :export (wrap 11 (join args))) (defn blue args :export (wrap 12 (join args))) (defn pink args :export (wrap 13 (join args))) (defn cyan args :export (wrap 14 (join args))) (defn white args :export (wrap 15 (join args))) (defn rainbow args \"Wrap ARGS in the colors of the rainbow!\" :export (let* (def count 0) (cat (join (map (split (join args) \"\") (fn (a) (set! count (bit-and (+ 1 count) 7)) (cat (or disabled (ref ansi-fg (if (zero? count) 7 (+ count 8)))) a))) \"\") (or disabled fg-reset)))) (defn rainbow-bg args \"Wrap ARGS in the colors of the rainbow!\" :export (def count 0) (def colored-list (map (split (join args) \"\") (fn (a) (set! count (bit-and (+ 1 count) 7)) (cat (or disabled (ref ansi-fg (bit-xor count 7))) (or disabled (ref ansi-bg count)) a)))) (cat (join colored-list \"\") (or disabled reset))) (defn reprint-line (text width) :export (when-not width (set! width 20)) (print \"\\r\") (dotimes (i width) (print \" \")) (print \"\\r\") (print text)) (deftest \"\\e[0;33mabc\\e[0m\" (ansi/wrap 3 \"abc\")) (deftest \"\\e[0;30m123\\e[0m\" (ansi/black \"123\")) (deftest \"\\e[0;31m123\\e[0m\" (ansi/dark-red \"123\")) (deftest \"\\e[0;32m123\\e[0m\" (ansi/dark-green \"123\")) (deftest \"\\e[0;33m123\\e[0m\" (ansi/brown \"123\")) (deftest \"\\e[0;34m123\\e[0m\" (ansi/dark-blue \"123\")) (deftest \"\\e[0;35m123\\e[0m\" (ansi/purple \"123\")) (deftest \"\\e[0;36m123\\e[0m\" (ansi/teal \"123\")) (deftest \"\\e[0;37m123\\e[0m\" (ansi/dark-gray \"123\")) (deftest \"\\e[1;30m123\\e[0m\" (ansi/gray \"123\")) (deftest \"\\e[1;31m123\\e[0m\" (ansi/red \"123\")) (deftest \"\\e[1;32m123\\e[0m\" (ansi/green \"123\")) (deftest \"\\e[1;33m123\\e[0m\" (ansi/yellow \"123\")) (deftest \"\\e[1;34m123\\e[0m\" (ansi/blue \"123\")) (deftest \"\\e[1;35m123\\e[0m\" (ansi/pink \"123\")) (deftest \"\\e[1;36m123\\e[0m\" (ansi/cyan \"123\")) (deftest \"\\e[1;37m123\\e[0m\" (ansi/white \"123\")) (deftest \"\\e[1;31mt\\e[1;32me\\e[1;33ms\\e[1;34mt\\e[1;35me\\e[1;36mr\\e[1;37ml\\e[0;37me\\e[0;39m\" (ansi/rainbow \"testerle\")) (deftest \"\\e[0;36m\\e[41mt\\e[0;35m\\e[42me\\e[0;34m\\e[43ms\\e[0;33m\\e[44mt\\e[0;32m\\e[45me\\e[0;31m\\e[46mr\\e[0;30m\\e[47ml\\e[0;37m\\e[40me\\e[0m\" (ansi/rainbow-bg \"testerle\"))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :app/gopher string/write (do (def *module* :app/gopher) (import (Term) :core/term) (import (get) :net/gopher) (def screen-width 0) (def screen-height 0) (def frame-height 0) (def scroll-interval 8) (def last-char 0) (def cur-page (tree/new :url \"gopher://sdf.org\" :type :1 :scrolly 0 :data #nil :item #nil)) (def history #nil) (def term (:new Term)) (def gopher-type-map (tree/new :0 \"(TXT)\" :1 \"(DIR)\" :2 \"(NAM)\" :3 \"(ERR)\" :4 \"(BHX)\" :5 \"(DOS)\" :6 \"(UUE)\" :7 \"(FTS)\" :8 \"(TEL)\" :9 \"(BIN)\" :g \"(GIF)\" :I \"(IMG)\" :T \"(IBM)\" :< \"(SND)\" :d \"(DOC)\" :h \"(HTM)\" :p \"(PNG)\" :r \"(RTF)\" :s \"(WAV)\" :P \"(PDF)\" :X \"(XML)\" :i \"     \")) (defn gopher-type-name (data) (or (ref gopher-type-map (or (ref data :type) :un)) \" (?) \")) (defn get-modeline (page) (def y (get-item-pos page)) (def scroll (ref page :scrolly)) (def url (ref page :url)) (fmt \"{url}{}\" (if (> y 0) (fmt \" - L{y}\") \"\"))) (defn draw-modeline (page) (:move-cursor term 1 (dec screen-height)) (:set-color term :yellow :blue) (def colored-modeline (cat \" \" (pad-end (get-modeline page) (dec screen-width)))) (:put-string term colored-modeline) (:set-color term :default :default)) (defn draw-map (data page) (def scroll-y (ref page :scrolly)) (def y 0) (doseq (e data) (def cy (- y scroll-y)) (when (> cy frame-height) (return)) (when (>= cy 0) (:move-cursor term 2 (inc cy)) (:put-string term (gopher-type-name e)) (when (and (not (ref cur-page :item)) (= :1 (ref e :type))) (set! cur-page :item e)) (:move-cursor term 8 (inc cy)) (when (not= :i (ref e :type)) (:set-color term :blue :default)) (when (= e (ref cur-page :item)) (:set-color term :yellow :blue)) (:put-string term (ref e :display)) (:set-color term :default :default)) (inc! y))) (defn draw-text (data page) (:set-color term :default :default) (def scroll-y (ref page :scrolly)) (def y 0) (doseq (e data) (def cy (- y scroll-y)) (when (> cy frame-height) (return)) (when (>= cy 0) (:move-cursor term 2 (inc cy)) (:put-string term e)) (inc! y))) (defn draw-page (page) (when (nil? (ref page :data)) (return)) (if (= (ref page :type) :1) (draw-map (ref page :data) page) (draw-text (ref page :data) page))) (defn draw-screen (#nil) (:hide-cursor term) (:clear-screen term) (draw-page cur-page) (draw-modeline cur-page) (:show-cursor term) (:flip term)) (defn quit (#nil) (:stop term) (exit 0)) (defn previous-line (#nil) (def last-entry (ref cur-page :item)) (doseq (e (ref cur-page :data)) (when (= e (ref cur-page :item)) (set! cur-page :item last-entry) (center-buffer cur-page) (return)) (when (and (tree? e) (not= :i (ref e :type))) (set! last-entry e)))) (defn next-line (#nil) (def take-entry #f) (doseq (e (ref cur-page :data)) (when (and take-entry (not= :i (ref e :type))) (set! cur-page :item e) (center-buffer cur-page) (return)) (when (= e (ref cur-page :item)) (set! take-entry #t)))) (defn history-back (#nil) (when-not history (return)) (set! cur-page (car history)) (cdr! history)) (defn follow-link (#nil) (when (tree? (ref cur-page :item)) (set! history (cons cur-page history)) (def port (ref (ref cur-page :item) :port)) (set! port (if (or (= 70 port) (= \"70\" port)) \"\" (fmt \":{port}\"))) (def cur-url (fmt \"gopher://{}{}{}\" (ref (ref cur-page :item) :host) port (ref (ref cur-page :item) :path))) (def cur-type (ref (ref cur-page :item) :type)) (set! cur-page (tree/new :url cur-url :type cur-type :port port :scrolly 0 :data #nil :item #nil)))) (defn normalize-scroll (#nil) (set! cur-page :scrolly (max 0 (min (- (:length (ref cur-page :data)) frame-height) (ref cur-page :scrolly))))) (defn page-up (#nil) (set! cur-page :scrolly (- (ref cur-page :scrolly) scroll-interval)) (normalize-scroll)) (defn page-down (#nil) (set! cur-page :scrolly (+ (ref cur-page :scrolly) scroll-interval)) (normalize-scroll)) (defn read-bracketed-input (#nil) (def c (:poll-input term)) (case c (65 (previous-line)) (66 (next-line)) (67 (follow-link)) (68 (history-back)) (53 (:poll-input) term (page-up)) (54 (:poll-input) term (page-down)))) (defn read-escaped-input (#nil) (def c (:poll-input term)) (case c (91 (read-bracketed-input)))) (defn read-cx-input (#nil) (def c (:poll-input term)) (case c (3 (quit)))) (defn read-input (#nil) (def c (:poll-input term)) (set! last-char c) (case c (27 (read-escaped-input)) (16 (previous-line)) (14 (next-line)) (24 (read-cx-input)))) (defn get-data (page) (when-not (ref page :data) (set! page :data (get (ref page :url) (ref page :type))) (when (= (ref page :type) :1) (doseq (e (ref page :data)) (when (not= :i (ref e :type)) (return (set! page :item e))))) (when (= (ref page :type) :0) (set! page :data (split (ref page :data) \"\\n\"))))) (defn get-item-pos (page) (def y 0) (doseq (e (ref page :data)) (when (= e (ref page :item)) (return y)) (set! y (inc y))) (return -1)) (defn center-buffer (page) (def item-pos (get-item-pos page)) (when (< item-pos 0) (return)) (while (> (ref page :scrolly) item-pos) (set! page :scrolly (- (ref page :scrolly) scroll-interval))) (def item-bottom-pos (- item-pos frame-height)) (while (< (ref page :scrolly) item-bottom-pos) (set! page :scrolly (+ (ref page :scrolly) scroll-interval))) (normalize-scroll)) (defn main (args) :export (:start term) (:clear-screen term) (def s (:get-size term)) (set! screen-width (ref s :width)) (set! screen-height (ref s :height)) (set! frame-height (- screen-height 3)) (set! scroll-interval (int (/ frame-height 2))) (when (car args) (set! cur-page :data (car args))) (draw-screen) (while #t (get-data cur-page) (draw-screen) (read-input)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :app/termed/buffer string/write (do (def *module* :app/termed/buffer) (def cur-buffer #nil) (defn set-cur-buffer! (buf) :export (set! cur-buffer buf)) (defn get-cur-buffer (#nil) :export cur-buffer) (defn new-buffer (filename) :export (def lines (array/new (buffer/allocate 16))) (def buf (tree/new :lines lines :lines-clean (array/new #nil) :filename filename :changed #f :pos-x 0 :pos-y 0 :scroll-x 0 :scroll-y 0)) (return buf)) (defn get-line (buf line-y) :export (def lines (ref buf :lines)) (if (or (< line-y 0) (>= line-y (:length lines))) #nil (ref lines line-y))) (defn line-length (pos-y) :export (def buf cur-buffer) (def line (get-line buf pos-y)) (when-not line (return 0)) (dotimes (i (:length line) (:length line)) (when (zero? (ref line i)) (return i)))) (defn backward-delete-line (#nil) :export (def buf cur-buffer) (def lines (ref buf :lines)) (def ll (- (:length lines) 1)) (def pos-y (ref buf :pos-y)) (when (zero? pos-y) (return)) (while (< pos-y ll) (set! lines pos-y (inc pos-y)) (inc! pos-y)) (:length! lines (max 0 ll)) (set! buf :pos-y (- (ref buf :pos-y) 1)) (line-clean! buf (ref buf :pos-y) #f) (set! buf :pos-x (inc (line-length (ref buf :pos-y))))) (defn backward-char (#nil) :export (def buf cur-buffer) (def pos-x (ref buf :pos-x)) (when (< pos-x 1) (def pos-y (ref buf :pos-y)) (when (< pos-y 1) (return)) (set! buf :pos-y (dec pos-y)) (line-clean! buf (ref buf :pos-y) #f) (set! buf :pos-x (line-length (dec pos-y))) (return)) (set! buf :pos-x (dec pos-x))) (defn previous-line (#nil) :export (def buf cur-buffer) (def pos-x (ref buf :pos-x)) (def pos-y (ref buf :pos-y)) (when (< pos-y 1) (return)) (set! buf :pos-y (dec pos-y)) (line-clean! buf (ref buf :pos-y) #f) (set! buf :pos-x (min pos-x (line-length (dec pos-y))))) (defn next-line (#nil) :export (def buf cur-buffer) (def pos-x (ref buf :pos-x)) (def pos-y (ref buf :pos-y)) (def lines (ref buf :lines)) (def ll (- (:length lines) 1)) (when (>= pos-y ll) (return)) (set! buf :pos-y (inc pos-y)) (line-clean! buf (ref buf :pos-y) #f) (set! buf :pos-x (min pos-x (line-length (inc pos-y))))) (defn forward-char (#nil) :export (def buf cur-buffer) (def pos-x (ref buf :pos-x)) (def pos-y (ref buf :pos-y)) (def ll (line-length pos-y)) (when (>= pos-x ll) (when (>= (inc pos-y) (:length (ref buf :lines))) (return)) (set! buf :pos-x 0) (set! buf :pos-y (inc pos-y)) (line-clean! buf (ref buf :pos-y) #f) (return)) (set! buf :pos-x (inc pos-x))) (defn delete-forward-char (#nil) :export (def buf cur-buffer) (def line (get-line buf (ref buf :pos-y))) (when-not line (return)) (def pos-x (ref buf :pos-x)) (def bl (- (:length line) 2)) (while (<= pos-x bl) (set! line pos-x (ref line (inc pos-x))) (inc! pos-x)) (set! line (- (:length line) 1) 0)) (defn backward-delete-char (#nil) :export (def buf cur-buffer) (def line (get-line buf (ref buf :pos-y))) (when-not line (return)) (def pos-x (ref buf :pos-x)) (when (< pos-x 1) (backward-delete-line) (return)) (def bl (- (:length line) 1)) (while (<= pos-x bl) (set! line (- pos-x 1) (ref line pos-x)) (inc! pos-x)) (set! line bl 0) (set! buf :pos-x (- (ref buf :pos-x) 1))) (defn insert-char (c) :export (def buf cur-buffer) (def line (get-line buf (ref buf :pos-y))) (when-not line (return)) (def pos-x (ref buf :pos-x)) (def i (- (:length line) 1)) (when-not (zero? (ref line i)) (:length! line (+ (:length line) 16)) (def i (- (:length line) 1))) (while (> i pos-x) (set! line i (ref line (dec i))) (dec! i)) (set! line pos-x c) (set! buf :pos-x (inc pos-x))) (defn insert-newline (#nil) :export (def buf cur-buffer) (def lines (ref buf :lines)) (def lines-clean (ref buf :lines-clean)) (:length! lines (inc (:length lines))) (:length! lines-clean (:length lines)) (set! lines (- (:length lines) 1) (buffer/allocate 16)) (set! buf :pos-x 0) (set! buf :pos-y (inc (ref buf :pos-y))) (line-clean! buf (ref buf :pos-y) #f)) (defn get-buf-name (buf) :export (def filename (ref buf :filename)) (def saved (if (ref buf :changed) \"*\" \"\")) (fmt \"{filename}{saved}\")) (defn line-clean? (buf line) :export (def lines-clean (ref buf :lines-clean)) (when (>= line (:length lines-clean)) (return #f)) (or (ref lines-clean line) #f)) (defn line-clean! (buf line clean) :export (def lines-clean (ref buf :lines-clean)) (when (>= line (:length lines-clean)) (:length! lines-clean (inc line))) (set! lines-clean line clean))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :app/termed string/write (do (def *module* :app/termed) (import (Term) :core/term) (import (new-buffer :as new-buffer* get-line line-length forward-char backward-char backward-delete-line backward-delete-char insert-char insert-newline get-buf-name set-cur-buffer! get-cur-buffer previous-line next-line line-clean! line-clean? delete-forward-char) :app/termed/buffer) (def term (:new Term)) (def buffers (array/new #nil)) (def screen-width #nil) (def screen-height #nil) (def last-char 0) (def scroll-interval 10) (defn new-buffer (filename) (def buf (new-buffer* filename)) (array/push buffers buf) buf) (defn draw-gutter (#nil) (:draw-box term :red 1 2 4 (- screen-height 2))) (defn get-modeline (buf) (def x (ref buf :pos-x)) (def y (inc (ref buf :pos-y))) (def bufname (get-buf-name buf)) (def saved (if (ref buf :changed) \"*\" \"\")) (fmt \" L{y} - {bufname} - KeyCode: {last-char:X}\")) (defn draw-modeline (buf) (:move-cursor term 1 (dec screen-height)) (:set-color term :yellow :blue) (def colored-modeline (cat \" \" (pad-end (get-modeline buf) (dec screen-width)))) (:put-string term colored-modeline) (:set-color term :default :default)) (defn draw-buffer-line (buf term-x term-y term-w line-y) (def line (get-line buf line-y)) (when-not line (return)) (:move-cursor term term-x term-y) (:clear-line term) (when (= line-y (ref buf :pos-y)) (:set-color term :yellow :blue)) (def ln (fmt \" {:4} \" (inc line-y))) (:put-string term ln) (:set-color term :default) (:move-cursor term (+ 1 (:length ln) term-x) term-y) (def max-w (- term-w 7)) (when (>= (:length line) max-w) (set! line (:clone (:cut (buffer->string line) 0 max-w)))) (:put-string term line) (line-clean! buf line-y #t)) (defn draw-buffer (buf x y w h) (dotimes (cy h) (def line-y (+ cy (ref buf :scroll-y))) (when-not (line-clean? buf line-y) (draw-buffer-line buf x (+ cy y) w line-y))) (draw-modeline buf)) (defn draw-screen (#nil) (def cur-buffer (get-cur-buffer)) (:hide-cursor term) (draw-buffer cur-buffer 1 1 screen-width (- screen-height 2)) (:show-cursor term) (:move-cursor term (+ 1 1 6 (ref cur-buffer :pos-x)) (- (inc (ref cur-buffer :pos-y)) (ref cur-buffer :scroll-y))) (:flip term)) (defn quit (#nil) (:stop term) (exit 0)) (defn beginning-of-line (#nil) (set! (get-cur-buffer) :pos-x 0)) (defn end-of-line (#nil) (def buf (get-cur-buffer)) (set! buf :pos-x (line-length (ref buf :pos-y)))) (defn clear-frame (#nil) (dotimes (y (- screen-height 1)) (:move-cursor term 0 y) (:clear-line term))) (defn scroll-into-view (#nil) (def buf (get-cur-buffer)) (def frame-height (- screen-height 3)) (when (< (- (ref buf :pos-y) (ref buf :scroll-y)) 0) (array/fill! (ref buf :lines-clean) #f) (clear-frame) (set! buf :scroll-y (* scroll-interval (int (floor (/ (ref buf :pos-y) scroll-interval)))))) (when (> (- (ref buf :pos-y) (ref buf :scroll-y)) frame-height) (array/fill! (ref buf :lines-clean) #f) (clear-frame) (set! buf :scroll-y (* scroll-interval (int (ceil (/ (- (ref buf :pos-y) frame-height) scroll-interval)))))) (when (< (ref buf :scroll-y) 0) (array/fill! (ref buf :lines-clean) #f) (set! buf :scroll-y))) (defn read-bracketed-input (#nil) (def c (:poll-input term)) (case c (65 (dirty-buf!) (previous-line)) (66 (dirty-buf!) (next-line)) (67 (forward-char)) (68 (backward-char)))) (defn read-escaped-input (#nil) (def c (:poll-input term)) (when (= c 91) (return (read-bracketed-input))) (return (insert-char 91))) (defn read-cx-input (#nil) (def c (:poll-input term)) (when (= c 3) (return (quit)))) (defn dirty-buf! (#nil) (def buf (get-cur-buffer)) (line-clean! buf (ref buf :pos-y) #f)) (defn read-input (#nil) (def c (:poll-input term)) (set! last-char c) (case c (27 (read-escaped-input)) (1 (beginning-of-line)) (2 (backward-char)) (5 (end-of-line)) C-e (6 (forward-char)) (16 (dirty-buf!) (previous-line)) (14 (dirty-buf!) (next-line)) (24 (read-cx-input)) (126 (dirty-buf!) (delete-forward-char)) (127 (dirty-buf!) (backward-delete-char)) (13 (dirty-buf!) (insert-newline)) (otherwise (when (and (>= c 32) (< c 128)) (dirty-buf!) (return (insert-char c)))))) (defn load-buffer (filename) (def buf (new-buffer filename)) (def text (slurp filename)) (when text (set! buf :lines (apply array/new (map (split text \"\\n\") :clone))))) (defn main (args) :export (:start term) (:clear-screen term) (def s (:get-size term)) (set! screen-width (ref s :width)) (set! screen-height (ref s :height)) (for-each args load-buffer) (when (zero? (:length buffers)) (new-buffer \"*scratch*\")) (set-cur-buffer! (ref buffers (dec (:length buffers)))) (while #t (scroll-into-view) (draw-screen) (read-input)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :array/2d string/write (do (def *module* :array/2d) (defn allocate (width height) :export (tree/new :data (-> (:alloc Array (* width height)) (array/fill! 0)) :width width :height height)) (defn fill! (data v) :export (array/fill! (ref data :data) v) (return data)) (defn two-dee-ref (data x y oob-val) (if (or (>= x (ref data :width)) (>= y (ref data :height)) (< x 0) (< y 0)) oob-val (ref (ref data :data) (+ x (* y (ref data :width)))))) (export ref two-dee-ref) (defn set! (data x y val) :export (if (or (>= x (ref data :width)) (>= y (ref data :height)) (< x 0) (< y 0)) (exception :out-of-bounds \"Trying to set an array out of bounds\" data) (set! (ref data :data) (+ x (* y (ref data :width))) val)) (return data)) (defn print (data) :export (dotimes (y (ref data :height)) (dotimes (x (ref data :width)) (display (cat (array/2d/ref data x y) \" \"))) (newline)) (return data)) (deftest #t (-> (array/2d/allocate 4 4) (array/2d/set! 1 1 #t) (array/2d/ref 1 1))) (deftest #t (-> (array/2d/allocate 3 3) (array/2d/fill! #t) (array/2d/ref 1 1)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :compiler/c-asset-packer string/write (do (def *module* :compiler/c-asset-packer) (def hex-cache (:alloc Array 256)) (dotimes (i 256) (set! hex-cache i (fmt \"0x{i:02X}, \"))) (defn create-c-asset (raw out symbol-name) :export (typecheck/only out :lambda) (typecheck/only symbol-name :string) (out 'block-write (fmt \"unsigned char {symbol-name}[] = \\\"\")) (dotimes (i (:length raw)) (def c (ref raw i)) (case c (10 (out 'block-write \"\\\\n\\\"\\n\\\"\")) (13 (out 'block-write \"\\\\r\")) (34 (out 'block-write \"\\\\\\\"\")) (92 (out 'block-write \"\\\\\\\\\")) (otherwise (out 'char-write c)))) (out 'block-write \"\\\";\") (out 'close!)) (defn create-string-asset (in symbol-name) :export (with-string-port out (create-c-asset in out symbol-name))) (defn main (args) :export (def filename (car args)) (def output-file (cadr args)) (def symbol-name (caddr args)) (typecheck/only filename :string) (typecheck/only output-file :string) (typecheck/only symbol-name :string) (def out (make-output-port (file/open-output* output-file :replace))) (out 'block-write \"/* This file is auto-generated, manual changes will be overwritten! */\\n\") (create-c-asset (slurp filename) out symbol-name)) (deftest 2716273128 (import (hash) :crypto/adler32) (hash (compiler/c-asset-packer/create-string-asset \"asd\" \"test\"))) (deftest 29 (:length (compiler/c-asset-packer/create-string-asset \"asd\" \"test\"))) (deftest 40 (:length (compiler/c-asset-packer/create-string-asset \"j32093f3223f\" \"secret\"))) (deftest 535759991 (import (hash) :crypto/adler32) (hash (compiler/c-asset-packer/create-string-asset \"j32093f3223f\" \"secret\")))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :core/term string/write (do (def *module* :core/term) (def fg-colors (tree/new :default \"\\e[0m\" :black \"\\e[30m\" :red \"\\e[31m\" :green \"\\e[32m\" :yellow \"\\e[33m\" :blue \"\\e[34m\" :pink \"\\e[35m\" :magenta \"\\e[35m\" :purple \"\\e[35m\" :cyan \"\\e[36m\" :teal \"\\e[36m\" :white \"\\e[37m\")) (def bg-colors (tree/new :default \"\\e[49m\" :black \"\\e[40m\" :red \"\\e[41m\" :green \"\\e[42m\" :yellow \"\\e[43m\" :blue \"\\e[44m\" :pink \"\\e[45m\" :magenta \"\\e[45m\" :purple \"\\e[45m\" :cyan \"\\e[46m\" :teal \"\\e[46m\" :white \"\\e[47m\")) (defclass Term \"A buffered terminal connection\" :export (defn new (self out in) (when-not in (set! in stdin)) (when-not out (set! out stdout)) (tree/new :in-port in :out-port out :buf-port (make-string-output-port) :prototype* self)) (defn flip (self) (def s ((ref self :buf-port) 'return-string)) ((ref self :buf-port) 'close!) (set! self :buf-port (make-string-output-port)) ((ref self :out-port) 'block-write s) ((ref self :out-port) 'flush-output)) (defn put-char (self char) ((ref self :buf-port) 'char-write char)) (defn put-string (self text) ((ref self :buf-port) 'block-write text)) (defn clear-screen (self) ((ref self :buf-port) 'block-write \"\\e[2J\")) (defn clear-line (self) ((ref self :buf-port) 'block-write \"\\e[2K\")) (defn hide-cursor (self) ((ref self :out-port) 'block-write \"\\e[?25l\")) (defn show-cursor (self) ((ref self :out-port) 'block-write \"\\e[?25h\")) (defn start (self) ((ref self :in-port) :raw!) ((ref self :out-port) 'block-write \"\\e[?1049h\")) (defn stop (self) ((ref self :out-port) 'block-write \"\\e[?1049l\")) (defn move-cursor (self column line) ((ref self :buf-port) 'block-write (fmt \"\\e[{line};{column}H\"))) (defn set-fg-color (self color-name) (def v (ref fg-colors color-name)) (when-not v (exception \"Unknown color\" color-name)) ((ref self :buf-port) 'block-write v)) (defn set-bg-color (self color-name) (def v (ref bg-colors color-name)) (when-not v (exception \"Unknown color\" color-name)) ((ref self :buf-port) 'block-write v)) (defn set-color (self fg-color-name bg-color-name) (when fg-color-name (:set-fg-color self fg-color-name)) (when bg-color-name (:set-bg-color self bg-color-name))) (defn get-size (self) :export ((ref self :out-port) 'block-write \"\\e 7\") ((ref self :out-port) 'block-write \"\\e[9999;9999H\") ((ref self :out-port) 'block-write \"\\e[6n\") ((ref self :out-port) 'flush-output) (def buf (buffer/allocate 128)) (def i 0) (while #t (def c ((ref self :in-port) 'char-read)) (when (= c 82) ((ref self :out-port) 'block-write \"\\e 8\") (def s (split (cut (buffer->string buf i) 2) \";\")) (return (tree/new :width (read/int (cadr s)) :height (read/int (car s))))) (set! buf i c) (inc! i))) (defn get-width (self) (ref (:get-size self) :width)) (defn get-height (self) (ref (:get-size self) :height)) (defn poll-input (self) (def c ((ref self :in-port) 'char-read)) (if (= c :end-of-file) 0 c)) (defn draw-box (self color pos-x pos-y width height) :export (:set-bg-color self color) (dotimes (y height) (:move-cursor self pos-x (+ y pos-y)) (dotimes (x width) (:put-char self 32))) (:set-bg-color self :default))) (def fg-colors (tree/new :default \"\\e[0m\" :black \"\\e[30m\" :red \"\\e[31m\" :green \"\\e[32m\" :yellow \"\\e[33m\" :blue \"\\e[34m\" :pink \"\\e[35m\" :magenta \"\\e[35m\" :purple \"\\e[35m\" :cyan \"\\e[36m\" :teal \"\\e[36m\" :white \"\\e[37m\")) (def bg-colors (tree/new :default \"\\e[49m\" :black \"\\e[40m\" :red \"\\e[41m\" :green \"\\e[42m\" :yellow \"\\e[43m\" :blue \"\\e[44m\" :pink \"\\e[45m\" :magenta \"\\e[45m\" :purple \"\\e[45m\" :cyan \"\\e[46m\" :teal \"\\e[46m\" :white \"\\e[47m\")) (defclass Term \"A buffered terminal connection\" :export (defn new (self out in) (when-not in (set! in stdin)) (when-not out (set! out stdout)) (tree/new :in-port in :out-port out :buf-port (make-string-output-port) :prototype* self)) (defn flip (self) (def s ((ref self :buf-port) 'return-string)) ((ref self :buf-port) 'close!) (set! self :buf-port (make-string-output-port)) ((ref self :out-port) 'block-write s) ((ref self :out-port) 'flush-output)) (defn put-char (self char) ((ref self :buf-port) 'char-write char)) (defn put-string (self text) ((ref self :buf-port) 'block-write text)) (defn clear-screen (self) ((ref self :buf-port) 'block-write \"\\e[2J\")) (defn clear-line (self) ((ref self :buf-port) 'block-write \"\\e[2K\")) (defn hide-cursor (self) ((ref self :out-port) 'block-write \"\\e[?25l\")) (defn show-cursor (self) ((ref self :out-port) 'block-write \"\\e[?25h\")) (defn start (self) ((ref self :in-port) :raw!) ((ref self :out-port) 'block-write \"\\e[?1049h\")) (defn stop (self) ((ref self :out-port) 'block-write \"\\e[?1049l\")) (defn move-cursor (self column line) ((ref self :buf-port) 'block-write (fmt \"\\e[{line};{column}H\"))) (defn set-fg-color (self color-name) (def v (ref fg-colors color-name)) (when-not v (exception \"Unknown color\" color-name)) ((ref self :buf-port) 'block-write v)) (defn set-bg-color (self color-name) (def v (ref bg-colors color-name)) (when-not v (exception \"Unknown color\" color-name)) ((ref self :buf-port) 'block-write v)) (defn set-color (self fg-color-name bg-color-name) (when fg-color-name (:set-fg-color self fg-color-name)) (when bg-color-name (:set-bg-color self bg-color-name))) (defn get-size (self) :export ((ref self :out-port) 'block-write \"\\e 7\") ((ref self :out-port) 'block-write \"\\e[9999;9999H\") ((ref self :out-port) 'block-write \"\\e[6n\") ((ref self :out-port) 'flush-output) (def buf (buffer/allocate 128)) (def i 0) (while #t (def c ((ref self :in-port) 'char-read)) (when (= c 82) ((ref self :out-port) 'block-write \"\\e 8\") (def s (split (cut (buffer->string buf i) 2) \";\")) (return (tree/new :width (read/int (cadr s)) :height (read/int (car s))))) (set! buf i c) (inc! i))) (defn get-width (self) (ref (:get-size self) :width)) (defn get-height (self) (ref (:get-size self) :height)) (defn poll-input (self) (def c ((ref self :in-port) 'char-read)) (if (= c :end-of-file) 0 c)) (defn draw-box (self color pos-x pos-y width height) :export (:set-bg-color self color) (dotimes (y height) (:move-cursor self pos-x (+ y pos-y)) (dotimes (x width) (:put-char self 32))) (:set-bg-color self :default)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :crypto/adler32 string/write (do (def *module* :crypto/adler32) (defn hash (data) :export (def a 1) (def b 0) (when (and (not= (:type-name data) :buffer) (not= (:type-name data) :string)) (exception :type-error \"Can only hash buffers or strings\")) (dotimes (i (:length data)) (set! a (mod/int (add/int a (ref data i)) 65521)) (set! b (mod/int (add/int a b) 65521))) (bit-or a (bit-shift-left b 16))) (deftest \"00620062\" (fmt \"{:08X}\" (crypto/adler32/hash \"a\"))) (deftest \"0F9D02BC\" (fmt \"{:08X}\" (crypto/adler32/hash \"asdQWE123\"))) (deftest \"796B110D\" (fmt \"{:08X}\" (crypto/adler32/hash \"DiesIstEinTestDerNujelAdler32Implementierung\"))) (defn main (args) :export (when (not (car args)) (efmtln \"Usage: (...FILES)\") (exit 1)) (doseq (file args) (if (file/dir? file) (pfmtln \"nujel/adler32: {file}: Is a directory\") (if (file/file? file) (pfmtln \"{:08X} {file} ADLER32\" (hash (slurp/buffer file))) (pfmtln \"nujel/adler32: {file}: No such file or directory\")))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :crypto/crc32c string/write (do (def *module* :crypto/crc32c) (def table (:u32 (buffer/allocate (* 256 4)))) (let ((v '(0 4067132163 3778769143 324072436 3348797215 904991772 648144872 3570033899 2329499855 2024987596 1809983544 2575936315 1296289744 3207089363 2893594407 1578318884 274646895 3795141740 4049975192 51262619 3619967088 632279923 922689671 3298075524 2592579488 1760304291 2075979607 2312596564 1562183871 2943781820 3156637768 1313733451 549293790 3537243613 3246849577 871202090 3878099393 357341890 102525238 4101499445 2858735121 1477399826 1264559846 3107202533 1845379342 2677391885 2361733625 2125378298 820201905 3263744690 3520608582 598981189 4151959214 85089709 373468761 3827903834 3124367742 1213305469 1526817161 2842354314 2107672161 2412447074 2627466902 1861252501 1098587580 3004210879 2688576843 1378610760 2262928035 1955203488 1742404180 2511436119 3416409459 969524848 714683780 3639785095 205050476 4266873199 3976438427 526918040 1361435347 2739821008 2954799652 1114974503 2529119692 1691668175 2005155131 2247081528 3690758684 697762079 986182379 3366744552 476452099 3993867776 4250756596 255256311 1640403810 2477592673 2164122517 1922457750 2791048317 1412925310 1197962378 3037525897 3944729517 427051182 170179418 4165941337 746937522 3740196785 3451792453 1070968646 1905808397 2213795598 2426610938 1657317369 3053634322 1147748369 1463399397 2773627110 4215344322 153784257 444234805 3893493558 1021025245 3467647198 3722505002 797665321 2197175160 1889384571 1674398607 2443626636 1164749927 3070701412 2757221520 1446797203 137323447 4198817972 3910406976 461344835 3484808360 1037989803 781091935 3705997148 2460548119 1623424788 1939049696 2180517859 1429367560 2807687179 3020495871 1180866812 410100952 3927582683 4182430767 186734380 3756733383 763408580 1053836080 3434856499 2722870694 1344288421 1131464017 2971354706 1708204729 2545590714 2229949006 1988219213 680717673 3673779818 3383336350 1002577565 4010310262 493091189 238226049 4233660802 2987750089 1082061258 1395524158 2705686845 1972364758 2279892693 2494862625 1725896226 952904198 3399985413 3656866545 731699698 4283874585 222117402 510512622 3959836397 3280807620 837199303 582374963 3504198960 68661723 4135334616 3844915500 390545967 1230274059 3141532936 2825850620 1510247935 2395924756 2091215383 1878366691 2644384480 3553878443 565732008 854102364 3229815391 340358836 3861050807 4117890627 119113024 1493875044 2875275879 3090270611 1247431312 2660249211 1828433272 2141937292 2378227087 3811616794 291187481 34330861 4032846830 615137029 3603020806 3314634738 939183345 1776939221 2609017814 2295496738 2058945313 2926798794 1545135305 1330124605 3173225534 4084100981 17165430 307568514 3762199681 888469610 3332340585 3587147933 665062302 2042050490 2346497209 2559330125 1793573966 3190661285 1279665062 1595330642 2910671697))) (dotimes (i 256) (set! table i (car v)) (cdr! v))) (defn hash (data) :export (def crc 4294967295) (when (and (not= (:type-name data) :buffer) (not= (:type-name data) :string)) (exception :type-error \"Can only hash buffers or strings\")) (dotimes (i (:length data) (bit-xor 4294967295 crc)) (set! crc (bit-and 4294967295 (bit-xor (bit-shift-right crc 8) (ref table (bit-and 255 (bit-xor crc (ref data i))))))))) (deftest \"C1D04330\" (fmt \"{:08X}\" (crypto/crc32c/hash \"a\"))) (deftest \"5185664B\" (fmt \"{:08X}\" (crypto/crc32c/hash \"Test\"))) (deftest \"4D551068\" (fmt \"{:08X}\" (crypto/crc32c/hash \"Hello, World!\"))) (defn main (args) :export (when (not (car args)) (efmtln \"Usage: (...FILES)\") (exit 1)) (doseq (file args) (if (file/dir? file) (pfmtln \"nujel/crc32: {file}: Is a directory\") (if (file/file? file) (pfmtln \"{:08X} {file} CRC32\" (hash (slurp/buffer file))) (pfmtln \"nujel/crc32: {file}: No such file or directory\")))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :crypto/crc32 string/write (do (def *module* :crypto/crc32) (def table (:u32 (buffer/allocate (* 256 4)))) (let ((v '(0 1996959894 3993919788 2567524794 124634137 1886057615 3915621685 2657392035 249268274 2044508324 3772115230 2547177864 162941995 2125561021 3887607047 2428444049 498536548 1789927666 4089016648 2227061214 450548861 1843258603 4107580753 2211677639 325883990 1684777152 4251122042 2321926636 335633487 1661365465 4195302755 2366115317 997073096 1281953886 3579855332 2724688242 1006888145 1258607687 3524101629 2768942443 901097722 1119000684 3686517206 2898065728 853044451 1172266101 3705015759 2882616665 651767980 1373503546 3369554304 3218104598 565507253 1454621731 3485111705 3099436303 671266974 1594198024 3322730930 2970347812 795835527 1483230225 3244367275 3060149565 1994146192 31158534 2563907772 4023717930 1907459465 112637215 2680153253 3904427059 2013776290 251722036 2517215374 3775830040 2137656763 141376813 2439277719 3865271297 1802195444 476864866 2238001368 4066508878 1812370925 453092731 2181625025 4111451223 1706088902 314042704 2344532202 4240017532 1658658271 366619977 2362670323 4224994405 1303535960 984961486 2747007092 3569037538 1256170817 1037604311 2765210733 3554079995 1131014506 879679996 2909243462 3663771856 1141124467 855842277 2852801631 3708648649 1342533948 654459306 3188396048 3373015174 1466479909 544179635 3110523913 3462522015 1591671054 702138776 2966460450 3352799412 1504918807 783551873 3082640443 3233442989 3988292384 2596254646 62317068 1957810842 3939845945 2647816111 81470997 1943803523 3814918930 2489596804 225274430 2053790376 3826175755 2466906013 167816743 2097651377 4027552580 2265490386 503444072 1762050814 4150417245 2154129355 426522225 1852507879 4275313526 2312317920 282753626 1742555852 4189708143 2394877945 397917763 1622183637 3604390888 2714866558 953729732 1340076626 3518719985 2797360999 1068828381 1219638859 3624741850 2936675148 906185462 1090812512 3747672003 2825379669 829329135 1181335161 3412177804 3160834842 628085408 1382605366 3423369109 3138078467 570562233 1426400815 3317316542 2998733608 733239954 1555261956 3268935591 3050360625 752459403 1541320221 2607071920 3965973030 1969922972 40735498 2617837225 3943577151 1913087877 83908371 2512341634 3803740692 2075208622 213261112 2463272603 3855990285 2094854071 198958881 2262029012 4057260610 1759359992 534414190 2176718541 4139329115 1873836001 414664567 2282248934 4279200368 1711684554 285281116 2405801727 4167216745 1634467795 376229701 2685067896 3608007406 1308918612 956543938 2808555105 3495958263 1231636301 1047427035 2932959818 3654703836 1088359270 936918000 2847714899 3736837829 1202900863 817233897 3183342108 3401237130 1404277552 615818150 3134207493 3453421203 1423857449 601450431 3009837614 3294710456 1567103746 711928724 3020668471 3272380065 1510334235 755167117))) (dotimes (i 256) (set! table i (car v)) (cdr! v))) (defn hash (data) :export (def crc 4294967295) (when (and (not= (:type-name data) :buffer) (not= (:type-name data) :string)) (exception :type-error \"Can only hash buffers or strings\")) (dotimes (i (:length data) (bit-xor 4294967295 crc)) (set! crc (bit-and 4294967295 (bit-xor (bit-shift-right crc 8) (ref table (bit-and 255 (bit-xor crc (ref data i))))))))) (deftest \"E8B7BE43\" (fmt \"{:08X}\" (crypto/crc32/hash \"a\"))) (deftest \"784DD132\" (fmt \"{:08X}\" (crypto/crc32/hash \"Test\"))) (deftest \"EC4AC3D0\" (fmt \"{:08X}\" (crypto/crc32/hash \"Hello, World!\"))) (defn main (args) :export (when (not (car args)) (efmtln \"Usage: (...FILES)\") (exit 1)) (doseq (file args) (if (file/dir? file) (pfmtln \"nujel/crc32: {file}: Is a directory\") (if (file/file? file) (pfmtln \"{:08X} {file} CRC32\" (hash (slurp/buffer file))) (pfmtln \"nujel/crc32: {file}: No such file or directory\")))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :crypto/md5 string/write (do (def *module* :crypto/md5) (def s (array/new 7 12 17 22 7 12 17 22 7 12 17 22 7 12 17 22 5 9 14 20 5 9 14 20 5 9 14 20 5 9 14 20 4 11 16 23 4 11 16 23 4 11 16 23 4 11 16 23 6 10 15 21 6 10 15 21 6 10 15 21 6 10 15 21)) (def K (array/new 3614090360 3905402710 606105819 3250441966 4118548399 1200080426 2821735955 4249261313 1770035416 2336552879 4294925233 2304563134 1804603682 4254626195 2792965006 1236535329 4129170786 3225465664 643717713 3921069994 3593408605 38016083 3634488961 3889429448 568446438 3275163606 4107603335 1163531501 2850285829 4243563512 1735328473 2368359562 4294588738 2272392833 1839030562 4259657740 2763975236 1272893353 4139469664 3200236656 681279174 3936430074 3572445317 76029189 3654602809 3873151461 530742520 3299628645 4096336452 1126891415 2878612391 4237533241 1700485571 2399980690 4293915773 2240044497 1873313359 4264355552 2734768916 1309151649 4149444226 3174756917 718787259 3951481745)) (defn left-rotate (v i) (def t (bit-shift-left (bit-and 4294967295 v) i)) (bit-and 4294967295 (bit-or t (bit-shift-right t 32)))) (defn fmt-be (v) (fmt \"{:02x}{:02x}{:02x}{:02x}\" v (bit-shift-right v 8) (bit-shift-right v 16) (bit-shift-right v 24))) (defn hash (data) :export (when (and (not= (:type-name data) :buffer) (not= (:type-name data) :string)) (exception :type-error \"Can only hash buffers or strings\")) (def M (let* (def cur-len (:length data)) (def new-len (- (* (inc (div/int (+ cur-len 8) 64)) 64) 8)) (def buf (buffer/allocate (+ new-len 8))) (buffer/copy buf data 0 cur-len) (set! buf cur-len 128) (def p (- (:length buf) 8)) (set! cur-len (* cur-len 8)) (dotimes (i 8) (set! buf (+ p i) (bit-shift-right cur-len (* i 8)))) (:u32 buf))) (def h0 1732584193) (def h1 4023233417) (def h2 2562383102) (def h3 271733878) (dotimes (chunk (div/int (:length M) 16)) (def chunk-off (* chunk 16)) (def A h0) (def B h1) (def C h2) (def D h3) (dotimes (i 64) (cond ((< i 16) (def F (bit-or (bit-and B C) (bit-and (bit-not B) D))) (def g i)) ((< i 32) (def F (bit-or (bit-and D B) (bit-and (bit-not D) C))) (def g (bit-and (inc (* i 5)) 15))) ((< i 48) (def F (bit-xor B C D)) (def g (bit-and (+ 5 (* 3 i)) 15))) (#t (def F (bit-xor C (bit-or B (bit-not D)))) (def g (bit-and (* i 7) 15)))) (def temp D) (set! D C) (set! C B) (set! B (bit-and 4294967295 (+ B (left-rotate (+ A F (ref K i) (ref M (+ g chunk-off))) (ref s i))))) (set! A temp)) (set! h0 (+ h0 A)) (set! h1 (+ h1 B)) (set! h2 (+ h2 C)) (set! h3 (+ h3 D))) (fmt \"{}{}{}{}\" (fmt-be h0) (fmt-be h1) (fmt-be h2) (fmt-be h3))) (deftest \"d41d8cd98f00b204e9800998ecf8427e\" (crypto/md5/hash \"\")) (deftest \"0cc175b9c0f1b6a831c399e269772661\" (crypto/md5/hash \"a\")) (deftest \"900150983cd24fb0d6963f7d28e17f72\" (crypto/md5/hash \"abc\")) (deftest \"f96b697d7cb7938d525a2f31aaf161d0\" (crypto/md5/hash \"message digest\")) (deftest \"c3fcd3d76192e4007dfb496cca67e13b\" (crypto/md5/hash \"abcdefghijklmnopqrstuvwxyz\")) (deftest \"d174ab98d277d9f5a5611c2c9f419d9f\" (crypto/md5/hash \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")) (deftest \"57edf4a22be3c955ac49da2e2107b67a\" (crypto/md5/hash \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\")) (deftest \"9e107d9d372bb6826bd81d3542a419d6\" (crypto/md5/hash \"The quick brown fox jumps over the lazy dog\")) (deftest \"cb4794d9a70d922a9eafd5b82d14d560\" (crypto/md5/hash (-> (range 2048) (map :string) (join \", \")))) (defn main (args) :export (when (not (car args)) (efmtln \"Usage: (...FILES)\") (exit 1)) (doseq (file args) (if (file/dir? file) (pfmtln \"nujel/md5: {file}: Is a directory\") (if (file/file? file) (pfmtln \"{} {file} MD5\" (hash (slurp/buffer file))) (pfmtln \"nujel/md5: {file}: No such file or directory\")))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :games/guess string/write (do (def *module* :games/guess) (require :ansi) (import (rng) :random) (defn win (guesses-left) (pfmtln \"Fantastic, {} with {guesses-left} guesses left.\" (ansi/rainbow \"you won\")) (pfmtln \"Hope you had fun and have a nice day!\") (exit 0)) (defn loose (#nil) (pfmtln \"Too bad, you didn't guess the number in time, maybe next time.\") (pfmtln \"Hope you still had fun, have a nice day!\") (exit 0)) (defn quit (#nil) (pfmtln \"Bye!\") (exit 0)) (defn main (args) :export (println (ansi/rainbow \"Guess the number!!!\")) (println \"\") (println \"You have 10 tries, with every guess I will tell you if it was too high or too low, the number is in the range of 0 to 100\") (def rand (:new rng)) (def guesses-left 10) (def number (:int rand 100)) (while (> guesses-left 0) (def line (readline (fmt \"Your {} guess? \" (cond ((= guesses-left 1) (ansi/red \"final\")) (#t (- 11 guesses-left)))))) (when-not line (quit)) (def cur-guess (read/int line)) (when (= number cur-guess) (win guesses-left)) (if (< cur-guess number) (println \"Too low\") (println \"Too high\")) (set! guesses-left (- guesses-left 1))) (loose))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :help string/write (do (def *module* :help) (import (rainbow green yellow blue) :ansi) (defn main (args) :export (println (cat (rainbow \"Nujel\") \" - A Lisp dialect for games.\\n\")) (println (cat (green \"Usage:\") \" nujel (options) (command_string | file)\")) (println (cat \"\\nLow-level options - for work on the runtime itself\")) (println (cat \"  \" (yellow \"v\") \" - be verbose\")) (println (cat \"  \" (yellow \"r\") \" - run TinyREPL\")) (println (cat \"\\nHigh-level options - for working with/on Nujel code\")) (println (cat \"  \" (blue \"h\") \" - Print this help screen\")) (println (cat \"  \" (blue \"m\") \" - Execute the following module\")) (println (cat \"  \" (blue \"x\") \" - Run the expression following this argument directly\")) (println (cat \"\\nLong options - for working with/on Nujel code\")) (println (cat \"  \" (green \"no-color\") \" - Disable ANSI color\")) (println (cat \"  \" (green \"color   \") \" - Enable ANSI color\")))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :image/bmp string/write (do (def *module* :image/bmp) (defn buffer/view/le/set! (u8v offset bytes val) (while (> bytes 0) (set! u8v (inc! offset) (bit-and 255 val)) (dec! bytes) (set! val (bit-shift-right val 8))) offset) (defn calc-row-padding (width pixel-length) (def ret (- 4 (bit-and (* width pixel-length) 3))) (if (= ret 4) 0 ret)) (defn encode (image) :export (require :image) (def image-size (* (ref image :height) 3 (+ (ref image :width) (calc-row-padding (ref image :width) 3)))) (def header-size (+ 14 40)) (def file-size (+ image-size header-size)) (def out (buffer/allocate file-size)) (def b (:u8 out)) (def i -1) (set! b (inc! i) 66) (set! b (inc! i) 77) (set! i (buffer/view/le/set! b i 4 file-size)) (set! i (buffer/view/le/set! b i 4 0)) (set! i (buffer/view/le/set! b i 4 header-size)) (set! i (buffer/view/le/set! b i 4 40)) (set! i (buffer/view/le/set! b i 4 (ref image :width))) (set! i (buffer/view/le/set! b i 4 (ref image :height))) (set! i (buffer/view/le/set! b i 2 1)) (set! i (buffer/view/le/set! b i 2 24)) (set! i (buffer/view/le/set! b i 4 0)) (set! i (buffer/view/le/set! b i 4 image-size)) (set! i (buffer/view/le/set! b i 4 8192)) (set! i (buffer/view/le/set! b i 4 8192)) (set! i (buffer/view/le/set! b i 4 0)) (set! i (buffer/view/le/set! b i 4 0)) (def row-padding (calc-row-padding (ref image :width) 3)) (def pixels (- header-size 1)) (let ((y (- (ref image :height) 1))) (while (>= y 0) (dotimes (x (ref image :width)) (set! pixels (buffer/view/le/set! b pixels 3 (image/ref image x y)))) (set! pixels (+ pixels row-padding)) (set! y (add/int y -1)))) (return out)) (defn init! (#nil) :export (require :image) (image/add-encoder! \"bmp\" image/bmp/encode)) (deftest 3149043687 (import hash :crypto/adler32) (import (test-image-xor) :image) (hash (image/bmp/encode (test-image-xor))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :image string/write (do (def *module* :image) (def image/decoders (tree/new #nil)) (def image/encoders (tree/new #nil)) (defn add-encoder! (ext enc) :export (def ext (:keyword (lower-case ext))) (set! image/encoders ext enc)) (defn add-decoder! (ext dec) :export (def ext (:keyword (lower-case ext))) (set! image/decoders ext dec)) (defn get-encoder (path) (def ext (:keyword (lower-case (path/extension path)))) (ref image/encoders ext)) (defn get-decoder (path) (def ext (:keyword (lower-case (path/extension path)))) (ref image/decoders ext)) (defn new (width height) :export (def buffer (buffer/allocate (* width height 4))) (tree/new :width width :height height :buffer buffer :pixels (:u32 buffer))) (defn image/ref (img x y) :export-as ref (def i (+ (int x) (* (int y) (ref img :width)))) (ref (ref img :pixels) i)) (defn image/set! (img x y value) :export-as set! (def i (+ (int x) (* (int y) (ref img :width)))) (set! (ref img :pixels) i value)) (defn fill! (img value) :export (def p (ref img :pixels)) (dotimes (i (* (ref img :width) (ref img :height)) img) (set! p i value))) (defn map! (img fun) :export (def p (ref img :pixels)) (dotimes (i (* (ref img :width) (ref img :height)) img) (set! p i (fun (ref p i))))) (defn dup (img) :export (def ret (image/new (ref img :width) (ref img :height))) (def in (ref img :pixels)) (def out (ref ret :pixels)) (dotimes (i (* (ref img :width) (ref img :height)) img) (set! out i (ref in i)))) (defn save! (img path) :export (def enc (get-encoder path)) (if enc (file/write (enc img) path) (exception :missing-encoder \"Currently there is no encoder loaded for that image format\" path))) (defn adler32 (img) :export (import (hash) :crypto/adler32) (hash (ref img :buffer))) (defn test-image-xor (#nil) :export (def w 256) (def h 256) (def out (new w h)) (dotimes (x w out) (dotimes (y h) (image/set! out x y (bit-or x (bit-shift-left y 8) (bit-shift-left (bit-xor x y) 16)))))) (deftest 4040398435 (image/adler32 (image/test-image-xor)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :net/gopher string/write (do (def *module* :net/gopher) (defn parse-url (url) (when (= (:index-of url \"gopher://\") 0) (set! url (:cut url 9)) (def host url) (def port 70) (def path \"\") (def first-slash (:index-of url \"/\")) (when (>= first-slash 0) (set! path (:cut url first-slash)) (set! host (:cut url 0 first-slash))) (def first-colon (:index-of host \":\")) (when (>= first-colon 0) (set! port (read/int (:cut host (inc first-colon)))) (set! host (:cut host 0 first-colon))) (return (tree/new :host host :port port :path path :protocol :gopher))) #nil) (defn get* (host path port) (def buf (buffer/allocate 0)) (def fh (socket/connect host port)) (file/write* fh path (:length path)) (file/write* fh \"\\r\\n\" 2) (file/flush* fh) (def bytes-read 0) (def bytes-read-now 1) (while (not (zero? bytes-read-now)) (:length! buf (+ 8192 (:length buf))) (set! bytes-read-now (file/read* fh buf 8192 bytes-read)) (set! bytes-read (+ bytes-read bytes-read-now))) (file/close* fh) (def raw-res (buffer->string buf bytes-read)) raw-res) (defn parse-gopher-map (line) (def T (:cut line 0 1)) (when (or (= T \".\") (= T \" \") (= T \"\")) (return #nil)) (def cols (split (:cut line 1) \"\\t\")) (tree/new :type (:keyword T) :display (or (car cols) \"\") :path (or (cadr cols) \"\") :host (or (caddr cols) \"\") :port (or (cadddr cols) 70))) (defn get (url type) :export (when-not type (set! type :1)) (def info (parse-url url)) (when-not info (return #nil)) (def res (get* (ref info :host) (ref info :path) (ref info :port))) (when-not res (return #nil)) (if (= type :1) (-> (split res \"\\r\\n\") (map parse-gopher-map) (filter identity)) res))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :net/http string/write (do (def *module* :net/http) (defn req* (verb host path header) (set! header (if header (:clone header) (tree/new #nil))) (set! header :Host host) (set! header :Connection \"close\") (set! header :User-Agent \"Nujel/0.1\") (def header-lines (join (map (:keys header) (fn (k) (fmt \"{}: {}\" (:string k) (:string (ref header k))))) \"\\r\\n\")) (def req (fmt \"{verb} {path} HTTP/1.1\\r\\n{header-lines}\\r\\n\\r\\n\")) (def buf (buffer/allocate 0)) (def fh (socket/connect host 80)) (file/write* fh req (:length req)) (file/flush* fh) (def bytes-read 0) (def bytes-read-now 1) (while (not (zero? bytes-read-now)) (:length! buf (+ 65536 (:length buf))) (set! bytes-read-now (file/read* fh buf 65536 bytes-read)) (set! bytes-read (+ bytes-read bytes-read-now))) (file/close* fh) (def raw-res (buffer->string buf bytes-read)) (def eosl (:index-of raw-res \"\\r\\n\")) (when (< eosl 0) (return #nil)) (def eoh (:index-of raw-res \"\\r\\n\\r\\n\")) (when (< eoh 0) (return #nil)) (def headers (tree/new #nil)) (def body (:cut buf (+ 4 eoh))) (def status-list (split (buffer->string buf eosl) \" \")) (def status-code (read/int (cadr status-list))) (doseq (header (split (buffer->string buf eoh (+ 2 eosl)) \"\\r\\n\")) (def eok (:index-of header \":\")) (when (>= eok 0) (def key (:keyword (:cut header 0 eok))) (def v (trim (:cut header (inc eok)))) (set! headers key v))) (tree/new :http-version (car status-list) :status-code status-code :status-message (join (cddr status-list) \" \") :headers headers :body body)) (defn get (url) :export (when (= (:index-of url \"https://\") 0) (error \"https is unsupported right now\")) (when (= (:index-of url \"http://\") 0) (set! url (:cut url 7)) (def path-start (:index-of url \"/\")) (return (if (>= path-start 0) (http/req* \"GET\" (:cut url 0 path-start) (:cut url path-start)) (http/req* \"GET\" url \"/\")))) (error \"unsupported scheme\"))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :net string/write (do (def *module* :net) (import (get :as http/get) :net/http) (defn get (url) :export (def res (http/get url)) (when (> (ref res :status-code) 299) (return #nil)) (ref res :body)) (defn download (url filename) :export (when-not filename (set! filename (car (last-pair (split url \"/\"))))) (def body (get url)) (when body (file/write body filename)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :pretty/nujel string/write (do (def *module* :pretty/nujel) (import (fg-reset ansi-fg) :ansi) (def ansi-colors (array/new fg-reset (ref ansi-fg 1) (ref ansi-fg 2) (ref ansi-fg 3) (ref ansi-fg 4) (ref ansi-fg 5) (ref ansi-fg 6) (ref ansi-fg 7) (ref ansi-fg 8) (ref ansi-fg 9) (ref ansi-fg 10) (ref ansi-fg 11) (ref ansi-fg 12) (ref ansi-fg 13) (ref ansi-fg 14) (ref ansi-fg 15))) (def html-colors (array/new \"</span>\" \"<span class=\\\"nujel-hl-1\\\">\" \"<span class=\\\"nujel-hl-2\\\">\" \"<span class=\\\"nujel-hl-3\\\">\" \"<span class=\\\"nujel-hl-4\\\">\" \"<span class=\\\"nujel-hl-5\\\">\" \"<span class=\\\"nujel-hl-6\\\">\" \"<span class=\\\"nujel-hl-7\\\">\" \"<span class=\\\"nujel-hl-8\\\">\" \"<span class=\\\"nujel-hl-9\\\">\" \"<span class=\\\"nujel-hl-10\\\">\" \"<span class=\\\"nujel-hl-11\\\">\" \"<span class=\\\"nujel-hl-12\\\">\" \"<span class=\\\"nujel-hl-13\\\">\" \"<span class=\\\"nujel-hl-14\\\">\" \"<span class=\\\"nujel-hl-15\\\">\")) (defn comment-block (source i pp colors) (def len (:length source)) (pp 'block-write (ref colors 8)) (pp 'block-write \"#|\") (set! i (+ i 2)) (while (< i len) (def c (ref source i)) (cond ((and (= c 35) (= (ref source (inc/int i)) 124)) (set! i (comment-block source i pp colors))) ((and (= c 124) (= (ref source (inc/int i)) 35)) (pp 'block-write \"|#\") (pp 'block-write (ref colors 0)) (return (+ 2 i))) (#t (pp 'char-write c) (set! i (inc/int i))))) (pp 'block-write (ref colors 0)) (return i)) (defn comment-eol (source i pp colors) (def len (:length source)) (pp 'block-write (ref colors 8)) (while (< i len) (def c (ref source i)) (case c (10 (pp 'char-write c) (pp 'block-write (ref colors 0)) (return (inc/int i))) (otherwise (pp 'char-write c) (set! i (inc/int i))))) (pp 'block-write (ref colors 0)) (return i)) (defn continue-until-separator (source i pp colors) (def len (:length source)) (while (< i len) (def c (ref source i)) (case c ((10 13 32 40 41 40 41 34) (pp 'block-write (ref colors 0)) (return i)) (otherwise (pp 'char-write c) (set! i (inc/int i))))) (pp 'block-write (ref colors 0)) (return i)) (defn literal-special (source i pp colors) (def n (ref source (inc i))) (case n (33 (return (comment-eol source i pp colors))) (124 (return (comment-block source i pp colors))) (110 (return (literal-nil source i pp colors))) ((116 102) (return (literal-bool source i pp colors))) (otherwise (pp 'block-write (ref colors 2)) (continue-until-separator source i pp colors)))) (defn literal-keyword (source i pp colors) (pp 'block-write (ref colors 4)) (return (continue-until-separator source i pp colors))) (defn literal-number (source i pp colors) (pp 'block-write (ref colors 5)) (return (continue-until-separator source i pp colors))) (defn literal-string (source i pp colors) (def len (:length source)) (pp 'block-write (ref colors 3)) (def escaped-quote? #t) (while (< i len) (def c (ref source i)) (case c (92 (pp 'char-write c) (set! escaped-quote? #t) (set! i (inc/int i))) (34 (pp 'char-write c) (if escaped-quote? (do (set! i (inc/int i)) (set! escaped-quote? #f)) (do (pp 'block-write (ref colors 0)) (return (inc/int i))))) (otherwise (pp 'char-write c) (set! escaped-quote? #f) (set! i (inc/int i))))) (pp 'block-write (ref colors 0)) (return i)) (defn list-car (source i pp colors d) (pp 'block-write (ref colors 15)) (set! i (continue-until-separator source i pp colors)) (pp 'block-write (ref colors 0)) (return (top source i pp colors d))) (defn bracket-open (source i pp colors d) (pp 'block-write (ref colors (+ 1 (bit-and d 3)))) (pp 'char-write (ref source i)) (pp 'block-write (ref colors 0)) (list-car source (inc/int i) pp colors d)) (defn bracket-close (source i pp colors d) (pp 'block-write (ref colors (+ 1 (bit-and d 3)))) (pp 'char-write (ref source i)) (pp 'block-write (ref colors 0)) (return (inc/int i))) (defn literal-nil (source i pp colors) (pp 'block-write (ref colors 8)) (set! i (continue-until-separator source i pp colors)) (pp 'block-write (ref colors 0)) (return i)) (defn literal-bool (source i pp colors) (case (ref source (inc/int i)) (116 (pp 'block-write (ref colors 2))) (otherwise (pp 'block-write (ref colors 1)))) (set! i (continue-until-separator source i pp colors)) (pp 'block-write (ref colors 0)) (return i)) (defn start-quote (source i pp colors d) (pp 'block-write (ref colors 3)) (pp 'char-write (ref source i)) (continue-until-separator source (inc/int i) pp colors d)) (defn top (source i pp colors d) (def len (:length source)) (while (< i len) (def c (ref source i)) (case c (35 (set! i (literal-special source i pp colors))) (59 (set! i (comment-eol source i pp colors))) (34 (set! i (literal-string source i pp colors))) (58 (set! i (literal-keyword source i pp colors))) (39 (set! i (start-quote source i pp colors d))) ((40 91) (set! i (bracket-open source i pp colors (inc/int d)))) ((41 93) (return (bracket-close source i pp colors d))) ((48 49 50 51 52 53 54 55 56 57) (set! i (literal-number source i pp colors))) (otherwise (pp 'char-write c) (set! i (inc/int i))))) (return i)) (defn pp-nujel (source output-format) :export (def pp (make-string-output-port)) (def colors (case output-format (:html html-colors) (otherwise ansi-colors))) (top source 0 pp colors 0) (pp 'return-string)) (defn main (args) :export (when (or (not (car args)) (not (file/file? (car args)))) (emftln \"Usage: (...FILES)\") (exit 1)) (doseq (file args) (println (pp-nujel (slurp file)))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :random string/write (do (def *module* :random) (defclass rng \"A simple RNG\" :export (defn new (self seed) (when-not seed (set! seed (bit-xor (time) (time/milliseconds)))) (tree/new :seed seed :prototype* self)) (defn seed! (self seed) \"Set a new seed value for the RNG\" (set! self :seed seed)) (defn rng! (self) \"Generate a random integer\" (set! self :seed (+ 12345 (* (ref self :seed) 1103515245))) (bit-or (bit-shift-left (bit-and (ref self :seed) 65535) 16) (bit-and (bit-shift-right (ref self :seed) 16) 65535))) (defn int (self max) \"Return a value from 0 to MAX, or, if left out, a random int\" (if max (rem (abs (:rng! self)) max) (:rng! self)))) (deftest #t (int? (:int (:new random/rng)))) (deftest #t (def r (:new random/rng)) (:seed! r 123) (def first-value (:int r)) (:seed! r 123) (= first-value (:int r))) (deftest #t (def r (:new random/rng)) (:seed! r 99) (not= (:int r) (:int r))) (deftest #t (int? (-> (:new random/rng) :int))) (deftest #t (def rng (:new random/rng 123)) (def a (:int rng)) (:seed! rng 123) (= (:int rng) a)) (deftest #t (def rng (:new random/rng 99)) (not= (:int rng) (:int rng)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :repl string/write (do (def *module* :repl) (import (rainbow) :ansi) (def *1 #nil) (def *2 #nil) (def *3 #nil) (def line-history #nil) (def ctx (environment*)) (defn exception-handler (error) (print/error error)) (defn push-result (result) (set! *3 *2) (set! *2 *1) (set! *1 result) (return result)) (defn cmd/raw (line) :export (try (fn (err) (if (= (car err) :unmatched-opening-bracket) (cmd/raw ctx (cat line (readline \"... \"))) (throw err))) (def expr (read line)) (when (equal? '(#nil) expr) (print \"\\r\") (return)) (try exception-handler (def result (eval-in ctx (cons do expr))) (push-result result) (println (if (nil? result) \"\" (string/display result)))))) (defn cmd (#nil) (def buf \"\") (def line \"\") (while (not= (trim line) \"[/cmd]\") (set! buf (cat buf line)) (set! line (readline))) (def expr (cons do (read buf))) (def result (eval-in ctx expr)) (push-result result) (println (if (nil? result) \"\" (string/display result)))) (defn prompt (#nil) \"> \") (defn read-cmd (#nil) (def line (readline (prompt))) (cons! line line-history) (when (nil? line) (println \"Adios, cowboy...\") (exit 0)) (if (= (trim line) \"[cmd]\") (cmd) (cmd/raw line))) (defn welcome (#nil) (println (cat (rainbow \"Nujel\") \" REPL is ready for service!\"))) (defn main (args) :export (welcome) (while #t (try exception-handler (read-cmd))))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :serialization/json string/write (do (def *module* :serialization/json) (defn tree->json (v) \"Converts a tree into a JSON encoded string, you should prefer VAL->JSON\" (cat \"{\" (join (map (:keys v) (fn (k) (cat \"\\\"\" (:string k) \"\\\": \" (val->json (ref v k))))) \",\\n\") \"}\")) (defn val->json (v) :export-as serialize \"Return V as a JSON encoded string\" (case (:type-name v) (:nil \"null\") ((:int :float) (:string v)) (:bool (if v \"true\" \"false\")) ((:array :pair) (cat \"[\" (join (map v val->json) \",\") \"]\")) (:string (string/write v)) ((:symbol :keyword) (cat \"\\\"\" (:string v) \"\\\"\")) (:tree (tree->json v)) (otherwise (throw (list :type-error \"Can't encode the value into JSON\" v (current-lambda)))))) (deftest \"null\" (serialization/json/serialize #nil)) (deftest \"123\" (serialization/json/serialize 123)) (deftest \"123.123\" (serialization/json/serialize 123.123)) (deftest \"true\" (serialization/json/serialize #t)) (deftest \"false\" (serialization/json/serialize #f)) (deftest \"[1,2,3]\" (serialization/json/serialize (array/new 1 2 3))) (deftest \"[1,true,3.0]\" (serialization/json/serialize '(1 #t 3.0))) (deftest \"\\\"asd\\\"\" (serialization/json/serialize 'asd)) (deftest \"\\\"asd\\\"\" (serialization/json/serialize :asd)) (deftest \"\\\"asd\\\"\" (serialization/json/serialize \"asd\")) (deftest \"\\\"asd\\\"\" (serialization/json/serialize \"asd\")) (deftest \"{\\\"asd\\\": null}\" (serialization/json/serialize (tree/new :asd #nil))) (deftest \"{\\\"asd\\\": \\\"asd\\\"}\" (serialization/json/serialize (tree/new :asd :asd))) (deftest \"{\\\"asd\\\": 123}\" (serialization/json/serialize (tree/new :asd 123)))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :test string/write (do (def *module* :test) (require :ansi) (def test-list #nil) (def test-count 0) (def nujel-start 0) (def success-count 0) (def error-count 0) (def print-errors #t) (def print-passes #f) (defn add* (result expr) :export (set! test-list (cons (cons result expr) test-list)) (set! test-count (+ test-count 1))) (defn reset! (#nil) :export (set! test-list (cons 4 '(+ 3 1))) (set! test-count 1)) (defn display-results (description) \"Prints the result Message\" (efmtln \"{} {} - [{} / {}] in {} ms\" (if (and (zero? error-count) (> test-count 0)) (if (zero? success-count) (ansi/yellow \"?\") (ansi/green \"✓\")) (ansi/red \"✗\")) description (if (zero? success-count) (ansi/yellow success-count) (ansi/green success-count)) (if (zero? error-count) (ansi/gray error-count) (ansi/red error-count)) (- (time/milliseconds) nujel-start))) (defn test-success (res-should res-is expr) \"Should be called after a test has finished successfully\" (when print-passes (efmtln \"{} = {}\\r\\n{}\\r\\n\\r\\n\" (ansi/green (string/write res-is)) (ansi/green (string/write res-should)) (string/write expr))) (set! success-count (+ 1 success-count))) (defn test-failure (res-should res-is expr) \"Should be called if EXPR does not equal RES\" (when print-errors (pfmtln \"{} != {}\\r\\n{}\\r\\n\\r\\n\" (ansi/red (string/write res-is)) (ansi/green (string/write res-should)) (string/write expr))) (set! error-count (+ 1 error-count))) (defn run-test! (result rawexpr) :export \"Tests that RAWEXPR evaluates to RESULT\" (try (fn (err) (test-failure result (list :exception-caught err) rawexpr)) (def expr (eval rawexpr)) (if (equal? result expr) (test-success result expr rawexpr) (test-failure result expr rawexpr)))) (defn init! (output-passes hide-errors) :export \"Initialize the testing framework\" (set! print-errors (not hide-errors)) (set! print-passes (boolean output-passes)) (set! nujel-start (time/milliseconds)) (set! success-count 0) (set! error-count 0)) (defn finish! (description) :export (display-results description) (return error-count)) (defn run (output-passes hide-errors) :export \"Run through all automated Tests\" (init!) (doseq (cur-test test-list) (run-test! (car cur-test) (cdr cur-test))) (finish! (fmt \"{} {} [{System/OS} {System/Architecture}]\" (ansi/blue \":core\") (ansi/rainbow \"Nujel\")))) (defn load-file (filename) :export (doseq (t (read (slurp filename)) test-list) (when (= (car t) 'test/add) (cdr! t)) (add* (eval (car t)) (cons 'do (cdr t))))) (reset!) (defn add-builtin-tests (#nil) :export (doseq (test-funs (-> (symbol-table) (map resolve-or-nil) (filter callable?) (map (fn (a) (:meta a :tests))) (filter identity))) (doseq (fun test-funs) (add* (car fun) (cadr fun))))) (deftest #t (lambda? test/run))))\n"
"0E001A010E021A030401040201\n"
"}#{##(module/insert/defer :time string/write (do (def *module* :time) (defn seconds (timestamp) :export \"Return the seconds part of TIMESTAMP, defaults to current time\" (rem (or timestamp (time)) 60)) (defn minutes (timestamp) :export \"Return the minutes part of TIMESTAMP, defaults to current time\" (rem (div/int (or timestamp (time)) 60) 60)) (defn hours (timestamp) :export \"Return the hours part of TIMESTAMP, defaults to current time\" (rem (div/int (or timestamp (time)) 3600) 24)) (deftest 34 (time/seconds 1637755714)) (deftest 8 (time/minutes 1637755714)) (deftest 12 (time/hours 1637755714)) (deftest 59 (time/seconds 1637755739)) (deftest 0 (time/seconds 1637755740))))\n"
"0E001A010E021A030401040201\n"
"}";