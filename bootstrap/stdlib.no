#{##[bit-nand l #@[documentation: "Returns the Nand of its arguments" source: ["Returns the Nand of its arguments" [bit-not [apply bit-and l]]]] #{##[bit-not apply bit-and l]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 1
01
} lognand bit-and-not [x y] #@[documentation: "Bitwise and with complement" source: ["Bitwise and with complement" [bit-and x [bit-not y]]]] #{##[bit-and x bit-not y]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
04i 2
01
} bit-test? [α i] #@[documentation: "Test bit at position i" source: ["Test bit at position i" [typecheck/only α :int] [typecheck/only i :int] [not [zero? [bit-and α [bit-shift-left 1 i]]]]]] #{##[type-of α :int throw list :type-error "Expected a value of type :int" current-lambda i bit-and bit-shift-left #f #t]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
20
0Bo 7
24
09o 25
1Ai 3
05
1Ai 4
05
1Ai 5
1Ai 6
1Ai 1
05
1Ai 7
05
04i 0
04i 4
04i 1
0D
1Ai 0
05
1Ai 8
05
04i 1
1Ai 2
20
0Bo 7
24
09o 25
1Ai 3
05
1Ai 4
05
1Ai 5
1Ai 6
1Ai 8
05
1Ai 7
05
04i 0
04i 4
04i 1
0D
1Ai 9
05
1Ai 1
05
1Ai 10
05
02i 1
1Ai 8
05
04i 2
04i 2
2A
0Bo 8
1Ai 11
09o 5
1Ai 12
01
} bit-set? bit-shift-right [α i] #@[documentation: "Bitwise shift right" source: ["Bitwise shift right" [bit-shift-left α [- i]]]] #{##[bit-shift-left α - i]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
04i 2
01
} bit-set [x i] #@[documentation: "Set bit at i" source: ["Set bit at i" [bit-or x [bit-shift-left 1 i]]]] #{##[bit-or x bit-shift-left i]
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 1
1Ai 3
05
04i 2
04i 2
01
} bit-flip [x i] #@[documentation: "Flip bit at i" source: ["Flip bit at i" [bit-xor x [bit-shift-left 1 i]]]] #{##[bit-xor x bit-shift-left i]
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 1
1Ai 3
05
04i 2
04i 2
01
} bit-clear [x i] #@[documentation: "Clear bit at i" source: ["Clear bit at i" [bit-and x [bit-not [bit-shift-left 1 i]]]]] #{##[bit-and x bit-not bit-shift-left i]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
02i 1
1Ai 4
05
04i 2
04i 1
04i 2
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 0
05
1Ai 4
07
0D
1Ai 5
1Ai 6
1Ai 7
1Ai 8
17
1Ai 5
07
0D
1Ai 9
1Ai 10
1Ai 11
1Ai 12
17
1Ai 9
07
0D
1Ai 9
05
1Ai 13
07
0D
1Ai 14
1Ai 15
1Ai 16
1Ai 17
17
1Ai 14
07
0D
1Ai 18
1Ai 19
1Ai 20
1Ai 21
17
1Ai 18
07
0D
1Ai 22
1Ai 23
1Ai 24
1Ai 25
17
1Ai 22
07
0D
1Ai 26
1Ai 27
1Ai 28
1Ai 29
17
1Ai 26
07
01
}#{##[array/+= [a i v] #@[documentation: "Add V to the value in A at position I and store the result in A returning A" source: ["Add V to the value in A at position I and store the result in A returning A" [array/set! a i [+ v [array/ref a i]]]]] #{##[array/set! a i v array/ref]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 1
05
1Ai 2
05
04i 2
25
04i 3
01
} array/++ [a i] #@[documentation: "Increment position I in A and return A" source: ["Increment position I in A and return A" [array/+= a i 1]]] #{##[array/+= a i]
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 1
04i 3
01
} array/fill! [a v] #@[documentation: "Fills array a with value v" source: ["Fills array a with value v" [def len [array/length a]] [dotimes [i len] [array/set! a i v]] [return a]]] #{##[array/length a len i array/set! v]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
15
02i 0
1Ai 3
07
0D
24
1B
09o 29
0D
1C
1Ai 4
05
1Ai 1
05
1Ai 3
05
1Ai 5
05
04i 3
0D
02i 1
1Ai 3
05
03
1Ai 3
08
1Ai 3
05
1Ai 2
05
1E
0Ao -33
0D
24
16
0D
1Ai 1
05
01
01
} array/append [a b] #@[documentation: "Append array A to array B" source: ["Append array A to array B" [when-not [and [array? a] [array? b]] [throw [list :type-error "array/append expects two arrays as its arguments" #nil [current-lambda]]]] [def ret [array/allocate [+ [array/length a] [array/length b]]]] [dotimes [i [array/length a]] [array/set! ret i [array/ref a i]]] [let [[i [array/length a]] [rl [array/length ret]]] [while [< i rl] [array/set! ret i [array/ref b [- i [array/length a]]]] [set! i [add/int i 1]]]] [return ret]]] #{##[array? a b throw list :type-error "array/append expects two arrays as its arguments" current-lambda array/allocate array/length ret i array/set! array/ref rl]
1Ai 0
05
1Ai 1
05
04i 1
0C
0Bo 12
0D
1Ai 0
05
1Ai 2
05
04i 1
0Bo 7
24
09o 23
1Ai 3
05
1Ai 4
05
1Ai 5
1Ai 6
24
1Ai 7
05
04i 0
04i 4
04i 1
0D
1Ai 8
05
1Ai 9
05
1Ai 1
05
04i 1
1Ai 9
05
1Ai 2
05
04i 1
25
04i 1
1Ai 10
07
0D
15
02i 0
1Ai 11
07
0D
24
1B
09o 37
0D
1C
1Ai 12
05
1Ai 10
05
1Ai 11
05
1Ai 13
05
1Ai 1
05
1Ai 11
05
04i 2
04i 3
0D
02i 1
1Ai 11
05
03
1Ai 11
08
1Ai 11
05
1Ai 9
05
1Ai 1
05
04i 1
1E
0Ao -46
0D
24
16
0D
15
1Ai 9
05
1Ai 1
05
04i 1
1Ai 11
07
0D
1Ai 9
05
1Ai 10
05
04i 1
1Ai 14
07
0D
24
1B
09o 46
0D
1C
1Ai 12
05
1Ai 10
05
1Ai 11
05
1Ai 13
05
1Ai 2
05
1Ai 11
05
1Ai 9
05
1Ai 1
05
04i 1
26
04i 2
04i 3
0D
1Ai 11
05
02i 1
03
1Ai 11
08
1Ai 11
05
1Ai 14
05
1E
0Ao -50
16
0D
1Ai 10
05
01
01
} array/dup [a] #@[documentation: "Duplicate Array A" source: ["Duplicate Array A" [def ret [array/allocate [array/length a]]] [dotimes [i [array/length a]] [array/set! ret i [array/ref a i]]] [return ret]]] #{##[array/allocate array/length a ret i array/set! array/ref]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
1Ai 3
07
0D
15
02i 0
1Ai 4
07
0D
24
1B
09o 37
0D
1C
1Ai 5
05
1Ai 3
05
1Ai 4
05
1Ai 6
05
1Ai 2
05
1Ai 4
05
04i 2
04i 3
0D
02i 1
1Ai 4
05
03
1Ai 4
08
1Ai 4
05
1Ai 1
05
1Ai 2
05
04i 1
1E
0Ao -46
0D
24
16
0D
1Ai 3
05
01
01
} array/reduce [arr fun α] #@[documentation: "Reduce an array, [reduce] should be preferred" source: ["Reduce an array, [reduce] should be preferred" [def len [array/length arr]] [dotimes [i len] [set! α [fun α [array/ref arr i]]]] [return α]]] #{##[array/length arr len i fun α array/ref]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
15
02i 0
1Ai 3
07
0D
24
1B
09o 37
0D
1C
1Ai 4
05
1Ai 5
05
1Ai 6
05
1Ai 1
05
1Ai 3
05
04i 2
04i 2
1Ai 5
08
0D
02i 1
1Ai 3
05
03
1Ai 3
08
1Ai 3
05
1Ai 2
05
1E
0Ao -41
0D
24
16
0D
1Ai 5
05
01
01
} array/map [arr fun] #@[documentation: "Map an array, [map] should be preferred" source: ["Map an array, [map] should be preferred" [def len [array/length arr]] [dotimes [i len] [array/set! arr i [fun [array/ref arr i]]]] [return arr]]] #{##[array/length arr len i array/set! fun array/ref]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
15
02i 0
1Ai 3
07
0D
24
1B
09o 42
0D
1C
1Ai 4
05
1Ai 1
05
1Ai 3
05
1Ai 5
05
1Ai 6
05
1Ai 1
05
1Ai 3
05
04i 2
04i 1
04i 3
0D
02i 1
1Ai 3
05
03
1Ai 3
08
1Ai 3
05
1Ai 2
05
1E
0Ao -46
0D
24
16
0D
1Ai 1
05
01
01
} array/filter [arr pred] #@[documentation: "Filter an array, [filter] should be preferred" source: ["Filter an array, [filter] should be preferred" [def ri 0] [def len [array/length arr]] [def ret [array/allocate len]] [dotimes [ai len] [when [pred [array/ref arr ai]] [array/set! ret ri [array/ref arr ai]] [inc! ri]]] [array/length! ret ri]]] #{##[ri array/length arr len array/allocate ret ai pred array/ref array/set! array/length!]
02i 0
1Ai 0
07
0D
1Ai 1
05
1Ai 2
05
04i 1
1Ai 3
07
0D
1Ai 4
05
1Ai 3
05
04i 1
1Ai 5
07
0D
15
02i 0
1Ai 6
07
0D
24
1B
09o 70
0D
1C
1Ai 7
05
1Ai 8
05
1Ai 2
05
1Ai 6
05
04i 2
04i 1
0Bo 38
1Ai 9
05
1Ai 5
05
1Ai 0
05
1Ai 8
05
1Ai 2
05
1Ai 6
05
04i 2
04i 3
0D
1Ai 0
05
02i 1
25
1Ai 0
08
09o 4
24
0D
02i 1
1Ai 6
05
03
1Ai 6
08
1Ai 6
05
1Ai 3
05
1E
0Ao -74
0D
24
16
0D
1Ai 10
05
1Ai 5
05
1Ai 0
05
04i 2
01
} array/equal? [a b] #@[source: [[if [or [not [array? a]] [not [array? b]] [not= [array/length a] [array/length b]]] [return #f] [let [[ret #t]] [dotimes [i [array/length a]] [when-not [equal? [array/ref a i] [array/ref b i]] [set! ret #f] [set! i [array/length a]]]] [return ret]]]]] #{##[array? a #f #t b not= array/length ret i equal? array/ref]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 8
1Ai 2
09o 5
1Ai 3
0C
0Ao 55
0D
1Ai 0
05
1Ai 4
05
04i 1
0Bo 8
1Ai 2
09o 5
1Ai 3
0C
0Ao 32
0D
1Ai 5
05
1Ai 6
05
1Ai 1
05
04i 1
1Ai 6
05
1Ai 4
05
04i 1
04i 2
0C
0Ao 6
0D
1Ai 2
0Bo 9
1Ai 2
01
09o 109
15
1Ai 3
1Ai 7
07
0D
15
02i 0
1Ai 8
07
0D
24
1B
09o 66
0D
1C
1Ai 9
05
1Ai 10
05
1Ai 1
05
1Ai 8
05
04i 2
1Ai 10
05
1Ai 4
05
1Ai 8
05
04i 2
04i 2
0Bo 7
24
09o 20
1Ai 2
1Ai 7
08
0D
1Ai 6
05
1Ai 1
05
04i 1
1Ai 8
08
0D
02i 1
1Ai 8
05
03
1Ai 8
08
1Ai 8
05
1Ai 6
05
1Ai 1
05
04i 1
1E
0Ao -75
0D
24
16
0D
1Ai 7
05
01
16
01
} array/push [arr val] #@[documentation: "Append VAL to ARR" source: ["Append VAL to ARR" [-> arr [array/length! [+ 1 [array/length arr]]] [array/set! [- [array/length arr] 1] val]]]] #{##[array/set! array/length! arr array/length val]
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 1
1Ai 3
05
1Ai 2
05
04i 1
25
04i 2
1Ai 3
05
1Ai 2
05
04i 1
02i 1
26
1Ai 4
05
04i 3
01
} array/swap [arr i j] #@[documentation: "Swap values at I and J in ARR" source: ["Swap values at I and J in ARR" [def tmp [array/ref arr i]] [-> arr [array/set! i [array/ref arr j]] [array/set! j tmp]]]] #{##[array/ref arr i tmp array/set! j]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
1Ai 3
07
0D
1Ai 4
05
1Ai 4
05
1Ai 1
05
1Ai 2
05
1Ai 0
05
1Ai 1
05
1Ai 5
05
04i 2
04i 3
1Ai 5
05
1Ai 3
05
04i 3
01
} array/heapify [arr n at] #@[documentation: "bubble up the element from index AT to until the max-heap property is satisfied" source: ["bubble up the element from index AT to until the max-heap property is satisfied" [def top at] [def looping #t] [while looping [def l [+ [bit-shift-left at 1] 1]] [def r [+ [bit-shift-left at 1] 2]] [when [and [< l n] [> [array/ref arr l] [array/ref arr top]]] [set! top l]] [when [and [< r n] [> [array/ref arr r] [array/ref arr top]]] [set! top r]] [if [= top at] [set! looping #f] [do [array/swap arr at top] [set! at top]]]] [return arr]]] #{##[at top #t looping bit-shift-left l r n array/ref arr #f array/swap]
1Ai 0
05
1Ai 1
07
0D
1Ai 2
1Ai 3
07
0D
24
1B
09o 176
0D
1C
1Ai 4
05
1Ai 0
05
02i 1
04i 2
02i 1
25
1Ai 5
07
0D
1Ai 4
05
1Ai 0
05
02i 1
04i 2
02i 2
25
1Ai 6
07
0D
1Ai 5
05
1Ai 7
05
1E
0C
0Bo 27
0D
1Ai 8
05
1Ai 9
05
1Ai 5
05
04i 2
1Ai 8
05
1Ai 9
05
1Ai 1
05
04i 2
22
0Bo 12
1Ai 5
05
1Ai 1
08
09o 4
24
0D
1Ai 6
05
1Ai 7
05
1E
0C
0Bo 27
0D
1Ai 8
05
1Ai 9
05
1Ai 6
05
04i 2
1Ai 8
05
1Ai 9
05
1Ai 1
05
04i 2
22
0Bo 12
1Ai 6
05
1Ai 1
08
09o 4
24
0D
1Ai 1
05
1Ai 0
05
20
0Bo 11
1Ai 10
1Ai 3
08
09o 24
1Ai 11
05
1Ai 9
05
1Ai 0
05
1Ai 1
05
04i 3
0D
1Ai 1
05
1Ai 0
08
1Ai 3
05
0Ao -176
0D
1Ai 9
05
01
01
} array/make-heap [arr] #@[source: [[def l [array/length arr]] [def l2 [/ l 2]] [while [>= l2 0] [array/heapify arr l l2] [dec! l2]] [return arr]]] #{##[array/length arr l l2 array/heapify]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
02i 2
28
1Ai 3
07
0D
24
1B
09o 29
0D
1C
1Ai 4
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 3
0D
1Ai 3
05
02i 1
26
1Ai 3
08
1Ai 3
05
02i 0
21
0Ao -32
0D
1Ai 1
05
01
01
} array/heap-sort [arr] #@[source: [[array/make-heap arr] [def l [array/length arr]] [while [> l 0] [dec! l] [array/swap arr 0 l] [array/heapify arr l 0]] [return arr]]] #{##[array/make-heap arr array/length l array/swap array/heapify]
1Ai 0
05
1Ai 1
05
04i 1
0D
1Ai 2
05
1Ai 1
05
04i 1
1Ai 3
07
0D
24
1B
09o 42
0D
1C
1Ai 3
05
02i 1
26
1Ai 3
08
0D
1Ai 4
05
1Ai 1
05
02i 0
1Ai 3
05
04i 3
0D
1Ai 5
05
1Ai 1
05
1Ai 3
05
02i 0
04i 3
1Ai 3
05
02i 0
22
0Ao -45
0D
1Ai 1
05
01
01
} array/sort array/cut [arr start end] #@[documentation: "Return a newly allocated array with the values of ARR from START to END" source: ["Return a newly allocated array with the values of ARR from START to END" [set! start [max 0 start]] [set! end [min [array/length arr] end]] [def ret [array/allocate [max 0 [- end start]]]] [def i start] [while [< i end] [array/set! ret [- i start] [array/ref arr i]] [set! i [add/int i 1]]] [return ret]]] #{##[max start min array/length arr end array/allocate ret i array/set! array/ref]
1Ai 0
05
02i 0
1Ai 1
05
04i 2
1Ai 1
08
0D
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 1
1Ai 5
05
04i 2
1Ai 5
08
0D
1Ai 6
05
1Ai 0
05
02i 0
1Ai 5
05
1Ai 1
05
26
04i 2
04i 1
1Ai 7
07
0D
1Ai 1
05
1Ai 8
07
0D
24
1B
09o 41
0D
1C
1Ai 9
05
1Ai 7
05
1Ai 8
05
1Ai 1
05
26
1Ai 10
05
1Ai 4
05
1Ai 8
05
04i 2
04i 3
0D
1Ai 8
05
02i 1
03
1Ai 8
08
1Ai 8
05
1Ai 5
05
1E
0Ao -45
0D
1Ai 7
05
01
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
17
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 48
1Ai 49
1Ai 50
1Ai 51
17
1Ai 48
07
0D
1Ai 52
1Ai 53
1Ai 54
1Ai 55
17
1Ai 52
07
0D
1Ai 52
05
1Ai 56
07
0D
1Ai 57
1Ai 58
1Ai 59
1Ai 60
17
1Ai 57
07
01
}#{##[sum [c] #@[documentation: "Return the sum of every value in collection C" source: ["Return the sum of every value in collection C" [reduce c + 0]]] #{##[reduce c +]
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 0
04i 3
01
} every? [l p] #@[documentation: "Returns #t if P is true for every entry of collection L" source: ["Returns #t if P is true for every entry of collection L" [reduce l [fn [a b] [and a [p b]]] #t]]] #{##[reduce l anonymous [a b] #@[source: [[and a [p b]]]] #{##[a p b]
1Ai 0
05
0C
0Bo 12
0D
1Ai 1
05
1Ai 2
05
04i 1
01
} #t]
1Ai 0
05
1Ai 1
05
1Ai 2
1Ai 3
1Ai 4
1Ai 5
17
1Ai 6
04i 3
01
} join [l glue] #@[documentation: "Join every element of α together into a string with GLUE inbetween" source: ["Join every element of α together into a string with GLUE inbetween" [when-not glue [set! glue ""]] [if-not l "" [reduce l [fn [a b] [if a [cat a glue b] b]] #nil]]]] #{##[glue "" l reduce anonymous [a b] #@[source: [[if a [cat a glue b] b]]] #{##[a cat glue b]
1Ai 0
05
0Bo 20
1Ai 1
05
1Ai 0
05
1Ai 2
05
1Ai 3
05
04i 3
09o 6
1Ai 3
05
01
}]
1Ai 0
05
0Bo 7
24
09o 8
1Ai 1
1Ai 0
08
0D
1Ai 2
05
0Bo 24
1Ai 3
05
1Ai 2
05
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
24
04i 3
09o 5
1Ai 1
01
} for-each [l f] #@[documentation: "Runs F over every item in collection L" source: ["Runs F over every item in collection L" [reduce l [fn [a b] [f b]] #nil]]] #{##[reduce l anonymous [a b] #@[source: [[f b]]] #{##[f b]
1Ai 0
05
1Ai 1
05
04i 1
01
}]
1Ai 0
05
1Ai 1
05
1Ai 2
1Ai 3
1Ai 4
1Ai 5
17
24
04i 3
01
} count [l p] #@[documentation: "Count the number of items in L where P is true" source: ["Count the number of items in L where P is true" [if p [reduce l [fn [a b] [+ a [if [p b] 1 0]]] 0] [reduce l [fn [a b] [+ a 1]] 0]]]] #{##[p reduce l anonymous [a b] #@[source: [[+ a [if [p b] 1 0]]]] #{##[a p b]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
0Bo 8
02i 1
09o 5
02i 0
25
01
} [a b] #@[source: [[+ a 1]]] #{##[a]
1Ai 0
05
02i 1
25
01
}]
1Ai 0
05
0Bo 25
1Ai 1
05
1Ai 2
05
1Ai 3
1Ai 4
1Ai 5
1Ai 6
17
02i 0
04i 3
09o 22
1Ai 1
05
1Ai 2
05
1Ai 3
1Ai 7
1Ai 8
1Ai 9
17
02i 0
04i 3
01
} min l #@[documentation: "Returns the minimum value of its arguments, or collection" source: ["Returns the minimum value of its arguments, or collection" [reduce [if [cdr l] l [car l]] [fn [a b] [if [< a b] a b]]]]] #{##[reduce l anonymous [a b] #@[source: [[if [< a b] a b]]] #{##[a b]
1Ai 0
05
1Ai 1
05
1E
0Bo 9
1Ai 0
05
09o 6
1Ai 1
05
01
}]
1Ai 0
05
1Ai 1
05
12
0Bo 9
1Ai 1
05
09o 7
1Ai 1
05
11
1Ai 2
1Ai 3
1Ai 4
1Ai 5
17
04i 2
01
} max #@[documentation: "Returns the minimum value of its arguments, or collection" source: ["Returns the minimum value of its arguments, or collection" [reduce [if [cdr l] l [car l]] [fn [a b] [if [> a b] a b]]]]] #{##[reduce l anonymous [a b] #@[source: [[if [> a b] a b]]] #{##[a b]
1Ai 0
05
1Ai 1
05
22
0Bo 9
1Ai 0
05
09o 6
1Ai 1
05
01
}]
1Ai 0
05
1Ai 1
05
12
0Bo 9
1Ai 1
05
09o 7
1Ai 1
05
11
1Ai 2
1Ai 3
1Ai 4
1Ai 5
17
04i 2
01
} delete [l e] #@[documentation: "Returns a filtered list l with all elements equal to e omitted" source: ["Returns a filtered list l with all elements equal to e omitted" [filter l [fn [a] [not [= a e]]]]]] #{##[filter l anonymous [a] #@[source: [[not [= a e]]]] #{##[a e #f #t]
1Ai 0
05
1Ai 1
05
20
0Bo 8
1Ai 2
09o 5
1Ai 3
01
}]
1Ai 0
05
1Ai 1
05
1Ai 2
1Ai 3
1Ai 4
1Ai 5
17
04i 2
01
} remove [l p] #@[documentation: "Returns a filtered list l with all elements where P equal true removed" source: ["Returns a filtered list l with all elements where P equal true removed" [filter l [fn [a] [not [p a]]]]]] #{##[filter l anonymous [a] #@[source: [[not [p a]]]] #{##[p a #f #t]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 8
1Ai 2
09o 5
1Ai 3
01
}]
1Ai 0
05
1Ai 1
05
1Ai 2
1Ai 3
1Ai 4
1Ai 5
17
04i 2
01
} flatten/λ [a b] #@[source: [[cond [[collection? b] [append [reduce b flatten/λ #nil] a]] [#t [cons b a]]]]] #{##[collection? b append reduce flatten/λ a #t]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 26
1Ai 2
05
1Ai 3
05
1Ai 1
05
1Ai 4
05
24
04i 3
1Ai 5
05
04i 2
09o 19
1Ai 6
0Bo 13
1Ai 1
05
1Ai 5
05
14
09o 4
24
01
} flatten [l] #@[documentation: "Flatten a collection of collections into a simple list" source: ["Flatten a collection of collections into a simple list" [if-not [collection? l] l [nreverse [reduce l flatten/λ #nil]]]]] #{##[collection? l nreverse reduce flatten/λ]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 23
1Ai 2
05
1Ai 3
05
1Ai 1
05
1Ai 4
05
24
04i 3
04i 1
09o 6
1Ai 1
05
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 21
1Ai 25
1Ai 26
17
1Ai 24
07
0D
1Ai 27
1Ai 28
1Ai 29
1Ai 30
17
1Ai 27
07
0D
1Ai 31
1Ai 32
1Ai 33
1Ai 34
17
1Ai 31
07
0D
1Ai 35
1Ai 36
1Ai 37
1Ai 38
17
1Ai 35
07
0D
1Ai 39
1Ai 40
1Ai 41
1Ai 42
17
1Ai 39
07
01
}#{##[ref [l i] #@[documentation: "Return whatver is at position I in L" source: ["Return whatver is at position I in L" [case [type-of l] [:nil #nil] [:tree [tree/ref l i]] [:string [char-at l i]] [:array [array/ref l i]] [:pair [list/ref l i]] [otherwise [throw [list :type-error "You can only use ref with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-1 :nil :tree tree/ref i :string char-at :array array/ref :pair list/ref throw list :type-error "You can only use ref with a collection" current-lambda]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 7
24
09o 117
1Ai 2
05
1Ai 4
20
0Bo 17
1Ai 5
05
1Ai 1
05
1Ai 6
05
04i 2
09o 94
1Ai 2
05
1Ai 7
20
0Bo 17
1Ai 8
05
1Ai 1
05
1Ai 6
05
04i 2
09o 71
1Ai 2
05
1Ai 9
20
0Bo 17
1Ai 10
05
1Ai 1
05
1Ai 6
05
04i 2
09o 48
1Ai 2
05
1Ai 11
20
0Bo 17
1Ai 12
05
1Ai 1
05
1Ai 6
05
04i 2
09o 25
1Ai 13
05
1Ai 14
05
1Ai 15
1Ai 16
1Ai 1
05
1Ai 17
05
04i 0
04i 4
04i 1
16
01
} filter [l p] #@[documentation: "Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" source: ["Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" [case [type-of l] [:nil #nil] [:tree [tree/filter l p]] [:pair [list/filter l p]] [:array [array/filter l p]] [otherwise [throw [list :type-error "You can only use filter with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-2 :nil :tree tree/filter p :pair list/filter :array array/filter throw list :type-error "You can only use filter with a collection" current-lambda]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 7
24
09o 94
1Ai 2
05
1Ai 4
20
0Bo 17
1Ai 5
05
1Ai 1
05
1Ai 6
05
04i 2
09o 71
1Ai 2
05
1Ai 7
20
0Bo 17
1Ai 8
05
1Ai 1
05
1Ai 6
05
04i 2
09o 48
1Ai 2
05
1Ai 9
20
0Bo 17
1Ai 10
05
1Ai 1
05
1Ai 6
05
04i 2
09o 25
1Ai 11
05
1Ai 12
05
1Ai 13
1Ai 14
1Ai 1
05
1Ai 15
05
04i 0
04i 4
04i 1
16
01
} reduce [l f α] #@[documentation: "Combine all elements in collection l using operation F and starting value α" source: ["Combine all elements in collection l using operation F and starting value α" [case [type-of l] [:nil α] [:tree [tree/reduce l f α]] [:pair [list/reduce l f α]] [:array [array/reduce l f α]] [otherwise [f α l]]]]] #{##[type-of l ΓεnΣym-3 :nil α :tree tree/reduce f :pair list/reduce :array array/reduce]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 9
1Ai 4
05
09o 92
1Ai 2
05
1Ai 5
20
0Bo 20
1Ai 6
05
1Ai 1
05
1Ai 7
05
1Ai 4
05
04i 3
09o 66
1Ai 2
05
1Ai 8
20
0Bo 20
1Ai 9
05
1Ai 1
05
1Ai 7
05
1Ai 4
05
04i 3
09o 40
1Ai 2
05
1Ai 10
20
0Bo 20
1Ai 11
05
1Ai 1
05
1Ai 7
05
1Ai 4
05
04i 3
09o 14
1Ai 7
05
1Ai 4
05
1Ai 1
05
04i 2
16
01
} length [α] #@[documentation: "Returns the length of collection α" source: ["Returns the length of collection α" [case [type-of α] [:nil 0] [:array [array/length α]] [:pair [list/length α]] [:string [string/length α]] [:tree [tree/size α]] [otherwise [throw [list :type-error "You can only use length with a collection" α [current-lambda]]]]]]] #{##[type-of α ΓεnΣym-4 :nil :array array/length :pair list/length :string string/length :tree tree/size throw list :type-error "You can only use length with a collection" current-lambda]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 8
02i 0
09o 105
1Ai 2
05
1Ai 4
20
0Bo 14
1Ai 5
05
1Ai 1
05
04i 1
09o 85
1Ai 2
05
1Ai 6
20
0Bo 14
1Ai 7
05
1Ai 1
05
04i 1
09o 65
1Ai 2
05
1Ai 8
20
0Bo 14
1Ai 9
05
1Ai 1
05
04i 1
09o 45
1Ai 2
05
1Ai 10
20
0Bo 14
1Ai 11
05
1Ai 1
05
04i 1
09o 25
1Ai 12
05
1Ai 13
05
1Ai 14
1Ai 15
1Ai 1
05
1Ai 16
05
04i 0
04i 4
04i 1
16
01
} map [l f] #@[documentation: "Runs f over every item in collection l and returns the resulting list" source: ["Runs f over every item in collection l and returns the resulting list" [case [type-of l] [:nil #nil] [:pair [list/map l f]] [:array [array/map l f]] [otherwise [throw [list :type-error "You can only use map with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-5 :nil :pair list/map f :array array/map throw list :type-error "You can only use map with a collection" current-lambda]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 7
24
09o 71
1Ai 2
05
1Ai 4
20
0Bo 17
1Ai 5
05
1Ai 1
05
1Ai 6
05
04i 2
09o 48
1Ai 2
05
1Ai 7
20
0Bo 17
1Ai 8
05
1Ai 1
05
1Ai 6
05
04i 2
09o 25
1Ai 9
05
1Ai 10
05
1Ai 11
1Ai 12
1Ai 1
05
1Ai 13
05
04i 0
04i 4
04i 1
16
01
} sort [l] #@[documentation: "Sorts the collection L" source: ["Sorts the collection L" [case [type-of l] [:nil #nil] [:pair [list/sort l]] [:array [array/sort l]] [otherwise [throw [list :type-error "You can only use sort with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-6 :nil :pair list/sort :array array/sort throw list :type-error "You can only use sort with a collection" current-lambda]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 7
24
09o 65
1Ai 2
05
1Ai 4
20
0Bo 14
1Ai 5
05
1Ai 1
05
04i 1
09o 45
1Ai 2
05
1Ai 6
20
0Bo 14
1Ai 7
05
1Ai 1
05
04i 1
09o 25
1Ai 8
05
1Ai 9
05
1Ai 10
1Ai 11
1Ai 1
05
1Ai 12
05
04i 0
04i 4
04i 1
16
01
} member [l m] #@[documentation: "Returns the first pair/item of collection l whose car is equal to m" source: ["Returns the first pair/item of collection l whose car is equal to m" [case [type-of l] [:pair [list/member l m]] [otherwise [throw [list :type-error "You can only use member with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-7 :pair list/member m throw list :type-error "You can only use member with a collection" current-lambda]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 17
1Ai 4
05
1Ai 1
05
1Ai 5
05
04i 2
09o 25
1Ai 6
05
1Ai 7
05
1Ai 8
1Ai 9
1Ai 1
05
1Ai 10
05
04i 0
04i 4
04i 1
16
01
} cut [l start end] #@[documentation: "Return a subcollection of L from START to END" source: ["Return a subcollection of L from START to END" [case [type-of l] [:array [array/cut l start end]] [:pair [list/cut l start end]] [:string [string/cut l start end]] [otherwise [throw [list :type-error "You can only use member with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-8 :array array/cut start end :pair list/cut :string string/cut throw list :type-error "You can only use member with a collection" current-lambda]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 20
1Ai 4
05
1Ai 1
05
1Ai 5
05
1Ai 6
05
04i 3
09o 77
1Ai 2
05
1Ai 7
20
0Bo 20
1Ai 8
05
1Ai 1
05
1Ai 5
05
1Ai 6
05
04i 3
09o 51
1Ai 2
05
1Ai 9
20
0Bo 20
1Ai 10
05
1Ai 1
05
1Ai 5
05
1Ai 6
05
04i 3
09o 25
1Ai 11
05
1Ai 12
05
1Ai 13
1Ai 14
1Ai 1
05
1Ai 15
05
04i 0
04i 4
04i 1
16
01
} collection? [l] #@[source: [[case [type-of l] [[:pair :array :tree] #t] [otherwise #f]]]] #{##[type-of l ΓεnΣym-9 :pair :array :tree #f #t]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0C
0Ao 28
0D
1Ai 2
05
1Ai 4
20
0C
0Ao 17
0D
1Ai 2
05
1Ai 5
20
0C
0Ao 6
0D
1Ai 6
0Bo 8
1Ai 7
09o 5
1Ai 6
16
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
01
}#{##[array->list [arr] #@[source: [[def i [- [array/length arr] 1]] [def ret #nil] [while [>= i 0] [set! ret [cons [array/ref arr i] ret]] [dec! i]] [return ret]]] #{##[array/length arr i ret array/ref]
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
1Ai 2
07
0D
24
1Ai 3
07
0D
24
1B
09o 33
0D
1C
1Ai 4
05
1Ai 1
05
1Ai 2
05
04i 2
1Ai 3
05
14
1Ai 3
08
0D
1Ai 2
05
02i 1
26
1Ai 2
08
1Ai 2
05
02i 0
21
0Ao -36
0D
1Ai 3
05
01
01
} except-last-pair/iter [list rest] #@[documentation: "Iterator for except-last-pair" source: ["Iterator for except-last-pair" [if [nil? [cdr list]] [reverse rest] [except-last-pair/iter [cdr list] [cons [car list] rest]]]]] #{##[nil? list reverse rest except-last-pair/iter]
1Ai 0
05
1Ai 1
05
12
04i 1
0Bo 14
1Ai 2
05
1Ai 3
05
04i 1
09o 20
1Ai 4
05
1Ai 1
05
12
1Ai 1
05
11
1Ai 3
05
14
04i 2
01
} except-last-pair [list] #@[documentation: "Return a copy of LIST without the last pair" source: ["Return a copy of LIST without the last pair" [except-last-pair/iter list #nil]]] #{##[except-last-pair/iter list]
1Ai 0
05
1Ai 1
05
24
04i 2
01
} last-pair [list] #@[documentation: "Return the last pair of LIST" source: ["Return the last pair of LIST" [while [cdr list] [cdr! list]] list]] #{##[list]
24
1B
09o 12
0D
1C
1Ai 0
05
12
1Ai 0
08
1Ai 0
05
12
0Ao -13
0D
1Ai 0
05
01
} make-list [number value] #@[documentation: "Return a list of NUMBER elements containing VALUE in every car" source: ["Return a list of NUMBER elements containing VALUE in every car" [def list #nil] [while [>= [dec! number] 0] [set! list [cons value list]]] list]] #{##[list value number]
24
1Ai 0
07
0D
24
1B
09o 15
0D
1C
1Ai 1
05
1Ai 0
05
14
1Ai 0
08
1Ai 2
05
02i 1
26
1Ai 2
08
02i 0
21
0Ao -24
0D
1Ai 0
05
01
} range [end start step] #@[documentation: "Return a list containing values from START (inclusive) to END (exclusive) by STEP" source: ["Return a list containing values from START (inclusive) to END (exclusive) by STEP" [when-not end [throw [list :arity-error "[range] needs at least a specific end"]]] [when-not start [set! start 0]] [when-not step [set! step 1]] [def pred [if [pos? step] < >]] [def ret #nil] [while [pred start end] [set! ret [cons start ret]] [set! start [+ start step]]] [nreverse ret]]] #{##[end throw list :arity-error "[range] needs at least a specific end" start step 0.0 < > pred ret nreverse]
1Ai 0
05
0Bo 7
24
09o 17
1Ai 1
05
1Ai 2
05
1Ai 3
1Ai 4
04i 2
04i 1
0D
1Ai 5
05
0Bo 7
24
09o 8
02i 0
1Ai 5
08
0D
1Ai 6
05
0Bo 7
24
09o 8
02i 1
1Ai 6
08
0D
1Ai 6
05
1Ai 7
21
0Bo 9
1Ai 8
05
09o 6
1Ai 9
05
1Ai 10
07
0D
24
1Ai 11
07
0D
24
1B
09o 26
0D
1C
1Ai 5
05
1Ai 11
05
14
1Ai 11
08
0D
1Ai 5
05
1Ai 6
05
25
1Ai 5
08
1Ai 10
05
1Ai 5
05
1Ai 0
05
04i 2
0Ao -34
0D
1Ai 12
05
1Ai 11
05
04i 1
01
} list/reduce [l o s] #@[documentation: "Combine all elements in l using operation o and starting value s" source: ["Combine all elements in l using operation o and starting value s" [doseq [e l] [set! s [o s e]]] s]] #{##[l ΓεnΣym-1 e o s]
15
1Ai 0
05
1Ai 1
07
0D
1Ai 1
05
0Bo 49
24
1B
09o 35
0D
1C
1Ai 1
05
11
1Ai 2
07
0D
1Ai 3
05
1Ai 4
05
1Ai 2
05
04i 2
1Ai 4
08
0D
1Ai 1
05
12
1Ai 1
08
1Ai 1
05
0Ao -35
09o 4
24
16
0D
1Ai 4
05
01
} list/ref [l i] #@[documentation: "Returns the the element of list l at location i" source: ["Returns the the element of list l at location i" [while [and l [> i 0]] [dec! i] [cdr! l]] [car l]]] #{##[i l]
24
1B
09o 22
0D
1C
1Ai 0
05
02i 1
26
1Ai 0
08
0D
1Ai 1
05
12
1Ai 1
08
1Ai 1
05
0C
0Bo 10
0D
1Ai 0
05
02i 0
22
0Ao -33
0D
1Ai 1
05
11
01
} reverse [l] #@[documentation: "Return the list l in reverse order" source: ["Return the list l in reverse order" [def ret] [doseq [e l] [set! ret [cons e ret]]] ret]] #{##[ret l ΓεnΣym-2 e]
24
1Ai 0
07
0D
15
1Ai 1
05
1Ai 2
07
0D
1Ai 2
05
0Bo 45
24
1B
09o 31
0D
1C
1Ai 2
05
11
1Ai 3
07
0D
1Ai 3
05
1Ai 0
05
14
1Ai 0
08
0D
1Ai 2
05
12
1Ai 2
08
1Ai 2
05
0Ao -31
09o 4
24
16
0D
1Ai 0
05
01
} list/length [l] #@[documentation: "Returns the length of list l" source: ["Returns the length of list l" [def ret 0] [doseq [e l] [inc! ret]] ret]] #{##[ret l ΓεnΣym-3 e]
02i 0
1Ai 0
07
0D
15
1Ai 1
05
1Ai 2
07
0D
1Ai 2
05
0Bo 44
24
1B
09o 30
0D
1C
1Ai 2
05
11
1Ai 3
07
0D
1Ai 0
05
02i 1
25
1Ai 0
08
0D
1Ai 2
05
12
1Ai 2
08
1Ai 2
05
0Ao -30
09o 4
24
16
0D
1Ai 0
05
01
} list/filter [l p] #@[documentation: "Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" source: ["Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" [def ret #nil] [doseq [e l] [when [p e] [set! ret [cons e ret]]]] [nreverse ret]]] #{##[ret l ΓεnΣym-4 e p nreverse]
24
1Ai 0
07
0D
15
1Ai 1
05
1Ai 2
07
0D
1Ai 2
05
0Bo 60
24
1B
09o 46
0D
1C
1Ai 2
05
11
1Ai 3
07
0D
1Ai 4
05
1Ai 3
05
04i 1
0Bo 16
1Ai 3
05
1Ai 0
05
14
1Ai 0
08
09o 4
24
0D
1Ai 2
05
12
1Ai 2
08
1Ai 2
05
0Ao -46
09o 4
24
16
0D
1Ai 5
05
1Ai 0
05
04i 1
01
} list/map [l f] #@[documentation: "Runs f over every item in list l and returns the resulting list" source: ["Runs f over every item in list l and returns the resulting list" [def ret #nil] [doseq [e l] [set! ret [cons [f e] ret]]] [nreverse ret]]] #{##[ret l ΓεnΣym-5 e f nreverse]
24
1Ai 0
07
0D
15
1Ai 1
05
1Ai 2
07
0D
1Ai 2
05
0Bo 50
24
1B
09o 36
0D
1C
1Ai 2
05
11
1Ai 3
07
0D
1Ai 4
05
1Ai 3
05
04i 1
1Ai 0
05
14
1Ai 0
08
0D
1Ai 2
05
12
1Ai 2
08
1Ai 2
05
0Ao -36
09o 4
24
16
0D
1Ai 5
05
1Ai 0
05
04i 1
01
} append [a b] #@[documentation: "Appends two lists A and B together" source: ["Appends two lists A and B together" [def ret b] [set! a [reverse a]] [doseq [t a] [set! ret [cons t ret]]] ret]] #{##[b ret reverse a ΓεnΣym-6 t]
1Ai 0
05
1Ai 1
07
0D
1Ai 2
05
1Ai 3
05
04i 1
1Ai 3
08
0D
15
1Ai 3
05
1Ai 4
07
0D
1Ai 4
05
0Bo 45
24
1B
09o 31
0D
1C
1Ai 4
05
11
1Ai 5
07
0D
1Ai 5
05
1Ai 1
05
14
1Ai 1
08
0D
1Ai 4
05
12
1Ai 4
08
1Ai 4
05
0Ao -31
09o 4
24
16
0D
1Ai 1
05
01
} sublist [l start end ret] #@[documentation: "Returns a new list containing all elements of l from start to end" source: ["Returns a new list containing all elements of l from start to end" [cond [[nil? l] [reverse ret]] [[neg? end] [sublist l start [+ [length l] end]]] [[zero? end] [reverse ret]] [[> start 0] [sublist [cdr l] [+ -1 start] [+ -1 end] #nil]] [[> end 0] [sublist [cdr l] 0 [+ -1 end] [cons [car l] ret]]]]]] #{##[nil? l reverse ret end 0.0 sublist start length]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 14
1Ai 2
05
1Ai 3
05
04i 1
09o 128
1Ai 4
05
1Ai 5
1E
0Bo 29
1Ai 6
05
1Ai 1
05
1Ai 7
05
1Ai 8
05
1Ai 1
05
04i 1
1Ai 4
05
25
04i 3
09o 93
1Ai 4
05
2A
0Bo 14
1Ai 2
05
1Ai 3
05
04i 1
09o 75
1Ai 7
05
02i 0
22
0Bo 28
1Ai 6
05
1Ai 1
05
12
02i -1
1Ai 7
05
25
02i -1
1Ai 4
05
25
24
04i 4
09o 41
1Ai 4
05
02i 0
22
0Bo 31
1Ai 6
05
1Ai 1
05
12
02i 0
02i -1
1Ai 4
05
25
1Ai 1
05
11
1Ai 3
05
14
04i 4
09o 4
24
01
} list-head [l k] #@[documentation: "Returns the first k elements of list l" source: ["Returns the first k elements of list l" [sublist l 0 k]]] #{##[sublist l k]
1Ai 0
05
1Ai 1
05
02i 0
1Ai 2
05
04i 3
01
} list-tail [l k] #@[documentation: "Returns the sublist of l obtained by omitting the first l elements" source: ["Returns the sublist of l obtained by omitting the first l elements" [sublist l k [length l]]]] #{##[sublist l k length]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 1
05
04i 1
04i 3
01
} list/member [l m] #@[documentation: "Returns the first pair of list l whose car is equal to m" source: ["Returns the first pair of list l whose car is equal to m" [cond [[nil? l] #f] [[= [car l] m] l] [#t [list/member [cdr l] m]]]]] #{##[nil? l #f m #t list/member]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 8
1Ai 2
09o 41
1Ai 1
05
11
1Ai 3
05
20
0Bo 9
1Ai 1
05
09o 24
1Ai 4
0Bo 18
1Ai 5
05
1Ai 1
05
12
1Ai 3
05
04i 2
09o 4
24
01
} getf [l key] #@[documentation: "Return the value in LIST following KEY" source: ["Return the value in LIST following KEY" [cond [[nil? l] #nil] [[= key [car l]] [cadr l]] [#t [getf [cdr l] key]]]]] #{##[nil? l key #t getf]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 7
24
09o 43
1Ai 2
05
1Ai 1
05
11
20
0Bo 11
1Ai 1
05
12
11
09o 24
1Ai 3
0Bo 18
1Ai 4
05
1Ai 1
05
12
1Ai 2
05
04i 2
09o 4
24
01
} list/sort/bubble [l] #@[documentation: "Terribly slow way to sort a list, though it was simple to write" source: ["Terribly slow way to sort a list, though it was simple to write" [if-not l #nil [do [def top [car l]] [def next #nil] [cdr! l] [while l [if [<= [car l] top] [do [set! next [cons top next]] [set! top [car l]]] [set! next [cons [car l] next]]] [cdr! l]] [cons top [list/sort/bubble next]]]]]] #{##[l top next list/sort/bubble]
1Ai 0
05
0Bo 104
1Ai 0
05
11
1Ai 1
07
0D
24
1Ai 2
07
0D
1Ai 0
05
12
1Ai 0
08
0D
24
1B
09o 56
0D
1C
1Ai 0
05
11
1Ai 1
05
1F
0Bo 24
1Ai 1
05
1Ai 2
05
14
1Ai 2
08
0D
1Ai 0
05
11
1Ai 1
08
09o 14
1Ai 0
05
11
1Ai 2
05
14
1Ai 2
08
0D
1Ai 0
05
12
1Ai 0
08
1Ai 0
05
0Ao -56
0D
1Ai 1
05
1Ai 3
05
1Ai 2
05
04i 1
14
09o 4
24
01
} list/merge-sorted-lists [l1 l2] #@[source: [[cond [[nil? l1] l2] [[nil? l2] l1] [#t [if [< [car l1] [car l2]] [cons [car l1] [list/merge-sorted-lists [cdr l1] l2]] [cons [car l2] [list/merge-sorted-lists l1 [cdr l2]]]]]]]] #{##[nil? l1 l2 #t list/merge-sorted-lists]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 9
1Ai 2
05
09o 78
1Ai 0
05
1Ai 2
05
04i 1
0Bo 9
1Ai 1
05
09o 61
1Ai 3
0Bo 55
1Ai 1
05
11
1Ai 2
05
11
1E
0Bo 23
1Ai 1
05
11
1Ai 4
05
1Ai 1
05
12
1Ai 2
05
04i 2
14
09o 20
1Ai 2
05
11
1Ai 4
05
1Ai 1
05
1Ai 2
05
12
04i 2
14
09o 4
24
01
} list/split-half-rec [l acc1 acc2] #@[source: [[cond [[nil? l] [cons acc1 acc2]] [[nil? [cdr l]] [cons [cons [car l] acc1] acc2]] [#t [list/split-half-rec [cddr l] [cons [car l] acc1] [cons [cadr l] acc2]]]]]] #{##[nil? l acc1 acc2 #t list/split-half-rec]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 13
1Ai 2
05
1Ai 3
05
14
09o 66
1Ai 0
05
1Ai 1
05
12
04i 1
0Bo 18
1Ai 1
05
11
1Ai 2
05
14
1Ai 3
05
14
09o 39
1Ai 4
0Bo 33
1Ai 5
05
1Ai 1
05
12
12
1Ai 1
05
11
1Ai 2
05
14
1Ai 1
05
12
11
1Ai 3
05
14
04i 3
09o 4
24
01
} list/split-half [l] #@[source: [[list/split-half-rec l #nil #nil]]] #{##[list/split-half-rec l]
1Ai 0
05
1Ai 1
05
24
24
04i 3
01
} list/sort/merge [l] #@[documentation: "Sorts a list" source: ["Sorts a list" [if [nil? [cdr l]] l [do [def parts [list/split-half l]] [list/merge-sorted-lists [list/sort/merge [car parts]] [list/sort/merge [cdr parts]]]]]]] #{##[nil? l list/split-half parts list/merge-sorted-lists list/sort/merge]
1Ai 0
05
1Ai 1
05
12
04i 1
0Bo 9
1Ai 1
05
09o 38
1Ai 2
05
1Ai 1
05
04i 1
1Ai 3
07
0D
1Ai 4
05
1Ai 5
05
1Ai 3
05
11
04i 1
1Ai 5
05
1Ai 3
05
12
04i 1
04i 2
01
} list/sort list? [a] #@[documentation: "Return #t is A is a proper list" source: ["Return #t is A is a proper list" [when-not a [return #f]] [while a [when-not [pair? a] [return #f]] [cdr! a]] [return #t]]] #{##[a #f pair? #t]
1Ai 0
05
0Bo 7
24
09o 6
1Ai 1
01
0D
24
1B
09o 31
0D
1C
1Ai 2
05
1Ai 0
05
04i 1
0Bo 7
24
09o 6
1Ai 1
01
0D
1Ai 0
05
12
1Ai 0
08
1Ai 0
05
0Ao -31
0D
1Ai 3
01
01
} list/equal? [a b] #@[documentation: "#t if A and B are equal" source: ["#t if A and B are equal" [if [pair? a] [and [list/equal? [car a] [car b]] [list/equal? [cdr a] [cdr b]]] [equal? a b]]]] #{##[pair? a list/equal? b equal?]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 37
1Ai 2
05
1Ai 1
05
11
1Ai 3
05
11
04i 2
0C
0Bo 17
0D
1Ai 2
05
1Ai 1
05
12
1Ai 3
05
12
04i 2
09o 14
1Ai 4
05
1Ai 1
05
1Ai 3
05
04i 2
01
} list/take [l count] #@[documentation: "Take the first COUNT elements from list L" source: ["Take the first COUNT elements from list L" [if [<= count 0] #nil [cons [car l] [list/take [cdr l] [- count 1]]]]]] #{##[count l list/take]
1Ai 0
05
02i 0
1F
0Bo 7
24
09o 23
1Ai 1
05
11
1Ai 2
05
1Ai 1
05
12
1Ai 0
05
02i 1
26
04i 2
14
01
} list/drop [l count] #@[documentation: "Drop the final COUNT elements from list L" source: ["Drop the final COUNT elements from list L" [if [<= count 0] l [list/drop [cdr l] [- count 1]]]]] #{##[count l list/drop]
1Ai 0
05
02i 0
1F
0Bo 9
1Ai 1
05
09o 18
1Ai 2
05
1Ai 1
05
12
1Ai 0
05
02i 1
26
04i 2
01
} list/cut [l start end] #@[documentation: "Return a subsequence of L from START to END" source: ["Return a subsequence of L from START to END" [list/take [list/drop l [max 0 start]] [- end [max 0 start]]]]] #{##[list/take list/drop l max start end]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
02i 0
1Ai 4
05
04i 2
04i 2
1Ai 5
05
1Ai 3
05
02i 0
1Ai 4
05
04i 2
26
04i 2
01
} list/replace [l search-for replace-with] #@[documentation: "Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH\nUses [equal?] so we can search/replace lists/trees and other complex data structures" source: ["Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH" "" "Uses [equal?] so we can search/replace lists/trees and other complex data structures" [cond [[not l] #nil] [[equal? l search-for] replace-with] [[equal? [car l] search-for] [cons replace-with [list/replace [cdr l] search-for replace-with]]] [#t [cons [if [pair? [car l]] [list/replace [car l] search-for replace-with] [car l]] [list/replace [cdr l] search-for replace-with]]]]]] #{##[l #f #t equal? search-for replace-with list/replace pair?]
1Ai 0
05
0Bo 8
1Ai 1
09o 5
1Ai 2
0Bo 7
24
09o 119
1Ai 3
05
1Ai 0
05
1Ai 4
05
04i 2
0Bo 9
1Ai 5
05
09o 99
1Ai 3
05
1Ai 0
05
11
1Ai 4
05
04i 2
0Bo 25
1Ai 5
05
1Ai 6
05
1Ai 0
05
12
1Ai 4
05
1Ai 5
05
04i 3
14
09o 62
1Ai 2
0Bo 56
1Ai 7
05
1Ai 0
05
11
04i 1
0Bo 21
1Ai 6
05
1Ai 0
05
11
1Ai 4
05
1Ai 5
05
04i 3
09o 7
1Ai 0
05
11
1Ai 6
05
1Ai 0
05
12
1Ai 4
05
1Ai 5
05
04i 3
14
09o 4
24
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
17
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 48
1Ai 49
1Ai 50
1Ai 51
17
1Ai 48
07
0D
1Ai 52
1Ai 53
1Ai 54
1Ai 55
17
1Ai 52
07
0D
1Ai 56
1Ai 57
1Ai 58
1Ai 59
17
1Ai 56
07
0D
1Ai 60
1Ai 61
1Ai 62
1Ai 63
17
1Ai 60
07
0D
1Ai 64
1Ai 65
1Ai 66
1Ai 67
17
1Ai 64
07
0D
1Ai 68
1Ai 69
1Ai 70
1Ai 71
17
1Ai 68
07
0D
1Ai 72
1Ai 73
1Ai 74
1Ai 75
17
1Ai 72
07
0D
1Ai 76
1Ai 77
1Ai 78
1Ai 79
17
1Ai 76
07
0D
1Ai 80
1Ai 81
1Ai 82
1Ai 83
17
1Ai 80
07
0D
1Ai 84
1Ai 85
1Ai 86
1Ai 87
17
1Ai 84
07
0D
1Ai 88
1Ai 89
1Ai 90
1Ai 91
17
1Ai 88
07
0D
1Ai 88
05
1Ai 92
07
0D
1Ai 93
1Ai 94
1Ai 95
1Ai 96
17
1Ai 93
07
0D
1Ai 97
1Ai 98
1Ai 99
1Ai 100
17
1Ai 97
07
0D
1Ai 101
1Ai 102
1Ai 103
1Ai 104
17
1Ai 101
07
0D
1Ai 105
1Ai 106
1Ai 107
1Ai 108
17
1Ai 105
07
0D
1Ai 109
1Ai 110
1Ai 111
1Ai 112
17
1Ai 109
07
0D
1Ai 113
1Ai 114
1Ai 115
1Ai 116
17
1Ai 113
07
01
}#{##[tree/zip [keys values] #@[documentation: "Return a tree where KEYS point to VALUES" source: ["Return a tree where KEYS point to VALUES" [def ret [tree/new #nil]] [doseq [key keys] [tree/set! ret key [car values]] [cdr! values]] ret]] #{##[tree/new ret keys ΓεnΣym-1 key tree/set! values]
1Ai 0
05
24
04i 1
1Ai 1
07
0D
15
1Ai 2
05
1Ai 3
07
0D
1Ai 3
05
0Bo 58
24
1B
09o 44
0D
1C
1Ai 3
05
11
1Ai 4
07
0D
1Ai 5
05
1Ai 1
05
1Ai 4
05
1Ai 6
05
11
04i 3
0D
1Ai 6
05
12
1Ai 6
08
0D
1Ai 3
05
12
1Ai 3
08
1Ai 3
05
0Ao -44
09o 4
24
16
0D
1Ai 1
05
01
} tree/+= [t k v] #@[documentation: "Increment value at K in T by V" source: ["Increment value at K in T by V" [tree/set! t k [+ v [int [or [tree/ref t k] 0]]]]]] #{##[tree/set! t k v int tree/ref #f]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 1
05
1Ai 2
05
04i 2
0C
0Ao 13
0D
02i 0
0C
0Ao 6
0D
1Ai 6
04i 1
25
04i 3
01
} tree/-= [t k v] #@[documentation: "Decrement value at K in T by V" source: ["Decrement value at K in T by V" [quasiquote [tree/+= [unquote t] [unquote k] [- [unquote v]]]]]] #{##[tree/+= t k - v]
1Ai 0
1Ai 1
05
1Ai 2
05
1Ai 3
1Ai 4
05
24
14
14
24
14
14
14
14
01
} tree/++ [t k] #@[documentation: "Increment value at K in T by 1" source: ["Increment value at K in T by 1" [quasiquote [tree/+= [unquote t] [unquote k] 1]]]] #{##[tree/+= t k]
1Ai 0
1Ai 1
05
1Ai 2
05
02i 1
24
14
14
14
14
01
} tree/-- [t k] #@[documentation: "Increment value at K in T by 1" source: ["Increment value at K in T by 1" [quasiquote [tree/-= [unquote t] [unquote k] 1]]]] #{##[tree/-= t k]
1Ai 0
1Ai 1
05
1Ai 2
05
02i 1
24
14
14
14
14
01
} tree/equal? [a b] #@[documentation: "Compares two trees for equality" source: ["Compares two trees for equality" [if [and [tree? a] [tree? b]] [and [= [tree/key* a] [tree/key* b]] [equal? [tree/value* a] [tree/value* b]] [tree/equal? [tree/left* a] [tree/left* b]] [tree/equal? [tree/right* a] [tree/right* b]]] [equal? a b]]]] #{##[tree? a b tree/key* equal? tree/value* tree/equal? tree/left* tree/right*]
1Ai 0
05
1Ai 1
05
04i 1
0C
0Bo 12
0D
1Ai 0
05
1Ai 2
05
04i 1
0Bo 101
1Ai 3
05
1Ai 1
05
04i 1
1Ai 3
05
1Ai 2
05
04i 1
20
0C
0Bo 77
0D
1Ai 4
05
1Ai 5
05
1Ai 1
05
04i 1
1Ai 5
05
1Ai 2
05
04i 1
04i 2
0C
0Bo 51
0D
1Ai 6
05
1Ai 7
05
1Ai 1
05
04i 1
1Ai 7
05
1Ai 2
05
04i 1
04i 2
0C
0Bo 25
0D
1Ai 6
05
1Ai 8
05
1Ai 1
05
04i 1
1Ai 8
05
1Ai 2
05
04i 1
04i 2
09o 14
1Ai 4
05
1Ai 1
05
1Ai 2
05
04i 2
01
} tree/reduce [l o s] #@[documentation: "Combine all elements in l using operation o and starting value s" source: ["Combine all elements in l using operation o and starting value s" [list/reduce [tree/values l] o s]]] #{##[list/reduce tree/values l o s]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
1Ai 3
05
1Ai 4
05
04i 3
01
} tree/filter [l f] #@[documentation: "Return a new tree with all elements from L where F retunrs true" source: ["Return a new tree with all elements from L where F retunrs true" [def ret [tree/new #nil]] [doseq [e [tree/keys l]] [def t [tree/ref l e]] [when [f t] [tree/set! ret e t]]] ret]] #{##[tree/new ret tree/keys l ΓεnΣym-2 e tree/ref t f tree/set!]
1Ai 0
05
24
04i 1
1Ai 1
07
0D
15
1Ai 2
05
1Ai 3
05
04i 1
1Ai 4
07
0D
1Ai 4
05
0Bo 79
24
1B
09o 65
0D
1C
1Ai 4
05
11
1Ai 5
07
0D
1Ai 6
05
1Ai 3
05
1Ai 5
05
04i 2
1Ai 7
07
0D
1Ai 8
05
1Ai 7
05
04i 1
0Bo 20
1Ai 9
05
1Ai 1
05
1Ai 5
05
1Ai 7
05
04i 3
09o 4
24
0D
1Ai 4
05
12
1Ai 4
08
1Ai 4
05
0Ao -65
09o 4
24
16
0D
1Ai 1
05
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
18
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
18
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
18
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
01
}#{##[compile/backend/none [expr] #@[source: [expr]] #{##[expr]
1Ai 0
05
01
} compile/backend/bytecode [expr] #@[source: [[-> [bytecompile expr] assemble*]]] #{##[assemble* bytecompile expr]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
01
} :bytecode *active-backend* tree/new :none backend/tree backend [expr] #@[source: [[[tree/ref backend/tree *active-backend*] expr]]] #{##[tree/ref backend/tree *active-backend* expr]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
1Ai 3
05
04i 1
01
} compile/for [backend expr environment] #@[source: [[def last-backend *active-backend*] [def ret #nil] [try [fn [e] [set! *active-backend* last-backend] [throw e]] [set! *active-backend* backend] [set! ret [compile expr environment]] [set! *active-backend* last-backend] [return ret]]]] #{##[*active-backend* last-backend ret anonymous [e] #@[source: [[set! *active-backend* last-backend] [throw e]]] #{##[last-backend *active-backend* throw e]
1Ai 0
05
1Ai 1
08
0D
1Ai 2
05
1Ai 3
05
04i 1
01
} backend compile* expr current-closure]
1Ai 0
05
1Ai 1
07
0D
24
1Ai 2
07
0D
1Ai 3
1Ai 4
1Ai 5
1Ai 6
17
19o 39
1Ai 7
05
1Ai 0
08
0D
1Ai 8
05
1Ai 9
05
1Ai 10
05
04i 0
04i 2
1Ai 2
08
0D
1Ai 1
05
1Ai 0
08
0D
1Ai 2
05
01
16
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
07
0D
1Ai 10
05
1Ai 8
1Ai 4
05
1Ai 11
1Ai 0
05
04i 4
1Ai 12
07
0D
1Ai 13
1Ai 14
1Ai 15
1Ai 16
17
1Ai 13
07
0D
1Ai 17
1Ai 18
1Ai 19
1Ai 20
17
1Ai 17
07
01
}#{##[$nop [] #@[documentation: "[] -> []\nDo nothing" source: ["[] -> []" "Do nothing" :inline '[#$0]] inline: #t] #{##[[#$0]]
1Ai 0
01
} $ret [] #@[documentation: "[a] -> []\nReturn top of value stack" source: ["[a] -> []" "Return top of value stack" :inline '[#$1]] inline: #t] #{##[[#$1]]
1Ai 0
01
} $add/int [] #@[documentation: "[a b] -> [result]\nAdds the two topmost values and pushes the result" source: ["[a b] -> [result]" "Adds the two topmost values and pushes the result" :inline '[#$3]] inline: #t] #{##[[#$3]]
1Ai 0
01
} $get [] #@[documentation: "[s] -> [a]\nResolve symbol S and put whatever is bound to it in the current context on the stack" source: ["[s] -> [a]" "Resolve symbol S and put whatever is bound to it in the current context on the stack" :inline '[#$5]] inline: #t] #{##[[#$5]]
1Ai 0
01
} $def/new [] #@[documentation: "[s v] -> [v]\nDefine S to resolve to V in the current environment" source: ["[s v] -> [v]" "Define S to resolve to V in the current environment" :inline '[#$7]] inline: #t] #{##[[#$7]]
1Ai 0
01
} $set/new [] #@[documentation: "[s v] -> [v]\nSet S to resolve to V in the current environment" source: ["[s v] -> [v]" "Set S to resolve to V in the current environment" :inline '[#$8]] inline: #t] #{##[[#$8]]
1Ai 0
01
} $dup [] #@[documentation: "[a] -> [a a]\nDuplicates the value that is on the top of the stack" source: ["[a] -> [a a]" "Duplicates the value that is on the top of the stack" :inline '[#$C]] inline: #t] #{##[[#$C]]
1Ai 0
01
} $drop [] #@[documentation: "[a] -> []\nDrop whatever is on top of the stack" source: ["[a] -> []" "Drop whatever is on top of the stack" :inline '[#$D]] inline: #t] #{##[[#$D]]
1Ai 0
01
} $closure/push [] #@[documentation: "[] -> [closure]\nPush the current closure as a λ on the stack" source: ["[] -> [closure]" "Push the current closure as a λ on the stack" :inline '[#$13]] inline: #t] #{##[[#$13]]
1Ai 0
01
} $let [] #@[documentation: "[] -> []\nCreate a new let closure and switch to it" source: ["[] -> []" "Create a new let closure and switch to it" :inline '[#$15]] inline: #t] #{##[[#$15]]
1Ai 0
01
} $closure/pop [] #@[documentation: "[] -> []\nLeave the current closure and return to the parent one" source: ["[] -> []" "Leave the current closure and return to the parent one" :inline '[#$16]] inline: #t] #{##[[#$16]]
1Ai 0
01
} $roots/save [] #@[documentation: "[] -> []\nStore the current root stack pointer used for guarding allocations into the current closure" source: ["[] -> []" "Store the current root stack pointer used for guarding allocations into the current closure" :inline '[#$1B]] inline: #t] #{##[[#$1B]]
1Ai 0
01
} $roots/restore [] #@[documentation: "[] -> []\nRestore the current root stack pointer to what is stored within the current closure" source: ["[] -> []" "Restore the current root stack pointer to what is stored within the current closure" :inline '[#$1C]] inline: #t] #{##[[#$1C]]
1Ai 0
01
} $< [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$1E]] inline: #t] #{##[[#$1E]]
1Ai 0
01
} $<= [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$1F]] inline: #t] #{##[[#$1F]]
1Ai 0
01
} $= [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$20]] inline: #t] #{##[[#$20]]
1Ai 0
01
} $>= [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$21]] inline: #t] #{##[[#$21]]
1Ai 0
01
} $> [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$22]] inline: #t] #{##[[#$22]]
1Ai 0
01
} $push/nil [] #@[documentation: "[] -> [nil]\nPush a #nil on the stack" source: ["[] -> [nil]" "Push a #nil on the stack" :inline '[#$24]] inline: #t] #{##[[#$24]]
1Ai 0
01
} $car [] #@[documentation: "[l] -> [car]\nReplace L with its car" source: ["[l] -> [car]" "Replace L with its car" :inline '[#$11]] inline: #t] #{##[[#$11]]
1Ai 0
01
} $cdr [] #@[documentation: "[l] -> [cdr]\nReplace L with its cdr" source: ["[l] -> [cdr]" "Replace L with its cdr" :inline '[#$12]] inline: #t] #{##[[#$12]]
1Ai 0
01
} $cons [] #@[documentation: "[car cdr] -> [pair]\nCons CAR and CDR together and put it on the stack" source: ["[car cdr] -> [pair]" "Cons CAR and CDR together and put it on the stack" :inline '[#$14]] inline: #t] #{##[[#$14]]
1Ai 0
01
} $fn/dynamic [] #@[documentation: "[name args docs body] -> [λ]\nCreate a new λ" source: ["[name args docs body] -> [λ]" "Create a new λ" :inline '[#$17]] inline: #t] #{##[[#$17]]
1Ai 0
01
} $macro/dynamic [] #@[documentation: "[name args docs body] -> [μ]\nCreate a new μ" source: ["[name args docs body] -> [μ]" "Create a new μ" :inline '[#$18]] inline: #t] #{##[[#$18]]
1Ai 0
01
} $add [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$25]] inline: #t] #{##[[#$25]]
1Ai 0
01
} $sub [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$26]] inline: #t] #{##[[#$26]]
1Ai 0
01
} $mul [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$27]] inline: #t] #{##[[#$27]]
1Ai 0
01
} $div [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$28]] inline: #t] #{##[[#$28]]
1Ai 0
01
} $rem [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$29]] inline: #t] #{##[[#$29]]
1Ai 0
01
} $zero? [] #@[documentation: "[a] -> [result]" source: ["[a] -> [result]" :inline '[#$2A]] inline: #t] #{##[[#$2A]]
1Ai 0
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
17
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 48
1Ai 49
1Ai 50
1Ai 51
17
1Ai 48
07
0D
1Ai 52
1Ai 53
1Ai 54
1Ai 55
17
1Ai 52
07
0D
1Ai 56
1Ai 57
1Ai 58
1Ai 59
17
1Ai 56
07
0D
1Ai 60
1Ai 61
1Ai 62
1Ai 63
17
1Ai 60
07
0D
1Ai 64
1Ai 65
1Ai 66
1Ai 67
17
1Ai 64
07
0D
1Ai 68
1Ai 69
1Ai 70
1Ai 71
17
1Ai 68
07
0D
1Ai 72
1Ai 73
1Ai 74
1Ai 75
17
1Ai 72
07
0D
1Ai 76
1Ai 77
1Ai 78
1Ai 79
17
1Ai 76
07
0D
1Ai 80
1Ai 81
1Ai 82
1Ai 83
17
1Ai 80
07
0D
1Ai 84
1Ai 85
1Ai 86
1Ai 87
17
1Ai 84
07
0D
1Ai 88
1Ai 89
1Ai 90
1Ai 91
17
1Ai 88
07
0D
1Ai 92
1Ai 93
1Ai 94
1Ai 95
17
1Ai 92
07
0D
1Ai 96
1Ai 97
1Ai 98
1Ai 99
17
1Ai 96
07
0D
1Ai 100
1Ai 101
1Ai 102
1Ai 103
17
1Ai 100
07
0D
1Ai 104
1Ai 105
1Ai 106
1Ai 107
17
1Ai 104
07
0D
1Ai 108
1Ai 109
1Ai 110
1Ai 111
17
1Ai 108
07
0D
1Ai 112
1Ai 113
1Ai 114
1Ai 115
17
1Ai 112
07
0D
1Ai 116
1Ai 117
1Ai 118
1Ai 119
17
1Ai 116
07
01
}#{##[sym->bytecode-op [v] #@[source: [[def i [sym->index v]] [list [int->bytecode-op [bit-and [bit-shift-right i 16] 255]] [int->bytecode-op [bit-and [bit-shift-right i 8] 255]] [int->bytecode-op [bit-and i 255]]]]] #{##[sym->index v i list int->bytecode-op bit-and bit-shift-right 255]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 6
05
1Ai 2
05
02i 16
04i 2
1Ai 7
04i 2
04i 1
1Ai 4
05
1Ai 5
05
1Ai 6
05
1Ai 2
05
02i 8
04i 2
1Ai 7
04i 2
04i 1
1Ai 4
05
1Ai 5
05
1Ai 2
05
1Ai 7
04i 2
04i 1
04i 3
01
} int-fit-in-byte? [a] #@[source: [[and [<= a 127] [>= a -128]]]] #{##[a]
1Ai 0
05
02i 127
1F
0C
0Bo 10
0D
1Ai 0
05
02i -128
21
01
} $push/int [a] #@[documentation: "[] -> [a]\nPush A on the stack as an :int" source: ["[] -> [a]" "Push A on the stack as an :int" [if [int-fit-in-byte? a] [$push/int/byte a] [$push/val a]]]] #{##[int-fit-in-byte? a $push/int/byte $push/val]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 14
1Ai 2
05
1Ai 1
05
04i 1
09o 11
1Ai 3
05
1Ai 1
05
04i 1
01
} $push/int/byte [a] #@[documentation: "[] -> [a]\nPush A on the stack as an :int that fits within a byte" source: ["[] -> [a]" "Push A on the stack as an :int that fits within a byte" [when-not [int-fit-in-byte? a] [throw [list :invalid-bc-op "$push/int/byte can only push a signed 8-bit value" a [current-lambda]]]] [list #$2 [int->bytecode-op a]]]] #{##[int-fit-in-byte? a throw list :invalid-bc-op "$push/int/byte can only push a signed 8-bit value" current-lambda #$2 int->bytecode-op]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 7
24
09o 25
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 5
1Ai 1
05
1Ai 6
05
04i 0
04i 4
04i 1
0D
1Ai 3
05
1Ai 7
1Ai 8
05
1Ai 1
05
04i 1
04i 2
01
} $def [sym] #@[documentation: "[val] -> [val]\nDefine a new binding for SYM and associate VAL to it" source: ["[val] -> [val]" "Define a new binding for SYM and associate VAL to it" [list #$E [sym->bytecode-op sym]]]] #{##[list #$E sym->bytecode-op sym]
1Ai 0
05
1Ai 1
1Ai 2
05
1Ai 3
05
04i 1
04i 2
01
} $set [sym] #@[documentation: "[val] -> [val]\nUpdate the binding for SYM and associate VAL to it" source: ["[val] -> [val]" "Update the binding for SYM and associate VAL to it" [list #$F [sym->bytecode-op sym]]]] #{##[list #$F sym->bytecode-op sym]
1Ai 0
05
1Ai 1
1Ai 2
05
1Ai 3
05
04i 1
04i 2
01
} $apply/optimize? [fun arg-count] #@[source: [[case fun [[+ - * / rem] [= arg-count 2]] [[zero? car cdr add/int cons < <= = >= >] #t]]]] #{##[fun ΓεnΣym-1 + - * / rem #f arg-count zero? car cdr add/int cons < <= = >= > #t]
15
1Ai 0
05
1Ai 1
07
0D
1Ai 1
05
1Ai 2
05
20
0C
0Ao 54
0D
1Ai 1
05
1Ai 3
05
20
0C
0Ao 42
0D
1Ai 1
05
1Ai 4
05
20
0C
0Ao 30
0D
1Ai 1
05
1Ai 5
05
20
0C
0Ao 18
0D
1Ai 1
05
1Ai 6
05
20
0C
0Ao 6
0D
1Ai 7
0Bo 12
1Ai 8
05
02i 2
20
09o 134
1Ai 1
05
1Ai 9
05
20
0C
0Ao 114
0D
1Ai 1
05
1Ai 10
05
20
0C
0Ao 102
0D
1Ai 1
05
1Ai 11
05
20
0C
0Ao 90
0D
1Ai 1
05
1Ai 12
05
20
0C
0Ao 78
0D
1Ai 1
05
1Ai 13
05
20
0C
0Ao 66
0D
1Ai 1
05
1Ai 14
05
20
0C
0Ao 54
0D
1Ai 1
05
1Ai 15
05
20
0C
0Ao 42
0D
1Ai 1
05
1Ai 16
05
20
0C
0Ao 30
0D
1Ai 1
05
1Ai 17
05
20
0C
0Ao 18
0D
1Ai 1
05
1Ai 18
05
20
0C
0Ao 6
0D
1Ai 7
0Bo 8
1Ai 19
09o 4
24
16
01
} $apply [arg-count fun] #@[documentation: "arguments -> [result]\nRead arg-count arguments from the stack, apply the to fun and push the result on the stack" source: ["arguments -> [result]" "Read arg-count arguments from the stack, apply the to fun and push the result on the stack" [case arg-count [1 [case fun [car [$car]] [cdr [$cdr]] [zero? [$zero?]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]] [2 [case fun [add/int [$add/int]] [+ [$add]] [- [$sub]] [* [$mul]] [/ [$div]] [rem [$rem]] [cons [$cons]] [< [$<]] [<= [$<=]] [= [$=]] [>= [$>=]] [> [$>]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]]] #{##[arg-count ΓεnΣym-2 fun ΓεnΣym-3 car [#$11] cdr [#$12] zero? [#$2A] throw list :arity-error "Wrong number of arguments for that function" current-lambda ΓεnΣym-4 add/int [#$3] + [#$25] - [#$26] * [#$27] / [#$28] rem [#$29] cons [#$14] < [#$1E] <= [#$1F] = [#$20] >= [#$21] > [#$22]]
15
1Ai 0
05
1Ai 1
07
0D
1Ai 1
05
02i 1
20
0Bo 82
15
1Ai 2
05
1Ai 3
07
0D
1Ai 3
05
1Ai 4
05
20
0Bo 8
1Ai 5
09o 55
1Ai 3
05
1Ai 6
05
20
0Bo 8
1Ai 7
09o 40
1Ai 3
05
1Ai 8
05
20
0Bo 8
1Ai 9
09o 25
1Ai 10
05
1Ai 11
05
1Ai 12
1Ai 13
1Ai 2
05
1Ai 14
05
04i 0
04i 4
04i 1
16
09o 248
1Ai 1
05
02i 2
20
0Bo 217
15
1Ai 2
05
1Ai 15
07
0D
1Ai 15
05
1Ai 16
05
20
0Bo 8
1Ai 17
09o 190
1Ai 15
05
1Ai 18
05
20
0Bo 8
1Ai 19
09o 175
1Ai 15
05
1Ai 20
05
20
0Bo 8
1Ai 21
09o 160
1Ai 15
05
1Ai 22
05
20
0Bo 8
1Ai 23
09o 145
1Ai 15
05
1Ai 24
05
20
0Bo 8
1Ai 25
09o 130
1Ai 15
05
1Ai 26
05
20
0Bo 8
1Ai 27
09o 115
1Ai 15
05
1Ai 28
05
20
0Bo 8
1Ai 29
09o 100
1Ai 15
05
1Ai 30
05
20
0Bo 8
1Ai 31
09o 85
1Ai 15
05
1Ai 32
05
20
0Bo 8
1Ai 33
09o 70
1Ai 15
05
1Ai 34
05
20
0Bo 8
1Ai 35
09o 55
1Ai 15
05
1Ai 36
05
20
0Bo 8
1Ai 37
09o 40
1Ai 15
05
1Ai 38
05
20
0Bo 8
1Ai 39
09o 25
1Ai 10
05
1Ai 11
05
1Ai 12
1Ai 13
1Ai 2
05
1Ai 14
05
04i 0
04i 4
04i 1
16
09o 25
1Ai 10
05
1Ai 11
05
1Ai 12
1Ai 13
1Ai 2
05
1Ai 14
05
04i 0
04i 4
04i 1
16
01
} $apply/dynamic [arg-count fun] #@[source: [[when [> arg-count 255] [exception :arity-error "Functions can only take up to 255 arguments directly, you can use [apply] instead though" arg-count]] [list #$4 [int->bytecode-op arg-count]]]] #{##[arg-count 255 throw list :arity-error "Functions can only take up to 255 arguments directly, you can use [apply] instead though" current-lambda #$4 int->bytecode-op]
1Ai 0
05
1Ai 1
22
0Bo 28
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 5
1Ai 0
05
1Ai 6
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 3
05
1Ai 7
1Ai 8
05
1Ai 0
05
04i 1
04i 2
01
} $try [target] #@[documentation: "[] -> []\nTry something, jumping to target if an exception occurs" source: ["[] -> []" "Try something, jumping to target if an exception occurs" [list #$19 [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[list #$19 :relocate target int->bytecode-op]
1Ai 0
05
1Ai 1
1Ai 0
05
1Ai 2
1Ai 3
05
02i 8
02i 0
1Ai 4
05
02i 0
04i 1
04i 5
1Ai 0
05
1Ai 2
1Ai 3
05
02i 0
02i 1
1Ai 4
05
02i 0
04i 1
04i 5
04i 3
01
} $jmp [target] #@[source: [[list #$9 [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[list #$9 :relocate target int->bytecode-op]
1Ai 0
05
1Ai 1
1Ai 0
05
1Ai 2
1Ai 3
05
02i 8
02i 0
1Ai 4
05
02i 0
04i 1
04i 5
1Ai 0
05
1Ai 2
1Ai 3
05
02i 0
02i 1
1Ai 4
05
02i 0
04i 1
04i 5
04i 3
01
} $push/val [v] #@[documentation: "[] -> [v]\nPushes v onto the stack" source: ["[] -> [v]" "Pushes v onto the stack" [when [nil? v] [throw [list :invalid-bc-op "Can't push #nil as a normal lVal" v [current-lambda]]]] [list #$1A [list :literal v]]]] #{##[nil? v throw list :invalid-bc-op "Can't push #nil as a normal lVal" current-lambda #$1A :literal]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 28
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 5
1Ai 1
05
1Ai 6
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 3
05
1Ai 7
1Ai 3
05
1Ai 8
1Ai 1
05
04i 2
04i 2
01
} $push/val/ext $jt [target] #@[source: [[list #$A [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[list #$A :relocate target int->bytecode-op]
1Ai 0
05
1Ai 1
1Ai 0
05
1Ai 2
1Ai 3
05
02i 8
02i 0
1Ai 4
05
02i 0
04i 1
04i 5
1Ai 0
05
1Ai 2
1Ai 3
05
02i 0
02i 1
1Ai 4
05
02i 0
04i 1
04i 5
04i 3
01
} $jf [target] #@[source: [[list #$B [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[list #$B :relocate target int->bytecode-op]
1Ai 0
05
1Ai 1
1Ai 0
05
1Ai 2
1Ai 3
05
02i 8
02i 0
1Ai 4
05
02i 0
04i 1
04i 5
1Ai 0
05
1Ai 2
1Ai 3
05
02i 0
02i 1
1Ai 4
05
02i 0
04i 1
04i 5
04i 3
01
} $fn [name args docs body] #@[source: [[list #$25 [val->bytecode-op name] [val->bytecode-op args] [val->bytecode-op docs] [val->bytecode-op body]]]] #{##[list #$25 val->bytecode-op name args docs body]
1Ai 0
05
1Ai 1
1Ai 2
05
1Ai 3
05
04i 1
1Ai 2
05
1Ai 4
05
04i 1
1Ai 2
05
1Ai 5
05
04i 1
1Ai 2
05
1Ai 6
05
04i 1
04i 5
01
} $macro* [name args docs body] #@[source: [[list #$26 [val->bytecode-op name] [val->bytecode-op args] [val->bytecode-op docs] [val->bytecode-op body]]]] #{##[list #$26 val->bytecode-op name args docs body]
1Ai 0
05
1Ai 1
1Ai 2
05
1Ai 3
05
04i 1
1Ai 2
05
1Ai 4
05
04i 1
1Ai 2
05
1Ai 5
05
04i 1
1Ai 2
05
1Ai 6
05
04i 1
04i 5
01
} assemble/build-sym-map [code sym-map pos] #@[source: [[while code [case [type-of [car code]] [:bytecode-op [tree/set! sym-map :last-op [inc! pos]]] [:keyword [case [car code] [:label [tree/set! sym-map [cadr code] pos] [cdr! code]] [:literal [cdr! code]]]] [:pair [set! pos [assemble/build-sym-map [car code] sym-map pos]]]] [cdr! code]] [return pos]]] #{##[type-of code ΓεnΣym-5 :bytecode-op tree/set! sym-map :last-op pos :keyword ΓεnΣym-6 :label :literal :pair assemble/build-sym-map]
24
1B
09o 168
0D
1C
15
1Ai 0
05
1Ai 1
05
11
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 25
1Ai 4
05
1Ai 5
05
1Ai 6
1Ai 7
05
02i 1
25
1Ai 7
08
04i 3
09o 112
1Ai 2
05
1Ai 8
20
0Bo 72
15
1Ai 1
05
11
1Ai 9
07
0D
1Ai 9
05
1Ai 10
20
0Bo 30
1Ai 4
05
1Ai 5
05
1Ai 1
05
12
11
1Ai 7
05
04i 3
0D
1Ai 1
05
12
1Ai 1
08
09o 23
1Ai 9
05
1Ai 11
20
0Bo 13
1Ai 1
05
12
1Ai 1
08
09o 4
24
16
09o 34
1Ai 2
05
1Ai 12
20
0Bo 24
1Ai 13
05
1Ai 1
05
11
1Ai 5
05
1Ai 7
05
04i 3
1Ai 7
08
09o 4
24
16
0D
1Ai 1
05
12
1Ai 1
08
1Ai 1
05
0Ao -168
0D
1Ai 7
05
01
01
} assemble/relocate-op [code sym-map pos out] #@[source: [[def target [tree/ref sym-map [cadr code]]] [def off [- [+ target [cadddr code]] pos]] [array/set! out [inc! pos] [int->bytecode-op [bit-and [bit-shift-right off [caddr code]] 255]]] [return pos]]] #{##[tree/ref sym-map code target cadddr pos off array/set! out int->bytecode-op bit-and bit-shift-right caddr 255]
1Ai 0
05
1Ai 1
05
1Ai 2
05
12
11
04i 2
1Ai 3
07
0D
1Ai 3
05
1Ai 4
05
1Ai 2
05
04i 1
25
1Ai 5
05
26
1Ai 6
07
0D
1Ai 7
05
1Ai 8
05
1Ai 5
05
02i 1
25
1Ai 5
08
1Ai 9
05
1Ai 10
05
1Ai 11
05
1Ai 6
05
1Ai 12
05
1Ai 2
05
04i 1
04i 2
1Ai 13
04i 2
04i 1
04i 3
0D
1Ai 5
05
01
01
} assemble/emit-relocated-ops [code sym-map pos out] #@[source: [[if [= [car code] :relocate] [set! pos [assemble/relocate-op code sym-map pos out]] [doseq [op code] [case [type-of op] [:bytecode-op [array/set! out [inc! pos] op]] [:pair [set! pos [assemble/emit-relocated-ops op sym-map pos out]]]]]] [return pos]]] #{##[code :relocate assemble/relocate-op sym-map pos out ΓεnΣym-7 op type-of ΓεnΣym-8 :bytecode-op array/set! :pair assemble/emit-relocated-ops]
1Ai 0
05
11
1Ai 1
20
0Bo 26
1Ai 2
05
1Ai 0
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
04i 4
1Ai 4
08
09o 130
15
1Ai 0
05
1Ai 6
07
0D
1Ai 6
05
0Bo 114
24
1B
09o 100
0D
1C
1Ai 6
05
11
1Ai 7
07
0D
15
1Ai 8
05
1Ai 7
05
04i 1
1Ai 9
07
0D
1Ai 9
05
1Ai 10
20
0Bo 26
1Ai 11
05
1Ai 5
05
1Ai 4
05
02i 1
25
1Ai 4
08
1Ai 7
05
04i 3
09o 36
1Ai 9
05
1Ai 12
20
0Bo 26
1Ai 13
05
1Ai 7
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
04i 4
1Ai 4
08
09o 4
24
16
0D
1Ai 6
05
12
1Ai 6
08
1Ai 6
05
0Ao -100
09o 4
24
16
0D
1Ai 4
05
01
01
} literal-index->bytecode-op [i] #@[source: [[if [< i 256] [int->bytecode-op i] [list [int->bytecode-op [bit-and [bit-shift-right i 8] 255]] [int->bytecode-op [bit-and i 255]]]]]] #{##[i 256 int->bytecode-op list bit-and bit-shift-right 255]
1Ai 0
05
1Ai 1
1E
0Bo 14
1Ai 2
05
1Ai 0
05
04i 1
09o 45
1Ai 3
05
1Ai 2
05
1Ai 4
05
1Ai 5
05
1Ai 0
05
02i 8
04i 2
1Ai 6
04i 2
04i 1
1Ai 2
05
1Ai 4
05
1Ai 0
05
1Ai 6
04i 2
04i 1
04i 2
01
} *max-literal-arr* assemble/add-literal [lit lit-arr] #@[source: [[when [>= [array/length lit-arr] 65535] [exception :out-of-bounds "Can only store up to 255 literals per bytecode-arr" code]] [when [not= [type-of lit] :pair] [dotimes [i [array/length lit-arr]] [when [equal? [array/ref lit-arr i] lit] [return [literal-index->bytecode-op i]]]]] [array/length! lit-arr [+ 1 [array/length lit-arr]]] [array/set! lit-arr [- [array/length lit-arr] 1] lit] [literal-index->bytecode-op [- [array/length lit-arr] 1]]]] #{##[array/length lit-arr 65535 throw list :out-of-bounds "Can only store up to 255 literals per bytecode-arr" code current-lambda not= type-of lit :pair i equal? array/ref literal-index->bytecode-op array/length! array/set!]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
21
0Bo 28
1Ai 3
05
1Ai 4
05
1Ai 5
1Ai 6
1Ai 7
05
1Ai 8
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 9
05
1Ai 10
05
1Ai 11
05
04i 1
1Ai 12
04i 2
0Bo 83
15
02i 0
1Ai 13
07
0D
24
1B
09o 50
0D
1C
1Ai 14
05
1Ai 15
05
1Ai 1
05
1Ai 13
05
04i 2
1Ai 11
05
04i 2
0Bo 15
1Ai 16
05
1Ai 13
05
04i 1
01
09o 4
24
0D
02i 1
1Ai 13
05
03
1Ai 13
08
1Ai 13
05
1Ai 0
05
1Ai 1
05
04i 1
1E
0Ao -59
0D
24
16
09o 4
24
0D
1Ai 17
05
1Ai 1
05
02i 1
1Ai 0
05
1Ai 1
05
04i 1
25
04i 2
0D
1Ai 18
05
1Ai 1
05
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
1Ai 11
05
04i 3
0D
1Ai 16
05
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 1
01
} assemble/build-lit-arr [code lit-arr] #@[source: [[when-not code [return #nil]] [cond [[pair? [car code]] [cons [assemble/build-lit-arr [car code] lit-arr] [assemble/build-lit-arr [cdr code] lit-arr]]] [[and [= [car code] #$1A] [= [car [cadr code]] :literal]] [cdr! code] [def index-op [assemble/add-literal [cadar code] lit-arr]] [cons [if [pair? index-op] #$6 #$1A] [cons index-op [assemble/build-lit-arr [cdr code] lit-arr]]]] [[= :literal [car code]] [cdr! code] [cons [assemble/add-literal [car code] lit-arr] [assemble/build-lit-arr [cdr code] lit-arr]]] [otherwise [cons [car code] [assemble/build-lit-arr [cdr code] lit-arr]]]]]] #{##[code pair? assemble/build-lit-arr lit-arr #$1A :literal assemble/add-literal cadar index-op #$6 otherwise]
1Ai 0
05
0Bo 7
24
09o 5
24
01
0D
1Ai 1
05
1Ai 0
05
11
04i 1
0Bo 31
1Ai 2
05
1Ai 0
05
11
1Ai 3
05
04i 2
1Ai 2
05
1Ai 0
05
12
1Ai 3
05
04i 2
14
09o 166
1Ai 0
05
11
1Ai 4
20
0C
0Bo 13
0D
1Ai 0
05
12
11
11
1Ai 5
20
0Bo 69
1Ai 0
05
12
1Ai 0
08
0D
1Ai 6
05
1Ai 7
05
1Ai 0
05
04i 1
1Ai 3
05
04i 2
1Ai 8
07
0D
1Ai 1
05
1Ai 8
05
04i 1
0Bo 8
1Ai 9
09o 5
1Ai 4
1Ai 8
05
1Ai 2
05
1Ai 0
05
12
1Ai 3
05
04i 2
14
14
09o 76
1Ai 5
1Ai 0
05
11
20
0Bo 39
1Ai 0
05
12
1Ai 0
08
0D
1Ai 6
05
1Ai 0
05
11
1Ai 3
05
04i 2
1Ai 2
05
1Ai 0
05
12
1Ai 3
05
04i 2
14
09o 30
1Ai 10
05
0Bo 23
1Ai 0
05
11
1Ai 2
05
1Ai 0
05
12
1Ai 3
05
04i 2
14
09o 4
24
01
} assemble/flatten [code ret] #@[source: [[when-not code [return ret]] [when-not [pair? code] [return ret]] [set! ret [assemble/flatten [cdr code] ret]] [if [and [pair? [car code]] [not [keyword? [caar code]]]] [assemble/flatten [car code] ret] [cons [car code] ret]]]] #{##[code ret pair? assemble/flatten keyword? #f #t]
1Ai 0
05
0Bo 7
24
09o 7
1Ai 1
05
01
0D
1Ai 2
05
1Ai 0
05
04i 1
0Bo 7
24
09o 7
1Ai 1
05
01
0D
1Ai 3
05
1Ai 0
05
12
1Ai 1
05
04i 2
1Ai 1
08
0D
1Ai 2
05
1Ai 0
05
11
04i 1
0C
0Bo 24
0D
1Ai 4
05
1Ai 0
05
11
11
04i 1
0Bo 8
1Ai 5
09o 5
1Ai 6
0Bo 18
1Ai 3
05
1Ai 0
05
11
1Ai 1
05
04i 2
09o 11
1Ai 0
05
11
1Ai 1
05
14
01
} assemble* [code] #@[documentation: "Assemble all arguments into a single :bytecode-array" source: ["Assemble all arguments into a single :bytecode-array" [def sym-map [tree/new #nil]] [def lit-arr [array/new #nil]] [def tmp [-> [assemble/flatten code] [assemble/build-lit-arr lit-arr]]] [assemble/build-sym-map tmp sym-map 0] [def out [array/allocate [tree/ref sym-map :last-op]]] [assemble/emit-relocated-ops tmp sym-map -1 out] [arr->bytecode-arr out lit-arr]]] #{##[tree/new sym-map array/new lit-arr assemble/build-lit-arr assemble/flatten code tmp assemble/build-sym-map array/allocate tree/ref :last-op out assemble/emit-relocated-ops arr->bytecode-arr]
1Ai 0
05
24
04i 1
1Ai 1
07
0D
1Ai 2
05
24
04i 1
1Ai 3
07
0D
1Ai 4
05
1Ai 5
05
1Ai 6
05
04i 1
1Ai 3
05
04i 2
1Ai 7
07
0D
1Ai 8
05
1Ai 7
05
1Ai 1
05
02i 0
04i 3
0D
1Ai 9
05
1Ai 10
05
1Ai 1
05
1Ai 11
04i 2
04i 1
1Ai 12
07
0D
1Ai 13
05
1Ai 7
05
1Ai 1
05
02i -1
1Ai 12
05
04i 4
0D
1Ai 14
05
1Ai 12
05
1Ai 3
05
04i 2
01
} assemble l #@[documentation: "Assemble all arguments into a single :bytecode-array" source: ["Assemble all arguments into a single :bytecode-array" [assemble* l]]] #{##[assemble* l]
1Ai 0
05
1Ai 1
05
04i 1
01
} asmrun ops #@[documentation: "Assemble and evaluate all bytecode arguments" source: ["Assemble and evaluate all bytecode arguments" [quasiquote [apply [current-closure] [assemble [unquote-splicing ops]]]]]] #{##[apply current-closure assemble append ops]
1Ai 0
1Ai 1
24
14
1Ai 2
1Ai 3
05
1Ai 4
05
24
04i 2
14
24
14
14
14
01
} asmdebug #@[documentation: "Assemble and evaluate all bytecode arguments" source: ["Assemble and evaluate all bytecode arguments" [def bc [apply assemble ops]] [disassemble bc] [def v [apply [current-closure] bc #t]] [pfmtln "Result: {:?}{}" v [type-of v]]]] #{##[apply assemble ops bc disassemble current-closure #t v println fmt-arg-0 type-of fmt-arg-1 cat "Result: " string/write]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
1Ai 3
07
0D
1Ai 4
05
1Ai 3
05
04i 1
0D
1Ai 0
05
1Ai 5
05
04i 0
1Ai 3
05
1Ai 6
04i 3
1Ai 7
07
0D
1Ai 8
05
15
1Ai 7
05
1Ai 9
07
0D
1Ai 10
05
1Ai 7
05
04i 1
1Ai 11
07
0D
1Ai 12
05
1Ai 13
1Ai 14
05
1Ai 9
05
04i 1
1Ai 11
05
04i 3
16
04i 1
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
17
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 44
05
1Ai 48
07
0D
1Ai 49
1Ai 50
1Ai 51
1Ai 52
17
1Ai 49
07
0D
1Ai 53
1Ai 54
1Ai 55
1Ai 56
17
1Ai 53
07
0D
1Ai 57
1Ai 58
1Ai 59
1Ai 60
17
1Ai 57
07
0D
1Ai 61
1Ai 62
1Ai 63
1Ai 64
17
1Ai 61
07
0D
1Ai 65
1Ai 66
1Ai 67
1Ai 68
17
1Ai 65
07
0D
1Ai 69
1Ai 70
1Ai 71
1Ai 72
17
1Ai 69
07
0D
1Ai 73
1Ai 74
1Ai 75
1Ai 76
17
1Ai 73
07
0D
1Ai 77
1Ai 78
1Ai 79
1Ai 80
17
1Ai 77
07
0D
02i 0
1Ai 81
07
0D
1Ai 82
1Ai 83
1Ai 84
1Ai 85
17
1Ai 82
07
0D
1Ai 86
1Ai 87
1Ai 88
1Ai 89
17
1Ai 86
07
0D
1Ai 90
1Ai 91
1Ai 92
1Ai 93
17
1Ai 90
07
0D
1Ai 94
1Ai 95
1Ai 96
1Ai 97
17
1Ai 94
07
0D
1Ai 98
1Ai 99
1Ai 100
1Ai 101
17
1Ai 98
07
0D
1Ai 102
1Ai 103
1Ai 104
1Ai 105
18
1Ai 102
07
0D
1Ai 106
1Ai 103
1Ai 107
1Ai 108
17
1Ai 106
07
01
}#{##[bytecompile/gen-label/counter bytecompile/gen-label [prefix] #@[source: [[inc! bytecompile/gen-label/counter] [string->symbol [cat prefix "label-" bytecompile/gen-label/counter]]]] #{##[bytecompile/gen-label/counter string->symbol cat prefix "label-"]
1Ai 0
05
02i 1
25
1Ai 0
08
0D
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 0
05
04i 3
04i 1
01
} bytecompile/literal [source] #@[source: [[case [type-of source] [:int [$push/int source]] [:nil [$push/nil]] [:symbol [list [$push/val source] [$get]]] [[:native-function :lambda] [bytecompile/literal [closure/name source]]] [otherwise [$push/val source]]]]] #{##[type-of source ΓεnΣym-1 :int $push/int :nil [#$24] :symbol list $push/val [#$5] :native-function :lambda #f bytecompile/literal closure/name]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 14
1Ai 4
05
1Ai 1
05
04i 1
09o 95
1Ai 2
05
1Ai 5
20
0Bo 8
1Ai 6
09o 81
1Ai 2
05
1Ai 7
20
0Bo 21
1Ai 8
05
1Ai 9
05
1Ai 1
05
04i 1
1Ai 10
04i 2
09o 54
1Ai 2
05
1Ai 11
20
0C
0Ao 17
0D
1Ai 2
05
1Ai 12
20
0C
0Ao 6
0D
1Ai 13
0Bo 19
1Ai 14
05
1Ai 15
05
1Ai 1
05
04i 1
04i 1
09o 11
1Ai 9
05
1Ai 1
05
04i 1
16
01
} bytecompile/quote [source] #@[source: [[case [type-of source] [:nil [$push/nil]] [:int [$push/int source]] [otherwise [$push/val source]]]]] #{##[type-of source ΓεnΣym-2 :nil [#$24] :int $push/int $push/val]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 8
1Ai 4
09o 31
1Ai 2
05
1Ai 5
20
0Bo 14
1Ai 6
05
1Ai 1
05
04i 1
09o 11
1Ai 7
05
1Ai 1
05
04i 1
16
01
} bytecompile/do/form [source env] #@[source: [[when source [cons [cons [bytecompile* [car source] env] [if [last? source] #nil [cons [$drop] #nil]]] [bytecompile/do/form [cdr source] env]]]]] #{##[source bytecompile* env nil? [#$D] bytecompile/do/form]
1Ai 0
05
0Bo 52
1Ai 1
05
1Ai 0
05
11
1Ai 2
05
04i 2
1Ai 3
05
1Ai 0
05
12
04i 1
0Bo 7
24
09o 7
1Ai 4
24
14
14
1Ai 5
05
1Ai 0
05
12
1Ai 2
05
04i 2
14
09o 4
24
01
} bytecompile/do [source env] #@[source: [[list [bytecompile/do/form [cdr source] env]]]] #{##[list bytecompile/do/form source env]
1Ai 0
05
1Ai 1
05
1Ai 2
05
12
1Ai 3
05
04i 2
04i 1
01
} bytecompile/def [source env] #@[source: [[when [or [not [symbol? [cadr source]]] [not [cddr source]]] [throw [list :type-error "[def] needs a symbol name and a value as arguments" #nil env]]] [list [bytecompile* [caddr source] env] [$push/val [cadr source]] [$def/new]]]] #{##[symbol? source #f #t throw list :type-error "[def] needs a symbol name and a value as arguments" env bytecompile* caddr $push/val [#$7]]
1Ai 0
05
1Ai 1
05
12
11
04i 1
0Bo 8
1Ai 2
09o 5
1Ai 3
0C
0Ao 26
0D
1Ai 1
05
12
12
0Bo 8
1Ai 2
09o 5
1Ai 3
0C
0Ao 6
0D
1Ai 2
0Bo 24
1Ai 4
05
1Ai 5
05
1Ai 6
1Ai 7
24
1Ai 8
05
04i 4
04i 1
09o 4
24
0D
1Ai 5
05
1Ai 9
05
1Ai 10
05
1Ai 1
05
04i 1
1Ai 8
05
04i 2
1Ai 11
05
1Ai 1
05
12
11
04i 1
1Ai 12
04i 3
01
} bytecompile/set! [source env] #@[source: [[when [or [not [symbol? [cadr source]]] [not [cddr source]]] [throw [list :type-error "[set!] needs a symbol name and a value as arguments" #nil env]]] [list [bytecompile* [caddr source] env] [$push/val [cadr source]] [$set/new]]]] #{##[symbol? source #f #t throw list :type-error "[set!] needs a symbol name and a value as arguments" env bytecompile* caddr $push/val [#$8]]
1Ai 0
05
1Ai 1
05
12
11
04i 1
0Bo 8
1Ai 2
09o 5
1Ai 3
0C
0Ao 26
0D
1Ai 1
05
12
12
0Bo 8
1Ai 2
09o 5
1Ai 3
0C
0Ao 6
0D
1Ai 2
0Bo 24
1Ai 4
05
1Ai 5
05
1Ai 6
1Ai 7
24
1Ai 8
05
04i 4
04i 1
09o 4
24
0D
1Ai 5
05
1Ai 9
05
1Ai 10
05
1Ai 1
05
04i 1
1Ai 8
05
04i 2
1Ai 11
05
1Ai 1
05
12
11
04i 1
1Ai 12
04i 3
01
} bytecompile/if [source env] #@[source: [[let [[sym-else [bytecompile/gen-label]] [sym-after [bytecompile/gen-label]]] [list [bytecompile* [cadr source] env] [$jf sym-else] [bytecompile* [caddr source] env] [$jmp sym-after] [list :label sym-else] [bytecompile* [cadddr source] env] [list :label sym-after]]]]] #{##[bytecompile/gen-label sym-else sym-after list bytecompile* source env $jf caddr $jmp :label cadddr]
15
1Ai 0
05
04i 0
1Ai 1
07
0D
1Ai 0
05
04i 0
1Ai 2
07
0D
1Ai 3
05
1Ai 4
05
1Ai 5
05
12
11
1Ai 6
05
04i 2
1Ai 7
05
1Ai 1
05
04i 1
1Ai 4
05
1Ai 8
05
1Ai 5
05
04i 1
1Ai 6
05
04i 2
1Ai 9
05
1Ai 2
05
04i 1
1Ai 3
05
1Ai 10
1Ai 1
05
04i 2
1Ai 4
05
1Ai 11
05
1Ai 5
05
04i 1
1Ai 6
05
04i 2
1Ai 3
05
1Ai 10
1Ai 2
05
04i 2
04i 7
16
01
} bytecompile/while [source env] #@[source: [[def sym-start [bytecompile/gen-label]] [def sym-end [bytecompile/gen-label]] [list [$push/nil] [$roots/save] [$jmp sym-end] [list :label sym-start] [$drop] [$roots/restore] [bytecompile/do/form [cddr source] env] [list :label sym-end] [bytecompile* [cadr source] env] [$jt sym-start]]]] #{##[bytecompile/gen-label sym-start sym-end list [#$24] [#$1B] $jmp :label [#$D] [#$1C] bytecompile/do/form source env bytecompile* $jt]
1Ai 0
05
04i 0
1Ai 1
07
0D
1Ai 0
05
04i 0
1Ai 2
07
0D
1Ai 3
05
1Ai 4
1Ai 5
1Ai 6
05
1Ai 2
05
04i 1
1Ai 3
05
1Ai 7
1Ai 1
05
04i 2
1Ai 8
1Ai 9
1Ai 10
05
1Ai 11
05
12
12
1Ai 12
05
04i 2
1Ai 3
05
1Ai 7
1Ai 2
05
04i 2
1Ai 13
05
1Ai 11
05
12
11
1Ai 12
05
04i 2
1Ai 14
05
1Ai 1
05
04i 1
04i 10
01
} bytecompile/procedure/arg [source env] #@[source: [[if [last? source] [bytecompile* [car source] env] [cons [bytecompile* [car source] env] [bytecompile/procedure/arg [cdr source] env]]]]] #{##[nil? source bytecompile* env bytecompile/procedure/arg]
1Ai 0
05
1Ai 1
05
12
04i 1
0Bo 18
1Ai 2
05
1Ai 1
05
11
1Ai 3
05
04i 2
09o 28
1Ai 2
05
1Ai 1
05
11
1Ai 3
05
04i 2
1Ai 4
05
1Ai 1
05
12
1Ai 3
05
04i 2
14
01
} bytecompile/procedure/inline? [op] #@[source: [[case [type-of op] [:lambda [meta op :inline]] [#t #f]]]] #{##[type-of op ΓεnΣym-3 :lambda meta :inline #t #f]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 16
1Ai 4
05
1Ai 1
05
1Ai 5
04i 2
09o 18
1Ai 2
05
1Ai 6
20
0Bo 8
1Ai 7
09o 4
24
16
01
} bytecompile/procedure/inline [op args env] #@[source: [[def arg-count [length args]] [when [> arg-count 1] [throw [list :compiler-error "For now only monadic functions can be inlined" op [current-lambda]]]] [def form [macroexpand/do [meta op :source] env]] [def arg-name [car [closure/arguments op]]] [if args [bytecompile* [list/replace form arg-name [car args]] env] [bytecompile* form env]]]] #{##[length args arg-count throw list :compiler-error "For now only monadic functions can be inlined" op current-lambda macroexpand/do meta :source env form closure/arguments arg-name bytecompile* list/replace]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
02i 1
22
0Bo 28
1Ai 3
05
1Ai 4
05
1Ai 5
1Ai 6
1Ai 7
05
1Ai 8
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 9
05
1Ai 10
05
1Ai 7
05
1Ai 11
04i 2
1Ai 12
05
04i 2
1Ai 13
07
0D
1Ai 14
05
1Ai 7
05
04i 1
11
1Ai 15
07
0D
1Ai 1
05
0Bo 29
1Ai 16
05
1Ai 17
05
1Ai 13
05
1Ai 15
05
1Ai 1
05
11
04i 3
1Ai 12
05
04i 2
09o 14
1Ai 16
05
1Ai 13
05
1Ai 12
05
04i 2
01
} bytecompile/procedure [op args env op-raw] #@[source: [[if [bytecompile/procedure/inline? op] [bytecompile/procedure/inline op args env] [bytecompile/procedure/default op args env op-raw]]]] #{##[bytecompile/procedure/inline? op bytecompile/procedure/inline args env bytecompile/procedure/default op-raw]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 20
1Ai 2
05
1Ai 1
05
1Ai 3
05
1Ai 4
05
04i 3
09o 20
1Ai 5
05
1Ai 1
05
1Ai 3
05
1Ai 4
05
1Ai 6
05
04i 4
01
} bytecompile/procedure/default [op args env op-raw] #@[source: [[def arg-count [length args]] [if [$apply/optimize? op arg-count] [list [when args [bytecompile/procedure/arg args]] [$apply arg-count op]] [list [bytecompile* op-raw env] [when args [bytecompile/procedure/arg args]] [$apply/dynamic arg-count]]]]] #{##[length args arg-count $apply/optimize? op list bytecompile/procedure/arg $apply bytecompile* op-raw env $apply/dynamic]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 3
05
1Ai 4
05
1Ai 2
05
04i 2
0Bo 40
1Ai 5
05
1Ai 1
05
0Bo 14
1Ai 6
05
1Ai 1
05
04i 1
09o 4
24
1Ai 7
05
1Ai 2
05
1Ai 4
05
04i 2
04i 2
09o 45
1Ai 5
05
1Ai 8
05
1Ai 9
05
1Ai 10
05
04i 2
1Ai 1
05
0Bo 14
1Ai 6
05
1Ai 1
05
04i 1
09o 4
24
1Ai 11
05
1Ai 2
05
04i 1
04i 3
01
} bytecompile/and/rec [source env label-end] #@[source: [[list [bytecompile* [car source] env] [when [cdr source] [list [$dup] [$jf label-end] [$drop] [bytecompile/and/rec [cdr source] env label-end]]]]]] #{##[list bytecompile* source env [#$C] $jf label-end [#$D] bytecompile/and/rec]
1Ai 0
05
1Ai 1
05
1Ai 2
05
11
1Ai 3
05
04i 2
1Ai 2
05
12
0Bo 38
1Ai 0
05
1Ai 4
1Ai 5
05
1Ai 6
05
04i 1
1Ai 7
1Ai 8
05
1Ai 2
05
12
1Ai 3
05
1Ai 6
05
04i 3
04i 4
09o 4
24
04i 2
01
} bytecompile/and [source env] #@[source: [[def label-end [bytecompile/gen-label]] [list [bytecompile/and/rec [cdr source] env label-end] [list :label label-end]]]] #{##[bytecompile/gen-label label-end list bytecompile/and/rec source env :label]
1Ai 0
05
04i 0
1Ai 1
07
0D
1Ai 2
05
1Ai 3
05
1Ai 4
05
12
1Ai 5
05
1Ai 1
05
04i 3
1Ai 2
05
1Ai 6
1Ai 1
05
04i 2
04i 2
01
} bytecompile/or/rec [source env label-end] #@[source: [[when source [list [bytecompile* [car source] env] [$dup] [$jt label-end] [$drop] [bytecompile/or/rec [cdr source] env label-end]]]]] #{##[source list bytecompile* env [#$C] $jt label-end [#$D] bytecompile/or/rec]
1Ai 0
05
0Bo 50
1Ai 1
05
1Ai 2
05
1Ai 0
05
11
1Ai 3
05
04i 2
1Ai 4
1Ai 5
05
1Ai 6
05
04i 1
1Ai 7
1Ai 8
05
1Ai 0
05
12
1Ai 3
05
1Ai 6
05
04i 3
04i 5
09o 4
24
01
} bytecompile/or [source env] #@[source: [[def label-end [bytecompile/gen-label]] [list [bytecompile/or/rec [cdr source] env label-end] [$push/val #f] [list :label label-end]]]] #{##[bytecompile/gen-label label-end list bytecompile/or/rec source env $push/val #f :label]
1Ai 0
05
04i 0
1Ai 1
07
0D
1Ai 2
05
1Ai 3
05
1Ai 4
05
12
1Ai 5
05
1Ai 1
05
04i 3
1Ai 6
05
1Ai 7
04i 1
1Ai 2
05
1Ai 8
1Ai 1
05
04i 2
04i 3
01
} bytecompile/fn* [source env] #@[source: [[def arg-count [length [cdr source]]] [when [not= arg-count 5] [exception :arity-error "[fn*] needs exactly 4 arguments" source]] [cdr! source] [list [bytecompile* [car source] env] [bytecompile* [cadr source] env] [bytecompile* [caddr source] env] [bytecompile* [cadddr source] env] [$fn/dynamic]]]] #{##[length source arg-count not= throw list :arity-error "[fn*] needs exactly 4 arguments" current-lambda bytecompile* env caddr cadddr [#$17]]
1Ai 0
05
1Ai 1
05
12
04i 1
1Ai 2
07
0D
1Ai 3
05
1Ai 2
05
02i 5
04i 2
0Bo 28
1Ai 4
05
1Ai 5
05
1Ai 6
1Ai 7
1Ai 1
05
1Ai 8
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 1
05
12
1Ai 1
08
0D
1Ai 5
05
1Ai 9
05
1Ai 1
05
11
1Ai 10
05
04i 2
1Ai 9
05
1Ai 1
05
12
11
1Ai 10
05
04i 2
1Ai 9
05
1Ai 11
05
1Ai 1
05
04i 1
1Ai 10
05
04i 2
1Ai 9
05
1Ai 12
05
1Ai 1
05
04i 1
1Ai 10
05
04i 2
1Ai 13
04i 5
01
} bytecompile/macro* [source env] #@[source: [[def arg-count [length [cdr source]]] [when [not= arg-count 5] [exception :arity-error "[macro*] needs exactly 4 arguments" source]] [cdr! source] [list [bytecompile* [car source] env] [bytecompile* [cadr source] env] [bytecompile* [caddr source] env] [bytecompile* [cadddr source] env] [$macro/dynamic]]]] #{##[length source arg-count not= throw list :arity-error "[macro*] needs exactly 4 arguments" current-lambda bytecompile* env caddr cadddr [#$18]]
1Ai 0
05
1Ai 1
05
12
04i 1
1Ai 2
07
0D
1Ai 3
05
1Ai 2
05
02i 5
04i 2
0Bo 28
1Ai 4
05
1Ai 5
05
1Ai 6
1Ai 7
1Ai 1
05
1Ai 8
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 1
05
12
1Ai 1
08
0D
1Ai 5
05
1Ai 9
05
1Ai 1
05
11
1Ai 10
05
04i 2
1Ai 9
05
1Ai 1
05
12
11
1Ai 10
05
04i 2
1Ai 9
05
1Ai 11
05
1Ai 1
05
04i 1
1Ai 10
05
04i 2
1Ai 9
05
1Ai 12
05
1Ai 1
05
04i 1
1Ai 10
05
04i 2
1Ai 13
04i 5
01
} bytecompile/environment* [source env] #@[source: [[list [$let] [bytecompile/do/form [cdr source] env] [$drop] [$closure/push] [$closure/pop]]]] #{##[list [#$15] bytecompile/do/form source env [#$D] [#$13] [#$16]]
1Ai 0
05
1Ai 1
1Ai 2
05
1Ai 3
05
12
1Ai 4
05
04i 2
1Ai 5
1Ai 6
1Ai 7
04i 5
01
} bytecompile/let* [source env] #@[source: [[list [$let] [bytecompile/do [cadr source] env] [$closure/pop]]]] #{##[list [#$15] bytecompile/do source env [#$16]]
1Ai 0
05
1Ai 1
1Ai 2
05
1Ai 3
05
12
11
1Ai 4
05
04i 2
1Ai 5
04i 3
01
} bytecompile/return [source env] #@[source: [[list [bytecompile* [cadr source] env] [$ret]]]] #{##[list bytecompile* source env [#$1]]
1Ai 0
05
1Ai 1
05
1Ai 2
05
12
11
1Ai 3
05
04i 2
1Ai 4
04i 2
01
} bytecompile/try [source env] #@[source: [[def end-sym [bytecompile/gen-label]] [list [bytecompile* [cadr source] env] [$try end-sym] [bytecompile/do/form [cddr source] env] [$closure/pop] [list :label end-sym]]]] #{##[bytecompile/gen-label end-sym list bytecompile* source env $try bytecompile/do/form [#$16] :label]
1Ai 0
05
04i 0
1Ai 1
07
0D
1Ai 2
05
1Ai 3
05
1Ai 4
05
12
11
1Ai 5
05
04i 2
1Ai 6
05
1Ai 1
05
04i 1
1Ai 7
05
1Ai 4
05
12
12
1Ai 5
05
04i 2
1Ai 8
1Ai 2
05
1Ai 9
1Ai 1
05
04i 2
04i 5
01
} bytecompile* [source env] #@[documentation: "Compile the forms in source" source: ["Compile the forms in source" [def op [if [resolves? [car source] env] [resolve [car source] env] [car source]]] [case [type-of op] [[:lambda :native-function :pair :symbol] [case op [do [bytecompile/do source env]] [let* [bytecompile/let* source env]] [def [bytecompile/def source env]] [set! [bytecompile/set! source env]] [if [bytecompile/if source env]] [while [bytecompile/while source env]] [and [bytecompile/and source env]] [or [bytecompile/or source env]] [fn* [bytecompile/fn* source env]] [macro* [bytecompile/macro* source env]] [environment* [bytecompile/environment* source env]] [try [bytecompile/try source env]] [return [bytecompile/return source env]] '[bytecompile/quote [cadr source]] [otherwise [bytecompile/procedure op [cdr source] env [car source]]]]] [otherwise [bytecompile/literal source]]]]] #{##[resolves? source env resolve op type-of ΓεnΣym-4 :lambda :native-function :pair :symbol #f ΓεnΣym-5 do bytecompile/do let* bytecompile/let* def bytecompile/def set! bytecompile/set! if bytecompile/if while bytecompile/while and bytecompile/and or bytecompile/or fn* bytecompile/fn* macro* bytecompile/macro* environment* bytecompile/environment* try bytecompile/try return bytecompile/return quote bytecompile/quote bytecompile/procedure bytecompile/literal]
1Ai 0
05
1Ai 1
05
11
1Ai 2
05
04i 2
0Bo 18
1Ai 3
05
1Ai 1
05
11
1Ai 2
05
04i 2
09o 7
1Ai 1
05
11
1Ai 4
07
0D
15
1Ai 5
05
1Ai 4
05
04i 1
1Ai 6
07
0D
1Ai 6
05
1Ai 7
20
0C
0Ao 39
0D
1Ai 6
05
1Ai 8
20
0C
0Ao 28
0D
1Ai 6
05
1Ai 9
20
0C
0Ao 17
0D
1Ai 6
05
1Ai 10
20
0C
0Ao 6
0D
1Ai 11
0Bo 369
15
1Ai 4
05
1Ai 12
07
0D
1Ai 12
05
1Ai 13
05
20
0Bo 17
1Ai 14
05
1Ai 1
05
1Ai 2
05
04i 2
09o 333
1Ai 12
05
1Ai 15
05
20
0Bo 17
1Ai 16
05
1Ai 1
05
1Ai 2
05
04i 2
09o 309
1Ai 12
05
1Ai 17
05
20
0Bo 17
1Ai 18
05
1Ai 1
05
1Ai 2
05
04i 2
09o 285
1Ai 12
05
1Ai 19
05
20
0Bo 17
1Ai 20
05
1Ai 1
05
1Ai 2
05
04i 2
09o 261
1Ai 12
05
1Ai 21
05
20
0Bo 17
1Ai 22
05
1Ai 1
05
1Ai 2
05
04i 2
09o 237
1Ai 12
05
1Ai 23
05
20
0Bo 17
1Ai 24
05
1Ai 1
05
1Ai 2
05
04i 2
09o 213
1Ai 12
05
1Ai 25
05
20
0Bo 17
1Ai 26
05
1Ai 1
05
1Ai 2
05
04i 2
09o 189
1Ai 12
05
1Ai 27
05
20
0Bo 17
1Ai 28
05
1Ai 1
05
1Ai 2
05
04i 2
09o 165
1Ai 12
05
1Ai 29
05
20
0Bo 17
1Ai 30
05
1Ai 1
05
1Ai 2
05
04i 2
09o 141
1Ai 12
05
1Ai 31
05
20
0Bo 17
1Ai 32
05
1Ai 1
05
1Ai 2
05
04i 2
09o 117
1Ai 12
05
1Ai 33
05
20
0Bo 17
1Ai 34
05
1Ai 1
05
1Ai 2
05
04i 2
09o 93
1Ai 12
05
1Ai 35
05
20
0Bo 17
1Ai 36
05
1Ai 1
05
1Ai 2
05
04i 2
09o 69
1Ai 12
05
1Ai 37
05
20
0Bo 17
1Ai 38
05
1Ai 1
05
1Ai 2
05
04i 2
09o 45
1Ai 12
05
1Ai 39
05
20
0Bo 16
1Ai 40
05
1Ai 1
05
12
11
04i 1
09o 22
1Ai 41
05
1Ai 4
05
1Ai 1
05
12
1Ai 2
05
1Ai 1
05
11
04i 4
16
09o 11
1Ai 42
05
1Ai 1
05
04i 1
16
01
} bytecompile [form environment] #@[source: [[list [bytecompile* form environment] [$ret]]]] #{##[list bytecompile* form environment [#$1]]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
1Ai 4
04i 2
01
}]
02i 0
1Ai 0
07
0D
1Ai 1
1Ai 2
1Ai 3
1Ai 4
17
1Ai 1
07
0D
1Ai 5
1Ai 6
1Ai 7
1Ai 8
17
1Ai 5
07
0D
1Ai 9
1Ai 10
1Ai 11
1Ai 12
17
1Ai 9
07
0D
1Ai 13
1Ai 14
1Ai 15
1Ai 16
17
1Ai 13
07
0D
1Ai 17
1Ai 18
1Ai 19
1Ai 20
17
1Ai 17
07
0D
1Ai 21
1Ai 22
1Ai 23
1Ai 24
17
1Ai 21
07
0D
1Ai 25
1Ai 26
1Ai 27
1Ai 28
17
1Ai 25
07
0D
1Ai 29
1Ai 30
1Ai 31
1Ai 32
17
1Ai 29
07
0D
1Ai 33
1Ai 34
1Ai 35
1Ai 36
17
1Ai 33
07
0D
1Ai 37
1Ai 38
1Ai 39
1Ai 40
17
1Ai 37
07
0D
1Ai 41
1Ai 42
1Ai 43
1Ai 44
17
1Ai 41
07
0D
1Ai 45
1Ai 46
1Ai 47
1Ai 48
17
1Ai 45
07
0D
1Ai 49
1Ai 50
1Ai 51
1Ai 52
17
1Ai 49
07
0D
1Ai 53
1Ai 54
1Ai 55
1Ai 56
17
1Ai 53
07
0D
1Ai 57
1Ai 58
1Ai 59
1Ai 60
17
1Ai 57
07
0D
1Ai 61
1Ai 62
1Ai 63
1Ai 64
17
1Ai 61
07
0D
1Ai 65
1Ai 66
1Ai 67
1Ai 68
17
1Ai 65
07
0D
1Ai 69
1Ai 70
1Ai 71
1Ai 72
17
1Ai 69
07
0D
1Ai 73
1Ai 74
1Ai 75
1Ai 76
17
1Ai 73
07
0D
1Ai 77
1Ai 78
1Ai 79
1Ai 80
17
1Ai 77
07
0D
1Ai 81
1Ai 82
1Ai 83
1Ai 84
17
1Ai 81
07
0D
1Ai 85
1Ai 86
1Ai 87
1Ai 88
17
1Ai 85
07
0D
1Ai 89
1Ai 90
1Ai 91
1Ai 92
17
1Ai 89
07
0D
1Ai 93
1Ai 94
1Ai 95
1Ai 96
17
1Ai 93
07
0D
1Ai 97
1Ai 98
1Ai 99
1Ai 100
17
1Ai 97
07
0D
1Ai 101
1Ai 102
1Ai 103
1Ai 104
17
1Ai 101
07
01
}#{##[disassemble/length [op] #@[documentation: "Return the length in bytes of a bytecode operation and all its arguments" source: ["Return the length in bytes of a bytecode operation and all its arguments" [case op [[#$0 #$1 #$3 #$5 #$7 #$8 #$C #$D #$11 #$12 #$13 #$14 #$15 #$16 #$1B #$1C #$1E #$1F #$20 #$21 #$22 #$24 #$25 #$26 #$27 #$28 #$29 #$2A] 1] [[#$2 #$4 #$1A] 2] [[#$6 #$9 #$A #$B #$18 #$19] 3] [[#$E #$F #$10] 4] [otherwise [throw [list :unknown-op "This op needs its length specified for disassembly to work" op [current-lambda]]]]]]] #{##[op ΓεnΣym-1 #$0 #$1 #$3 #$5 #$7 #$8 #$C #$D #$11 #$12 #$13 #$14 #$15 #$16 #$1B #$1C #$1E #$1F #$20 #$21 #$22 #$24 #$25 #$26 #$27 #$28 #$29 #$2A #f #$2 #$4 #$1A #$6 #$9 #$A #$B #$18 #$19 #$E #$F #$10 throw list :unknown-op "This op needs its length specified for disassembly to work" current-lambda]
15
1Ai 0
05
1Ai 1
07
0D
1Ai 1
05
1Ai 2
20
0C
0Ao 303
0D
1Ai 1
05
1Ai 3
20
0C
0Ao 292
0D
1Ai 1
05
1Ai 4
20
0C
0Ao 281
0D
1Ai 1
05
1Ai 5
20
0C
0Ao 270
0D
1Ai 1
05
1Ai 6
20
0C
0Ao 259
0D
1Ai 1
05
1Ai 7
20
0C
0Ao 248
0D
1Ai 1
05
1Ai 8
20
0C
0Ao 237
0D
1Ai 1
05
1Ai 9
20
0C
0Ao 226
0D
1Ai 1
05
1Ai 10
20
0C
0Ao 215
0D
1Ai 1
05
1Ai 11
20
0C
0Ao 204
0D
1Ai 1
05
1Ai 12
20
0C
0Ao 193
0D
1Ai 1
05
1Ai 13
20
0C
0Ao 182
0D
1Ai 1
05
1Ai 14
20
0C
0Ao 171
0D
1Ai 1
05
1Ai 15
20
0C
0Ao 160
0D
1Ai 1
05
1Ai 16
20
0C
0Ao 149
0D
1Ai 1
05
1Ai 17
20
0C
0Ao 138
0D
1Ai 1
05
1Ai 18
20
0C
0Ao 127
0D
1Ai 1
05
1Ai 19
20
0C
0Ao 116
0D
1Ai 1
05
1Ai 20
20
0C
0Ao 105
0D
1Ai 1
05
1Ai 21
20
0C
0Ao 94
0D
1Ai 1
05
1Ai 22
20
0C
0Ao 83
0D
1Ai 1
05
1Ai 23
20
0C
0Ao 72
0D
1Ai 1
05
1Ai 24
20
0C
0Ao 61
0D
1Ai 1
05
1Ai 25
20
0C
0Ao 50
0D
1Ai 1
05
1Ai 26
20
0C
0Ao 39
0D
1Ai 1
05
1Ai 27
20
0C
0Ao 28
0D
1Ai 1
05
1Ai 28
20
0C
0Ao 17
0D
1Ai 1
05
1Ai 29
20
0C
0Ao 6
0D
1Ai 30
0Bo 8
02i 1
09o 187
1Ai 1
05
1Ai 31
20
0C
0Ao 28
0D
1Ai 1
05
1Ai 32
20
0C
0Ao 17
0D
1Ai 1
05
1Ai 33
20
0C
0Ao 6
0D
1Ai 30
0Bo 8
02i 2
09o 144
1Ai 1
05
1Ai 34
20
0C
0Ao 61
0D
1Ai 1
05
1Ai 35
20
0C
0Ao 50
0D
1Ai 1
05
1Ai 36
20
0C
0Ao 39
0D
1Ai 1
05
1Ai 37
20
0C
0Ao 28
0D
1Ai 1
05
1Ai 38
20
0C
0Ao 17
0D
1Ai 1
05
1Ai 39
20
0C
0Ao 6
0D
1Ai 30
0Bo 8
02i 3
09o 68
1Ai 1
05
1Ai 40
20
0C
0Ao 28
0D
1Ai 1
05
1Ai 41
20
0C
0Ao 17
0D
1Ai 1
05
1Ai 42
20
0C
0Ao 6
0D
1Ai 30
0Bo 8
02i 4
09o 25
1Ai 43
05
1Ai 44
05
1Ai 45
1Ai 46
1Ai 0
05
1Ai 47
05
04i 0
04i 4
04i 1
16
01
} bytecode/nil-catcher [error] #@[source: [[if [= [car error] :type-error] #nil [throw error]]]] #{##[error :type-error throw]
1Ai 0
05
11
1Ai 1
20
0Bo 7
24
09o 11
1Ai 2
05
1Ai 0
05
04i 1
01
} bytecode-op->val [a b c] #@[documentation: "Turn three bytecode ops representing an encoded value into an actual value" source: ["Turn three bytecode ops representing an encoded value into an actual value" [index->val [bit-or [bit-shift-left [bytecode-op->int a] 16] [bit-shift-left [bytecode-op->int b] 8] [bytecode-op->int c]]]]] #{##[index->val bit-or bit-shift-left bytecode-op->int a b c]
1Ai 0
05
1Ai 1
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 1
02i 16
04i 2
1Ai 2
05
1Ai 3
05
1Ai 5
05
04i 1
02i 8
04i 2
04i 2
1Ai 3
05
1Ai 6
05
04i 1
04i 2
04i 1
01
} bytecode-arr->val [a i] #@[documentation: "Read a bytecode encoded value in A at I and return it" source: ["Read a bytecode encoded value in A at I and return it" [try bytecode/nil-catcher [bytecode-op->val [ref a i] [ref a [+ 1 i]] [ref a [+ 2 i]]]]]] #{##[bytecode/nil-catcher bytecode-op->val ref a i]
1Ai 0
05
19o 48
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 2
1Ai 2
05
1Ai 3
05
02i 1
1Ai 4
05
25
04i 2
1Ai 2
05
1Ai 3
05
02i 2
1Ai 4
05
25
04i 2
04i 3
16
01
} bytecode-op->sym [a b c] #@[documentation: "Turn three bytecode ops representing an encoded symbol into an actual symbol" source: ["Turn three bytecode ops representing an encoded symbol into an actual symbol" [index->sym [bit-or [bit-shift-left [bytecode-op->int a] 16] [bit-shift-left [bytecode-op->int b] 8] [bytecode-op->int c]]]]] #{##[index->sym bit-or bit-shift-left bytecode-op->int a b c]
1Ai 0
05
1Ai 1
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 1
02i 16
04i 2
1Ai 2
05
1Ai 3
05
1Ai 5
05
04i 1
02i 8
04i 2
04i 2
1Ai 3
05
1Ai 6
05
04i 1
04i 2
04i 1
01
} bytecode-arr->sym [a i] #@[documentation: "Read a bytecode encoded symbol in A at I and return it" source: ["Read a bytecode encoded symbol in A at I and return it" [try bytecode/nil-catcher [bytecode-op->sym [ref a i] [ref a [+ 1 i]] [ref a [+ 2 i]]]]]] #{##[bytecode/nil-catcher bytecode-op->sym ref a i]
1Ai 0
05
19o 48
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 2
1Ai 2
05
1Ai 3
05
02i 1
1Ai 4
05
25
04i 2
1Ai 2
05
1Ai 3
05
02i 2
1Ai 4
05
25
04i 2
04i 3
16
01
} bytecode-op->offset [a b] #@[documentation: "Turn two bytecode ops encoding an offset into the integer representation" source: ["Turn two bytecode ops encoding an offset into the integer representation" [def t [bit-or [bit-shift-left [bytecode-op->int a] 8] [bytecode-op->int b]]] [if-not [> t 32768] t [- [- 65536 t]]]]] #{##[bit-or bit-shift-left bytecode-op->int a b t 32768 - 65536]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
02i 8
04i 2
1Ai 2
05
1Ai 4
05
04i 1
04i 2
1Ai 5
07
0D
1Ai 5
05
1Ai 6
22
0Bo 17
1Ai 7
05
1Ai 8
1Ai 5
05
26
04i 1
09o 6
1Ai 5
05
01
} bytecode-arr->offset [a i] #@[documentation: "Read a bytecode encoded offset in A at I and return it as a signed integer" source: ["Read a bytecode encoded offset in A at I and return it as a signed integer" [bytecode-op->offset [ref a i] [ref a [+ 1 i]]]]] #{##[bytecode-op->offset ref a i]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
1Ai 1
05
1Ai 2
05
02i 1
1Ai 3
05
25
04i 2
04i 2
01
} disassemble/maybe-quote [v] #@[documentation: "Quotes symbols but just passes through every other value" source: ["Quotes symbols but just passes through every other value" [if [symbol? v] [list 'quote v] v]]] #{##[symbol? v list quote]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 16
1Ai 2
05
1Ai 3
1Ai 1
05
04i 2
09o 6
1Ai 1
05
01
} disassemble/op [a i literals] #@[documentation: "Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" source: ["Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" [case [ref a i] [#$0 '[$nop]] [#$1 '[$ret]] [#$2 [quasiquote [$push/int/byte [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$3 '[$add/int]] [#$4 [quasiquote [$apply/dynamic [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$5 '[$get]] [#$6 [quasiquote [$push/val/ext [unquote [ref literals [bit-or [bytecode-op->int [ref a [+ i 1]]] [bit-shift-left [bytecode-op->int [ref a [+ i 2]]] 8]]]]]]] [#$7 [quasiquote [$def/new]]] [#$8 [quasiquote [$set/new]]] [#$9 [quasiquote [$jmp* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$A [quasiquote [$jt* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$B [quasiquote [$jf* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$C '[$dup]] [#$D '[$drop]] [#$E [quasiquote [$def [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$F [quasiquote [$set [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$10 [quasiquote [$get [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$11 '[$car]] [#$12 '[$cdr]] [#$13 '[$closure/push]] [#$14 '[$cons]] [#$15 '[$let]] [#$16 '[$closure/pop]] [#$18 [quasiquote [$try/old [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$19 [quasiquote [$try [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$1A [quasiquote [$push/val [unquote [disassemble/maybe-quote [ref literals [bytecode-op->int [ref a [+ i 1]]]]]]]]] [#$1B '[$roots/push]] [#$1C '[$roots/pop]] [#$1E '[$<]] [#$1F '[$<=]] [#$20 '[$=]] [#$21 '[$>=]] [#$22 '[$>]] [#$24 '[$push/nil]] [#$25 '[$add]] [#$26 '[$sub]] [#$27 '[$mul]] [#$28 '[$div]] [#$29 '[$rem]] [#$2A '[$zero?]] [otherwise :unknown-op]]]] #{##[ref a i ΓεnΣym-2 #$0 [$nop] #$1 [$ret] #$2 $push/int/byte bytecode-op->int #$3 [$add/int] #$4 $apply/dynamic #$5 [$get] #$6 $push/val/ext literals bit-or bit-shift-left #$7 $def/new #$8 $set/new #$9 $jmp* bytecode-arr->offset #$A $jt* #$B $jf* #$C [$dup] #$D [$drop] #$E $def bytecode-arr->sym #$F $set #$10 $get #$11 [$car] #$12 [$cdr] #$13 [$closure/push] #$14 [$cons] #$15 [$let] #$16 [$closure/pop] #$18 $try/old #$19 $try #$1A $push/val disassemble/maybe-quote #$1B [$roots/push] #$1C [$roots/pop] #$1E [$<] #$1F [$<=] #$20 [$=] #$21 [$>=] #$22 [$>] #$24 [$push/nil] #$25 [$add] #$26 [$sub] #$27 [$mul] #$28 [$div] #$29 [$rem] #$2A [$zero?] :unknown-op]
15
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
1Ai 3
07
0D
1Ai 3
05
1Ai 4
20
0Bo 8
1Ai 5
09o 831
1Ai 3
05
1Ai 6
20
0Bo 8
1Ai 7
09o 817
1Ai 3
05
1Ai 8
20
0Bo 30
1Ai 9
1Ai 10
05
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
04i 1
24
14
14
09o 781
1Ai 3
05
1Ai 11
20
0Bo 8
1Ai 12
09o 767
1Ai 3
05
1Ai 13
20
0Bo 30
1Ai 14
1Ai 10
05
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
04i 1
24
14
14
09o 731
1Ai 3
05
1Ai 15
20
0Bo 8
1Ai 16
09o 717
1Ai 3
05
1Ai 17
20
0Bo 69
1Ai 18
1Ai 0
05
1Ai 19
05
1Ai 20
05
1Ai 10
05
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
04i 1
1Ai 21
05
1Ai 10
05
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 2
25
04i 2
04i 1
02i 8
04i 2
04i 2
04i 2
24
14
14
09o 642
1Ai 3
05
1Ai 22
20
0Bo 10
1Ai 23
24
14
09o 626
1Ai 3
05
1Ai 24
20
0Bo 10
1Ai 25
24
14
09o 610
1Ai 3
05
1Ai 26
20
0Bo 25
1Ai 27
1Ai 28
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
24
14
14
09o 579
1Ai 3
05
1Ai 29
20
0Bo 25
1Ai 30
1Ai 28
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
24
14
14
09o 548
1Ai 3
05
1Ai 31
20
0Bo 25
1Ai 32
1Ai 28
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
24
14
14
09o 517
1Ai 3
05
1Ai 33
20
0Bo 8
1Ai 34
09o 503
1Ai 3
05
1Ai 35
20
0Bo 8
1Ai 36
09o 489
1Ai 3
05
1Ai 37
20
0Bo 25
1Ai 38
1Ai 39
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
24
14
14
09o 458
1Ai 3
05
1Ai 40
20
0Bo 25
1Ai 41
1Ai 39
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
24
14
14
09o 427
1Ai 3
05
1Ai 42
20
0Bo 25
1Ai 43
1Ai 39
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
24
14
14
09o 396
1Ai 3
05
1Ai 44
20
0Bo 8
1Ai 45
09o 382
1Ai 3
05
1Ai 46
20
0Bo 8
1Ai 47
09o 368
1Ai 3
05
1Ai 48
20
0Bo 8
1Ai 49
09o 354
1Ai 3
05
1Ai 50
20
0Bo 8
1Ai 51
09o 340
1Ai 3
05
1Ai 52
20
0Bo 8
1Ai 53
09o 326
1Ai 3
05
1Ai 54
20
0Bo 8
1Ai 55
09o 312
1Ai 3
05
1Ai 56
20
0Bo 25
1Ai 57
1Ai 28
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
24
14
14
09o 281
1Ai 3
05
1Ai 58
20
0Bo 25
1Ai 59
1Ai 28
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
24
14
14
09o 250
1Ai 3
05
1Ai 60
20
0Bo 43
1Ai 61
1Ai 62
05
1Ai 0
05
1Ai 19
05
1Ai 10
05
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 1
25
04i 2
04i 1
04i 2
04i 1
24
14
14
09o 201
1Ai 3
05
1Ai 63
20
0Bo 8
1Ai 64
09o 187
1Ai 3
05
1Ai 65
20
0Bo 8
1Ai 66
09o 173
1Ai 3
05
1Ai 67
20
0Bo 8
1Ai 68
09o 159
1Ai 3
05
1Ai 69
20
0Bo 8
1Ai 70
09o 145
1Ai 3
05
1Ai 71
20
0Bo 8
1Ai 72
09o 131
1Ai 3
05
1Ai 73
20
0Bo 8
1Ai 74
09o 117
1Ai 3
05
1Ai 75
20
0Bo 8
1Ai 76
09o 103
1Ai 3
05
1Ai 77
20
0Bo 8
1Ai 78
09o 89
1Ai 3
05
1Ai 79
20
0Bo 8
1Ai 80
09o 75
1Ai 3
05
1Ai 81
20
0Bo 8
1Ai 82
09o 61
1Ai 3
05
1Ai 83
20
0Bo 8
1Ai 84
09o 47
1Ai 3
05
1Ai 85
20
0Bo 8
1Ai 86
09o 33
1Ai 3
05
1Ai 87
20
0Bo 8
1Ai 88
09o 19
1Ai 3
05
1Ai 89
20
0Bo 8
1Ai 90
09o 5
1Ai 91
16
01
} disassemble/array [a i literals] #@[documentation: "Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" source: ["Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" [def ret #nil] [while [< i [array/length a]] [set! ret [cons [cons i [disassemble/op a i literals]] ret]] [set! i [+ i [disassemble/length [ref a i]]]]] [nreverse ret]]] #{##[ret i disassemble/op a literals disassemble/length ref array/length nreverse]
24
1Ai 0
07
0D
24
1B
09o 54
0D
1C
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 1
05
1Ai 4
05
04i 3
14
1Ai 0
05
14
1Ai 0
08
0D
1Ai 1
05
1Ai 5
05
1Ai 6
05
1Ai 3
05
1Ai 1
05
04i 2
04i 1
25
1Ai 1
08
1Ai 1
05
1Ai 7
05
1Ai 3
05
04i 1
1E
0Ao -63
0D
1Ai 8
05
1Ai 0
05
04i 1
01
} disassemble/bytecode-array [code] #@[documentation: "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," source: ["Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," [disassemble/array [bytecode-arr->arr code] 0 [bytecode-literals code]]]] #{##[disassemble/array bytecode-arr->arr code bytecode-literals]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
02i 0
1Ai 3
05
1Ai 2
05
04i 1
04i 3
01
} disassemble/print [bc] #@[source: [[doseq [a [disassemble/bytecode-array bc]] [println [cat [ansi-blue [string/pad-start [string [car a]] 6]] " - " [cdr a]]]]]] #{##[disassemble/bytecode-array bc ΓεnΣym-3 a println cat ansi-blue string/pad-start string " - "]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
0Bo 72
24
1B
09o 58
0D
1C
1Ai 2
05
11
1Ai 3
07
0D
1Ai 4
05
1Ai 5
05
1Ai 6
05
1Ai 7
05
1Ai 8
05
1Ai 3
05
11
04i 1
02i 6
04i 2
04i 1
1Ai 9
1Ai 3
05
12
04i 3
04i 1
0D
1Ai 2
05
12
1Ai 2
08
1Ai 2
05
0Ao -58
09o 4
24
16
01
} disassemble [bc] #@[documentation: "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," source: ["Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," [case [type-of bc] [[:lambda :macro] [disassemble/print [closure/code bc]]] [:bytecode-array [disassemble/print bc]] [otherwise [throw [list :type-error "Can't disassemble that" bc [current-lambda]]]]]]] #{##[type-of bc ΓεnΣym-4 :lambda :macro #f disassemble/print closure/code :bytecode-array throw list :type-error "Can't disassemble that" current-lambda]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0C
0Ao 17
0D
1Ai 2
05
1Ai 4
20
0C
0Ao 6
0D
1Ai 5
0Bo 19
1Ai 6
05
1Ai 7
05
1Ai 1
05
04i 1
04i 1
09o 45
1Ai 2
05
1Ai 8
20
0Bo 14
1Ai 6
05
1Ai 1
05
04i 1
09o 25
1Ai 9
05
1Ai 10
05
1Ai 11
1Ai 12
1Ai 1
05
1Ai 13
05
04i 0
04i 4
04i 1
16
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
17
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 48
1Ai 49
1Ai 50
1Ai 51
17
1Ai 48
07
0D
1Ai 52
1Ai 53
1Ai 54
1Ai 55
17
1Ai 52
07
01
}#{##[load/forms [source environment] #@[documentation: "Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" source: ["Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" [doseq [form source] [apply environment [compile* source environment]]]]] #{##[source ΓεnΣym-1 form apply environment compile*]
15
1Ai 0
05
1Ai 1
07
0D
1Ai 1
05
0Bo 54
24
1B
09o 40
0D
1C
1Ai 1
05
11
1Ai 2
07
0D
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 0
05
1Ai 4
05
04i 2
04i 2
0D
1Ai 1
05
12
1Ai 1
08
1Ai 1
05
0Ao -40
09o 4
24
16
01
} macroexpand/forms [source-raw environment] #@[documentation: "Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined." source: ["Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined." [when-not environment [set! environment [environment*]]] [load/forms source-raw environment] [macroexpand source-raw environment]]] #{##[environment load/forms source-raw macroexpand]
1Ai 0
05
0Bo 7
24
09o 11
15
24
0D
13
16
1Ai 0
08
0D
1Ai 1
05
1Ai 2
05
1Ai 0
05
04i 2
0D
1Ai 3
05
1Ai 2
05
1Ai 0
05
04i 2
01
} compile* [source environment] #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [-> [macroexpand source environment] constant-fold backend]]] #{##[backend constant-fold macroexpand source environment]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 2
04i 1
04i 1
01
} compile/debug [expr] #@[source: [[disassemble [compile expr]]]] #{##[disassemble compile* expr current-closure]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 0
04i 2
04i 1
01
} compile/do* [source environment] #@[source: [[compile* [cons do source] environment]]] #{##[compile* do source environment]
1Ai 0
05
1Ai 1
05
1Ai 2
05
14
1Ai 3
05
04i 2
01
} compile [source] #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [quasiquote [compile* [unquote source] [current-closure]]]]] #{##[compile* source current-closure]
1Ai 0
1Ai 1
05
1Ai 2
24
14
24
14
14
14
01
} compile/do [source] #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [quasiquote [compile* [cons do [unquote source]] [current-closure]]]]] #{##[compile* cons do source current-closure]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
05
24
14
14
14
1Ai 4
24
14
24
14
14
14
01
} meta/parse/body [type args body] #@[source: [[def meta [tree/new #nil]] [doseq [v body] [case [type-of v] [:pair [return meta]] [:string [tree/set! meta :documentation [trim [cat [string [tree/ref meta :documentation]] "\n" v]]]] [:keyword [tree/set! meta v #t]]]] [return meta]]] #{##[tree/new meta body ΓεnΣym-2 v type-of ΓεnΣym-3 :pair :string tree/set! :documentation trim cat string tree/ref "\n" :keyword #t]
1Ai 0
05
24
04i 1
1Ai 1
07
0D
15
1Ai 2
05
1Ai 3
07
0D
1Ai 3
05
0Bo 143
24
1B
09o 129
0D
1C
1Ai 3
05
11
1Ai 4
07
0D
15
1Ai 5
05
1Ai 4
05
04i 1
1Ai 6
07
0D
1Ai 6
05
1Ai 7
20
0Bo 10
1Ai 1
05
01
09o 81
1Ai 6
05
1Ai 8
20
0Bo 46
1Ai 9
05
1Ai 1
05
1Ai 10
1Ai 11
05
1Ai 12
05
1Ai 13
05
1Ai 14
05
1Ai 1
05
1Ai 10
04i 2
04i 1
1Ai 15
1Ai 4
05
04i 3
04i 1
04i 3
09o 29
1Ai 6
05
1Ai 16
20
0Bo 19
1Ai 9
05
1Ai 1
05
1Ai 4
05
1Ai 17
04i 3
09o 4
24
16
0D
1Ai 3
05
12
1Ai 3
08
1Ai 3
05
0Ao -129
09o 4
24
16
0D
1Ai 1
05
01
01
} defmacro [name args . body] #@[documentation: "Define a new macro" source: ["Define a new macro" [quasiquote [def [unquote name] [macro* '[unquote name] '[unquote args] [unquote [tree/set! [meta/parse/body :macro args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]]] #{##[def name macro* quote args tree/set! meta/parse/body :macro body :source compile/do* current-closure]
1Ai 0
1Ai 1
05
1Ai 2
1Ai 3
1Ai 1
05
24
14
14
1Ai 3
1Ai 4
05
24
14
14
1Ai 5
05
1Ai 6
05
1Ai 7
1Ai 4
05
1Ai 8
05
04i 3
1Ai 9
1Ai 8
05
04i 3
1Ai 3
1Ai 10
05
1Ai 8
05
1Ai 11
05
04i 0
04i 2
24
14
14
24
14
14
14
14
14
24
14
14
14
01
} fn [args . body] #@[documentation: "Define an anonymous function" source: ["Define an anonymous function" [quasiquote [fn* 'anonymous '[unquote args] [unquote [tree/set! [meta/parse/body :lambda args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]] #{##[fn* quote anonymous args tree/set! meta/parse/body :lambda body :source compile/do* current-closure]
1Ai 0
1Ai 1
1Ai 2
24
14
14
1Ai 1
1Ai 3
05
24
14
14
1Ai 4
05
1Ai 5
05
1Ai 6
1Ai 3
05
1Ai 7
05
04i 3
1Ai 8
1Ai 7
05
04i 3
1Ai 1
1Ai 9
05
1Ai 7
05
1Ai 10
05
04i 0
04i 2
24
14
14
24
14
14
14
14
14
01
} defn [name args . body] #@[documentation: "Define a new function" source: ["Define a new function" [quasiquote [def [unquote name] [fn* '[unquote name] '[unquote args] [unquote [tree/set! [meta/parse/body :lambda args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]]] #{##[def name fn* quote args tree/set! meta/parse/body :lambda body :source compile/do* current-closure]
1Ai 0
1Ai 1
05
1Ai 2
1Ai 3
1Ai 1
05
24
14
14
1Ai 3
1Ai 4
05
24
14
14
1Ai 5
05
1Ai 6
05
1Ai 7
1Ai 4
05
1Ai 8
05
04i 3
1Ai 9
1Ai 8
05
04i 3
1Ai 3
1Ai 10
05
1Ai 8
05
1Ai 11
05
04i 0
04i 2
24
14
14
24
14
14
14
14
14
24
14
14
14
01
} eval-in [closure expr] #@[documentation: "Compile and the immediatly evaluate the result\nMostly used by lRun()" source: ["Compile and the immediatly evaluate the result" "" "Mostly used by lRun()" [try display/error [apply closure [compile* expr closure]]]]] #{##[display/error apply closure compile* expr]
1Ai 0
05
19o 23
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 2
05
04i 2
04i 2
16
01
} eval [expr] #@[documentation: "Compile, Evaluate and then return the result of EXPR" source: ["Compile, Evaluate and then return the result of EXPR" [quasiquote [eval-in [current-closure] [unquote expr]]]]] #{##[eval-in current-closure expr]
1Ai 0
1Ai 1
24
14
1Ai 2
05
24
14
14
14
01
} typecheck/only [v t] #@[source: [[quasiquote [when-not [= [type-of [unquote v]] [unquote t]] [throw [list :type-error [unquote [fmt "Expected a value of type {t}"]] [unquote v] [current-lambda]]]]]]] #{##[when-not = type-of v t throw list :type-error cat "Expected a value of type " current-lambda]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
05
24
14
14
1Ai 4
05
24
14
14
14
1Ai 5
1Ai 6
1Ai 7
1Ai 8
05
1Ai 9
1Ai 4
05
04i 2
1Ai 3
05
1Ai 10
24
14
24
14
14
14
14
14
24
14
14
24
14
14
14
01
} typecheck/numeric/single [v] #@[source: [[quasiquote [when-not [numeric? [unquote v]] [throw [list :type-error [unquote [fmt "Expected numeric value"]] [unquote v] [current-lambda]]]]]]] #{##[when-not numeric? v throw list :type-error "Expected numeric value" current-lambda]
1Ai 0
1Ai 1
1Ai 2
05
24
14
14
1Ai 3
1Ai 4
1Ai 5
1Ai 6
1Ai 2
05
1Ai 7
24
14
24
14
14
14
14
14
24
14
14
24
14
14
14
01
} typecheck/numeric v #@[source: [[map v typecheck/numeric/single]]] #{##[map v typecheck/numeric/single]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
01
} profile-form [raw] #@[source: [[def start-time [time/milliseconds]] [def val [eval raw]] [def end-time [time/milliseconds]] [display [cat "Evaluating " [ansi-yellow [string/write raw]] " to " [ansi-green [string/write val]] " took " [ansi-red [cat [- end-time start-time] "ms"] "\n"]]]]] #{##[time/milliseconds start-time eval-in current-closure raw val end-time print cat "Evaluating " ansi-yellow string/write " to " ansi-green " took " ansi-red "ms" "\n"]
1Ai 0
05
04i 0
1Ai 1
07
0D
1Ai 2
05
1Ai 3
05
04i 0
1Ai 4
05
04i 2
1Ai 5
07
0D
1Ai 0
05
04i 0
1Ai 6
07
0D
1Ai 7
05
1Ai 8
05
1Ai 9
1Ai 10
05
1Ai 11
05
1Ai 4
05
04i 1
04i 1
1Ai 12
1Ai 13
05
1Ai 11
05
1Ai 5
05
04i 1
04i 1
1Ai 14
1Ai 15
05
1Ai 8
05
1Ai 6
05
1Ai 1
05
26
1Ai 16
04i 2
1Ai 17
04i 2
04i 6
04i 1
01
} profile body #@[documentation: "Measure and display how much time and ressources it takes for BODY to be evaluated" source: ["Measure and display how much time and ressources it takes for BODY to be evaluated" [quasiquote [profile-form '[unquote [if [last? body] [car body] [cons 'do body]]]]]]] #{##[profile-form quote nil? body do]
1Ai 0
1Ai 1
1Ai 2
05
1Ai 3
05
12
04i 1
0Bo 10
1Ai 3
05
11
09o 9
1Ai 4
1Ai 3
05
14
24
14
14
24
14
14
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
18
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
18
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
18
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
18
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
18
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 48
1Ai 49
1Ai 50
1Ai 51
18
1Ai 48
07
0D
1Ai 52
1Ai 53
1Ai 54
1Ai 55
18
1Ai 52
07
0D
1Ai 56
1Ai 57
1Ai 58
1Ai 59
17
1Ai 56
07
0D
1Ai 60
1Ai 61
1Ai 62
1Ai 63
18
1Ai 60
07
0D
1Ai 64
1Ai 65
1Ai 66
1Ai 67
17
1Ai 64
07
0D
1Ai 68
1Ai 69
1Ai 70
1Ai 71
18
1Ai 68
07
01
}#{##[pure? [expr] #@[source: [[and [not [pair? expr]] [not [symbol? expr]] #t]]] #{##[pair? expr #f #t symbol?]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 8
1Ai 2
09o 5
1Ai 3
0C
0Bo 29
0D
1Ai 4
05
1Ai 1
05
04i 1
0Bo 8
1Ai 2
09o 5
1Ai 3
0C
0Bo 6
0D
1Ai 3
01
} constant-foldable? [fun] #@[source: [[case fun [[add/int bit-and bit-or bit-xor bit-not bit-shift-left bit-shift-right popcount abs sqrt pow rem + - * / cat trim string/length uppercase lowercase capitalize] #t] [['add/int 'bit-and 'bit-or 'bit-xor 'bit-not 'bit-shift-left 'bit-shift-right 'popcount 'abs 'sqrt 'pow 'rem '+ '- '* '/ 'cat 'trim 'string/length 'uppercase 'lowercase 'capitalize] #t] [#t #f]]]] #{##[fun ΓεnΣym-1 add/int bit-and bit-or bit-xor bit-not bit-shift-left bit-shift-right popcount abs sqrt pow rem + - * / cat trim string/length uppercase lowercase capitalize #f #t]
15
1Ai 0
05
1Ai 1
07
0D
1Ai 1
05
1Ai 2
05
20
0C
0Ao 258
0D
1Ai 1
05
1Ai 3
05
20
0C
0Ao 246
0D
1Ai 1
05
1Ai 4
05
20
0C
0Ao 234
0D
1Ai 1
05
1Ai 5
05
20
0C
0Ao 222
0D
1Ai 1
05
1Ai 6
05
20
0C
0Ao 210
0D
1Ai 1
05
1Ai 7
05
20
0C
0Ao 198
0D
1Ai 1
05
1Ai 8
05
20
0C
0Ao 186
0D
1Ai 1
05
1Ai 9
05
20
0C
0Ao 174
0D
1Ai 1
05
1Ai 10
05
20
0C
0Ao 162
0D
1Ai 1
05
1Ai 11
05
20
0C
0Ao 150
0D
1Ai 1
05
1Ai 12
05
20
0C
0Ao 138
0D
1Ai 1
05
1Ai 13
05
20
0C
0Ao 126
0D
1Ai 1
05
1Ai 14
05
20
0C
0Ao 114
0D
1Ai 1
05
1Ai 15
05
20
0C
0Ao 102
0D
1Ai 1
05
1Ai 16
05
20
0C
0Ao 90
0D
1Ai 1
05
1Ai 17
05
20
0C
0Ao 78
0D
1Ai 1
05
1Ai 18
05
20
0C
0Ao 66
0D
1Ai 1
05
1Ai 19
05
20
0C
0Ao 54
0D
1Ai 1
05
1Ai 20
05
20
0C
0Ao 42
0D
1Ai 1
05
1Ai 21
05
20
0C
0Ao 30
0D
1Ai 1
05
1Ai 22
05
20
0C
0Ao 18
0D
1Ai 1
05
1Ai 23
05
20
0C
0Ao 6
0D
1Ai 24
0Bo 8
1Ai 25
09o 270
1Ai 1
05
1Ai 2
20
0C
0Ao 237
0D
1Ai 1
05
1Ai 3
20
0C
0Ao 226
0D
1Ai 1
05
1Ai 4
20
0C
0Ao 215
0D
1Ai 1
05
1Ai 5
20
0C
0Ao 204
0D
1Ai 1
05
1Ai 6
20
0C
0Ao 193
0D
1Ai 1
05
1Ai 7
20
0C
0Ao 182
0D
1Ai 1
05
1Ai 8
20
0C
0Ao 171
0D
1Ai 1
05
1Ai 9
20
0C
0Ao 160
0D
1Ai 1
05
1Ai 10
20
0C
0Ao 149
0D
1Ai 1
05
1Ai 11
20
0C
0Ao 138
0D
1Ai 1
05
1Ai 12
20
0C
0Ao 127
0D
1Ai 1
05
1Ai 13
20
0C
0Ao 116
0D
1Ai 1
05
1Ai 14
20
0C
0Ao 105
0D
1Ai 1
05
1Ai 15
20
0C
0Ao 94
0D
1Ai 1
05
1Ai 16
20
0C
0Ao 83
0D
1Ai 1
05
1Ai 17
20
0C
0Ao 72
0D
1Ai 1
05
1Ai 18
20
0C
0Ao 61
0D
1Ai 1
05
1Ai 19
20
0C
0Ao 50
0D
1Ai 1
05
1Ai 20
20
0C
0Ao 39
0D
1Ai 1
05
1Ai 21
20
0C
0Ao 28
0D
1Ai 1
05
1Ai 22
20
0C
0Ao 17
0D
1Ai 1
05
1Ai 23
20
0C
0Ao 6
0D
1Ai 24
0Bo 8
1Ai 25
09o 18
1Ai 1
05
1Ai 25
20
0Bo 8
1Ai 24
09o 4
24
16
01
} constant-fold/resolve [sym] #@[source: [[when-not [symbol? sym] [return sym]] [resolve sym]]] #{##[symbol? sym resolve]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 7
24
09o 7
1Ai 1
05
01
0D
1Ai 2
05
1Ai 1
05
04i 1
01
} constant-fold/args [expr] #@[source: [[when-not expr [return expr]] [if [pair? [car expr]] [cons [constant-fold [car expr]] [constant-fold/args [cdr expr]]] [cons [car expr] [constant-fold/args [cdr expr]]]]]] #{##[expr pair? constant-fold constant-fold/args]
1Ai 0
05
0Bo 7
24
09o 7
1Ai 0
05
01
0D
1Ai 1
05
1Ai 0
05
11
04i 1
0Bo 25
1Ai 2
05
1Ai 0
05
11
04i 1
1Ai 3
05
1Ai 0
05
12
04i 1
14
09o 17
1Ai 0
05
11
1Ai 3
05
1Ai 0
05
12
04i 1
14
01
} constant-fold [expr] #@[documentation: "Will try and evaluate as many constant as possible to make the expression simpler." source: ["Will try and evaluate as many constant as possible to make the expression simpler." [if-not [pair? expr] expr [do [def folded-fun [car expr]] [when [= 'quote folded-fun] [return expr]] [def folded-args [constant-fold/args [cdr expr]]] [if [and [constant-foldable? folded-fun] [every? folded-args pure?]] [try [fn [] [cons folded-fun folded-args]] [apply [constant-fold/resolve folded-fun] folded-args]] [cons folded-fun folded-args]]]]]] #{##[pair? expr folded-fun quote constant-fold/args folded-args constant-foldable? every? pure? anonymous [] #@[source: [[cons folded-fun folded-args]]] #{##[folded-fun folded-args]
1Ai 0
05
1Ai 1
05
14
01
} apply constant-fold/resolve]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 111
1Ai 1
05
11
1Ai 2
07
0D
1Ai 3
1Ai 2
05
20
0Bo 10
1Ai 1
05
01
09o 4
24
0D
1Ai 4
05
1Ai 1
05
12
04i 1
1Ai 5
07
0D
1Ai 6
05
1Ai 2
05
04i 1
0C
0Bo 15
0D
1Ai 7
05
1Ai 5
05
1Ai 8
05
04i 2
0Bo 35
1Ai 9
1Ai 10
1Ai 11
1Ai 12
17
19o 20
1Ai 13
05
1Ai 14
05
1Ai 2
05
04i 1
1Ai 5
05
04i 2
16
09o 10
1Ai 2
05
1Ai 5
05
14
09o 6
1Ai 1
05
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
01
}#{##[macroexpand/do/args [args env] #@[source: [[if [last? args] [cons [macroexpand* [car args] env] #nil] [if [pair? [car args]] [let* [def ocar [macroexpand* [car args] env]] [if [pair? ocar] [cons ocar [macroexpand/do/args [cdr args] env]] [macroexpand/do/args [cdr args] env]]] [macroexpand/do/args [cdr args] env]]]]] #{##[nil? args macroexpand* env pair? ocar macroexpand/do/args]
1Ai 0
05
1Ai 1
05
12
04i 1
0Bo 20
1Ai 2
05
1Ai 1
05
11
1Ai 3
05
04i 2
24
14
09o 90
1Ai 4
05
1Ai 1
05
11
04i 1
0Bo 66
15
1Ai 2
05
1Ai 1
05
11
1Ai 3
05
04i 2
1Ai 5
07
0D
1Ai 4
05
1Ai 5
05
04i 1
0Bo 22
1Ai 5
05
1Ai 6
05
1Ai 1
05
12
1Ai 3
05
04i 2
14
09o 15
1Ai 6
05
1Ai 1
05
12
1Ai 3
05
04i 2
16
09o 15
1Ai 6
05
1Ai 1
05
12
1Ai 3
05
04i 2
01
} macroexpand/do [source env] #@[source: [[def args [macroexpand/do/args source env]] [if [last? args] [car args] [cons 'do args]]]] #{##[macroexpand/do/args source env args nil? do]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
1Ai 3
07
0D
1Ai 4
05
1Ai 3
05
12
04i 1
0Bo 10
1Ai 3
05
11
09o 9
1Ai 5
1Ai 3
05
14
01
} macroexpand/form [source env op arity implicit-do? no-expand-bitmap] #@[source: [[def ret [cons op #nil]] [def l [cdr source]] [dotimes [i arity] [set! ret [cons [if [bit-set? no-expand-bitmap i] [car l] [macroexpand* [car l] env]] ret]] [cdr! l]] [if implicit-do? [set! ret [cons [macroexpand/do l env] ret]] [when l [throw [list :arity-error [cat "form contains more than " arity " arguments"] source [current-lambda]]]]] [return [nreverse ret]]]] #{##[op ret source l i bit-set? no-expand-bitmap macroexpand* env arity implicit-do? macroexpand/do throw list :arity-error cat "form contains more than " " arguments" current-lambda nreverse]
1Ai 0
05
24
14
1Ai 1
07
0D
1Ai 2
05
12
1Ai 3
07
0D
15
02i 0
1Ai 4
07
0D
24
1B
09o 63
0D
1C
1Ai 5
05
1Ai 6
05
1Ai 4
05
04i 2
0Bo 10
1Ai 3
05
11
09o 15
1Ai 7
05
1Ai 3
05
11
1Ai 8
05
04i 2
1Ai 1
05
14
1Ai 1
08
0D
1Ai 3
05
12
1Ai 3
08
0D
02i 1
1Ai 4
05
03
1Ai 4
08
1Ai 4
05
1Ai 9
05
1E
0Ao -67
0D
24
16
0D
1Ai 10
05
0Bo 24
1Ai 11
05
1Ai 3
05
1Ai 8
05
04i 2
1Ai 1
05
14
1Ai 1
08
09o 45
1Ai 3
05
0Bo 38
1Ai 12
05
1Ai 13
05
1Ai 14
1Ai 15
05
1Ai 16
1Ai 9
05
1Ai 17
04i 3
1Ai 2
05
1Ai 18
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 19
05
1Ai 1
05
04i 1
01
01
} macroexpand/fold [op source env] #@[source: [[if [cdr source] [if [cddr source] [list op [macroexpand/fold op [except-last-pair source] env] [macroexpand* [car [last-pair source]] env]] [list op [macroexpand* [car source] env] [macroexpand* [cadr source] env]]] [list op [macroexpand* [car source] env]]]]] #{##[source list op macroexpand/fold except-last-pair env macroexpand* last-pair]
1Ai 0
05
12
0Bo 94
1Ai 0
05
12
12
0Bo 50
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 2
05
1Ai 4
05
1Ai 0
05
04i 1
1Ai 5
05
04i 3
1Ai 6
05
1Ai 7
05
1Ai 0
05
04i 1
11
1Ai 5
05
04i 2
04i 3
09o 36
1Ai 1
05
1Ai 2
05
1Ai 6
05
1Ai 0
05
11
1Ai 5
05
04i 2
1Ai 6
05
1Ai 0
05
12
11
1Ai 5
05
04i 2
04i 3
09o 23
1Ai 1
05
1Ai 2
05
1Ai 6
05
1Ai 0
05
11
1Ai 5
05
04i 2
04i 2
01
} macroexpand* [source env] #@[documentation: "Expand all macros within source" source: ["Expand all macros within source" [def op [if [resolves? [car source] env] [resolve [car source] env] [car source]]] [case [type-of op] [:nil source] [:native-function [case op [[+ - * / rem bit-and bit-or bit-xor] [macroexpand/fold op [cdr source]]] [do [macroexpand/do source env]] [return [macroexpand/form source env op 1 #f 0]] [[try while] [macroexpand/form source env op 1 #t 0]] [[def set!] [macroexpand/form source env op 2 #f 1]] [if [macroexpand/form source env op 3 #f 0]] [[fn* macro*] [macroexpand/form source env op 4 #t 7]] [[let* environment*] [list op [macroexpand/do [cdr source] env]]] 'source [otherwise [map source [fn [α] [macroexpand* α env]]]]]] [:macro [macroexpand* [macro-apply op [cdr source]] env]] [otherwise [map source [fn [α] [macroexpand* α env]]]]]]] #{##[resolves? source env resolve op type-of ΓεnΣym-1 :nil :native-function ΓεnΣym-2 + - * / rem bit-and bit-or bit-xor #f macroexpand/fold do macroexpand/do return macroexpand/form try while #t def set! if fn* macro* let* environment* list quote map anonymous [α] #@[source: [[macroexpand* α env]]] #{##[macroexpand* α env]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
01
} :macro macroexpand* macro-apply [α] #{##[macroexpand* α env]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
01
}]
1Ai 0
05
1Ai 1
05
11
1Ai 2
05
04i 2
0Bo 18
1Ai 3
05
1Ai 1
05
11
1Ai 2
05
04i 2
09o 7
1Ai 1
05
11
1Ai 4
07
0D
15
1Ai 5
05
1Ai 4
05
04i 1
1Ai 6
07
0D
1Ai 6
05
1Ai 7
20
0Bo 9
1Ai 1
05
09o 520
1Ai 6
05
1Ai 8
20
0Bo 462
15
1Ai 4
05
1Ai 9
07
0D
1Ai 9
05
1Ai 10
05
20
0C
0Ao 90
0D
1Ai 9
05
1Ai 11
05
20
0C
0Ao 78
0D
1Ai 9
05
1Ai 12
05
20
0C
0Ao 66
0D
1Ai 9
05
1Ai 13
05
20
0C
0Ao 54
0D
1Ai 9
05
1Ai 14
05
20
0C
0Ao 42
0D
1Ai 9
05
1Ai 15
05
20
0C
0Ao 30
0D
1Ai 9
05
1Ai 16
05
20
0C
0Ao 18
0D
1Ai 9
05
1Ai 17
05
20
0C
0Ao 6
0D
1Ai 18
0Bo 18
1Ai 19
05
1Ai 4
05
1Ai 1
05
12
04i 2
09o 334
1Ai 9
05
1Ai 20
05
20
0Bo 17
1Ai 21
05
1Ai 1
05
1Ai 2
05
04i 2
09o 310
1Ai 9
05
1Ai 22
05
20
0Bo 26
1Ai 23
05
1Ai 1
05
1Ai 2
05
1Ai 4
05
02i 1
1Ai 18
02i 0
04i 6
09o 277
1Ai 9
05
1Ai 24
05
20
0C
0Ao 18
0D
1Ai 9
05
1Ai 25
05
20
0C
0Ao 6
0D
1Ai 18
0Bo 26
1Ai 23
05
1Ai 1
05
1Ai 2
05
1Ai 4
05
02i 1
1Ai 26
02i 0
04i 6
09o 225
1Ai 9
05
1Ai 27
05
20
0C
0Ao 18
0D
1Ai 9
05
1Ai 28
05
20
0C
0Ao 6
0D
1Ai 18
0Bo 26
1Ai 23
05
1Ai 1
05
1Ai 2
05
1Ai 4
05
02i 2
1Ai 18
02i 1
04i 6
09o 173
1Ai 9
05
1Ai 29
05
20
0Bo 26
1Ai 23
05
1Ai 1
05
1Ai 2
05
1Ai 4
05
02i 3
1Ai 18
02i 0
04i 6
09o 140
1Ai 9
05
1Ai 30
05
20
0C
0Ao 18
0D
1Ai 9
05
1Ai 31
05
20
0C
0Ao 6
0D
1Ai 18
0Bo 26
1Ai 23
05
1Ai 1
05
1Ai 2
05
1Ai 4
05
02i 4
1Ai 26
02i 7
04i 6
09o 88
1Ai 9
05
1Ai 32
05
20
0C
0Ao 18
0D
1Ai 9
05
1Ai 33
05
20
0C
0Ao 6
0D
1Ai 18
0Bo 26
1Ai 34
05
1Ai 4
05
1Ai 21
05
1Ai 1
05
12
1Ai 2
05
04i 2
04i 2
09o 36
1Ai 9
05
1Ai 35
05
20
0Bo 9
1Ai 1
05
09o 20
1Ai 36
05
1Ai 1
05
1Ai 37
1Ai 38
1Ai 39
1Ai 40
17
04i 2
16
09o 52
1Ai 6
05
1Ai 41
20
0Bo 26
1Ai 42
05
1Ai 43
05
1Ai 4
05
1Ai 1
05
12
04i 2
1Ai 2
05
04i 2
09o 20
1Ai 36
05
1Ai 1
05
1Ai 37
1Ai 44
1Ai 39
1Ai 45
17
04i 2
16
01
} macroexpand [source env] #@[documentation: "Macroexpand the forms in source" source: ["Macroexpand the forms in source" [macroexpand* source [or env [current-closure]]]]] #{##[macroexpand* source env current-closure #f]
1Ai 0
05
1Ai 1
05
1Ai 2
05
0C
0Ao 16
0D
1Ai 3
05
04i 0
0C
0Ao 6
0D
1Ai 4
04i 2
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
01
}#{##[let/arg [arg] #@[source: [[when arg [when [or [not [pair? arg]] [not [symbol? [car arg]]]] [throw [list :invalid-let-form "Please fix the structure of the let form" arg]]] [quasiquote [def [unquote [car arg]] [unquote [cadr arg]]]]]]] #{##[arg pair? #f #t symbol? throw list :invalid-let-form "Please fix the structure of the let form" def]
1Ai 0
05
0Bo 95
1Ai 1
05
1Ai 0
05
04i 1
0Bo 8
1Ai 2
09o 5
1Ai 3
0C
0Ao 30
0D
1Ai 4
05
1Ai 0
05
11
04i 1
0Bo 8
1Ai 2
09o 5
1Ai 3
0C
0Ao 6
0D
1Ai 2
0Bo 23
1Ai 5
05
1Ai 6
05
1Ai 7
1Ai 8
1Ai 0
05
04i 3
04i 1
09o 4
24
0D
1Ai 9
1Ai 0
05
11
1Ai 0
05
12
11
24
14
14
14
09o 4
24
01
} let/args [args] #@[source: [[if-not args #nil [cons [let/arg [car args]] [let/args [cdr args]]]]]] #{##[args let/arg let/args]
1Ai 0
05
0Bo 25
1Ai 1
05
1Ai 0
05
11
04i 1
1Ai 2
05
1Ai 0
05
12
04i 1
14
09o 4
24
01
} let [bindings . body] #@[documentation: "Evalutes to BODY if PRED is true" source: ["Evalutes to BODY if PRED is true" [quasiquote [let* [do [unquote-splicing [let/args bindings]] [unquote-splicing body]]]]]] #{##[let* do append let/args bindings body]
1Ai 0
1Ai 1
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 1
1Ai 2
05
1Ai 5
05
24
04i 2
04i 2
14
24
14
14
01
} if-let [binding then else] #@[source: [[quasiquote [let* [def [unquote [car binding]] [unquote [cadr binding]]] [if [unquote [car binding]] [unquote then] [unquote else]]]]]] #{##[let* def binding if then else]
1Ai 0
1Ai 1
1Ai 2
05
11
1Ai 2
05
12
11
24
14
14
14
1Ai 3
1Ai 2
05
11
1Ai 4
05
1Ai 5
05
24
14
14
14
14
24
14
14
14
01
} when-let [binding . body] #@[source: [[quasiquote [if-let [unquote binding] [unquote [cons 'do body]] #nil]]]] #{##[if-let binding do body]
1Ai 0
1Ai 1
05
1Ai 2
1Ai 3
05
14
24
24
14
14
14
14
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
18
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
18
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
18
1Ai 16
07
01
}#{##[#t otherwise deftest l #@[source: []] #{##[]
24
01
} defqtest #{##[]
24
01
} comment body #@[documentation: "Does nothing" source: ["Does nothing" #nil]] #{##[]
24
01
} += [val inc] #@[source: [[quasiquote [set! [unquote val] [+ [unquote val] [unquote inc]]]]]] #{##[set! val + inc]
1Ai 0
1Ai 1
05
1Ai 2
1Ai 1
05
1Ai 3
05
24
14
14
14
24
14
14
14
01
} cdr! [l] #@[documentation: "[set! l [cdr l]]" source: ["[set! l [cdr l]]" [quasiquote [set! [unquote l] [cdr [unquote l]]]]]] #{##[set! l cdr]
1Ai 0
1Ai 1
05
1Ai 2
1Ai 1
05
24
14
14
24
14
14
14
01
} boolean [v] #@[documentation: "Coerce to boolean" source: [:inline "Coerce to boolean" [if v #t #f]] inline: #t] #{##[v #t #f]
1Ai 0
05
0Bo 8
1Ai 1
09o 5
1Ai 2
01
} not [v] #@[documentation: "Return true if V is false" source: [:inline "Return true if V is false" [if v #f #t]] inline: #t] #{##[v #f #t]
1Ai 0
05
0Bo 8
1Ai 1
09o 5
1Ai 2
01
} identity [α] #@[documentation: "Returns its argument" source: [:inline "Returns its argument" α] inline: #t] #{##[α]
1Ai 0
05
01
} list arguments #@[documentation: "Return ARGUMENTS as a list" source: ["Return ARGUMENTS as a list" arguments]] #{##[arguments]
1Ai 0
05
01
} caar [p] #@[documentation: "[car [car p]]" source: [:inline "[car [car p]]" [car [car p]]] inline: #t] #{##[p]
1Ai 0
05
11
11
01
} cadr [p] #@[documentation: "[car [cdr p]]" source: [:inline "[car [cdr p]]" [car [cdr p]]] inline: #t] #{##[p]
1Ai 0
05
12
11
01
} cdar [p] #@[documentation: "[cdr [car p]]" source: [:inline "[cdr [car p]]" [cdr [car p]]] inline: #t] #{##[p]
1Ai 0
05
11
12
01
} cddr [p] #@[documentation: "[cdr [cdr p]]" source: [:inline "[cdr [cdr p]]" [cdr [cdr p]]] inline: #t] #{##[p]
1Ai 0
05
12
12
01
} cadar [p] #@[documentation: "[cdr [car p]]" source: ["[cdr [car p]]" [car [cdr [car p]]]]] #{##[p]
1Ai 0
05
11
12
11
01
} caddr [p] #@[documentation: "[car [cdr [cdr p]]]" source: ["[car [cdr [cdr p]]]" [car [cdr [cdr p]]]]] #{##[p]
1Ai 0
05
12
12
11
01
} cdddr [p] #@[documentation: "[cdr [cdr [cdr p]]]" source: ["[cdr [cdr [cdr p]]]" [cdr [cdr [cdr p]]]]] #{##[p]
1Ai 0
05
12
12
12
01
} cadddr [p] #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [car [cdr [cdr [cdr p]]]]]] #{##[p]
1Ai 0
05
12
12
12
11
01
} cddddr [p] #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [cdr [cdr [cdr [cdr p]]]]]] #{##[p]
1Ai 0
05
12
12
12
12
01
} caddddr [p] #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [car [cdr [cdr [cdr [cdr p]]]]]]] #{##[p]
1Ai 0
05
12
12
12
12
11
01
} cdddddr [p] #@[documentation: "[cdr [cdr [cdr [cdr p]]]]" source: ["[cdr [cdr [cdr [cdr p]]]]" [cdr [cdr [cdr [cdr [cdr p]]]]]]] #{##[p]
1Ai 0
05
12
12
12
12
12
01
} keyword->string [α] #@[source: [[when-not [keyword? α] [throw [list :type-error "[keyword->string] can only be called on keywords" α [current-lambda]]]] [symbol->string [keyword->symbol α]]]] #{##[keyword? α throw list :type-error "[keyword->string] can only be called on keywords" current-lambda symbol->string keyword->symbol]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 7
24
09o 25
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 5
1Ai 1
05
1Ai 6
05
04i 0
04i 4
04i 1
0D
1Ai 7
05
1Ai 8
05
1Ai 1
05
04i 1
04i 1
01
} string->keyword [α] #@[source: [[when-not [string? α] [throw [list :type-error "[string->keyword] can only be called on strings" α [current-lambda]]]] [symbol->keyword [string->symbol α]]]] #{##[string? α throw list :type-error "[string->keyword] can only be called on strings" current-lambda symbol->keyword string->symbol]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 7
24
09o 25
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 5
1Ai 1
05
1Ai 6
05
04i 0
04i 4
04i 1
0D
1Ai 7
05
1Ai 8
05
1Ai 1
05
04i 1
04i 1
01
} exception [type description value] #@[source: [[quasiquote [throw [list [unquote type] [unquote description] [unquote value] [current-lambda]]]]]] #{##[throw list type description value current-lambda]
1Ai 0
1Ai 1
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
24
14
24
14
14
14
14
14
24
14
14
01
}]
1Ai 0
1Ai 1
07
0D
1Ai 2
1Ai 3
1Ai 4
1Ai 5
18
1Ai 2
07
0D
1Ai 6
1Ai 3
1Ai 4
1Ai 7
18
1Ai 6
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
18
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
18
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
18
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
17
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 48
1Ai 49
1Ai 50
1Ai 51
17
1Ai 48
07
0D
1Ai 52
1Ai 53
1Ai 54
1Ai 55
17
1Ai 52
07
0D
1Ai 56
1Ai 57
1Ai 58
1Ai 59
17
1Ai 56
07
0D
1Ai 60
1Ai 61
1Ai 62
1Ai 63
17
1Ai 60
07
0D
1Ai 64
1Ai 65
1Ai 66
1Ai 67
17
1Ai 64
07
0D
1Ai 68
1Ai 69
1Ai 70
1Ai 71
17
1Ai 68
07
0D
1Ai 72
1Ai 73
1Ai 74
1Ai 75
17
1Ai 72
07
0D
1Ai 76
1Ai 77
1Ai 78
1Ai 79
17
1Ai 76
07
0D
1Ai 80
1Ai 81
1Ai 82
1Ai 83
17
1Ai 80
07
0D
1Ai 84
1Ai 85
1Ai 86
1Ai 87
17
1Ai 84
07
0D
1Ai 88
1Ai 89
1Ai 90
1Ai 91
18
1Ai 88
07
01
}#{##[if-not [pred then else] #@[source: [[quasiquote [if [unquote pred] [unquote else] [unquote then]]]]] #{##[if pred else then]
1Ai 0
1Ai 1
05
1Ai 2
05
1Ai 3
05
24
14
14
14
14
01
} when-not [pred . body] #@[documentation: "Evalutes to BODY if PRED is false" source: ["Evalutes to BODY if PRED is false" [quasiquote [if [unquote pred] #nil [do [unquote-splicing body]]]]]] #{##[if pred do append body]
1Ai 0
1Ai 1
05
24
1Ai 2
1Ai 3
05
1Ai 4
05
24
04i 2
14
24
14
14
14
14
01
} when [pred . body] #@[documentation: "Evalutes to BODY if PRED is true" source: ["Evalutes to BODY if PRED is true" [quasiquote [if [unquote pred] [do [unquote-splicing body]] #nil]]]] #{##[if pred do append body]
1Ai 0
1Ai 1
05
1Ai 2
1Ai 3
05
1Ai 4
05
24
04i 2
14
24
24
14
14
14
14
01
} case/clauses/multiple [key-sym cases] #@[source: [[when cases [cons [list '= key-sym [car cases]] [case/clauses/multiple key-sym [cdr cases]]]]]] #{##[cases list = key-sym case/clauses/multiple]
1Ai 0
05
0Bo 33
1Ai 1
05
1Ai 2
1Ai 3
05
1Ai 0
05
11
04i 3
1Ai 4
05
1Ai 3
05
1Ai 0
05
12
04i 2
14
09o 4
24
01
} case/clauses [key-sym clauses] #@[source: [[when clauses [if [= [caar clauses] 'otherwise] [cons 'do [cdar clauses]] [list 'if [if [pair? [caar clauses]] [if [and [= [car [caar clauses]] 'quote] [last? [cdr [caar clauses]]] [symbol? [cadr [caar clauses]]]] [list '= key-sym [caar clauses]] [cons 'or [case/clauses/multiple key-sym [caar clauses]]]] [list '= key-sym [caar clauses]]] [cons 'do [cdar clauses]] [case/clauses key-sym [cdr clauses]]]]]]] #{##[clauses otherwise do list if pair? quote nil? symbol? = key-sym or case/clauses/multiple case/clauses]
1Ai 0
05
0Bo 166
1Ai 0
05
11
11
1Ai 1
20
0Bo 14
1Ai 2
1Ai 0
05
11
12
14
09o 141
1Ai 3
05
1Ai 4
1Ai 5
05
1Ai 0
05
11
11
04i 1
0Bo 86
1Ai 0
05
11
11
11
1Ai 6
20
0C
0Bo 33
0D
1Ai 7
05
1Ai 0
05
11
11
12
12
04i 1
0C
0Bo 16
0D
1Ai 8
05
1Ai 0
05
11
11
12
11
04i 1
0Bo 21
1Ai 3
05
1Ai 9
1Ai 10
05
1Ai 0
05
11
11
04i 3
09o 19
1Ai 11
1Ai 12
05
1Ai 10
05
1Ai 0
05
11
11
04i 2
14
09o 18
1Ai 3
05
1Ai 9
1Ai 10
05
1Ai 0
05
11
11
04i 3
1Ai 2
1Ai 0
05
11
12
14
1Ai 13
05
1Ai 10
05
1Ai 0
05
12
04i 2
04i 4
09o 4
24
01
} case [key-form . clauses] #@[source: [[def key-sym [gensym]] [list 'let* [list 'def key-sym key-form] [case/clauses key-sym clauses]]]] #{##[gensym key-sym list let* def key-form case/clauses clauses]
1Ai 0
05
04i 0
1Ai 1
07
0D
1Ai 2
05
1Ai 3
1Ai 2
05
1Ai 4
1Ai 1
05
1Ai 5
05
04i 3
1Ai 6
05
1Ai 1
05
1Ai 7
05
04i 2
04i 3
01
} cond body #@[documentation: "Contains multiple cond clauses" source: ["Contains multiple cond clauses" [when [and body [caar body]] [list 'if [caar body] [cons 'do [cdar body]] [macro-apply cond [cdr body]]]]]] #{##[body list if do macro-apply cond]
1Ai 0
05
0C
0Bo 9
0D
1Ai 0
05
11
11
0Bo 38
1Ai 1
05
1Ai 2
1Ai 0
05
11
11
1Ai 3
1Ai 0
05
11
12
14
1Ai 4
05
1Ai 5
05
1Ai 0
05
12
04i 2
04i 4
09o 4
24
01
} dotimes [binding . body] #@[documentation: "binding => [name n result-form]\nRepeatedly executes body with name bound to integers from 0 through n-1. Returns result-form or #nil." source: ["binding => [name n result-form]" "Repeatedly executes body with name bound to integers from 0 through n-1. Returns result-form or #nil." [def sym [car binding]] [typecheck/only sym :symbol] [def times [cadr binding]] [def result-form [caddr binding]] [quasiquote [let [[[unquote sym] 0]] [while [< [unquote sym] [unquote times]] [unquote-splicing body] [set! [unquote sym] [add/int 1 [unquote sym]]]] [unquote result-form]]]]] #{##[binding sym type-of :symbol throw list :type-error "Expected a value of type :symbol" current-lambda times caddr result-form let while < append body set! add/int]
1Ai 0
05
11
1Ai 1
07
0D
1Ai 2
05
1Ai 1
05
04i 1
1Ai 3
20
0Bo 7
24
09o 25
1Ai 4
05
1Ai 5
05
1Ai 6
1Ai 7
1Ai 1
05
1Ai 8
05
04i 0
04i 4
04i 1
0D
1Ai 0
05
12
11
1Ai 9
07
0D
1Ai 10
05
1Ai 0
05
04i 1
1Ai 11
07
0D
1Ai 12
1Ai 1
05
02i 0
24
14
14
24
14
1Ai 13
1Ai 14
1Ai 1
05
1Ai 9
05
24
14
14
14
1Ai 15
05
1Ai 16
05
1Ai 17
1Ai 1
05
1Ai 18
02i 1
1Ai 1
05
24
14
14
14
24
14
14
14
24
14
04i 2
14
14
1Ai 11
05
24
14
14
14
14
01
} doseq [for-loop . body] #@[documentation: "[doseq [l [list 1 2 3 4]] [println l]]" source: ["[doseq [l [list 1 2 3 4]] [println l]]" [def symbol-name [gensym]] [quasiquote [let [[[unquote symbol-name] [unquote [cadr for-loop]]]] [when [unquote symbol-name] [while [unquote symbol-name] [def [unquote [car for-loop]] [car [unquote symbol-name]]] [unquote-splicing body] [cdr! [unquote symbol-name]]]]]]]] #{##[gensym symbol-name let for-loop when while def car append body cdr!]
1Ai 0
05
04i 0
1Ai 1
07
0D
1Ai 2
1Ai 1
05
1Ai 3
05
12
11
24
14
14
24
14
1Ai 4
1Ai 1
05
1Ai 5
1Ai 1
05
1Ai 6
1Ai 3
05
11
1Ai 7
1Ai 1
05
24
14
14
24
14
14
14
1Ai 8
05
1Ai 9
05
1Ai 10
1Ai 1
05
24
14
14
24
14
04i 2
14
14
14
24
14
14
14
24
14
14
14
01
} thread/-> [init fun] #@[source: [[if-not fun init [if [pair? [car fun]] [quasiquote [[unquote [caar fun]] [unquote [thread/-> init [cdr fun]]] [unquote-splicing [cdar fun]]]] [list [car fun] [thread/-> init [cdr fun]]]]]]] #{##[fun pair? thread/-> init append list]
1Ai 0
05
0Bo 72
1Ai 1
05
1Ai 0
05
11
04i 1
0Bo 36
1Ai 0
05
11
11
1Ai 2
05
1Ai 3
05
1Ai 0
05
12
04i 2
1Ai 4
05
1Ai 0
05
11
12
24
04i 2
14
14
09o 24
1Ai 5
05
1Ai 0
05
11
1Ai 2
05
1Ai 3
05
1Ai 0
05
12
04i 2
04i 2
09o 6
1Ai 3
05
01
} -> [init . fun] #@[documentation: "Thread init as the first argument through every function in fun" source: ["Thread init as the first argument through every function in fun" [thread/-> init [reverse fun]]]] #{##[thread/-> init reverse fun]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
04i 2
01
} thread/->> [init fun] #@[source: [[if-not fun init [append [car fun] [cons [thread/->> init [cdr fun]] #nil]]]]] #{##[fun append thread/->> init]
1Ai 0
05
0Bo 29
1Ai 1
05
1Ai 0
05
11
1Ai 2
05
1Ai 3
05
1Ai 0
05
12
04i 2
24
14
04i 2
09o 6
1Ai 3
05
01
} ->> [init . fun] #@[documentation: "Thread init as the last argument through every function in fun" source: ["Thread init as the last argument through every function in fun" [thread/->> init [reverse fun]]]] #{##[thread/->> init reverse fun]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
04i 2
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
18
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
18
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
18
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
18
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
18
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
18
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
18
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
18
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 48
1Ai 49
1Ai 50
1Ai 51
18
1Ai 48
07
01
}#{##[tree/new module/cache module/loader module/add-loader [f] #@[source: [[set! module/loader [cons f module/loader]]]] #{##[f module/loader]
1Ai 0
05
1Ai 1
05
14
1Ai 1
08
01
} module/save-state [] #@[source: [[tree/new :cache module/cache :loader module/loader]]] #{##[tree/new :cache module/cache :loader module/loader]
1Ai 0
05
1Ai 1
1Ai 2
05
1Ai 3
1Ai 4
05
04i 4
01
} module/restore-state [c] #@[source: [[set! module/cache [tree/ref c :cache]] [set! module/loader [tree/ref c :loader]]]] #{##[tree/ref c :cache module/cache :loader module/loader]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
1Ai 3
08
0D
1Ai 0
05
1Ai 1
05
1Ai 4
04i 2
1Ai 5
08
01
} module/qualify-symbol [module-name symbol] #@[source: [[string->symbol [cat [keyword->symbol module-name] "/" [string symbol]]]]] #{##[string->symbol cat keyword->symbol module-name "/" string symbol]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
1Ai 4
1Ai 5
05
1Ai 6
05
04i 1
04i 3
04i 1
01
} module body #@[documentation: "Define a new module and return it" source: ["Define a new module and return it" [macroexpand [cons 'environment* [cons '[def exports [tree/new #nil]] body]]]]] #{##[macroexpand environment* [def exports [tree/new #nil]] body]
1Ai 0
05
1Ai 1
1Ai 2
1Ai 3
05
14
14
04i 1
01
} defmodule [name . body] #@[documentation: "Define a new named module" source: ["Define a new named module" [quasiquote [module/insert [unquote name] [unquote [cons module body]]]]]] #{##[module/insert name module body]
1Ai 0
1Ai 1
05
1Ai 2
05
1Ai 3
05
14
24
14
14
14
01
} export [name value] #@[source: [[quasiquote [tree/set! exports '[unquote name] [unquote value]]]]] #{##[tree/set! exports quote name value]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
05
24
14
14
1Ai 4
05
24
14
14
14
14
01
} require* [module env qualify?] #@[source: [[def mod [module/load module]] [def exports [resolve 'exports mod]] [doseq [k [tree/keys exports]] [def q [if qualify? [module/qualify-symbol module [keyword->symbol k]] [keyword->symbol k]]] [def expr [quasiquote [def [unquote q] [module/import [unquote mod] '[unquote [keyword->symbol k]]]]]] [apply env [compile* expr env]]]]] #{##[module/load module mod resolve exports tree/keys ΓεnΣym-1 k qualify? module/qualify-symbol keyword->symbol q def module/import quote expr apply env compile*]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 3
05
1Ai 4
1Ai 2
05
04i 2
1Ai 4
07
0D
15
1Ai 5
05
1Ai 4
05
04i 1
1Ai 6
07
0D
1Ai 6
05
0Bo 126
24
1B
09o 112
0D
1C
1Ai 6
05
11
1Ai 7
07
0D
1Ai 8
05
0Bo 22
1Ai 9
05
1Ai 1
05
1Ai 10
05
1Ai 7
05
04i 1
04i 2
09o 11
1Ai 10
05
1Ai 7
05
04i 1
1Ai 11
07
0D
1Ai 12
1Ai 11
05
1Ai 13
1Ai 2
05
1Ai 14
1Ai 10
05
1Ai 7
05
04i 1
24
14
14
24
14
14
14
24
14
14
14
1Ai 15
07
0D
1Ai 16
05
1Ai 17
05
1Ai 18
05
1Ai 15
05
1Ai 17
05
04i 2
04i 2
0D
1Ai 6
05
12
1Ai 6
08
1Ai 6
05
0Ao -112
09o 4
24
16
01
} use [module] #@[source: [[quasiquote [require* [unquote module] [current-closure] #f]]]] #{##[require* module current-closure #f]
1Ai 0
1Ai 1
05
1Ai 2
24
14
1Ai 3
24
14
14
14
14
01
} require [module] #@[source: [[quasiquote [require* [unquote module] [current-closure] #t]]]] #{##[require* module current-closure #t]
1Ai 0
1Ai 1
05
1Ai 2
24
14
1Ai 3
24
14
14
14
14
01
} import* [local-symbol module module-symbol] #@[source: [[quasiquote [def [unquote local-symbol] [module/import [unquote module] '[unquote module-symbol]]]]]] #{##[def local-symbol module/import module quote module-symbol]
1Ai 0
1Ai 1
05
1Ai 2
1Ai 3
05
1Ai 4
1Ai 5
05
24
14
14
24
14
14
14
24
14
14
14
01
} import [names module] #@[source: [[when-not [list? names] [return [quasiquote [import* [unquote names] [module/load [unquote module]] [unquote names]]]]] [def ret #nil] [while names [if [= [cadr names] :as] [do [set! ret [cons [quasiquote [import* [unquote [caddr names]] [module/load [unquote module]] [unquote [car names]]]] ret]] [set! names [cddr names]]] [set! ret [cons [quasiquote [import* [unquote [car names]] [module/load [unquote module]] [unquote [car names]]]] ret]]] [cdr! names]] [cons do [nreverse ret]]]] #{##[list? names import* module/load module ret :as caddr do nreverse]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 7
24
09o 25
1Ai 2
1Ai 1
05
1Ai 3
1Ai 4
05
24
14
14
1Ai 1
05
24
14
14
14
14
01
0D
24
1Ai 5
07
0D
24
1B
09o 100
0D
1C
1Ai 1
05
12
11
1Ai 6
20
0Bo 49
1Ai 2
1Ai 7
05
1Ai 1
05
04i 1
1Ai 3
1Ai 4
05
24
14
14
1Ai 1
05
11
24
14
14
14
14
1Ai 5
05
14
1Ai 5
08
0D
1Ai 1
05
12
12
1Ai 1
08
09o 33
1Ai 2
1Ai 1
05
11
1Ai 3
1Ai 4
05
24
14
14
1Ai 1
05
11
24
14
14
14
14
1Ai 5
05
14
1Ai 5
08
0D
1Ai 1
05
12
1Ai 1
08
1Ai 1
05
0Ao -100
0D
1Ai 8
05
1Ai 9
05
1Ai 5
05
04i 1
14
01
} module/load/external [name] #@[source: [[doseq [loader module/loader] [def mod [loader name]] [when mod [return mod]]] [return #nil]]] #{##[module/loader ΓεnΣym-2 loader name mod]
15
1Ai 0
05
1Ai 1
07
0D
1Ai 1
05
0Bo 61
24
1B
09o 47
0D
1C
1Ai 1
05
11
1Ai 2
07
0D
1Ai 2
05
1Ai 3
05
04i 1
1Ai 4
07
0D
1Ai 4
05
0Bo 10
1Ai 4
05
01
09o 4
24
0D
1Ai 1
05
12
1Ai 1
08
1Ai 1
05
0Ao -47
09o 4
24
16
0D
24
01
01
} module/insert [name module] #@[source: [[tree/set! module/cache name module]]] #{##[tree/set! module/cache name module]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 3
01
} module/load [name] #@[source: [[case [type-of name] [:object name] [:keyword [or [tree/ref module/cache name] [do [def mod [module/load/external name]] [when mod [tree/set! module/cache name mod]] [return mod]]]]]]] #{##[type-of name ΓεnΣym-3 :object :keyword tree/ref module/cache module/load/external mod tree/set! #f]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 9
1Ai 1
05
09o 80
1Ai 2
05
1Ai 4
20
0Bo 70
1Ai 5
05
1Ai 6
05
1Ai 1
05
04i 2
0C
0Ao 52
0D
1Ai 7
05
1Ai 1
05
04i 1
1Ai 8
07
0D
1Ai 8
05
0Bo 20
1Ai 9
05
1Ai 6
05
1Ai 1
05
1Ai 8
05
04i 3
09o 4
24
0D
1Ai 8
05
01
0C
0Ao 6
0D
1Ai 10
09o 4
24
16
01
} module/import-all [module symbol] #@[source: [[def exports [resolve 'exports module]] [typecheck/only exports :tree] [return exports]]] #{##[resolve exports module type-of :tree throw list :type-error "Expected a value of type :tree" current-lambda]
1Ai 0
05
1Ai 1
1Ai 2
05
04i 2
1Ai 1
07
0D
1Ai 3
05
1Ai 1
05
04i 1
1Ai 4
20
0Bo 7
24
09o 25
1Ai 5
05
1Ai 6
05
1Ai 7
1Ai 8
1Ai 1
05
1Ai 9
05
04i 0
04i 4
04i 1
0D
1Ai 1
05
01
01
} module/import [module symbol] #@[source: [[def exports [module/import-all module symbol]] [when-not [tree/has? exports symbol] [exception :import-error [if [resolves? symbol module] "That symbol was not exported" "That symbol does not exist in that module"]]] [tree/ref exports symbol]]] #{##[module/import-all module symbol exports tree/has? throw list :import-error resolves? "That symbol was not exported" "That symbol does not exist in that module" current-lambda tree/ref]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
1Ai 3
07
0D
1Ai 4
05
1Ai 3
05
1Ai 2
05
04i 2
0Bo 7
24
09o 42
1Ai 5
05
1Ai 6
05
1Ai 7
1Ai 8
05
1Ai 2
05
1Ai 1
05
04i 2
0Bo 8
1Ai 9
09o 5
1Ai 10
24
1Ai 11
05
04i 0
04i 4
04i 1
0D
1Ai 12
05
1Ai 3
05
1Ai 2
05
04i 2
01
}]
1Ai 0
05
24
04i 1
1Ai 1
07
0D
24
1Ai 2
07
0D
1Ai 3
1Ai 4
1Ai 5
1Ai 6
17
1Ai 3
07
0D
1Ai 7
1Ai 8
1Ai 9
1Ai 10
17
1Ai 7
07
0D
1Ai 11
1Ai 12
1Ai 13
1Ai 14
17
1Ai 11
07
0D
1Ai 15
1Ai 16
1Ai 17
1Ai 18
17
1Ai 15
07
0D
1Ai 19
1Ai 20
1Ai 21
1Ai 22
18
1Ai 19
07
0D
1Ai 23
1Ai 24
1Ai 25
1Ai 26
18
1Ai 23
07
0D
1Ai 27
1Ai 28
1Ai 29
1Ai 30
18
1Ai 27
07
0D
1Ai 31
1Ai 32
1Ai 33
1Ai 34
17
1Ai 31
07
0D
1Ai 35
1Ai 36
1Ai 37
1Ai 38
18
1Ai 35
07
0D
1Ai 39
1Ai 40
1Ai 41
1Ai 42
18
1Ai 39
07
0D
1Ai 43
1Ai 44
1Ai 45
1Ai 46
18
1Ai 43
07
0D
1Ai 47
1Ai 48
1Ai 49
1Ai 50
18
1Ai 47
07
0D
1Ai 51
1Ai 52
1Ai 53
1Ai 54
17
1Ai 51
07
0D
1Ai 55
1Ai 56
1Ai 57
1Ai 58
17
1Ai 55
07
0D
1Ai 59
1Ai 60
1Ai 61
1Ai 62
17
1Ai 59
07
0D
1Ai 63
1Ai 64
1Ai 65
1Ai 66
17
1Ai 63
07
0D
1Ai 67
1Ai 68
1Ai 69
1Ai 70
17
1Ai 67
07
01
}#{##[numeric? [a] #@[documentation: "Return #t if a is a number" source: ["Return #t if a is a number" [or [int? a] [float? a] [vec? a]]]] #{##[int? a float? vec? #f]
1Ai 0
05
1Ai 1
05
04i 1
0C
0Ao 32
0D
1Ai 2
05
1Ai 1
05
04i 1
0C
0Ao 19
0D
1Ai 3
05
1Ai 1
05
04i 1
0C
0Ao 6
0D
1Ai 4
01
} last? [a] #@[documentation: "Return #t if a is the last pair in a list" source: [:inline "Return #t if a is the last pair in a list" [nil? [cdr a]]] inline: #t] #{##[nil? a]
1Ai 0
05
1Ai 1
05
12
04i 1
01
} pos? [a] #@[documentation: "Return #t if a is positive" source: [:inline "Return #t if a is positive" [>= a 0.0]] inline: #t] #{##[a 0.0]
1Ai 0
05
1Ai 1
21
01
} zero-neg? [a] #@[documentation: "Return #t if a is zero or negative" source: [:inline "Return #t if a is zero or negative" [<= a 0.0]] inline: #t] #{##[a 0.0]
1Ai 0
05
1Ai 1
1F
01
} neg? [a] #@[documentation: "Returns #t if a is negative" source: [:inline "Returns #t if a is negative" [< a 0.0]] inline: #t] #{##[a 0.0]
1Ai 0
05
1Ai 1
1E
01
} odd? [a] #@[documentation: "Predicate that returns #t if a is odd" source: ["Predicate that returns #t if a is odd" [= [rem [int a] 2] 1]]] #{##[int a]
1Ai 0
05
1Ai 1
05
04i 1
02i 2
29
02i 1
20
01
} even? [a] #@[documentation: "Predicate that returns #t if a is even" source: ["Predicate that returns #t if a is even" [= [mod/int [int a] 2] 0]]] #{##[mod/int int a]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
02i 2
04i 2
02i 0
20
01
} not-zero? [val] #@[documentation: "#t if VAL is not zero" source: [:inline "#t if VAL is not zero" [not= 0 val]] inline: #t] #{##[not= val]
1Ai 0
05
02i 0
1Ai 1
05
04i 2
01
} equal? [a b] #@[documentation: "High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." source: ["High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." [def cur-type [type-of a]] [if [not= cur-type [type-of b]] #f [case cur-type [:array [array/equal? a b]] [:tree [tree/equal? a b]] [:pair [list/equal? a b]] [otherwise [= a b]]]]]] #{##[type-of a cur-type not= b #f ΓεnΣym-1 :array array/equal? :tree tree/equal? :pair list/equal?]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 3
05
1Ai 2
05
1Ai 0
05
1Ai 4
05
04i 1
04i 2
0Bo 8
1Ai 5
09o 88
15
1Ai 2
05
1Ai 6
07
0D
1Ai 6
05
1Ai 7
20
0Bo 17
1Ai 8
05
1Ai 1
05
1Ai 4
05
04i 2
09o 56
1Ai 6
05
1Ai 9
20
0Bo 17
1Ai 10
05
1Ai 1
05
1Ai 4
05
04i 2
09o 33
1Ai 6
05
1Ai 11
20
0Bo 17
1Ai 12
05
1Ai 1
05
1Ai 4
05
04i 2
09o 10
1Ai 1
05
1Ai 4
05
20
16
01
} inequal? [a b] #@[documentation: "High level inequality comparator" source: ["High level inequality comparator" [not [equal? a b]]]] #{##[equal? a b #f #t]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
0Bo 8
1Ai 3
09o 5
1Ai 4
01
} int? [val] #@[source: [[= :int [type-of val]]]] #{##[:int type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} float? [val] #@[source: [[= :float [type-of val]]]] #{##[:float type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} vec? [val] #@[source: [[= :vec [type-of val]]]] #{##[:vec type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} boolean? [val] #@[source: [[= :bool [type-of val]]]] #{##[:bool type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} pair? [val] #@[source: [[= :pair [type-of val]]]] #{##[:pair type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} array? [val] #@[source: [[= :array [type-of val]]]] #{##[:array type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} string? [val] #@[source: [[= :string [type-of val]]]] #{##[:string type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} symbol? [val] #@[source: [[= :symbol [type-of val]]]] #{##[:symbol type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} object? [val] #@[source: [[= :object [type-of val]]]] #{##[:object type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} tree? [val] #@[source: [[= :tree [type-of val]]]] #{##[:tree type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} keyword? [v] #@[source: [[= :keyword [type-of v]]]] #{##[:keyword type-of v]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} macro? [val] #@[source: [[= :macro [type-of val]]]] #{##[:macro type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} lambda? [val] #@[source: [[or [= :lambda [type-of val]]]]] #{##[:lambda type-of val #f]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
0C
0Ao 6
0D
1Ai 3
01
} native? [val] #@[source: [[= :native-function [type-of val]]]] #{##[:native-function type-of val]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} procedure? [val] #@[source: [[or [lambda? val] [native? val]]]] #{##[lambda? val native? #f]
1Ai 0
05
1Ai 1
05
04i 1
0C
0Ao 19
0D
1Ai 2
05
1Ai 1
05
04i 1
0C
0Ao 6
0D
1Ai 3
01
} buffer? [v] #@[source: [[= :buffer [type-of v]]]] #{##[:buffer type-of v]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} buffer-view? [v] #@[source: [[= :buffer-view [type-of v]]]] #{##[:buffer-view type-of v]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} bytecode-array? [v] #@[source: [[= :bytecode-array [type-of v]]]] #{##[:bytecode-array type-of v]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} bytecode-op? [v] #@[source: [[= :bytecode-op [type-of v]]]] #{##[:bytecode-op type-of v]
1Ai 0
1Ai 1
05
1Ai 2
05
04i 1
20
01
} in-range? [v min max] #@[source: [[and [>= v min] [<= v max]]]] #{##[v min max]
1Ai 0
05
1Ai 1
05
21
0C
0Bo 11
0D
1Ai 0
05
1Ai 2
05
1F
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
17
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 48
1Ai 49
1Ai 50
1Ai 51
17
1Ai 48
07
0D
1Ai 52
1Ai 53
1Ai 54
1Ai 55
17
1Ai 52
07
0D
1Ai 56
1Ai 57
1Ai 58
1Ai 59
17
1Ai 56
07
0D
1Ai 60
1Ai 61
1Ai 62
1Ai 63
17
1Ai 60
07
0D
1Ai 64
1Ai 65
1Ai 66
1Ai 67
17
1Ai 64
07
0D
1Ai 68
1Ai 69
1Ai 70
1Ai 71
17
1Ai 68
07
0D
1Ai 72
1Ai 73
1Ai 74
1Ai 75
17
1Ai 72
07
0D
1Ai 76
1Ai 77
1Ai 78
1Ai 79
17
1Ai 76
07
0D
1Ai 80
1Ai 81
1Ai 82
1Ai 83
17
1Ai 80
07
0D
1Ai 84
1Ai 85
1Ai 86
1Ai 87
17
1Ai 84
07
0D
1Ai 88
1Ai 89
1Ai 90
1Ai 91
17
1Ai 88
07
0D
1Ai 92
1Ai 93
1Ai 94
1Ai 95
17
1Ai 92
07
0D
1Ai 96
1Ai 97
1Ai 98
1Ai 99
17
1Ai 96
07
0D
1Ai 100
1Ai 101
1Ai 102
1Ai 103
17
1Ai 100
07
0D
1Ai 104
1Ai 105
1Ai 106
1Ai 107
17
1Ai 104
07
0D
1Ai 108
1Ai 109
1Ai 110
1Ai 111
17
1Ai 108
07
0D
1Ai 112
1Ai 113
1Ai 114
1Ai 115
17
1Ai 112
07
0D
1Ai 116
1Ai 117
1Ai 118
1Ai 119
17
1Ai 116
07
01
}#{##[quasiquote-real [l depth] #@[source: [[if [nil? l] #nil [if [pair? l] [if [= [caar l] 'unquote-splicing] [if [zero? depth] [list 'append [cadr [car l]] [quasiquote-real [cdr l] depth]] [list 'unquote-splicing [quasiquote-real [cadr l] [+ -1 depth]]]] [if [= [car l] 'unquote] [if [zero? depth] [cadr l] [list 'unquote [quasiquote-real [cadr l] [+ -1 depth]]]] [if [= [car l] 'quasiquote] [quasiquote-real [quasiquote-real [cadr l] [+ 1 depth]] depth] [if [zero? depth] [list 'cons [quasiquote-real [car l] depth] [quasiquote-real [cdr l] depth]] [cons [quasiquote-real [car l] depth] [quasiquote-real [cdr l] depth]]]]]] [if [and [zero? depth] [symbol? l]] [cons 'quote [cons l #nil]] l]]]]] #{##[nil? l pair? unquote-splicing depth list append quasiquote-real unquote quasiquote cons symbol? quote]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 7
24
09o 277
1Ai 2
05
1Ai 1
05
04i 1
0Bo 232
1Ai 1
05
11
11
1Ai 3
20
0Bo 64
1Ai 4
05
2A
0Bo 31
1Ai 5
05
1Ai 6
1Ai 1
05
11
12
11
1Ai 7
05
1Ai 1
05
12
1Ai 4
05
04i 2
04i 3
09o 26
1Ai 5
05
1Ai 3
1Ai 7
05
1Ai 1
05
12
11
02i -1
1Ai 4
05
25
04i 2
04i 2
09o 157
1Ai 1
05
11
1Ai 8
20
0Bo 44
1Ai 4
05
2A
0Bo 11
1Ai 1
05
12
11
09o 26
1Ai 5
05
1Ai 8
1Ai 7
05
1Ai 1
05
12
11
02i -1
1Ai 4
05
25
04i 2
04i 2
09o 106
1Ai 1
05
11
1Ai 9
20
0Bo 30
1Ai 7
05
1Ai 7
05
1Ai 1
05
12
11
02i 1
1Ai 4
05
25
04i 2
1Ai 4
05
04i 2
09o 69
1Ai 4
05
2A
0Bo 37
1Ai 5
05
1Ai 10
1Ai 7
05
1Ai 1
05
11
1Ai 4
05
04i 2
1Ai 7
05
1Ai 1
05
12
1Ai 4
05
04i 2
04i 3
09o 28
1Ai 7
05
1Ai 1
05
11
1Ai 4
05
04i 2
1Ai 7
05
1Ai 1
05
12
1Ai 4
05
04i 2
14
09o 37
1Ai 4
05
2A
0C
0Bo 12
0D
1Ai 11
05
1Ai 1
05
04i 1
0Bo 14
1Ai 12
1Ai 1
05
24
14
14
09o 6
1Ai 1
05
01
} quasiquote [l] #@[source: [[quasiquote-real l 0]]] #{##[quasiquote-real l]
1Ai 0
05
1Ai 1
05
02i 0
04i 2
01
} unquote [expr] #@[source: [[throw [list :unquote-without-quasiquote "unquote should only occur inside a quasiquote, never evaluated directly"]]]] #{##[throw list :unquote-without-quasiquote "unquote should only occur inside a quasiquote, never evaluated directly"]
1Ai 0
05
1Ai 1
05
1Ai 2
1Ai 3
04i 2
04i 1
01
} unquote-splicing [expr] #@[source: [[throw [list :unquote-splicing-without-quasiq "unquote-splicing should only occur inside a quasiquote, never evaluated directly"]]]] #{##[throw list :unquote-splicing-without-quasiq "unquote-splicing should only occur inside a quasiquote, never evaluated directly"]
1Ai 0
05
1Ai 1
05
1Ai 2
1Ai 3
04i 2
04i 1
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
18
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
01
}#{##[3.14159 PI π inc [x] #@[documentation: "Return a number 1 greater than x" source: [:inline "Return a number 1 greater than x" [+ 1 x]] inline: #t] #{##[x]
02i 1
1Ai 0
05
25
01
} inc! [i v] #@[documentation: "Decrement I by V (defaults to 1) and store the result in I" source: ["Decrement I by V (defaults to 1) and store the result in I" [quasiquote [set! [unquote i] [+ [unquote i] [unquote [or v 1]]]]]]] #{##[set! i + v #f]
1Ai 0
1Ai 1
05
1Ai 2
1Ai 1
05
1Ai 3
05
0C
0Ao 13
0D
02i 1
0C
0Ao 6
0D
1Ai 4
24
14
14
14
24
14
14
14
01
} dec [x] #@[documentation: "Return a number 1 less than x" source: [:inline "Return a number 1 less than x" [+ -1 x]] inline: #t] #{##[x]
02i -1
1Ai 0
05
25
01
} dec! [i v] #@[documentation: "Decrement I by V and store the result in I" source: ["Decrement I by V and store the result in I" [quasiquote [set! [unquote i] [- [unquote i] [unquote [or v 1]]]]]]] #{##[set! i - v #f]
1Ai 0
1Ai 1
05
1Ai 2
1Ai 1
05
1Ai 3
05
0C
0Ao 13
0D
02i 1
0C
0Ao 6
0D
1Ai 4
24
14
14
14
24
14
14
14
01
} +x [α] #@[documentation: "Return a function that adds α to it's argument, useful for mapping" source: ["Return a function that adds α to it's argument, useful for mapping" [fn [β] [+ α β]]]] #{##[anonymous [β] #@[source: [[+ α β]]] #{##[α β]
1Ai 0
05
1Ai 1
05
25
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
01
} fib [i] #@[documentation: "Terribly inefficient, but, useful for testing the GC" source: ["Terribly inefficient, but, useful for testing the GC" [if [< i 2] i [+ [fib [- i 2]] [fib [- i 1]]]]]] #{##[i fib]
1Ai 0
05
02i 2
1E
0Bo 9
1Ai 0
05
09o 26
1Ai 1
05
1Ai 0
05
02i 2
26
04i 1
1Ai 1
05
1Ai 0
05
02i 1
26
04i 1
25
01
} wrap-value [val min max] #@[documentation: "Constrains VAL to be within MIN and MAX, wrapping it around" source: ["Constrains VAL to be within MIN and MAX, wrapping it around" [+ min [rem [- val min] [- max min]]]]] #{##[min val max]
1Ai 0
05
1Ai 1
05
1Ai 0
05
26
1Ai 2
05
1Ai 0
05
26
29
25
01
} +1 [v] #@[source: [[quasiquote [+ 1 [unquote v]]]]] #{##[+ v]
1Ai 0
02i 1
1Ai 1
05
24
14
14
14
01
} radians [degrees] #@[documentation: "Convert a quantity in degrees to radians" source: ["Convert a quantity in degrees to radians" [/ [* π degrees] 180.0]]] #{##[π degrees 180.0]
1Ai 0
05
1Ai 1
05
27
1Ai 2
28
01
}]
1Ai 0
1Ai 1
07
0D
1Ai 0
1Ai 2
07
0D
1Ai 3
1Ai 4
1Ai 5
1Ai 6
17
1Ai 3
07
0D
1Ai 7
1Ai 8
1Ai 9
1Ai 10
18
1Ai 7
07
0D
1Ai 11
1Ai 12
1Ai 13
1Ai 14
17
1Ai 11
07
0D
1Ai 15
1Ai 16
1Ai 17
1Ai 18
18
1Ai 15
07
0D
1Ai 19
1Ai 20
1Ai 21
1Ai 22
17
1Ai 19
07
0D
1Ai 23
1Ai 24
1Ai 25
1Ai 26
17
1Ai 23
07
0D
1Ai 27
1Ai 28
1Ai 29
1Ai 30
17
1Ai 27
07
0D
1Ai 31
1Ai 32
1Ai 33
1Ai 34
18
1Ai 31
07
0D
1Ai 35
1Ai 36
1Ai 37
1Ai 38
17
1Ai 35
07
01
}#{##[describe/closure [c i] #@[source: [[when c [if [= c root-closure] [cat [ansi-blue [cat [int [or i 0]] "# <root environment>"]] "\r\n"] [do [def data [closure/data c]] [def l [length data]] [cat [ansi-blue [cat [int [or i 0]] "# " [string/write c]]] " - " [if [< l 16] [string/write data] "-+- Very big tree structure -+-"] "\r\n" [describe/closure [closure/caller c] [+ [int [or i 0]] 1]]]]]]]] #{##[c root-closure cat ansi-blue int i #f "# <root environment>" "\r\n" closure/data data length l "# " string/write " - " "-+- Very big tree structure -+-" describe/closure closure/caller]
1Ai 0
05
0Bo 195
1Ai 0
05
1Ai 1
05
20
0Bo 47
1Ai 2
05
1Ai 3
05
1Ai 2
05
1Ai 4
05
1Ai 5
05
0C
0Ao 13
0D
02i 0
0C
0Ao 6
0D
1Ai 6
04i 1
1Ai 7
04i 2
04i 1
1Ai 8
04i 2
09o 138
1Ai 9
05
1Ai 0
05
04i 1
1Ai 10
07
0D
1Ai 11
05
1Ai 10
05
04i 1
1Ai 12
07
0D
1Ai 2
05
1Ai 3
05
1Ai 2
05
1Ai 4
05
1Ai 5
05
0C
0Ao 13
0D
02i 0
0C
0Ao 6
0D
1Ai 6
04i 1
1Ai 13
1Ai 14
05
1Ai 0
05
04i 1
04i 3
04i 1
1Ai 15
1Ai 12
05
02i 16
1E
0Bo 14
1Ai 14
05
1Ai 10
05
04i 1
09o 5
1Ai 16
1Ai 8
1Ai 17
05
1Ai 18
05
1Ai 0
05
04i 1
1Ai 4
05
1Ai 5
05
0C
0Ao 13
0D
02i 0
0C
0Ao 6
0D
1Ai 6
04i 1
02i 1
25
04i 2
04i 5
09o 4
24
01
} stacktrace [] #@[source: [[display [describe/closure [closure/caller [current-lambda]]]]]] #{##[print describe/closure closure/caller current-lambda]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 0
04i 1
04i 1
04i 1
01
} display/error/wrap [i text] #@[source: [[case i [0 [ansi-red text]] [1 [string text]] [2 [ansi-yellow [string/write text]]] [3 [describe/closure text]] [otherwise text]]]] #{##[i ΓεnΣym-1 ansi-red text string ansi-yellow string/write describe/closure]
15
1Ai 0
05
1Ai 1
07
0D
1Ai 1
05
02i 0
20
0Bo 14
1Ai 2
05
1Ai 3
05
04i 1
09o 71
1Ai 1
05
02i 1
20
0Bo 14
1Ai 4
05
1Ai 3
05
04i 1
09o 51
1Ai 1
05
02i 2
20
0Bo 19
1Ai 5
05
1Ai 6
05
1Ai 3
05
04i 1
04i 1
09o 26
1Ai 1
05
02i 3
20
0Bo 14
1Ai 7
05
1Ai 3
05
04i 1
09o 6
1Ai 3
05
16
01
} display/error/iter [error i] #@[source: [[if error [cons [display/error/wrap i [car error]] [display/error/iter [cdr error] [+ 1 i]]] [cons "" #nil]]]] #{##[error display/error/wrap i display/error/iter ""]
1Ai 0
05
0Bo 34
1Ai 1
05
1Ai 2
05
1Ai 0
05
11
04i 2
1Ai 3
05
1Ai 0
05
12
02i 1
1Ai 2
05
25
04i 2
14
09o 7
1Ai 4
24
14
01
} display/error [error] #@[documentation: "Display ERROR in a nice, human readable way" source: ["Display ERROR in a nice, human readable way" [display [join [display/error/iter error 0] "\r\n"]]]] #{##[print join display/error/iter error "\r\n"]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
02i 0
04i 2
1Ai 4
04i 2
04i 1
01
} closure/documentation [o] #@[source: [[meta o :documentation]]] #{##[meta o :documentation]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
01
} describe/thing [o] #@[documentation: "Describe a specific value O" source: ["Describe a specific value O" [def documentation [closure/documentation o]] [def arguments [closure/arguments o]] [fmt "{arguments:?} - {documentation}"]]] #{##[closure/documentation o documentation closure/arguments arguments cat string/write " - "]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 3
05
1Ai 1
05
04i 1
1Ai 4
07
0D
1Ai 5
05
1Ai 6
05
1Ai 4
05
04i 1
1Ai 7
1Ai 2
05
04i 3
01
} describe/string [a] #@[documentation: "Descibe whatever value string A resolves to" source: ["Descibe whatever value string A resolves to" [describe/thing [resolve [string->symbol a]]]]] #{##[describe/thing resolve string->symbol a]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
04i 1
04i 1
01
} describe [fun] #@[documentation: "Describe FUN, if there is documentation available" source: ["Describe FUN, if there is documentation available" [if [string? fun] [describe/string fun] [describe/thing fun]]]] #{##[string? fun describe/string describe/thing]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 14
1Ai 2
05
1Ai 1
05
04i 1
09o 11
1Ai 3
05
1Ai 1
05
04i 1
01
} symbol-table [off len environment] #@[documentation: "Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" source: ["Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" [when-not environment [set! environment root-closure]] [when-not off [set! off 0]] [when-not len [set! len 9999999]] [sublist [eval-in environment '[symbol-table*]] off [+ off len] #nil]]] #{##[environment root-closure off len 9999999 sublist eval-in [symbol-table*]]
1Ai 0
05
0Bo 7
24
09o 9
1Ai 1
05
1Ai 0
08
0D
1Ai 2
05
0Bo 7
24
09o 8
02i 0
1Ai 2
08
0D
1Ai 3
05
0Bo 7
24
09o 8
1Ai 4
1Ai 3
08
0D
1Ai 5
05
1Ai 6
05
1Ai 0
05
1Ai 7
04i 2
1Ai 2
05
1Ai 2
05
1Ai 3
05
25
24
04i 4
01
} gensym/counter gensym [prefix] #@[source: [[inc! gensym/counter] [string->symbol [cat prefix "ΓεnΣym-" gensym/counter]]]] #{##[gensym/counter string->symbol cat prefix "ΓεnΣym-"]
1Ai 0
05
02i 1
25
1Ai 0
08
0D
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 0
05
04i 3
04i 1
01
} current-closure root-closure]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
02i 0
1Ai 40
07
0D
1Ai 41
1Ai 42
1Ai 43
1Ai 44
17
1Ai 41
07
0D
1Ai 45
05
04i 0
1Ai 46
07
01
}#{##[random/seed random/seed-initialize! [] #@[source: [[set! random/seed [bit-xor [time] [time/milliseconds]]]]] #{##[bit-xor time time/milliseconds random/seed]
1Ai 0
05
1Ai 1
05
04i 0
1Ai 2
05
04i 0
04i 2
1Ai 3
08
01
} random/rng! [] #@[source: [[set! random/seed [+ 12345 [* random/seed 1103515245]]] [bit-or [bit-shift-left [bit-and random/seed 65535] 16] [bit-and [bit-shift-right random/seed 16] 65535]]]] #{##[12345 random/seed 1103515245 bit-or bit-shift-left bit-and 65535 bit-shift-right]
1Ai 0
1Ai 1
05
1Ai 2
27
25
1Ai 1
08
0D
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 1
05
1Ai 6
04i 2
02i 16
04i 2
1Ai 5
05
1Ai 7
05
1Ai 1
05
02i 16
04i 2
1Ai 6
04i 2
04i 2
01
} random/seed! [new-seed] #@[documentation: "Set a new seed value for the RNG" source: ["Set a new seed value for the RNG" [set! seed new-seed]]] #{##[new-seed seed]
1Ai 0
05
1Ai 1
08
01
} [] #@[documentation: "Return the current RNG seed value" source: ["Return the current RNG seed value" seed]] #{##[seed]
1Ai 0
05
01
} random [max] #@[documentation: "Return a value from 0 to MAX, or, if left out, a random int" source: ["Return a value from 0 to MAX, or, if left out, a random int" [if [numeric? max] [rem [abs [random/rng!]] max] [random/rng!]]]] #{##[numeric? max abs random/rng!]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 20
1Ai 2
05
1Ai 3
05
04i 0
04i 1
1Ai 1
05
29
09o 8
1Ai 3
05
04i 0
01
}]
02i 0
1Ai 0
07
0D
1Ai 1
1Ai 2
1Ai 3
1Ai 4
17
1Ai 1
07
0D
1Ai 5
1Ai 6
1Ai 7
1Ai 8
17
1Ai 5
07
0D
1Ai 9
1Ai 10
1Ai 11
1Ai 12
17
1Ai 9
07
0D
1Ai 0
1Ai 13
1Ai 14
1Ai 15
17
1Ai 0
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 1
05
04i 0
01
}#{##[#f ansi/disabled "\e[0m" ansi-reset "\e[0;39m" ansi-fg-reset "\e[49m" ansi-bg-reset array/new "\e[0;30m" "\e[0;31m" "\e[0;32m" "\e[0;33m" "\e[0;34m" "\e[0;35m" "\e[0;36m" "\e[0;37m" "\e[1;30m" "\e[1;31m" "\e[1;32m" "\e[1;33m" "\e[1;34m" "\e[1;35m" "\e[1;36m" "\e[1;37m" ansi-fg "\e[40m" "\e[41m" "\e[42m" "\e[43m" "\e[44m" "\e[45m" "\e[46m" "\e[47m" ansi-bg ansi-wrap [code string] #@[documentation: "Wrap STRING in the ansi color CODE" source: ["Wrap STRING in the ansi color CODE" [cat [or ansi/disabled [array/ref ansi-fg code]] string [or ansi/disabled ansi-reset]]]] #{##[cat ansi/disabled array/ref ansi-fg code #f string ansi-reset]
1Ai 0
05
1Ai 1
05
0C
0Ao 22
0D
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 2
0C
0Ao 6
0D
1Ai 5
1Ai 6
05
1Ai 1
05
0C
0Ao 14
0D
1Ai 7
05
0C
0Ao 6
0D
1Ai 5
04i 3
01
} ansi-black args #@[documentation: "Wrap ARGS in black" source: ["Wrap ARGS in black" [ansi-wrap 0 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 0
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-dark-red #@[documentation: "Wrap ARGS in dark red" source: ["Wrap ARGS in dark red" [ansi-wrap 1 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 1
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-dark-green #@[documentation: "Wrap ARGS in dark green" source: ["Wrap ARGS in dark green" [ansi-wrap 2 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 2
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-brown #@[documentation: "Wrap ARGS in brown" source: ["Wrap ARGS in brown" [ansi-wrap 3 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 3
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-dark-blue #@[documentation: "Wrap ARGS in dark blue" source: ["Wrap ARGS in dark blue" [ansi-wrap 4 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 4
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-purple #@[documentation: "Wrap ARGS in purple" source: ["Wrap ARGS in purple" [ansi-wrap 5 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 5
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-teal #@[documentation: "Wrap ARGS in teal" source: ["Wrap ARGS in teal" [ansi-wrap 6 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 6
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-dark-gray #@[documentation: "Wrap ARGS in dark gray" source: ["Wrap ARGS in dark gray" [ansi-wrap 7 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 7
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-gray #@[documentation: "Wrap ARGS in gray" source: ["Wrap ARGS in gray" [ansi-wrap 8 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 8
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-red #@[documentation: "Wrap ARGS in red" source: ["Wrap ARGS in red" [ansi-wrap 9 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 9
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-green #@[documentation: "Wrap ARGS in green" source: ["Wrap ARGS in green" [ansi-wrap 10 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 10
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-yellow #@[documentation: "Wrap ARGS in yellow" source: ["Wrap ARGS in yellow" [ansi-wrap 11 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 11
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-blue #@[documentation: "Wrap ARGS in blue" source: ["Wrap ARGS in blue" [ansi-wrap 12 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 12
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-pink #@[documentation: "Wrap ARGS in pink" source: ["Wrap ARGS in pink" [ansi-wrap 13 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 13
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-cyan #@[documentation: "Wrap ARGS in cyan" source: ["Wrap ARGS in cyan" [ansi-wrap 14 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 14
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-white #@[documentation: "Wrap ARGS in white" source: ["Wrap ARGS in white" [ansi-wrap 15 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1Ai 0
05
02i 15
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} ansi-rainbow #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [let* [def count 0] [cat [join [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] ""] [or ansi/disabled ansi-fg-reset]]]]] #{##[count cat join map split apply args "" anonymous [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] #{##[bit-and count cat ansi/disabled array/ref ansi-fg #f a]
1Ai 0
05
02i 1
1Ai 1
05
25
02i 7
04i 2
1Ai 1
08
0D
1Ai 2
05
1Ai 3
05
0C
0Ao 37
0D
1Ai 4
05
1Ai 5
05
1Ai 1
05
2A
0Bo 8
02i 7
09o 9
1Ai 1
05
02i 8
25
04i 2
0C
0Ao 6
0D
1Ai 6
1Ai 7
05
04i 2
01
} ansi/disabled ansi-fg-reset #f]
15
02i 0
1Ai 0
07
0D
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 1
05
1Ai 6
05
04i 2
1Ai 7
04i 2
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
04i 2
1Ai 7
04i 2
1Ai 12
05
0C
0Ao 14
0D
1Ai 13
05
0C
0Ao 6
0D
1Ai 14
04i 2
16
01
} ansi-rainbow-bg #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [def count 0] [def colored-list [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [bit-xor count 7]]] [or ansi/disabled [array/ref ansi-bg count]] a]]]] [cat [join colored-list ""] [or ansi/disabled ansi-reset]]]] #{##[count map split apply cat args "" anonymous [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [bit-xor count 7]]] [or ansi/disabled [array/ref ansi-bg count]] a]]] #{##[bit-and count cat ansi/disabled array/ref ansi-fg bit-xor #f ansi-bg a]
1Ai 0
05
02i 1
1Ai 1
05
25
02i 7
04i 2
1Ai 1
08
0D
1Ai 2
05
1Ai 3
05
0C
0Ao 29
0D
1Ai 4
05
1Ai 5
05
1Ai 6
05
1Ai 1
05
02i 7
04i 2
04i 2
0C
0Ao 6
0D
1Ai 7
1Ai 3
05
0C
0Ao 22
0D
1Ai 4
05
1Ai 8
05
1Ai 1
05
04i 2
0C
0Ao 6
0D
1Ai 7
1Ai 9
05
04i 3
01
} colored-list join ansi/disabled ansi-reset #f]
02i 0
1Ai 0
07
0D
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
04i 2
1Ai 6
04i 2
1Ai 7
1Ai 8
1Ai 9
1Ai 10
17
04i 2
1Ai 11
07
0D
1Ai 4
05
1Ai 12
05
1Ai 11
05
1Ai 6
04i 2
1Ai 13
05
0C
0Ao 14
0D
1Ai 14
05
0C
0Ao 6
0D
1Ai 15
04i 2
01
} reprint-line [text width] #@[source: [[when-not width [set! width 20]] [print "\r"] [dotimes [i width] [print " "]] [print "\r"] [print text]]] #{##[width print "\r" i " " text]
1Ai 0
05
0Bo 7
24
09o 8
02i 20
1Ai 0
08
0D
1Ai 1
05
1Ai 2
04i 1
0D
15
02i 0
1Ai 3
07
0D
24
1B
09o 22
0D
1C
1Ai 1
05
1Ai 4
04i 1
0D
02i 1
1Ai 3
05
03
1Ai 3
08
1Ai 3
05
1Ai 0
05
1E
0Ao -26
0D
24
16
0D
1Ai 1
05
1Ai 2
04i 1
0D
1Ai 1
05
1Ai 5
05
04i 1
01
}]
1Ai 0
1Ai 1
07
0D
1Ai 2
1Ai 3
07
0D
1Ai 4
1Ai 5
07
0D
1Ai 6
1Ai 7
07
0D
1Ai 8
05
1Ai 9
1Ai 10
1Ai 11
1Ai 12
1Ai 13
1Ai 14
1Ai 15
1Ai 16
1Ai 17
1Ai 18
1Ai 19
1Ai 20
1Ai 21
1Ai 22
1Ai 23
1Ai 24
04i 16
1Ai 25
07
0D
1Ai 2
1Ai 3
07
0D
1Ai 8
05
1Ai 26
1Ai 27
1Ai 28
1Ai 29
1Ai 30
1Ai 31
1Ai 32
1Ai 33
04i 8
1Ai 34
07
0D
1Ai 35
1Ai 36
1Ai 37
1Ai 38
17
1Ai 35
07
0D
1Ai 39
1Ai 40
1Ai 41
1Ai 42
17
1Ai 39
07
0D
1Ai 43
1Ai 40
1Ai 44
1Ai 45
17
1Ai 43
07
0D
1Ai 46
1Ai 40
1Ai 47
1Ai 48
17
1Ai 46
07
0D
1Ai 49
1Ai 40
1Ai 50
1Ai 51
17
1Ai 49
07
0D
1Ai 52
1Ai 40
1Ai 53
1Ai 54
17
1Ai 52
07
0D
1Ai 55
1Ai 40
1Ai 56
1Ai 57
17
1Ai 55
07
0D
1Ai 58
1Ai 40
1Ai 59
1Ai 60
17
1Ai 58
07
0D
1Ai 61
1Ai 40
1Ai 62
1Ai 63
17
1Ai 61
07
0D
1Ai 64
1Ai 40
1Ai 65
1Ai 66
17
1Ai 64
07
0D
1Ai 67
1Ai 40
1Ai 68
1Ai 69
17
1Ai 67
07
0D
1Ai 70
1Ai 40
1Ai 71
1Ai 72
17
1Ai 70
07
0D
1Ai 73
1Ai 40
1Ai 74
1Ai 75
17
1Ai 73
07
0D
1Ai 76
1Ai 40
1Ai 77
1Ai 78
17
1Ai 76
07
0D
1Ai 79
1Ai 40
1Ai 80
1Ai 81
17
1Ai 79
07
0D
1Ai 82
1Ai 40
1Ai 83
1Ai 84
17
1Ai 82
07
0D
1Ai 85
1Ai 40
1Ai 86
1Ai 87
17
1Ai 85
07
0D
1Ai 88
1Ai 40
1Ai 89
1Ai 90
17
1Ai 88
07
0D
1Ai 91
1Ai 40
1Ai 92
1Ai 93
17
1Ai 91
07
0D
1Ai 94
1Ai 95
1Ai 96
1Ai 97
17
1Ai 94
07
01
}#{##[tree/new :align :right :debug #f :base :width :padding-char " " fmt/format-arg/default fmt/find-non-digit-from-right [s i] #@[source: [[if [< i 0] -1 [do [def char [char-at s i]] [if [and [>= char 48] [<= char 57]] [fmt/find-non-digit-from-right s [- i 1]] i]]]]] #{##[i char-at s char fmt/find-non-digit-from-right]
1Ai 0
05
02i 0
1E
0Bo 8
02i -1
09o 58
1Ai 1
05
1Ai 2
05
1Ai 0
05
04i 2
1Ai 3
07
0D
1Ai 3
05
02i 48
21
0C
0Bo 10
0D
1Ai 3
05
02i 57
1F
0Bo 20
1Ai 4
05
1Ai 2
05
1Ai 0
05
02i 1
26
04i 2
09o 6
1Ai 0
05
01
} fmt/parse-spec [opts spec] #@[source: [[if [zero? [string/length spec]] opts [case [char-at spec [- [string/length spec] 1]] [[48 49 50 51 52 53 54 55 56 57] [def next-non-digit [fmt/find-non-digit-from-right spec [- [string/length spec] 1]]] [def number [string/cut spec [+ 1 next-non-digit] [string/length spec]]] [tree/set! opts :width [read/single number]] [when [= 48 [char-at number 0]] [tree/set! opts :padding-char "0"]] [fmt/parse-spec opts [string/cut spec 0 [+ 1 next-non-digit]]]] [63 [fmt/parse-spec [tree/set! opts :debug #t] [string/cut spec 0 [- [string/length spec] 1]]]] [88 [fmt/parse-spec [tree/set! opts :base :HEXADECIMAL] [string/cut spec 0 [- [string/length spec] 1]]]] [120 [fmt/parse-spec [tree/set! opts :base :hexadecimal] [string/cut spec 0 [- [string/length spec] 1]]]] [100 [fmt/parse-spec [tree/set! opts :base :decimal] [string/cut spec 0 [- [string/length spec] 1]]]] [111 [fmt/parse-spec [tree/set! opts :base :octal] [string/cut spec 0 [- [string/length spec] 1]]]] [98 [fmt/parse-spec [tree/set! opts :base :binary] [string/cut spec 0 [- [string/length spec] 1]]]] [60 [fmt/parse-spec [tree/set! opts :align :left] [string/cut spec 0 [- [string/length spec] 1]]]] [94 [fmt/parse-spec [tree/set! opts :align :center] [string/cut spec 0 [- [string/length spec] 1]]]] [62 [fmt/parse-spec [tree/set! opts :align :right] [string/cut spec 0 [- [string/length spec] 1]]]] [46 [fmt/parse-spec [tree/set! opts :precision [tree/ref opts :width]] [string/cut spec 0 [- [string/length spec] 1]]]] [otherwise [throw [list :format-error "Unknown form-spec option" spec [current-closure]]]]]]]] #{##[string/length spec opts char-at ΓεnΣym-1 #f fmt/find-non-digit-from-right next-non-digit string/cut number tree/set! :width read/single :padding-char "0" fmt/parse-spec :debug #t :base :HEXADECIMAL :hexadecimal :decimal :octal :binary :align :left :center :right :precision tree/ref throw list :format-error "Unknown form-spec option" current-closure]
1Ai 0
05
1Ai 1
05
04i 1
2A
0Bo 9
1Ai 2
05
09o 801
15
1Ai 3
05
1Ai 1
05
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 2
1Ai 4
07
0D
1Ai 4
05
02i 48
20
0C
0Ao 105
0D
1Ai 4
05
02i 49
20
0C
0Ao 94
0D
1Ai 4
05
02i 50
20
0C
0Ao 83
0D
1Ai 4
05
02i 51
20
0C
0Ao 72
0D
1Ai 4
05
02i 52
20
0C
0Ao 61
0D
1Ai 4
05
02i 53
20
0C
0Ao 50
0D
1Ai 4
05
02i 54
20
0C
0Ao 39
0D
1Ai 4
05
02i 55
20
0C
0Ao 28
0D
1Ai 4
05
02i 56
20
0C
0Ao 17
0D
1Ai 4
05
02i 57
20
0C
0Ao 6
0D
1Ai 5
0Bo 131
1Ai 6
05
1Ai 1
05
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 2
1Ai 7
07
0D
1Ai 8
05
1Ai 1
05
02i 1
1Ai 7
05
25
1Ai 0
05
1Ai 1
05
04i 1
04i 3
1Ai 9
07
0D
1Ai 10
05
1Ai 2
05
1Ai 11
1Ai 12
05
1Ai 9
05
04i 1
04i 3
0D
02i 48
1Ai 3
05
1Ai 9
05
02i 0
04i 2
20
0Bo 18
1Ai 10
05
1Ai 2
05
1Ai 13
1Ai 14
04i 3
09o 4
24
0D
1Ai 15
05
1Ai 2
05
1Ai 8
05
1Ai 1
05
02i 0
02i 1
1Ai 7
05
25
04i 3
04i 2
09o 533
1Ai 4
05
02i 63
20
0Bo 44
1Ai 15
05
1Ai 10
05
1Ai 2
05
1Ai 16
1Ai 17
04i 3
1Ai 8
05
1Ai 1
05
02i 0
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 3
04i 2
09o 483
1Ai 4
05
02i 88
20
0Bo 44
1Ai 15
05
1Ai 10
05
1Ai 2
05
1Ai 18
1Ai 19
04i 3
1Ai 8
05
1Ai 1
05
02i 0
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 3
04i 2
09o 433
1Ai 4
05
02i 120
20
0Bo 44
1Ai 15
05
1Ai 10
05
1Ai 2
05
1Ai 18
1Ai 20
04i 3
1Ai 8
05
1Ai 1
05
02i 0
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 3
04i 2
09o 383
1Ai 4
05
02i 100
20
0Bo 44
1Ai 15
05
1Ai 10
05
1Ai 2
05
1Ai 18
1Ai 21
04i 3
1Ai 8
05
1Ai 1
05
02i 0
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 3
04i 2
09o 333
1Ai 4
05
02i 111
20
0Bo 44
1Ai 15
05
1Ai 10
05
1Ai 2
05
1Ai 18
1Ai 22
04i 3
1Ai 8
05
1Ai 1
05
02i 0
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 3
04i 2
09o 283
1Ai 4
05
02i 98
20
0Bo 44
1Ai 15
05
1Ai 10
05
1Ai 2
05
1Ai 18
1Ai 23
04i 3
1Ai 8
05
1Ai 1
05
02i 0
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 3
04i 2
09o 233
1Ai 4
05
02i 60
20
0Bo 44
1Ai 15
05
1Ai 10
05
1Ai 2
05
1Ai 24
1Ai 25
04i 3
1Ai 8
05
1Ai 1
05
02i 0
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 3
04i 2
09o 183
1Ai 4
05
02i 94
20
0Bo 44
1Ai 15
05
1Ai 10
05
1Ai 2
05
1Ai 24
1Ai 26
04i 3
1Ai 8
05
1Ai 1
05
02i 0
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 3
04i 2
09o 133
1Ai 4
05
02i 62
20
0Bo 44
1Ai 15
05
1Ai 10
05
1Ai 2
05
1Ai 24
1Ai 27
04i 3
1Ai 8
05
1Ai 1
05
02i 0
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 3
04i 2
09o 83
1Ai 4
05
02i 46
20
0Bo 52
1Ai 15
05
1Ai 10
05
1Ai 2
05
1Ai 28
1Ai 29
05
1Ai 2
05
1Ai 11
04i 2
04i 3
1Ai 8
05
1Ai 1
05
02i 0
1Ai 0
05
1Ai 1
05
04i 1
02i 1
26
04i 3
04i 2
09o 25
1Ai 30
05
1Ai 31
05
1Ai 32
1Ai 33
1Ai 1
05
1Ai 34
05
04i 0
04i 4
04i 1
16
01
} fmt/debug [opts] #@[source: [[if-not [tree/ref opts :debug] opts [tree/set! opts :argument [list string/write [tree/ref opts :argument]]]]]] #{##[tree/ref opts :debug tree/set! :argument list string/write]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
0Bo 34
1Ai 3
05
1Ai 1
05
1Ai 4
1Ai 5
05
1Ai 6
05
1Ai 0
05
1Ai 1
05
1Ai 4
04i 2
04i 2
04i 3
09o 6
1Ai 1
05
01
} fmt/number-format [opts] #@[source: [[case [tree/ref opts :base] [:binary [tree/set! opts :argument [list int->string/binary [tree/ref opts :argument]]]] [:octal [tree/set! opts :argument [list int->string/octal [tree/ref opts :argument]]]] [:decimal [tree/set! opts :argument [list int->string/decimal [tree/ref opts :argument]]]] [:hexadecimal [tree/set! opts :argument [list int->string/hex [tree/ref opts :argument]]]] [:HEXADECIMAL [tree/set! opts :argument [list int->string/HEX [tree/ref opts :argument]]]] [otherwise opts]]]] #{##[tree/ref opts :base ΓεnΣym-2 :binary tree/set! :argument list int->string/binary :octal int->string/octal :decimal int->string/decimal :hexadecimal int->string/hex :HEXADECIMAL int->string/HEX]
15
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
1Ai 3
07
0D
1Ai 3
05
1Ai 4
20
0Bo 34
1Ai 5
05
1Ai 1
05
1Ai 6
1Ai 7
05
1Ai 8
05
1Ai 0
05
1Ai 1
05
1Ai 6
04i 2
04i 2
04i 3
09o 166
1Ai 3
05
1Ai 9
20
0Bo 34
1Ai 5
05
1Ai 1
05
1Ai 6
1Ai 7
05
1Ai 10
05
1Ai 0
05
1Ai 1
05
1Ai 6
04i 2
04i 2
04i 3
09o 126
1Ai 3
05
1Ai 11
20
0Bo 34
1Ai 5
05
1Ai 1
05
1Ai 6
1Ai 7
05
1Ai 12
05
1Ai 0
05
1Ai 1
05
1Ai 6
04i 2
04i 2
04i 3
09o 86
1Ai 3
05
1Ai 13
20
0Bo 34
1Ai 5
05
1Ai 1
05
1Ai 6
1Ai 7
05
1Ai 14
05
1Ai 0
05
1Ai 1
05
1Ai 6
04i 2
04i 2
04i 3
09o 46
1Ai 3
05
1Ai 15
20
0Bo 34
1Ai 5
05
1Ai 1
05
1Ai 6
1Ai 7
05
1Ai 16
05
1Ai 0
05
1Ai 1
05
1Ai 6
04i 2
04i 2
04i 3
09o 6
1Ai 1
05
16
01
} :binary "#b" :octal "#o" :decimal "#d" :hexadecimal "#x" :HEXADECIMAL fmt/number-format-prefixex fmt/number-format-prefix [opts] #@[source: [[if [or [not [tree/ref opts :debug]] [not [tree/ref opts :base]]] opts [-> [if [member '[:binary :octal :decimal :hexadecimal :HEXADECIMAL] [tree/ref opts :base]] [tree/set! opts :argument [list cat [tree/ref fmt/number-format-prefixex [tree/ref opts :base]] [tree/ref opts :argument]]] opts] [tree/set! :debug #f]]]]] #{##[tree/ref opts :debug #f #t :base tree/set! member [:binary :octal :decimal :hexadecimal :HEXADECIMAL] :argument list cat fmt/number-format-prefixex]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
0Bo 8
1Ai 3
09o 5
1Ai 4
0C
0Ao 31
0D
1Ai 0
05
1Ai 1
05
1Ai 5
04i 2
0Bo 8
1Ai 3
09o 5
1Ai 4
0C
0Ao 6
0D
1Ai 3
0Bo 9
1Ai 1
05
09o 84
1Ai 6
05
1Ai 7
05
1Ai 8
1Ai 0
05
1Ai 1
05
1Ai 5
04i 2
04i 2
0Bo 52
1Ai 6
05
1Ai 1
05
1Ai 9
1Ai 10
05
1Ai 11
05
1Ai 0
05
1Ai 12
05
1Ai 0
05
1Ai 1
05
1Ai 5
04i 2
04i 2
1Ai 0
05
1Ai 1
05
1Ai 9
04i 2
04i 3
04i 3
09o 6
1Ai 1
05
1Ai 2
1Ai 3
04i 3
01
} fmt/add-padding [opts] #@[source: [[if-not [tree/ref opts :width] opts [tree/set! opts :argument [list [case [tree/ref opts :align] [:right string/pad-start] [:center string/pad-middle] [:left string/pad-end]] [tree/ref opts :argument] [if [and [tree/ref opts :debug] [tree/ref opts :base]] [- [tree/ref opts :width] 2] [tree/ref opts :width]] [tree/ref opts :padding-char]]]]]] #{##[tree/ref opts :width tree/set! :argument list :align ΓεnΣym-3 :right string/pad-start :center string/pad-middle :left string/pad-end :debug :base :padding-char]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
0Bo 157
1Ai 3
05
1Ai 1
05
1Ai 4
1Ai 5
05
15
1Ai 0
05
1Ai 1
05
1Ai 6
04i 2
1Ai 7
07
0D
1Ai 7
05
1Ai 8
20
0Bo 9
1Ai 9
05
09o 34
1Ai 7
05
1Ai 10
20
0Bo 9
1Ai 11
05
09o 19
1Ai 7
05
1Ai 12
20
0Bo 9
1Ai 13
05
09o 4
24
16
1Ai 0
05
1Ai 1
05
1Ai 4
04i 2
1Ai 0
05
1Ai 1
05
1Ai 14
04i 2
0C
0Bo 14
0D
1Ai 0
05
1Ai 1
05
1Ai 15
04i 2
0Bo 19
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
02i 2
26
09o 13
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
1Ai 0
05
1Ai 1
05
1Ai 16
04i 2
04i 4
04i 3
09o 6
1Ai 1
05
01
} fmt/precision [opts] #@[source: [[if-not [tree/ref opts :precision] opts [tree/set! opts :argument [list string/round [tree/ref opts :argument] [tree/ref opts :precision]]]]]] #{##[tree/ref opts :precision tree/set! :argument list string/round]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
0Bo 44
1Ai 3
05
1Ai 1
05
1Ai 4
1Ai 5
05
1Ai 6
05
1Ai 0
05
1Ai 1
05
1Ai 4
04i 2
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
04i 3
04i 3
09o 6
1Ai 1
05
01
} fmt/truncate [opts] #@[source: [[if-not [tree/ref opts :width] opts [tree/set! opts :argument [list string/cut [tree/ref opts :argument] 0 [+ 1 [tree/ref opts :width]]]]]]] #{##[tree/ref opts :width tree/set! :argument list string/cut]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
0Bo 49
1Ai 3
05
1Ai 1
05
1Ai 4
1Ai 5
05
1Ai 6
05
1Ai 0
05
1Ai 1
05
1Ai 4
04i 2
02i 0
02i 1
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
25
04i 4
04i 3
09o 6
1Ai 1
05
01
} fmt/output [opts] #@[source: [[tree/ref opts :argument]]] #{##[tree/ref opts :argument]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
01
} fmt/format-arg [spec argument] #@[source: [[-> [tree/set! [fmt/parse-spec [tree/dup fmt/format-arg/default] spec] :argument argument] fmt/number-format fmt/precision fmt/add-padding fmt/truncate fmt/number-format-prefix fmt/debug fmt/output]]] #{##[fmt/output fmt/debug fmt/number-format-prefix fmt/truncate fmt/add-padding fmt/precision fmt/number-format tree/set! fmt/parse-spec tree/dup fmt/format-arg/default spec :argument argument]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 6
05
1Ai 7
05
1Ai 8
05
1Ai 9
05
1Ai 10
05
04i 1
1Ai 11
05
04i 2
1Ai 12
1Ai 13
05
04i 3
04i 1
04i 1
04i 1
04i 1
04i 1
04i 1
04i 1
01
} fmt/valid-argument? [argument] #@[source: [[or [int? argument] [symbol? argument]]]] #{##[int? argument symbol? #f]
1Ai 0
05
1Ai 1
05
04i 1
0C
0Ao 19
0D
1Ai 2
05
1Ai 1
05
04i 1
0C
0Ao 6
0D
1Ai 3
01
} fmt/arg-sym [v] #@[source: [[case [type-of v] [:int [fmt/arg-sym [cat "fmt-arg-" [string v]]]] [:symbol v] [:string [string->symbol v]] [otherwise [throw [list :type-error "Invalid fmt argument name" v [current-lambda]]]]]]] #{##[type-of v ΓεnΣym-4 :int fmt/arg-sym cat "fmt-arg-" string :symbol :string string->symbol throw list :type-error "Invalid fmt argument name" current-lambda]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 26
1Ai 4
05
1Ai 5
05
1Ai 6
1Ai 7
05
1Ai 1
05
04i 1
04i 2
04i 1
09o 60
1Ai 2
05
1Ai 8
20
0Bo 9
1Ai 1
05
09o 45
1Ai 2
05
1Ai 9
20
0Bo 14
1Ai 10
05
1Ai 1
05
04i 1
09o 25
1Ai 11
05
1Ai 12
05
1Ai 13
1Ai 14
1Ai 1
05
1Ai 15
05
04i 0
04i 4
04i 1
16
01
} fmt/expr [expr arguments-used opts] #@[source: [[when-not [string? expr] [throw [list :format-error "fmt needs a string literal as a first argument, since it is implemented as a macro" expr [current-lambda]]]] [def split-expr [split expr ":"]] [def argument [car split-expr]] [def format-spec [or [cadr split-expr] ""]] [if [= "" argument] [do [tree/-- opts :expr-count] [array/set! arguments-used [tree/ref opts :expr-count] #t] [fmt/format-arg format-spec [fmt/arg-sym [tree/ref opts :expr-count]]]] [let [[read-vals [read argument]]] [when [cdr read-vals] [throw [list :format-error "Format argument specifier contains more than a single atom" argument [current-lambda]]]] [when-not [fmt/valid-argument? [car read-vals]] [throw [list :format-error "Format argument specifier should be either an integer or a symbol" argument [current-lambda]]]] [when [int? [car read-vals]] [when [or [< [car read-vals] 0] [>= [car read-vals] [array/length arguments-used]]] [throw [list :format-error "fmt numbered argument is out of bounds" argument [current-lambda]]]] [array/set! arguments-used [car read-vals] #t]] [fmt/format-arg format-spec [fmt/arg-sym [car read-vals]]]]]]] #{##[string? expr throw list :format-error "fmt needs a string literal as a first argument, since it is implemented as a macro" current-lambda split ":" split-expr argument "" #f format-spec tree/+= opts :expr-count array/set! arguments-used tree/ref #t fmt/format-arg fmt/arg-sym read read-vals "Format argument specifier contains more than a single atom" fmt/valid-argument? "Format argument specifier should be either an integer or a symbol" int? array/length "fmt numbered argument is out of bounds"]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 7
24
09o 25
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 5
1Ai 1
05
1Ai 6
05
04i 0
04i 4
04i 1
0D
1Ai 7
05
1Ai 1
05
1Ai 8
04i 2
1Ai 9
07
0D
1Ai 9
05
11
1Ai 10
07
0D
1Ai 9
05
12
11
0C
0Ao 13
0D
1Ai 11
0C
0Ao 6
0D
1Ai 12
1Ai 13
07
0D
1Ai 11
1Ai 10
05
20
0Bo 63
1Ai 14
05
1Ai 15
05
1Ai 16
02i -1
04i 3
0D
1Ai 17
05
1Ai 18
05
1Ai 19
05
1Ai 15
05
1Ai 16
04i 2
1Ai 20
04i 3
0D
1Ai 21
05
1Ai 13
05
1Ai 22
05
1Ai 19
05
1Ai 15
05
1Ai 16
04i 2
04i 1
04i 2
09o 200
15
1Ai 23
05
1Ai 10
05
04i 1
1Ai 24
07
0D
1Ai 24
05
12
0Bo 28
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 25
1Ai 10
05
1Ai 6
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 26
05
1Ai 24
05
11
04i 1
0Bo 7
24
09o 25
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 27
1Ai 10
05
1Ai 6
05
04i 0
04i 4
04i 1
0D
1Ai 28
05
1Ai 24
05
11
04i 1
0Bo 82
1Ai 24
05
11
02i 0
1E
0C
0Ao 24
0D
1Ai 24
05
11
1Ai 29
05
1Ai 18
05
04i 1
21
0C
0Ao 6
0D
1Ai 12
0Bo 28
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 30
1Ai 10
05
1Ai 6
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 17
05
1Ai 18
05
1Ai 24
05
11
1Ai 20
04i 3
09o 4
24
0D
1Ai 21
05
1Ai 13
05
1Ai 22
05
1Ai 24
05
11
04i 1
04i 2
16
01
} fmt [format-string . args] #@[documentation: "Return a formatted string" source: ["Return a formatted string" [when-not [string? format-string] [throw [list :type-error "fmt needs a string literal as a first argument, since it is implemented as a macro" format-string [current-lambda]]]] [def cuts #nil] [dotimes [i [string/length format-string]] [case [char-at format-string i] [123 [do [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]] [set! cuts [cons i cuts]]]] [125 [do [when-not [int? [car cuts]] [throw [list :format-error "fmt expects all brackets to be closed" format-string [current-lambda]]]] [set! cuts [cons [cons [car cuts] i] [cdr cuts]]]]]]] [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]] [def expr-list #nil] [def last-pos [string/length format-string]] [def arguments-used [-> [array/allocate [length args]] [array/fill! #f]]] [def opts [tree/new :expr-count [array/length arguments-used]]] [doseq [c cuts] [def lit [string/cut format-string [+ [cdr c] 1] last-pos]] [when-not [= "" lit] [set! expr-list [cons lit expr-list]]] [def expr [fmt/expr [string/cut format-string [+ 1 [car c]] [cdr c]] arguments-used opts]] [set! expr-list [cons expr expr-list]] [set! last-pos [car c]]] [when [> last-pos 0] [def lit [string/cut format-string 0 last-pos]] [set! expr-list [cons lit expr-list]]] [dotimes [i [array/length arguments-used]] [when-not [array/ref arguments-used i] [throw [list :format-error "fmt expects all arguments to be used" [list format-string [list/ref args i]] [current-lambda]]]]] [def expr [if [cdr expr-list] [cons 'cat expr-list] [if [string? [car expr-list]] [car expr-list] [cons 'string expr-list]]]] [def fmt/args/map-fun/count 0] [defn fmt/args/map-fun [arg] [def s [string->symbol [cat "fmt-arg-" [string fmt/args/map-fun/count]]]] [inc! fmt/args/map-fun/count] [list 'def s arg]] [if args [quasiquote [let* [unquote-splicing [map args fmt/args/map-fun]] [unquote expr]]] expr]]] #{##[string? format-string throw list :type-error "fmt needs a string literal as a first argument, since it is implemented as a macro" current-lambda cuts i char-at ΓεnΣym-5 int? :format-error "fmt placeholders can't be nested" "fmt expects all brackets to be closed" string/length expr-list last-pos array/fill! array/allocate length args #f arguments-used tree/new :expr-count array/length opts ΓεnΣym-6 c string/cut lit "" fmt/expr expr array/ref "fmt expects all arguments to be used" list/ref cat string fmt/args/map-fun/count fmt/args/map-fun [arg] #@[source: [[def s [string->symbol [cat "fmt-arg-" [string fmt/args/map-fun/count]]]] [inc! fmt/args/map-fun/count] [list 'def s arg]]] #{##[string->symbol cat "fmt-arg-" string fmt/args/map-fun/count s list def arg]
1Ai 0
05
1Ai 1
05
1Ai 2
1Ai 3
05
1Ai 4
05
04i 1
04i 2
04i 1
1Ai 5
07
0D
1Ai 4
05
02i 1
25
1Ai 4
08
0D
1Ai 6
05
1Ai 7
1Ai 5
05
1Ai 8
05
04i 3
01
} let* append map]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 7
24
09o 25
1Ai 2
05
1Ai 3
05
1Ai 4
1Ai 5
1Ai 1
05
1Ai 6
05
04i 0
04i 4
04i 1
0D
24
1Ai 7
07
0D
15
02i 0
1Ai 8
07
0D
24
1B
09o 161
0D
1C
15
1Ai 9
05
1Ai 1
05
1Ai 8
05
04i 2
1Ai 10
07
0D
1Ai 10
05
02i 123
20
0Bo 55
1Ai 11
05
1Ai 7
05
11
04i 1
0Bo 28
1Ai 2
05
1Ai 3
05
1Ai 12
1Ai 13
1Ai 1
05
1Ai 6
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 8
05
1Ai 7
05
14
1Ai 7
08
09o 71
1Ai 10
05
02i 125
20
0Bo 61
1Ai 11
05
1Ai 7
05
11
04i 1
0Bo 7
24
09o 25
1Ai 2
05
1Ai 3
05
1Ai 12
1Ai 14
1Ai 1
05
1Ai 6
05
04i 0
04i 4
04i 1
0D
1Ai 7
05
11
1Ai 8
05
14
1Ai 7
05
12
14
1Ai 7
08
09o 4
24
16
0D
02i 1
1Ai 8
05
03
1Ai 8
08
1Ai 8
05
1Ai 15
05
1Ai 1
05
04i 1
1E
0Ao -170
0D
24
16
0D
1Ai 11
05
1Ai 7
05
11
04i 1
0Bo 28
1Ai 2
05
1Ai 3
05
1Ai 12
1Ai 13
1Ai 1
05
1Ai 6
05
04i 0
04i 4
04i 1
09o 4
24
0D
24
1Ai 16
07
0D
1Ai 15
05
1Ai 1
05
04i 1
1Ai 17
07
0D
1Ai 18
05
1Ai 19
05
1Ai 20
05
1Ai 21
05
04i 1
04i 1
1Ai 22
04i 2
1Ai 23
07
0D
1Ai 24
05
1Ai 25
1Ai 26
05
1Ai 23
05
04i 1
04i 2
1Ai 27
07
0D
15
1Ai 7
05
1Ai 28
07
0D
1Ai 28
05
0Bo 133
24
1B
09o 119
0D
1C
1Ai 28
05
11
1Ai 29
07
0D
1Ai 30
05
1Ai 1
05
1Ai 29
05
12
02i 1
25
1Ai 17
05
04i 3
1Ai 31
07
0D
1Ai 32
1Ai 31
05
20
0Bo 7
24
09o 13
1Ai 31
05
1Ai 16
05
14
1Ai 16
08
0D
1Ai 33
05
1Ai 30
05
1Ai 1
05
02i 1
1Ai 29
05
11
25
1Ai 29
05
12
04i 3
1Ai 23
05
1Ai 27
05
04i 3
1Ai 34
07
0D
1Ai 34
05
1Ai 16
05
14
1Ai 16
08
0D
1Ai 29
05
11
1Ai 17
08
0D
1Ai 28
05
12
1Ai 28
08
1Ai 28
05
0Ao -119
09o 4
24
16
0D
1Ai 17
05
02i 0
22
0Bo 33
1Ai 30
05
1Ai 1
05
02i 0
1Ai 17
05
04i 3
1Ai 31
07
0D
1Ai 31
05
1Ai 16
05
14
1Ai 16
08
09o 4
24
0D
15
02i 0
1Ai 8
07
0D
24
1B
09o 71
0D
1C
1Ai 35
05
1Ai 23
05
1Ai 8
05
04i 2
0Bo 7
24
09o 41
1Ai 2
05
1Ai 3
05
1Ai 12
1Ai 36
1Ai 3
05
1Ai 1
05
1Ai 37
05
1Ai 21
05
1Ai 8
05
04i 2
04i 2
1Ai 6
05
04i 0
04i 4
04i 1
0D
02i 1
1Ai 8
05
03
1Ai 8
08
1Ai 8
05
1Ai 26
05
1Ai 23
05
04i 1
1E
0Ao -80
0D
24
16
0D
1Ai 16
05
12
0Bo 12
1Ai 38
1Ai 16
05
14
09o 28
1Ai 0
05
1Ai 16
05
11
04i 1
0Bo 10
1Ai 16
05
11
09o 9
1Ai 39
1Ai 16
05
14
1Ai 34
07
0D
02i 0
1Ai 40
07
0D
1Ai 41
1Ai 42
1Ai 43
1Ai 44
17
1Ai 41
07
0D
1Ai 21
05
0Bo 30
1Ai 45
1Ai 46
05
1Ai 47
05
1Ai 21
05
1Ai 41
05
04i 2
1Ai 34
05
24
14
04i 2
14
09o 6
1Ai 34
05
01
} pfmt [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [print [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[print fmt format-string append args]
1Ai 0
1Ai 1
1Ai 2
05
1Ai 3
05
1Ai 4
05
24
04i 2
14
14
24
14
14
01
} efmt [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [error [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[error fmt format-string append args]
1Ai 0
1Ai 1
1Ai 2
05
1Ai 3
05
1Ai 4
05
24
04i 2
14
14
24
14
14
01
} pfmtln [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [println [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[println fmt format-string append args]
1Ai 0
1Ai 1
1Ai 2
05
1Ai 3
05
1Ai 4
05
24
04i 2
14
14
24
14
14
01
} efmtln [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [errorln [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[errorln fmt format-string append args]
1Ai 0
1Ai 1
1Ai 2
05
1Ai 3
05
1Ai 4
05
24
04i 2
14
14
24
14
14
01
}]
1Ai 0
05
1Ai 1
1Ai 2
1Ai 3
1Ai 4
1Ai 5
1Ai 4
1Ai 6
24
1Ai 7
1Ai 8
04i 10
1Ai 9
07
0D
1Ai 10
1Ai 11
1Ai 12
1Ai 13
17
1Ai 10
07
0D
1Ai 14
1Ai 15
1Ai 16
1Ai 17
17
1Ai 14
07
0D
1Ai 18
1Ai 19
1Ai 20
1Ai 21
17
1Ai 18
07
0D
1Ai 22
1Ai 23
1Ai 24
1Ai 25
17
1Ai 22
07
0D
1Ai 0
05
1Ai 26
1Ai 27
1Ai 28
1Ai 29
1Ai 30
1Ai 31
1Ai 32
1Ai 33
1Ai 34
1Ai 33
04i 10
1Ai 35
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
17
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 48
1Ai 49
1Ai 50
1Ai 51
17
1Ai 48
07
0D
1Ai 52
1Ai 53
1Ai 54
1Ai 55
17
1Ai 52
07
0D
1Ai 56
1Ai 57
1Ai 58
1Ai 59
17
1Ai 56
07
0D
1Ai 60
1Ai 61
1Ai 62
1Ai 63
17
1Ai 60
07
0D
1Ai 64
1Ai 65
1Ai 66
1Ai 67
17
1Ai 64
07
0D
1Ai 68
1Ai 69
1Ai 70
1Ai 71
17
1Ai 68
07
0D
1Ai 72
1Ai 73
1Ai 74
1Ai 75
18
1Ai 72
07
0D
1Ai 76
1Ai 77
1Ai 78
1Ai 79
18
1Ai 76
07
0D
1Ai 80
1Ai 81
1Ai 82
1Ai 83
18
1Ai 80
07
0D
1Ai 84
1Ai 85
1Ai 86
1Ai 87
18
1Ai 84
07
0D
1Ai 88
1Ai 89
1Ai 90
1Ai 91
18
1Ai 88
07
01
}#{##[string->keyword [α] #@[documentation: "Return string α as a keyword" source: [:inline "Return string α as a keyword" [symbol->keyword [string->symbol α]]] inline: #t] #{##[symbol->keyword string->symbol α]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
01
} string->byte-array [a] #@[documentation: "Turn a string into an UTF-8 encoded byte array" source: ["Turn a string into an UTF-8 encoded byte array" [def ret [array/allocate [string/length a]]] [dotimes [i [string/length a]] [array/set! ret i [char-at a i]]] ret]] #{##[array/allocate string/length a ret i array/set! char-at]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
1Ai 3
07
0D
15
02i 0
1Ai 4
07
0D
24
1B
09o 37
0D
1C
1Ai 5
05
1Ai 3
05
1Ai 4
05
1Ai 6
05
1Ai 2
05
1Ai 4
05
04i 2
04i 3
0D
02i 1
1Ai 4
05
03
1Ai 4
08
1Ai 4
05
1Ai 1
05
1Ai 2
05
04i 1
1E
0Ao -46
0D
24
16
0D
1Ai 3
05
01
} println [str] #@[documentation: "Print STR on a single line" source: ["Print STR on a single line" [print [cat str "\r\n"]]]] #{##[print cat str "\r\n"]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
04i 2
04i 1
01
} errorln [str] #@[documentation: "Print to stderr STR on a single line" source: ["Print to stderr STR on a single line" [error [cat str "\r\n"]]]] #{##[error cat str "\r\n"]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
04i 2
04i 1
01
} display [value] #@[documentation: "Display VALUE" source: [:inline "Display VALUE" [print value]] inline: #t] #{##[print value]
1Ai 0
05
1Ai 1
05
04i 1
01
} newline [] #@[documentation: "Print a single line feed character" source: ["Print a single line feed character" [print "\r\n"]]] #{##[print "\r\n"]
1Ai 0
05
1Ai 1
04i 1
01
} br [num] #@[documentation: "Return NUM=1 linebreaks" source: ["Return NUM=1 linebreaks" [if [or [nil? num] [<= [int num] 1]] "\n" [cat "\n" [br [+ -1 num]]]]]] #{##[nil? num int #f "\n" cat br]
1Ai 0
05
1Ai 1
05
04i 1
0C
0Ao 22
0D
1Ai 2
05
1Ai 1
05
04i 1
02i 1
1F
0C
0Ao 6
0D
1Ai 3
0Bo 8
1Ai 4
09o 21
1Ai 5
05
1Ai 4
1Ai 6
05
02i -1
1Ai 1
05
25
04i 1
04i 2
01
} path/ext?! [ext] #@[documentation: "Return a predicate that checks if a path ends on EXT" source: ["Return a predicate that checks if a path ends on EXT" [case [type-of ext] [:string [fn [path] [= ext [lowercase [path/extension path]]]]] [:pair [fn [path] [def cext [lowercase [path/extension path]]] [reduce ext [fn [α β] [or α [= β cext]]]]]] [otherwise [throw [list :type-error "Expected a :string or :list" ext]]]]]] #{##[type-of ext ΓεnΣym-1 :string anonymous [path] #@[source: [[= ext [lowercase [path/extension path]]]]] #{##[ext lowercase path/extension path]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
04i 1
20
01
} :pair [path] #@[source: [[def cext [lowercase [path/extension path]]] [reduce ext [fn [α β] [or α [= β cext]]]]]] #{##[lowercase path/extension path cext reduce ext anonymous [α β] #@[source: [[or α [= β cext]]]] #{##[α β cext #f]
1Ai 0
05
0C
0Ao 18
0D
1Ai 1
05
1Ai 2
05
20
0C
0Ao 6
0D
1Ai 3
01
}]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
1Ai 3
07
0D
1Ai 4
05
1Ai 5
05
1Ai 6
1Ai 7
1Ai 8
1Ai 9
17
04i 2
01
} throw list :type-error "Expected a :string or :list"]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 15
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
09o 41
1Ai 2
05
1Ai 8
20
0Bo 15
1Ai 4
1Ai 9
1Ai 10
1Ai 11
17
09o 20
1Ai 12
05
1Ai 13
05
1Ai 14
1Ai 15
1Ai 1
05
04i 3
04i 1
16
01
} path/extension [path] #@[documentation: "Return the extension of PATH" source: ["Return the extension of PATH" [def last-period [last-index-of path "."]] [if [>= last-period 0] [string/cut path [+ 1 last-period] [string/length path]] path]]] #{##[last-index-of path "." last-period string/cut string/length]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
1Ai 3
07
0D
1Ai 3
05
02i 0
21
0Bo 28
1Ai 4
05
1Ai 1
05
02i 1
1Ai 3
05
25
1Ai 5
05
1Ai 1
05
04i 1
04i 3
09o 6
1Ai 1
05
01
} path/without-extension [path] #@[documentation: "Return PATH, but without the extension part" source: ["Return PATH, but without the extension part" [def last-period [last-index-of path "."]] [if [>= last-period 0] [string/cut path 0 last-period] path]]] #{##[last-index-of path "." last-period string/cut]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
1Ai 3
07
0D
1Ai 3
05
02i 0
21
0Bo 19
1Ai 4
05
1Ai 1
05
02i 0
1Ai 3
05
04i 3
09o 6
1Ai 1
05
01
} int->string/binary [α] #@[documentation: "Turn α into a its **binary** string representation" source: ["Turn α into a its **binary** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [while [not-zero? α] [set! ret [cat [from-char-code [+ 48 [bit-and α 1]]] ret]] [set! α [bit-shift-right α 1]]] ret]] #{##["" ret α "0" cat from-char-code bit-and bit-shift-right not=]
1Ai 0
1Ai 1
07
0D
1Ai 2
05
0Bo 7
24
09o 8
02i 0
1Ai 2
07
0D
1Ai 2
05
2A
0Bo 11
1Ai 3
1Ai 1
08
09o 4
24
0D
24
1B
09o 48
0D
1C
1Ai 4
05
1Ai 5
05
02i 48
1Ai 6
05
1Ai 2
05
02i 1
04i 2
25
04i 1
1Ai 1
05
04i 2
1Ai 1
08
0D
1Ai 7
05
1Ai 2
05
02i 1
04i 2
1Ai 2
08
1Ai 8
05
02i 0
1Ai 2
05
04i 2
0Ao -55
0D
1Ai 1
05
01
} int->string/octal [α] #@[documentation: "Turn α into a its **octal** string representation" source: ["Turn α into a its **octal** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [while [not-zero? α] [set! ret [cat [from-char-code [+ 48 [bit-and α 7]]] ret]] [set! α [bit-shift-right α 3]]] ret]] #{##["" ret α "0" cat from-char-code bit-and bit-shift-right not=]
1Ai 0
1Ai 1
07
0D
1Ai 2
05
0Bo 7
24
09o 8
02i 0
1Ai 2
07
0D
1Ai 2
05
2A
0Bo 11
1Ai 3
1Ai 1
08
09o 4
24
0D
24
1B
09o 48
0D
1C
1Ai 4
05
1Ai 5
05
02i 48
1Ai 6
05
1Ai 2
05
02i 7
04i 2
25
04i 1
1Ai 1
05
04i 2
1Ai 1
08
0D
1Ai 7
05
1Ai 2
05
02i 3
04i 2
1Ai 2
08
1Ai 8
05
02i 0
1Ai 2
05
04i 2
0Ao -55
0D
1Ai 1
05
01
} array/new "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" int->string/hex/conversion-arr int->string/HEX [α] #@[documentation: "Turn α into a its **hexadecimal** string representation" source: ["Turn α into a its **hexadecimal** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [when [< α 0] [throw [list :type-error "Can't print negative numbers in hex for now" α [current-lambda]]]] [while [not-zero? α] [set! ret [cat [array/ref int->string/hex/conversion-arr [bit-and α 15]] ret]] [set! α [bit-shift-right α 4]]] ret]] #{##["" ret α "0" throw list :type-error "Can't print negative numbers in hex for now" current-lambda cat array/ref int->string/hex/conversion-arr bit-and bit-shift-right not=]
1Ai 0
1Ai 1
07
0D
1Ai 2
05
0Bo 7
24
09o 8
02i 0
1Ai 2
07
0D
1Ai 2
05
2A
0Bo 11
1Ai 3
1Ai 1
08
09o 4
24
0D
1Ai 2
05
02i 0
1E
0Bo 28
1Ai 4
05
1Ai 5
05
1Ai 6
1Ai 7
1Ai 2
05
1Ai 8
05
04i 0
04i 4
04i 1
09o 4
24
0D
24
1B
09o 48
0D
1C
1Ai 9
05
1Ai 10
05
1Ai 11
05
1Ai 12
05
1Ai 2
05
02i 15
04i 2
04i 2
1Ai 1
05
04i 2
1Ai 1
08
0D
1Ai 13
05
1Ai 2
05
02i 4
04i 2
1Ai 2
08
1Ai 14
05
02i 0
1Ai 2
05
04i 2
0Ao -55
0D
1Ai 1
05
01
} int->string/hex [α] #@[documentation: "Turn α into a its **hexadecimal** string representation" source: ["Turn α into a its **hexadecimal** string representation" [lowercase [int->string/HEX α]]]] #{##[lowercase int->string/HEX α]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
01
} int->string/decimal [α] #@[documentation: "Turn α into a its **decimal** string representation" source: ["Turn α into a its **decimal** string representation" [string α]]] #{##[string α]
1Ai 0
05
1Ai 1
05
04i 1
01
} int->string string/pad-start [text goal-length char] #@[documentation: "Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat char text]]] [if [> [string/length text] goal-length] [string/cut text [- [string/length text] goal-length] [string/length text]] text]]] #{##[char " " string? text string throw list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" current-lambda cat string/length goal-length string/cut]
1Ai 0
05
0Bo 7
24
09o 8
1Ai 1
1Ai 0
08
0D
1Ai 2
05
1Ai 3
05
04i 1
0Bo 7
24
09o 14
1Ai 4
05
1Ai 3
05
04i 1
1Ai 3
08
0D
1Ai 2
05
1Ai 0
05
04i 1
0Bo 7
24
09o 25
1Ai 5
05
1Ai 6
05
1Ai 7
1Ai 8
1Ai 0
05
1Ai 9
05
04i 0
04i 4
04i 1
0D
24
1B
09o 19
0D
1C
1Ai 10
05
1Ai 0
05
1Ai 3
05
04i 2
1Ai 3
08
1Ai 11
05
1Ai 3
05
04i 1
1Ai 12
05
1E
0Ao -28
0D
1Ai 11
05
1Ai 3
05
04i 1
1Ai 12
05
22
0Bo 34
1Ai 13
05
1Ai 3
05
1Ai 11
05
1Ai 3
05
04i 1
1Ai 12
05
26
1Ai 11
05
1Ai 3
05
04i 1
04i 3
09o 6
1Ai 3
05
01
} string/pad-end [text goal-length char] #@[documentation: "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat text char]]] [if [> [string/length text] goal-length] [string/cut text 0 goal-length] text]]] #{##[char " " string? text string throw list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" current-lambda cat string/length goal-length string/cut]
1Ai 0
05
0Bo 7
24
09o 8
1Ai 1
1Ai 0
08
0D
1Ai 2
05
1Ai 3
05
04i 1
0Bo 7
24
09o 14
1Ai 4
05
1Ai 3
05
04i 1
1Ai 3
08
0D
1Ai 2
05
1Ai 0
05
04i 1
0Bo 7
24
09o 25
1Ai 5
05
1Ai 6
05
1Ai 7
1Ai 8
1Ai 0
05
1Ai 9
05
04i 0
04i 4
04i 1
0D
24
1B
09o 19
0D
1C
1Ai 10
05
1Ai 3
05
1Ai 0
05
04i 2
1Ai 3
08
1Ai 11
05
1Ai 3
05
04i 1
1Ai 12
05
1E
0Ao -28
0D
1Ai 11
05
1Ai 3
05
04i 1
1Ai 12
05
22
0Bo 19
1Ai 13
05
1Ai 3
05
02i 0
1Ai 12
05
04i 3
09o 6
1Ai 3
05
01
} string/pad-middle [text goal-length char] #@[documentation: "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-middle needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat char text char]]] [if [> [string/length text] goal-length] [let [[end-overflow [/ [- [string/length text] goal-length] 2]] [start-overflow [- [- [string/length text] goal-length] end-overflow]]] [string/cut text start-overflow [+ start-overflow goal-length]]] text]]] #{##[char " " string? text string throw list :type-error "string/pad-middle needs char as a string, so that one can pad with multiple characters" current-lambda cat string/length goal-length end-overflow start-overflow string/cut]
1Ai 0
05
0Bo 7
24
09o 8
1Ai 1
1Ai 0
08
0D
1Ai 2
05
1Ai 3
05
04i 1
0Bo 7
24
09o 14
1Ai 4
05
1Ai 3
05
04i 1
1Ai 3
08
0D
1Ai 2
05
1Ai 0
05
04i 1
0Bo 7
24
09o 25
1Ai 5
05
1Ai 6
05
1Ai 7
1Ai 8
1Ai 0
05
1Ai 9
05
04i 0
04i 4
04i 1
0D
24
1B
09o 22
0D
1C
1Ai 10
05
1Ai 0
05
1Ai 3
05
1Ai 0
05
04i 3
1Ai 3
08
1Ai 11
05
1Ai 3
05
04i 1
1Ai 12
05
1E
0Ao -31
0D
1Ai 11
05
1Ai 3
05
04i 1
1Ai 12
05
22
0Bo 65
15
1Ai 11
05
1Ai 3
05
04i 1
1Ai 12
05
26
02i 2
28
1Ai 13
07
0D
1Ai 11
05
1Ai 3
05
04i 1
1Ai 12
05
26
1Ai 13
05
26
1Ai 14
07
0D
1Ai 15
05
1Ai 3
05
1Ai 14
05
1Ai 14
05
1Ai 12
05
25
04i 3
16
09o 6
1Ai 3
05
01
} string/round [text decimal-digits] #@[documentation: "Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" source: ["Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" [def pos [last-index-of text "."]] [if [>= pos 0] [string/cut text 0 [+ pos 1 decimal-digits]] text]]] #{##[last-index-of text "." pos string/cut decimal-digits]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
1Ai 3
07
0D
1Ai 3
05
02i 0
21
0Bo 26
1Ai 4
05
1Ai 1
05
02i 0
1Ai 3
05
02i 1
25
1Ai 5
05
25
04i 3
09o 6
1Ai 1
05
01
} split/empty [str separator] #@[source: [[def slen [string/length str]] [def start 0] [def ret #nil] [while [< start slen] [set! ret [cons [string/cut str start [+ 1 start]] ret]] [inc! start]] [reverse ret]]] #{##[string/length str slen start ret string/cut reverse]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
02i 0
1Ai 3
07
0D
24
1Ai 4
07
0D
24
1B
09o 39
0D
1C
1Ai 5
05
1Ai 1
05
1Ai 3
05
02i 1
1Ai 3
05
25
04i 3
1Ai 4
05
14
1Ai 4
08
0D
1Ai 3
05
02i 1
25
1Ai 3
08
1Ai 3
05
1Ai 2
05
1E
0Ao -43
0D
1Ai 6
05
1Ai 4
05
04i 1
01
} split/string [str separator start] #@[source: [[when-not start [set! start 0]] [def pos-found [index-of str separator start]] [if [>= pos-found 0] [cons [string/cut str start pos-found] [split/string str separator [+ pos-found [string/length separator]]]] [cons [string/cut str start [string/length str]] #nil]]]] #{##[start index-of str separator pos-found string/cut split/string string/length]
1Ai 0
05
0Bo 7
24
09o 8
02i 0
1Ai 0
08
0D
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 0
05
04i 3
1Ai 4
07
0D
1Ai 4
05
02i 0
21
0Bo 44
1Ai 5
05
1Ai 2
05
1Ai 0
05
1Ai 4
05
04i 3
1Ai 6
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 7
05
1Ai 3
05
04i 1
25
04i 3
14
09o 24
1Ai 5
05
1Ai 2
05
1Ai 0
05
1Ai 7
05
1Ai 2
05
04i 1
04i 3
24
14
01
} split [str separator] #@[documentation: "Splits STR into a list at every occurunse of SEPARATOR" source: ["Splits STR into a list at every occurunse of SEPARATOR" [typecheck/only str :string] [typecheck/only separator :string] [case [string/length separator] [0 [split/empty str]] [otherwise [split/string str separator 0]]]]] #{##[type-of str :string throw list :type-error "Expected a value of type :string" current-lambda separator string/length ΓεnΣym-2 split/empty split/string]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
20
0Bo 7
24
09o 25
1Ai 3
05
1Ai 4
05
1Ai 5
1Ai 6
1Ai 1
05
1Ai 7
05
04i 0
04i 4
04i 1
0D
1Ai 0
05
1Ai 8
05
04i 1
1Ai 2
20
0Bo 7
24
09o 25
1Ai 3
05
1Ai 4
05
1Ai 5
1Ai 6
1Ai 8
05
1Ai 7
05
04i 0
04i 4
04i 1
0D
15
1Ai 9
05
1Ai 8
05
04i 1
1Ai 10
07
0D
1Ai 10
05
02i 0
20
0Bo 14
1Ai 11
05
1Ai 1
05
04i 1
09o 16
1Ai 12
05
1Ai 1
05
1Ai 8
05
02i 0
04i 3
16
01
} read/single [text] #@[documentation: "Uses the reader and returns the first single value read from string TEXT" source: ["Uses the reader and returns the first single value read from string TEXT" [typecheck/only text :string] [car [read text]]]] #{##[type-of text :string throw list :type-error "Expected a value of type :string" current-lambda read]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
20
0Bo 7
24
09o 25
1Ai 3
05
1Ai 4
05
1Ai 5
1Ai 6
1Ai 1
05
1Ai 7
05
04i 0
04i 4
04i 1
0D
1Ai 8
05
1Ai 1
05
04i 1
11
01
} read/int [text] #@[documentation: "Reads the first string from TEXT" source: ["Reads the first string from TEXT" [int [read/single text]]]] #{##[int read/single text]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
01
} read/float [text] #@[documentation: "Reads the first float from TEXT" source: ["Reads the first float from TEXT" [float [read/single text]]]] #{##[float read/single text]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
01
} string/length?! [chars] #@[source: [[fn [a] [= chars [string/length a]]]]] #{##[anonymous [a] #@[source: [[= chars [string/length a]]]] #{##[chars string/length a]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
20
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
01
} contains-any? [str chars] #@[source: [[apply or [map [split chars ""] [fn [a] [>= [index-of str a] 0]]]]]] #{##[apply or map split chars "" anonymous [a] #@[source: [[>= [index-of str a] 0]]] #{##[index-of str a]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
02i 0
21
01
}]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
04i 2
1Ai 6
1Ai 7
1Ai 8
1Ai 9
17
04i 2
04i 2
01
} contains-all? [str chars] #@[source: [[apply and [map [split chars ""] [fn [a] [>= [index-of str a] 0]]]]]] #{##[apply and map split chars "" anonymous [a] #@[source: [[>= [index-of str a] 0]]] #{##[index-of str a]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
02i 0
21
01
}]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
04i 2
1Ai 6
1Ai 7
1Ai 8
1Ai 9
17
04i 2
04i 2
01
}]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
1Ai 0
07
0D
1Ai 4
1Ai 5
1Ai 6
1Ai 7
17
1Ai 4
07
0D
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
0D
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
0D
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
0D
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
0D
1Ai 24
1Ai 25
1Ai 26
1Ai 27
17
1Ai 24
07
0D
1Ai 28
1Ai 29
1Ai 30
1Ai 31
17
1Ai 28
07
0D
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
0D
1Ai 36
1Ai 37
1Ai 38
1Ai 39
17
1Ai 36
07
0D
1Ai 40
1Ai 41
1Ai 42
1Ai 43
17
1Ai 40
07
0D
1Ai 44
1Ai 45
1Ai 46
1Ai 47
17
1Ai 44
07
0D
1Ai 48
05
1Ai 49
1Ai 50
1Ai 51
1Ai 52
1Ai 53
1Ai 54
1Ai 55
1Ai 56
1Ai 57
1Ai 58
1Ai 59
1Ai 60
1Ai 61
1Ai 62
1Ai 63
1Ai 64
04i 16
1Ai 65
07
0D
1Ai 66
1Ai 67
1Ai 68
1Ai 69
17
1Ai 66
07
0D
1Ai 70
1Ai 71
1Ai 72
1Ai 73
17
1Ai 70
07
0D
1Ai 74
1Ai 75
1Ai 76
1Ai 77
17
1Ai 74
07
0D
1Ai 74
05
1Ai 78
07
0D
1Ai 79
1Ai 80
1Ai 81
1Ai 82
17
1Ai 79
07
0D
1Ai 83
1Ai 84
1Ai 85
1Ai 86
17
1Ai 83
07
0D
1Ai 87
1Ai 88
1Ai 89
1Ai 90
17
1Ai 87
07
0D
1Ai 91
1Ai 92
1Ai 93
1Ai 94
17
1Ai 91
07
0D
1Ai 95
1Ai 96
1Ai 97
1Ai 98
17
1Ai 95
07
0D
1Ai 99
1Ai 100
1Ai 101
1Ai 102
17
1Ai 99
07
0D
1Ai 103
1Ai 104
1Ai 105
1Ai 106
17
1Ai 103
07
0D
1Ai 107
1Ai 108
1Ai 109
1Ai 110
17
1Ai 107
07
0D
1Ai 111
1Ai 112
1Ai 113
1Ai 114
17
1Ai 111
07
0D
1Ai 115
1Ai 116
1Ai 117
1Ai 118
17
1Ai 115
07
0D
1Ai 119
1Ai 120
1Ai 121
1Ai 122
17
1Ai 119
07
0D
1Ai 123
1Ai 124
1Ai 125
1Ai 126
17
1Ai 123
07
0D
1Ai 127
1Ai 128
1Ai 129
1Ai 130
17
1Ai 127
07
01
}#{##[module/insert :array/2d tree/new exports *module* tree/set! allocate array/2d/allocate [width height] #@[source: [[tree/new :data [-> [array/allocate [* width height]] [array/fill! 0]] :width width :height height]]] #{##[tree/new :data array/fill! array/allocate width height :width :height]
1Ai 0
05
1Ai 1
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
27
04i 1
02i 0
04i 2
1Ai 6
1Ai 4
05
1Ai 7
1Ai 5
05
04i 6
01
} fill! array/2d/fill! [data v] #@[source: [[array/fill! [tree/ref data :data] v] [return data]]] #{##[array/fill! tree/ref data :data v]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
04i 2
1Ai 4
05
04i 2
0D
1Ai 2
05
01
01
} ref array/2d/ref [data x y oob-val] #@[source: [[if [or [>= x [tree/ref data :width]] [>= y [tree/ref data :height]] [< x 0] [< y 0]] oob-val [array/ref [tree/ref data :data] [+ x [* y [tree/ref data :width]]]]]]] #{##[x tree/ref data :width y :height #f oob-val array/ref :data]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
04i 2
21
0C
0Ao 47
0D
1Ai 4
05
1Ai 1
05
1Ai 2
05
1Ai 5
04i 2
21
0C
0Ao 28
0D
1Ai 0
05
02i 0
1E
0C
0Ao 17
0D
1Ai 4
05
02i 0
1E
0C
0Ao 6
0D
1Ai 6
0Bo 9
1Ai 7
05
09o 36
1Ai 8
05
1Ai 1
05
1Ai 2
05
1Ai 9
04i 2
1Ai 0
05
1Ai 4
05
1Ai 1
05
1Ai 2
05
1Ai 3
04i 2
27
25
04i 2
01
} set! array/2d/set! [data x y val] #@[source: [[if [or [>= x [tree/ref data :width]] [>= y [tree/ref data :height]] [< x 0] [< y 0]] [exception :out-of-bounds "Trying to set an array out of bounds" data] [array/set! [tree/ref data :data] [+ x [* y [tree/ref data :width]]] val]] [return data]]] #{##[x tree/ref data :width y :height #f throw list :out-of-bounds "Trying to set an array out of bounds" current-lambda array/set! :data val]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
04i 2
21
0C
0Ao 47
0D
1Ai 4
05
1Ai 1
05
1Ai 2
05
1Ai 5
04i 2
21
0C
0Ao 28
0D
1Ai 0
05
02i 0
1E
0C
0Ao 17
0D
1Ai 4
05
02i 0
1E
0C
0Ao 6
0D
1Ai 6
0Bo 28
1Ai 7
05
1Ai 8
05
1Ai 9
1Ai 10
1Ai 2
05
1Ai 11
05
04i 0
04i 4
04i 1
09o 39
1Ai 12
05
1Ai 1
05
1Ai 2
05
1Ai 13
04i 2
1Ai 0
05
1Ai 4
05
1Ai 1
05
1Ai 2
05
1Ai 3
04i 2
27
25
1Ai 14
05
04i 3
0D
1Ai 2
05
01
01
} print array/2d/print [data] #@[source: [[dotimes [y [tree/ref data :height]] [dotimes [x [tree/ref data :width]] [display [cat [array/2d/ref data x y] " "]]] [newline]] [return data]]] #{##[y x print cat array/2d/ref data " " tree/ref :width newline :height]
15
02i 0
1Ai 0
07
0D
24
1B
09o 91
0D
1C
15
02i 0
1Ai 1
07
0D
24
1B
09o 41
0D
1C
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 1
05
1Ai 0
05
04i 3
1Ai 6
04i 2
04i 1
0D
02i 1
1Ai 1
05
03
1Ai 1
08
1Ai 1
05
1Ai 7
05
1Ai 5
05
1Ai 8
04i 2
1E
0Ao -52
0D
24
16
0D
1Ai 9
05
04i 0
0D
02i 1
1Ai 0
05
03
1Ai 0
08
1Ai 0
05
1Ai 7
05
1Ai 5
05
1Ai 10
04i 2
1E
0Ao -102
0D
24
16
0D
1Ai 5
05
01
01
}]
1Ai 0
05
1Ai 1
15
1Ai 2
05
24
04i 1
1Ai 3
07
0D
1Ai 1
1Ai 4
07
0D
1Ai 5
05
1Ai 3
05
1Ai 6
1Ai 7
1Ai 8
1Ai 9
1Ai 10
17
1Ai 7
07
04i 3
0D
1Ai 5
05
1Ai 3
05
1Ai 11
1Ai 12
1Ai 13
1Ai 14
1Ai 15
17
1Ai 12
07
04i 3
0D
1Ai 5
05
1Ai 3
05
1Ai 16
1Ai 17
1Ai 18
1Ai 19
1Ai 20
17
1Ai 17
07
04i 3
0D
1Ai 5
05
1Ai 3
05
1Ai 21
1Ai 22
1Ai 23
1Ai 24
1Ai 25
17
1Ai 22
07
04i 3
0D
1Ai 5
05
1Ai 3
05
1Ai 26
1Ai 27
1Ai 28
1Ai 29
1Ai 30
17
1Ai 27
07
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[module/insert :avl tree/new exports *module* :e avl/empty avl/empty? [n] #@[source: [[= :e n]]] #{##[:e n]
1Ai 0
1Ai 1
05
20
01
} tree/set! default-cmp avl/default-cmp [x y] #@[source: [[if [< x y] -1 [if [> x y] 1 0]]]] #{##[x y]
1Ai 0
05
1Ai 1
05
1E
0Bo 8
02i -1
09o 20
1Ai 0
05
1Ai 1
05
22
0Bo 8
02i 1
09o 5
02i 0
01
} avl/typecheck [r k] #@[source: [[or [avl/empty? [avl/root r]] [= [type-of k] [type-of [avl/key [avl/root r]]]] [throw [list :type-error "AVL trees can only contains keys of a single type" k [current-lambda]]]]]] #{##[avl/empty? avl/root r type-of k avl/key throw list :type-error "AVL trees can only contains keys of a single type" current-lambda #f]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
0C
0Ao 65
0D
1Ai 3
05
1Ai 4
05
04i 1
1Ai 3
05
1Ai 5
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
04i 1
20
0C
0Ao 33
0D
1Ai 6
05
1Ai 7
05
1Ai 8
1Ai 9
1Ai 4
05
1Ai 10
05
04i 0
04i 4
04i 1
0C
0Ao 6
0D
1Ai 11
01
} tree avl/tree [cmp] #@[source: [[array/new avl/empty [or cmp avl/default-cmp]]]] #{##[array/new avl/empty cmp avl/default-cmp #f]
1Ai 0
05
1Ai 1
05
1Ai 2
05
0C
0Ao 14
0D
1Ai 3
05
0C
0Ao 6
0D
1Ai 4
04i 2
01
} avl/height [n] #@[source: [[if [avl/empty? n] 0 [array/ref n 0]]]] #{##[avl/empty? n array/ref]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 8
02i 0
09o 13
1Ai 2
05
1Ai 1
05
02i 0
04i 2
01
} avl/key [n] #@[source: [[array/ref n 1]]] #{##[array/ref n]
1Ai 0
05
1Ai 1
05
02i 1
04i 2
01
} avl/left [n] #@[source: [[array/ref n 2]]] #{##[array/ref n]
1Ai 0
05
1Ai 1
05
02i 2
04i 2
01
} avl/right [n] #@[source: [[array/ref n 3]]] #{##[array/ref n]
1Ai 0
05
1Ai 1
05
02i 3
04i 2
01
} avl/root [r] #@[source: [[array/ref r 0]]] #{##[array/ref r]
1Ai 0
05
1Ai 1
05
02i 0
04i 2
01
} avl/cmp [r] #@[source: [[array/ref r 1]]] #{##[array/ref r]
1Ai 0
05
1Ai 1
05
02i 1
04i 2
01
} avl/min-node [n] #@[source: [[if [avl/empty? n] avl/empty [let [[l [avl/left n]]] [if [avl/empty? l] n [avl/min-mode l]]]]]] #{##[avl/empty? n avl/empty avl/left l avl/min-mode]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 9
1Ai 2
05
09o 42
15
1Ai 3
05
1Ai 1
05
04i 1
1Ai 4
07
0D
1Ai 0
05
1Ai 4
05
04i 1
0Bo 9
1Ai 1
05
09o 11
1Ai 5
05
1Ai 4
05
04i 1
16
01
} avl/update-left [n l] #@[source: [[array/set! [array/dup n] 2 l]]] #{##[array/set! array/dup n l]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
02i 2
1Ai 3
05
04i 3
01
} avl/update-right [n r] #@[source: [[array/set! [array/dup n] 3 r]]] #{##[array/set! array/dup n r]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
02i 3
1Ai 3
05
04i 3
01
} avl/update-key [n k] #@[source: [[array/set! [array/dup n] 1 k]]] #{##[array/set! array/dup n k]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
02i 1
1Ai 3
05
04i 3
01
} avl/update-root [t r] #@[source: [[array/set! [array/dup t] 0 r]]] #{##[array/set! array/dup t r]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
02i 0
1Ai 3
05
04i 3
01
} avl/update-height [n] #@[source: [[array/set! [array/dup n] 0 [+ 1 [max [avl/height [avl/left n]] [avl/height [avl/right n]]]]]]] #{##[array/set! array/dup n max avl/height avl/left avl/right]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
02i 0
02i 1
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 2
05
04i 1
04i 1
1Ai 4
05
1Ai 6
05
1Ai 2
05
04i 1
04i 1
04i 2
25
04i 3
01
} avl/rotate-right [y] #@[source: [[let [[x [avl/left y]]] [avl/update-height [avl/update-right x [avl/update-height [avl/update-left y [avl/right x]]]]]]]] #{##[avl/left y x avl/update-height avl/update-right avl/update-left avl/right]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 3
05
1Ai 4
05
1Ai 2
05
1Ai 3
05
1Ai 5
05
1Ai 1
05
1Ai 6
05
1Ai 2
05
04i 1
04i 2
04i 1
04i 2
04i 1
16
01
} avl/rotate-left [x] #@[source: [[let [[y [avl/right x]]] [avl/update-height [avl/update-left y [avl/update-height [avl/update-right x [avl/left y]]]]]]]] #{##[avl/right x y avl/update-height avl/update-left avl/update-right avl/left]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 3
05
1Ai 4
05
1Ai 2
05
1Ai 3
05
1Ai 5
05
1Ai 1
05
1Ai 6
05
1Ai 2
05
04i 1
04i 2
04i 1
04i 2
04i 1
16
01
} avl/balance [n] #@[source: [[if [avl/empty? n] 0 [- [avl/height [avl/left n]] [avl/height [avl/right n]]]]]] #{##[avl/empty? n avl/height avl/left avl/right]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 8
02i 0
09o 30
1Ai 2
05
1Ai 3
05
1Ai 1
05
04i 1
04i 1
1Ai 2
05
1Ai 4
05
1Ai 1
05
04i 1
04i 1
26
01
} avl/insert-rebalance [n cmp v] #@[source: [[let [[b [avl/balance n]]] [cond [[> b 1] [case [cmp v [avl/key [avl/left n]]] [-1 [avl/rotate-right n]] [1 [avl/rotate-right [avl/update-left n [avl/rotate-left [avl/left n]]]]] [0 n]]] [[< b -1] [case [cmp v [avl/key [avl/right n]]] [1 [avl/rotate-left n]] [-1 [avl/rotate-left [avl/update-right n [avl/rotate-right [avl/right n]]]]] [0 n]]] [#t n]]]]] #{##[avl/balance n b cmp v avl/key avl/left ΓεnΣym-1 avl/rotate-right avl/update-left avl/rotate-left avl/right ΓεnΣym-2 avl/update-right #t]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
02i 1
22
0Bo 107
15
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 6
05
1Ai 1
05
04i 1
04i 1
04i 2
1Ai 7
07
0D
1Ai 7
05
02i -1
20
0Bo 14
1Ai 8
05
1Ai 1
05
04i 1
09o 57
1Ai 7
05
02i 1
20
0Bo 32
1Ai 8
05
1Ai 9
05
1Ai 1
05
1Ai 10
05
1Ai 6
05
1Ai 1
05
04i 1
04i 1
04i 2
04i 1
09o 19
1Ai 7
05
02i 0
20
0Bo 9
1Ai 1
05
09o 4
24
16
09o 128
1Ai 2
05
02i -1
1E
0Bo 107
15
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 11
05
1Ai 1
05
04i 1
04i 1
04i 2
1Ai 12
07
0D
1Ai 12
05
02i 1
20
0Bo 14
1Ai 10
05
1Ai 1
05
04i 1
09o 57
1Ai 12
05
02i -1
20
0Bo 32
1Ai 10
05
1Ai 13
05
1Ai 1
05
1Ai 8
05
1Ai 11
05
1Ai 1
05
04i 1
04i 1
04i 2
04i 1
09o 19
1Ai 12
05
02i 0
20
0Bo 9
1Ai 1
05
09o 4
24
16
09o 15
1Ai 14
0Bo 9
1Ai 1
05
09o 4
24
16
01
} avl/node-insert [n cmp v] #@[source: [[if [avl/empty? n] [array/new 1 v avl/empty avl/empty] [case [cmp v [avl/key n]] [-1 [avl/insert-rebalance [avl/update-height [avl/update-left n [avl/node-insert [avl/left n] cmp v]]] cmp v]] [1 [avl/insert-rebalance [avl/update-height [avl/update-right n [avl/node-insert [avl/right n] cmp v]]] cmp v]] [0 [avl/update-key n v]]]]]] #{##[avl/empty? n array/new v avl/empty cmp avl/key ΓεnΣym-3 avl/insert-rebalance avl/update-height avl/update-left avl/node-insert avl/left avl/update-right avl/right avl/update-key]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 22
1Ai 2
05
02i 1
1Ai 3
05
1Ai 4
05
1Ai 4
05
04i 4
09o 159
15
1Ai 5
05
1Ai 3
05
1Ai 6
05
1Ai 1
05
04i 1
04i 2
1Ai 7
07
0D
1Ai 7
05
02i -1
20
0Bo 49
1Ai 8
05
1Ai 9
05
1Ai 10
05
1Ai 1
05
1Ai 11
05
1Ai 12
05
1Ai 1
05
04i 1
1Ai 5
05
1Ai 3
05
04i 3
04i 2
04i 1
1Ai 5
05
1Ai 3
05
04i 3
09o 82
1Ai 7
05
02i 1
20
0Bo 49
1Ai 8
05
1Ai 9
05
1Ai 13
05
1Ai 1
05
1Ai 11
05
1Ai 14
05
1Ai 1
05
04i 1
1Ai 5
05
1Ai 3
05
04i 3
04i 2
04i 1
1Ai 5
05
1Ai 3
05
04i 3
09o 27
1Ai 7
05
02i 0
20
0Bo 17
1Ai 15
05
1Ai 1
05
1Ai 3
05
04i 2
09o 4
24
16
01
} insert avl/insert [t v] #@[documentation: "Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" source: ["Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" [avl/typecheck t v] [avl/update-root t [avl/node-insert [avl/root t] [avl/cmp t] v]]]] #{##[avl/typecheck t v avl/update-root avl/node-insert avl/root avl/cmp]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 2
0D
1Ai 3
05
1Ai 1
05
1Ai 4
05
1Ai 5
05
1Ai 1
05
04i 1
1Ai 6
05
1Ai 1
05
04i 1
1Ai 2
05
04i 3
04i 2
01
} avl/node-get [n cmp v] #@[source: [[if [avl/empty? n] #nil [case [cmp v [avl/key n]] [0 [avl/key n]] [-1 [avl/node-get [avl/left n] cmp v]] [1 [avl/node-get [avl/right n] cmp v]]]]]] #{##[avl/empty? n cmp v avl/key ΓεnΣym-4 avl/node-get avl/left avl/right]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 7
24
09o 108
15
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 1
05
04i 1
04i 2
1Ai 5
07
0D
1Ai 5
05
02i 0
20
0Bo 14
1Ai 4
05
1Ai 1
05
04i 1
09o 66
1Ai 5
05
02i -1
20
0Bo 25
1Ai 6
05
1Ai 7
05
1Ai 1
05
04i 1
1Ai 2
05
1Ai 3
05
04i 3
09o 35
1Ai 5
05
02i 1
20
0Bo 25
1Ai 6
05
1Ai 8
05
1Ai 1
05
04i 1
1Ai 2
05
1Ai 3
05
04i 3
09o 4
24
16
01
} get avl/get [t v] #@[documentation: "Retrieve the key V from tree T, or #nil if V is not in it" source: ["Retrieve the key V from tree T, or #nil if V is not in it" [if [or [avl/empty? [avl/root t]] [not= [type-of v] [type-of [avl/key [avl/root t]]]]] #nil [avl/node-get [avl/root t] [avl/cmp t] v]]]] #{##[avl/empty? avl/root t not= type-of v avl/key #f avl/node-get avl/cmp]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
0C
0Ao 42
0D
1Ai 3
05
1Ai 4
05
1Ai 5
05
04i 1
1Ai 4
05
1Ai 6
05
1Ai 1
05
1Ai 2
05
04i 1
04i 1
04i 1
04i 2
0C
0Ao 6
0D
1Ai 7
0Bo 7
24
09o 27
1Ai 8
05
1Ai 1
05
1Ai 2
05
04i 1
1Ai 9
05
1Ai 2
05
04i 1
1Ai 5
05
04i 3
01
} from-list avl/from-list [l cmp] #@[documentation: "Create a new avl tree using the keys in L and the comparison function CMP" source: ["Create a new avl tree using the keys in L and the comparison function CMP" [list/reduce l avl/insert [avl/tree cmp]]]] #{##[list/reduce l avl/insert avl/tree cmp]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 1
04i 3
01
} avl/remove-rebalance [n] #@[source: [[if [avl/empty? n] n [let [[b [avl/balance n]] [l [avl/left n]] [r [avl/right n]]] [cond [[> b 1] [if [>= [avl/balance l] 0] [avl/rotate-right n] [avl/rotate-right [avl/update-left n [avl/rotate-left l]]]]] [[< b -1] [if [<= [avl/balance r] 0] [avl/rotate-left n] [avl/rotate-left [avl/update-right n [avl/rotate-right r]]]]] [#t n]]]]]] #{##[avl/empty? n avl/balance b avl/left l avl/right r avl/rotate-right avl/update-left avl/rotate-left avl/update-right #t]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 9
1Ai 1
05
09o 169
15
1Ai 2
05
1Ai 1
05
04i 1
1Ai 3
07
0D
1Ai 4
05
1Ai 1
05
04i 1
1Ai 5
07
0D
1Ai 6
05
1Ai 1
05
04i 1
1Ai 7
07
0D
1Ai 3
05
02i 1
22
0Bo 52
1Ai 2
05
1Ai 5
05
04i 1
02i 0
21
0Bo 14
1Ai 8
05
1Ai 1
05
04i 1
09o 24
1Ai 8
05
1Ai 9
05
1Ai 1
05
1Ai 10
05
1Ai 5
05
04i 1
04i 2
04i 1
09o 73
1Ai 3
05
02i -1
1E
0Bo 52
1Ai 2
05
1Ai 7
05
04i 1
02i 0
1F
0Bo 14
1Ai 10
05
1Ai 1
05
04i 1
09o 24
1Ai 10
05
1Ai 11
05
1Ai 1
05
1Ai 8
05
1Ai 7
05
04i 1
04i 2
04i 1
09o 15
1Ai 12
0Bo 9
1Ai 1
05
09o 4
24
16
01
} avl/node-remove [n cmp v] #@[source: [[if [avl/empty? n] n [let [[root [case [cmp v [avl/key n]] [-1 [avl/update-left n [avl/node-remove [avl/left n] cmp v]]] [1 [avl/update-right n [avl/node-remove [avl/right n] cmp v]]] [0 [cond [[avl/empty? [avl/left n]] [avl/right n]] [[avl/empty? [avl/right n]] [avl/left n]] [#t [let [[k [avl/key [avl/min-node [avl/right n]]]]] [avl/update-key [avl/update-right [avl/right n] [avl/node-remove [avl/right n] cmp v]] k]]]]]]]] [set! root [avl/update-height root]] [avl/remove-rebalance root]]]]] #{##[avl/empty? n cmp v avl/key ΓεnΣym-5 avl/update-left avl/node-remove avl/left avl/update-right avl/right #t avl/min-node k avl/update-key root avl/update-height avl/remove-rebalance]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 9
1Ai 1
05
09o 269
15
15
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 1
05
04i 1
04i 2
1Ai 5
07
0D
1Ai 5
05
02i -1
20
0Bo 33
1Ai 6
05
1Ai 1
05
1Ai 7
05
1Ai 8
05
1Ai 1
05
04i 1
1Ai 2
05
1Ai 3
05
04i 3
04i 2
09o 182
1Ai 5
05
02i 1
20
0Bo 33
1Ai 9
05
1Ai 1
05
1Ai 7
05
1Ai 10
05
1Ai 1
05
04i 1
1Ai 2
05
1Ai 3
05
04i 3
04i 2
09o 143
1Ai 5
05
02i 0
20
0Bo 133
1Ai 0
05
1Ai 8
05
1Ai 1
05
04i 1
04i 1
0Bo 14
1Ai 10
05
1Ai 1
05
04i 1
09o 103
1Ai 0
05
1Ai 10
05
1Ai 1
05
04i 1
04i 1
0Bo 14
1Ai 8
05
1Ai 1
05
04i 1
09o 76
1Ai 11
0Bo 70
15
1Ai 4
05
1Ai 12
05
1Ai 10
05
1Ai 1
05
04i 1
04i 1
04i 1
1Ai 13
07
0D
1Ai 14
05
1Ai 9
05
1Ai 10
05
1Ai 1
05
04i 1
1Ai 7
05
1Ai 10
05
1Ai 1
05
04i 1
1Ai 2
05
1Ai 3
05
04i 3
04i 2
1Ai 13
05
04i 2
16
09o 4
24
09o 4
24
16
1Ai 15
07
0D
1Ai 16
05
1Ai 15
05
04i 1
1Ai 15
08
0D
1Ai 17
05
1Ai 15
05
04i 1
16
01
} remove avl/remove [t v] #@[documentation: "Remove the key V from tree T if it is contained within it" source: ["Remove the key V from tree T if it is contained within it" [avl/update-root t [avl/node-remove [avl/root t] [avl/cmp t] v]]]] #{##[avl/update-root t avl/node-remove avl/root avl/cmp v]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 1
05
04i 1
1Ai 4
05
1Ai 1
05
04i 1
1Ai 5
05
04i 3
04i 2
01
} avl/equal-node? [a b] #@[source: [[if [avl/empty? a] [avl/empty? b] [and [equal? [avl/key a] [avl/key b]] [avl/equal-node? [avl/left a] [avl/left b]] [avl/equal-node? [avl/right a] [avl/right b]]]]]] #{##[avl/empty? a b equal? avl/key avl/equal-node? avl/left avl/right]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 14
1Ai 0
05
1Ai 2
05
04i 1
09o 76
1Ai 3
05
1Ai 4
05
1Ai 1
05
04i 1
1Ai 4
05
1Ai 2
05
04i 1
04i 2
0C
0Bo 51
0D
1Ai 5
05
1Ai 6
05
1Ai 1
05
04i 1
1Ai 6
05
1Ai 2
05
04i 1
04i 2
0C
0Bo 25
0D
1Ai 5
05
1Ai 7
05
1Ai 1
05
04i 1
1Ai 7
05
1Ai 2
05
04i 1
04i 2
01
} equal? avl/equal? [a b] #@[documentation: "Test if two avl trees are equal" source: ["Test if two avl trees are equal" [avl/equal-node? [avl/root a] [avl/root b]]]] #{##[avl/equal-node? avl/root a b]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
1Ai 1
05
1Ai 3
05
04i 1
04i 2
01
} avl/reduce-node [node o s] #@[source: [[if [avl/empty? node] s [o [avl/key node] [avl/reduce-node [avl/right node] o [avl/reduce-node [avl/left node] o s]]]]]] #{##[avl/empty? node s o avl/key avl/reduce-node avl/right avl/left]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 9
1Ai 2
05
09o 51
1Ai 3
05
1Ai 4
05
1Ai 1
05
04i 1
1Ai 5
05
1Ai 6
05
1Ai 1
05
04i 1
1Ai 3
05
1Ai 5
05
1Ai 7
05
1Ai 1
05
04i 1
1Ai 3
05
1Ai 2
05
04i 3
04i 3
04i 2
01
} reduce avl/reduce [t o s] #@[documentation: "Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" source: ["Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" [avl/reduce-node [avl/root t] o s]]] #{##[avl/reduce-node avl/root t o s]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
1Ai 3
05
1Ai 4
05
04i 3
01
} avl/reduce-node-bin [n o s] #@[source: [[if [avl/empty? n] s [o [o [avl/key n] [avl/reduce-node-bin [avl/left n] o s]] [avl/reduce-node-bin [avl/right n] o s]]]]] #{##[avl/empty? n s o avl/key avl/reduce-node-bin avl/left avl/right]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 9
1Ai 2
05
09o 59
1Ai 3
05
1Ai 3
05
1Ai 4
05
1Ai 1
05
04i 1
1Ai 5
05
1Ai 6
05
1Ai 1
05
04i 1
1Ai 3
05
1Ai 2
05
04i 3
04i 2
1Ai 5
05
1Ai 7
05
1Ai 1
05
04i 1
1Ai 3
05
1Ai 2
05
04i 3
04i 2
01
} reduce-bin avl/reduce-bin [t o s] #@[documentation: "Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" source: ["Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" [avl/reduce-node-bin [avl/root t] o s]]] #{##[avl/reduce-node-bin avl/root t o s]
1Ai 0
05
1Ai 1
05
1Ai 2
05
04i 1
1Ai 3
05
1Ai 4
05
04i 3
01
} map avl/map [t f] #@[documentation: "Create a new avl tree by mapping each key in T using F, using the same comparison function as T" source: ["Create a new avl tree by mapping each key in T using F, using the same comparison function as T" [avl/reduce t [fn [x acc] [avl/insert acc [f x]]] [avl/tree [avl/cmp t]]]]] #{##[avl/reduce t anonymous [x acc] #@[source: [[avl/insert acc [f x]]]] #{##[avl/insert acc f x]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
04i 2
01
} avl/tree avl/cmp]
1Ai 0
05
1Ai 1
05
1Ai 2
1Ai 3
1Ai 4
1Ai 5
17
1Ai 6
05
1Ai 7
05
1Ai 1
05
04i 1
04i 1
04i 3
01
} map-to avl/map-to [t f cmp] #@[documentation: "Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" source: ["Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" [avl/reduce t [fn [x acc] [avl/insert acc [f x]]] [avl/tree cmp]]]] #{##[avl/reduce t anonymous [x acc] #@[source: [[avl/insert acc [f x]]]] #{##[avl/insert acc f x]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
04i 2
01
} avl/tree cmp]
1Ai 0
05
1Ai 1
05
1Ai 2
1Ai 3
1Ai 4
1Ai 5
17
1Ai 6
05
1Ai 7
05
04i 1
04i 3
01
} to-list avl/to-list [t] #@[source: [[avl/reduce t cons #nil]]] #{##[avl/reduce t cons]
1Ai 0
05
1Ai 1
05
1Ai 2
05
24
04i 3
01
}]
1Ai 0
05
1Ai 1
15
1Ai 2
05
24
04i 1
1Ai 3
07
0D
1Ai 1
1Ai 4
07
0D
1Ai 5
1Ai 6
07
0D
1Ai 7
1Ai 8
1Ai 9
1Ai 10
17
1Ai 7
07
0D
1Ai 11
05
1Ai 3
05
1Ai 12
1Ai 13
1Ai 14
1Ai 15
1Ai 16
17
1Ai 13
07
04i 3
0D
1Ai 17
1Ai 18
1Ai 19
1Ai 20
17
1Ai 17
07
0D
1Ai 11
05
1Ai 3
05
1Ai 21
1Ai 22
1Ai 23
1Ai 24
1Ai 25
17
1Ai 22
07
04i 3
0D
1Ai 26
1Ai 27
1Ai 28
1Ai 29
17
1Ai 26
07
0D
1Ai 30
1Ai 31
1Ai 32
1Ai 33
17
1Ai 30
07
0D
1Ai 34
1Ai 35
1Ai 36
1Ai 37
17
1Ai 34
07
0D
1Ai 38
1Ai 39
1Ai 40
1Ai 41
17
1Ai 38
07
0D
1Ai 42
1Ai 43
1Ai 44
1Ai 45
17
1Ai 42
07
0D
1Ai 46
1Ai 47
1Ai 48
1Ai 49
17
1Ai 46
07
0D
1Ai 50
1Ai 51
1Ai 52
1Ai 53
17
1Ai 50
07
0D
1Ai 54
1Ai 55
1Ai 56
1Ai 57
17
1Ai 54
07
0D
1Ai 58
1Ai 59
1Ai 60
1Ai 61
17
1Ai 58
07
0D
1Ai 62
1Ai 63
1Ai 64
1Ai 65
17
1Ai 62
07
0D
1Ai 66
1Ai 67
1Ai 68
1Ai 69
17
1Ai 66
07
0D
1Ai 70
1Ai 71
1Ai 72
1Ai 73
17
1Ai 70
07
0D
1Ai 74
1Ai 75
1Ai 76
1Ai 77
17
1Ai 74
07
0D
1Ai 78
1Ai 79
1Ai 80
1Ai 81
17
1Ai 78
07
0D
1Ai 82
1Ai 83
1Ai 84
1Ai 85
17
1Ai 82
07
0D
1Ai 86
1Ai 87
1Ai 88
1Ai 89
17
1Ai 86
07
0D
1Ai 90
1Ai 91
1Ai 92
1Ai 93
17
1Ai 90
07
0D
1Ai 11
05
1Ai 3
05
1Ai 94
1Ai 95
1Ai 96
1Ai 97
1Ai 98
17
1Ai 95
07
04i 3
0D
1Ai 99
1Ai 100
1Ai 101
1Ai 102
17
1Ai 99
07
0D
1Ai 11
05
1Ai 3
05
1Ai 103
1Ai 104
1Ai 105
1Ai 106
1Ai 107
17
1Ai 104
07
04i 3
0D
1Ai 11
05
1Ai 3
05
1Ai 108
1Ai 109
1Ai 110
1Ai 111
1Ai 112
17
1Ai 109
07
04i 3
0D
1Ai 113
1Ai 114
1Ai 115
1Ai 116
17
1Ai 113
07
0D
1Ai 117
1Ai 118
1Ai 119
1Ai 120
17
1Ai 117
07
0D
1Ai 11
05
1Ai 3
05
1Ai 121
1Ai 122
1Ai 123
1Ai 124
1Ai 125
17
1Ai 122
07
04i 3
0D
1Ai 126
1Ai 127
1Ai 128
1Ai 129
17
1Ai 126
07
0D
1Ai 11
05
1Ai 3
05
1Ai 130
1Ai 131
1Ai 132
1Ai 133
1Ai 134
17
1Ai 131
07
04i 3
0D
1Ai 135
1Ai 136
1Ai 137
1Ai 138
17
1Ai 135
07
0D
1Ai 11
05
1Ai 3
05
1Ai 139
1Ai 140
1Ai 141
1Ai 142
1Ai 143
17
1Ai 140
07
04i 3
0D
1Ai 144
1Ai 145
1Ai 146
1Ai 147
17
1Ai 144
07
0D
1Ai 11
05
1Ai 3
05
1Ai 148
1Ai 149
1Ai 150
1Ai 151
1Ai 152
17
1Ai 149
07
04i 3
0D
1Ai 11
05
1Ai 3
05
1Ai 153
1Ai 154
1Ai 155
1Ai 156
1Ai 157
17
1Ai 154
07
04i 3
0D
1Ai 11
05
1Ai 3
05
1Ai 158
1Ai 159
1Ai 160
1Ai 161
1Ai 162
17
1Ai 159
07
04i 3
0D
1Ai 11
05
1Ai 3
05
1Ai 163
1Ai 164
1Ai 165
1Ai 166
1Ai 167
17
1Ai 164
07
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[module/insert :crypto/adler32 tree/new exports *module* tree/set! hash [data] #@[source: [[def a 1] [def b 0] [when [string? data] [set! data [string->buffer data]]] [when [not= [type-of data] :buffer] [exception :type-error "Can only hash buffers or strings"]] [def v [buffer/view/u8* data]] [dotimes [i [buffer/length data]] [set! a [mod/int [add/int a [buffer/view/ref v i]] 65521]] [set! b [mod/int [add/int a b] 65521]]] [bit-or a [bit-shift-left b 16]]]] #{##[a b string? data string->buffer not= type-of :buffer throw list :type-error "Can only hash buffers or strings" current-lambda buffer/view/u8* v i mod/int buffer/view/ref 65521 buffer/length bit-or bit-shift-left]
02i 1
1Ai 0
07
0D
02i 0
1Ai 1
07
0D
1Ai 2
05
1Ai 3
05
04i 1
0Bo 17
1Ai 4
05
1Ai 3
05
04i 1
1Ai 3
08
09o 4
24
0D
1Ai 5
05
1Ai 6
05
1Ai 3
05
04i 1
1Ai 7
04i 2
0Bo 26
1Ai 8
05
1Ai 9
05
1Ai 10
1Ai 11
24
1Ai 12
05
04i 0
04i 4
04i 1
09o 4
24
0D
1Ai 13
05
1Ai 3
05
04i 1
1Ai 14
07
0D
15
02i 0
1Ai 15
07
0D
24
1B
09o 58
0D
1C
1Ai 16
05
1Ai 0
05
1Ai 17
05
1Ai 14
05
1Ai 15
05
04i 2
03
1Ai 18
04i 2
1Ai 0
08
0D
1Ai 16
05
1Ai 0
05
1Ai 1
05
03
1Ai 18
04i 2
1Ai 1
08
0D
02i 1
1Ai 15
05
03
1Ai 15
08
1Ai 15
05
1Ai 19
05
1Ai 3
05
04i 1
1E
0Ao -67
0D
24
16
0D
1Ai 20
05
1Ai 0
05
1Ai 21
05
1Ai 1
05
02i 16
04i 2
04i 2
01
}]
1Ai 0
05
1Ai 1
15
1Ai 2
05
24
04i 1
1Ai 3
07
0D
1Ai 1
1Ai 4
07
0D
1Ai 5
05
1Ai 3
05
1Ai 6
1Ai 6
1Ai 7
1Ai 8
1Ai 9
17
1Ai 6
07
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[module/insert :image tree/new exports *module* image/decoders image/encoders tree/set! add-encoder! image/add-encoder! [ext enc] #@[source: [[def ext [string->keyword [lowercase ext]]] [tree/set! image/encoders ext enc]]] #{##[symbol->keyword string->symbol lowercase ext tree/set! image/encoders enc]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
04i 1
04i 1
1Ai 3
07
0D
1Ai 4
05
1Ai 5
05
1Ai 3
05
1Ai 6
05
04i 3
01
} add-decoder! image/add-decoder! [ext dec] #@[source: [[def ext [string->keyword [lowercase ext]]] [tree/set! image/decoders ext dec]]] #{##[symbol->keyword string->symbol lowercase ext tree/set! image/decoders dec]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 1
04i 1
04i 1
1Ai 3
07
0D
1Ai 4
05
1Ai 5
05
1Ai 3
05
1Ai 6
05
04i 3
01
} image/get-encoder [path] #@[source: [[def ext [string->keyword [lowercase [path/extension path]]]] [tree/ref image/encoders ext]]] #{##[symbol->keyword string->symbol lowercase path/extension path ext tree/ref image/encoders]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 1
04i 1
04i 1
04i 1
1Ai 5
07
0D
1Ai 6
05
1Ai 7
05
1Ai 5
05
04i 2
01
} image/get-decoder [path] #@[source: [[def ext [string->keyword [lowercase [path/extension path]]]] [tree/ref image/decoders ext]]] #{##[symbol->keyword string->symbol lowercase path/extension path ext tree/ref image/decoders]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 1
04i 1
04i 1
04i 1
1Ai 5
07
0D
1Ai 6
05
1Ai 7
05
1Ai 5
05
04i 2
01
} new image/new [width height] #@[source: [[def buffer [buffer/allocate [* width height 4]]] [tree/new :width width :height height :buffer buffer :pixels [buffer/view/u32* buffer]]]] #{##[buffer/allocate width height buffer tree/new :width :height :buffer :pixels buffer/view/u32*]
1Ai 0
05
1Ai 1
05
1Ai 2
05
27
02i 4
27
04i 1
1Ai 3
07
0D
1Ai 4
05
1Ai 5
1Ai 1
05
1Ai 6
1Ai 2
05
1Ai 7
1Ai 3
05
1Ai 8
1Ai 9
05
1Ai 3
05
04i 1
04i 8
01
} ref image/ref [img x y] #@[source: [[def i [+ [int x] [* [int y] [tree/ref img :width]]]] [buffer/view/ref [tree/ref img :pixels] i]]] #{##[int x y tree/ref img :width i buffer/view/ref :pixels]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 0
05
1Ai 2
05
04i 1
1Ai 3
05
1Ai 4
05
1Ai 5
04i 2
27
25
1Ai 6
07
0D
1Ai 7
05
1Ai 3
05
1Ai 4
05
1Ai 8
04i 2
1Ai 6
05
04i 2
01
} set! image/set! [img x y value] #@[source: [[def i [+ [int x] [* [int y] [tree/ref img :width]]]] [buffer/view/set! [tree/ref img :pixels] i value]]] #{##[int x y tree/ref img :width i buffer/view/set! :pixels value]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 0
05
1Ai 2
05
04i 1
1Ai 3
05
1Ai 4
05
1Ai 5
04i 2
27
25
1Ai 6
07
0D
1Ai 7
05
1Ai 3
05
1Ai 4
05
1Ai 8
04i 2
1Ai 6
05
1Ai 9
05
04i 3
01
} fill! image/fill! [img value] #@[source: [[def p [tree/ref img :pixels]] [dotimes [i [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! p i value]] [return img]]] #{##[tree/ref img :pixels p i buffer/view/set! value :width :height]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
1Ai 3
07
0D
15
02i 0
1Ai 4
07
0D
24
1B
09o 29
0D
1C
1Ai 5
05
1Ai 3
05
1Ai 4
05
1Ai 6
05
04i 3
0D
02i 1
1Ai 4
05
03
1Ai 4
08
1Ai 4
05
1Ai 0
05
1Ai 1
05
1Ai 7
04i 2
1Ai 0
05
1Ai 1
05
1Ai 8
04i 2
27
1E
0Ao -51
0D
24
16
0D
1Ai 1
05
01
01
} map! image/map! [img fun] #@[source: [[def p [tree/ref img :pixels]] [dotimes [i [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! p i [fun [buffer/view/ref p i]]]] [return img]]] #{##[tree/ref img :pixels p i buffer/view/set! fun buffer/view/ref :width :height]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 2
1Ai 3
07
0D
15
02i 0
1Ai 4
07
0D
24
1B
09o 42
0D
1C
1Ai 5
05
1Ai 3
05
1Ai 4
05
1Ai 6
05
1Ai 7
05
1Ai 3
05
1Ai 4
05
04i 2
04i 1
04i 3
0D
02i 1
1Ai 4
05
03
1Ai 4
08
1Ai 4
05
1Ai 0
05
1Ai 1
05
1Ai 8
04i 2
1Ai 0
05
1Ai 1
05
1Ai 9
04i 2
27
1E
0Ao -64
0D
24
16
0D
1Ai 1
05
01
01
} dup image/dup [img] #@[source: [[def ret [image/new [tree/ref img :width] [tree/ref img :height]]] [def in [tree/ref img :pixels]] [def out [tree/ref ret :pixels]] [dotimes [i [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! out i [buffer/view/ref in i]]] [return ret]]] #{##[image/new tree/ref img :width :height ret :pixels in out i buffer/view/set! buffer/view/ref]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
04i 2
1Ai 1
05
1Ai 2
05
1Ai 4
04i 2
04i 2
1Ai 5
07
0D
1Ai 1
05
1Ai 2
05
1Ai 6
04i 2
1Ai 7
07
0D
1Ai 1
05
1Ai 5
05
1Ai 6
04i 2
1Ai 8
07
0D
15
02i 0
1Ai 9
07
0D
24
1B
09o 37
0D
1C
1Ai 10
05
1Ai 8
05
1Ai 9
05
1Ai 11
05
1Ai 7
05
1Ai 9
05
04i 2
04i 3
0D
02i 1
1Ai 9
05
03
1Ai 9
08
1Ai 9
05
1Ai 1
05
1Ai 2
05
1Ai 3
04i 2
1Ai 1
05
1Ai 2
05
1Ai 4
04i 2
27
1E
0Ao -59
0D
24
16
0D
1Ai 5
05
01
01
} save! image/save! [img path] #@[source: [[def enc [image/get-encoder path]] [if enc [file/write [enc img] path] [exception :missing-encoder "Currently there is no encoder loaded for that image format" path]]]] #{##[image/get-encoder path enc file/write img throw list :missing-encoder "Currently there is no encoder loaded for that image format" current-lambda]
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
0Bo 22
1Ai 3
05
1Ai 2
05
1Ai 4
05
04i 1
1Ai 1
05
04i 2
09o 25
1Ai 5
05
1Ai 6
05
1Ai 7
1Ai 8
1Ai 1
05
1Ai 9
05
04i 0
04i 4
04i 1
01
} adler32 image/adler32 [img] #@[source: [[import [hash] :crypto/adler32] [hash [tree/ref img :buffer]]]] #{##[module/import module/load :crypto/adler32 hash tree/ref img :buffer]
1Ai 0
05
1Ai 1
05
1Ai 2
04i 1
1Ai 3
04i 2
1Ai 3
07
0D
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 6
04i 2
04i 1
01
} test-image-xor image/test-image-xor [] #@[source: [[def w 256] [def h 256] [def out [image/new w h]] [dotimes [x w] [dotimes [y h] [image/set! out x y [bit-or x [bit-shift-left y 8] [bit-shift-left [bit-xor x y] 16]]]]] [return out]]] #{##[256 w h image/new out x y image/set! bit-or bit-shift-left bit-xor]
1Ai 0
1Ai 1
07
0D
1Ai 0
1Ai 2
07
0D
1Ai 3
05
1Ai 1
05
1Ai 2
05
04i 2
1Ai 4
07
0D
15
02i 0
1Ai 5
07
0D
24
1B
09o 107
0D
1C
15
02i 0
1Ai 6
07
0D
24
1B
09o 70
0D
1C
1Ai 7
05
1Ai 4
05
1Ai 5
05
1Ai 6
05
1Ai 8
05
1Ai 8
05
1Ai 5
05
1Ai 9
05
1Ai 6
05
02i 8
04i 2
04i 2
1Ai 9
05
1Ai 10
05
1Ai 5
05
1Ai 6
05
04i 2
02i 16
04i 2
04i 2
04i 4
0D
02i 1
1Ai 6
05
03
1Ai 6
08
1Ai 6
05
1Ai 2
05
1E
0Ao -74
0D
24
16
0D
02i 1
1Ai 5
05
03
1Ai 5
08
1Ai 5
05
1Ai 1
05
1E
0Ao -111
0D
24
16
0D
1Ai 4
05
01
01
}]
1Ai 0
05
1Ai 1
15
1Ai 2
05
24
04i 1
1Ai 3
07
0D
1Ai 1
1Ai 4
07
0D
1Ai 2
05
24
04i 1
1Ai 5
07
0D
1Ai 2
05
24
04i 1
1Ai 6
07
0D
1Ai 7
05
1Ai 3
05
1Ai 8
1Ai 9
1Ai 10
1Ai 11
1Ai 12
17
1Ai 9
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 13
1Ai 14
1Ai 15
1Ai 16
1Ai 17
17
1Ai 14
07
04i 3
0D
1Ai 18
1Ai 19
1Ai 20
1Ai 21
17
1Ai 18
07
0D
1Ai 22
1Ai 23
1Ai 24
1Ai 25
17
1Ai 22
07
0D
1Ai 7
05
1Ai 3
05
1Ai 26
1Ai 27
1Ai 28
1Ai 29
1Ai 30
17
1Ai 27
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 31
1Ai 32
1Ai 33
1Ai 34
1Ai 35
17
1Ai 32
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 36
1Ai 37
1Ai 38
1Ai 39
1Ai 40
17
1Ai 37
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 41
1Ai 42
1Ai 43
1Ai 44
1Ai 45
17
1Ai 42
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 46
1Ai 47
1Ai 48
1Ai 49
1Ai 50
17
1Ai 47
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 51
1Ai 52
1Ai 53
1Ai 54
1Ai 55
17
1Ai 52
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 56
1Ai 57
1Ai 58
1Ai 59
1Ai 60
17
1Ai 57
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 61
1Ai 62
1Ai 63
1Ai 64
1Ai 65
17
1Ai 62
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 66
1Ai 67
1Ai 68
1Ai 69
1Ai 70
17
1Ai 67
07
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[module/insert :image/bmp tree/new exports *module* buffer/view/le/set! [u8v offset bytes val] #@[source: [[while [> bytes 0] [buffer/view/set! u8v [inc! offset] [bit-and 255 val]] [dec! bytes] [set! val [bit-shift-right val 8]]] offset]] #{##[buffer/view/set! u8v offset bit-and 255 val bytes bit-shift-right]
24
1B
09o 56
0D
1C
1Ai 0
05
1Ai 1
05
1Ai 2
05
02i 1
25
1Ai 2
08
1Ai 3
05
1Ai 4
1Ai 5
05
04i 2
04i 3
0D
1Ai 6
05
02i 1
26
1Ai 6
08
0D
1Ai 7
05
1Ai 5
05
02i 8
04i 2
1Ai 5
08
1Ai 6
05
02i 0
22
0Ao -59
0D
1Ai 2
05
01
} image/bmp/row-padding [width pixel-length] #@[source: [[def ret [- 4 [bit-and [* width pixel-length] 3]]] [if [= ret 4] 0 ret]]] #{##[bit-and width pixel-length ret]
02i 4
1Ai 0
05
1Ai 1
05
1Ai 2
05
27
02i 3
04i 2
26
1Ai 3
07
0D
1Ai 3
05
02i 4
20
0Bo 8
02i 0
09o 6
1Ai 3
05
01
} tree/set! encode image/bmp/encode [image] #@[source: [[require :image] [def image-size [* [tree/ref image :height] 3 [+ [tree/ref image :width] [image/bmp/row-padding [tree/ref image :width] 3]]]] [def header-size [+ 14 40]] [def file-size [+ image-size header-size]] [def out [buffer/allocate file-size]] [def b [buffer/view/u8* out]] [def i -1] [buffer/view/set! b [inc! i] 66] [buffer/view/set! b [inc! i] 77] [set! i [buffer/view/le/set! b i 4 file-size]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 header-size]] [set! i [buffer/view/le/set! b i 4 40]] [set! i [buffer/view/le/set! b i 4 [tree/ref image :width]]] [set! i [buffer/view/le/set! b i 4 [tree/ref image :height]]] [set! i [buffer/view/le/set! b i 2 1]] [set! i [buffer/view/le/set! b i 2 24]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 image-size]] [set! i [buffer/view/le/set! b i 4 8192]] [set! i [buffer/view/le/set! b i 4 8192]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 0]] [def row-padding [image/bmp/row-padding [tree/ref image :width] 3]] [def pixels [- header-size 1]] [let [[y [- [tree/ref image :height] 1]]] [while [>= y 0] [dotimes [x [tree/ref image :width]] [set! pixels [buffer/view/le/set! b pixels 3 [image/ref image x y]]]] [set! pixels [+ pixels row-padding]] [set! y [add/int y -1]]]] [return out]]] #{##[require* :image current-closure #t tree/ref image :height :width image/bmp/row-padding image-size header-size file-size buffer/allocate out buffer/view/u8* b i buffer/view/set! buffer/view/le/set! 8192 row-padding pixels y x image/ref]
1Ai 0
05
1Ai 1
1Ai 2
05
04i 0
1Ai 3
04i 3
0D
1Ai 4
05
1Ai 5
05
1Ai 6
04i 2
02i 3
27
1Ai 4
05
1Ai 5
05
1Ai 7
04i 2
1Ai 8
05
1Ai 4
05
1Ai 5
05
1Ai 7
04i 2
02i 3
04i 2
25
27
1Ai 9
07
0D
02i 54
1Ai 10
07
0D
1Ai 9
05
1Ai 10
05
25
1Ai 11
07
0D
1Ai 12
05
1Ai 11
05
04i 1
1Ai 13
07
0D
1Ai 14
05
1Ai 13
05
04i 1
1Ai 15
07
0D
02i -1
1Ai 16
07
0D
1Ai 17
05
1Ai 15
05
1Ai 16
05
02i 1
25
1Ai 16
08
02i 66
04i 3
0D
1Ai 17
05
1Ai 15
05
1Ai 16
05
02i 1
25
1Ai 16
08
02i 77
04i 3
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
1Ai 11
05
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
02i 0
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
1Ai 10
05
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
02i 40
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
1Ai 4
05
1Ai 5
05
1Ai 7
04i 2
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
1Ai 4
05
1Ai 5
05
1Ai 6
04i 2
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 2
02i 1
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 2
02i 24
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
02i 0
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
1Ai 9
05
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
1Ai 19
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
1Ai 19
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
02i 0
04i 4
1Ai 16
08
0D
1Ai 18
05
1Ai 15
05
1Ai 16
05
02i 4
02i 0
04i 4
1Ai 16
08
0D
1Ai 8
05
1Ai 4
05
1Ai 5
05
1Ai 7
04i 2
02i 3
04i 2
1Ai 20
07
0D
1Ai 10
05
02i 1
26
1Ai 21
07
0D
15
1Ai 4
05
1Ai 5
05
1Ai 6
04i 2
02i 1
26
1Ai 22
07
0D
24
1B
09o 100
0D
1C
15
02i 0
1Ai 23
07
0D
24
1B
09o 45
0D
1C
1Ai 18
05
1Ai 15
05
1Ai 21
05
02i 3
1Ai 24
05
1Ai 5
05
1Ai 23
05
1Ai 22
05
04i 3
04i 4
1Ai 21
08
0D
02i 1
1Ai 23
05
03
1Ai 23
08
1Ai 23
05
1Ai 4
05
1Ai 5
05
1Ai 7
04i 2
1E
0Ao -56
0D
24
16
0D
1Ai 21
05
1Ai 20
05
25
1Ai 21
08
0D
1Ai 22
05
02i -1
03
1Ai 22
08
1Ai 22
05
02i 0
21
0Ao -103
16
0D
1Ai 13
05
01
01
} init! image/bmp/init! [] #@[source: [[require :image] [image/add-encoder! "bmp" image/bmp/encode]]] #{##[require* :image current-closure #t image/add-encoder! "bmp" image/bmp/encode]
1Ai 0
05
1Ai 1
1Ai 2
05
04i 0
1Ai 3
04i 3
0D
1Ai 4
05
1Ai 5
1Ai 6
05
04i 2
01
}]
1Ai 0
05
1Ai 1
15
1Ai 2
05
24
04i 1
1Ai 3
07
0D
1Ai 1
1Ai 4
07
0D
1Ai 5
1Ai 6
1Ai 7
1Ai 8
17
1Ai 5
07
0D
1Ai 9
1Ai 10
1Ai 11
1Ai 12
17
1Ai 9
07
0D
1Ai 13
05
1Ai 3
05
1Ai 14
1Ai 15
1Ai 16
1Ai 17
1Ai 18
17
1Ai 15
07
04i 3
0D
1Ai 13
05
1Ai 3
05
1Ai 19
1Ai 20
1Ai 21
1Ai 22
1Ai 23
17
1Ai 20
07
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[module/insert :io/ansi tree/new exports *module* #f disabled tree/set! disable! [v] #@[source: [[set! disabled [if [nil? v] #t v]]]] #{##[nil? v #t disabled]
1Ai 0
05
1Ai 1
05
04i 1
0Bo 8
1Ai 2
09o 6
1Ai 1
05
1Ai 3
08
01
} "\e[0m" reset "\e[0;39m" fg-reset "\e[49m" bg-reset array/new "\e[0;30m" "\e[0;31m" "\e[0;32m" "\e[0;33m" "\e[0;34m" "\e[0;35m" "\e[0;36m" "\e[0;37m" "\e[1;30m" "\e[1;31m" "\e[1;32m" "\e[1;33m" "\e[1;34m" "\e[1;35m" "\e[1;36m" "\e[1;37m" ansi-fg "\e[40m" "\e[41m" "\e[42m" "\e[43m" "\e[44m" "\e[45m" "\e[46m" "\e[47m" ansi-bg wrap [code string] #@[documentation: "Wrap STRING in the ansi color CODE" source: ["Wrap STRING in the ansi color CODE" [cat [or disabled [array/ref ansi-fg code]] string [or disabled reset]]]] #{##[cat disabled array/ref ansi-fg code #f string reset]
1Ai 0
05
1Ai 1
05
0C
0Ao 22
0D
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 2
0C
0Ao 6
0D
1Ai 5
1Ai 6
05
1Ai 1
05
0C
0Ao 14
0D
1Ai 7
05
0C
0Ao 6
0D
1Ai 5
04i 3
01
} black args #@[source: [[wrap 0 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 0
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} dark-red #@[source: [[wrap 1 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 1
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} dark-green #@[source: [[wrap 2 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 2
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} dark-brown brown #@[source: [[wrap 3 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 3
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} dark-blue #@[source: [[wrap 4 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 4
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} purple #@[source: [[wrap 5 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 5
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} teal #@[source: [[wrap 6 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 6
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} dark-gray #@[source: [[wrap 7 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 7
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} gray #@[source: [[wrap 8 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 8
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} red #@[source: [[wrap 9 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 9
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} green #@[source: [[wrap 10 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 10
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} yellow #@[source: [[wrap 11 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 11
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} blue #@[source: [[wrap 12 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 12
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} pink #@[source: [[wrap 13 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 13
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} cyan #@[source: [[wrap 14 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 14
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} white #@[source: [[wrap 15 [apply cat args]]]] #{##[wrap apply cat args]
1Ai 0
05
02i 15
1Ai 1
05
1Ai 2
05
1Ai 3
05
04i 2
04i 2
01
} rainbow #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [let* [def count 0] [cat [join [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] ""] [or disabled fg-reset]]]]] #{##[count cat join map split apply args "" anonymous [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] #{##[bit-and count cat disabled array/ref ansi-fg #f a]
1Ai 0
05
02i 1
1Ai 1
05
25
02i 7
04i 2
1Ai 1
08
0D
1Ai 2
05
1Ai 3
05
0C
0Ao 37
0D
1Ai 4
05
1Ai 5
05
1Ai 1
05
2A
0Bo 8
02i 7
09o 9
1Ai 1
05
02i 8
25
04i 2
0C
0Ao 6
0D
1Ai 6
1Ai 7
05
04i 2
01
} disabled fg-reset #f]
15
02i 0
1Ai 0
07
0D
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
1Ai 1
05
1Ai 6
05
04i 2
1Ai 7
04i 2
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
04i 2
1Ai 7
04i 2
1Ai 12
05
0C
0Ao 14
0D
1Ai 13
05
0C
0Ao 6
0D
1Ai 14
04i 2
16
01
} rainbow-bg #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [def count 0] [def colored-list [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [bit-xor count 7]]] [or disabled [array/ref ansi-bg count]] a]]]] [cat [join colored-list ""] [or disabled reset]]]] #{##[count map split apply cat args "" anonymous [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [bit-xor count 7]]] [or disabled [array/ref ansi-bg count]] a]]] #{##[bit-and count cat disabled array/ref ansi-fg bit-xor #f ansi-bg a]
1Ai 0
05
02i 1
1Ai 1
05
25
02i 7
04i 2
1Ai 1
08
0D
1Ai 2
05
1Ai 3
05
0C
0Ao 29
0D
1Ai 4
05
1Ai 5
05
1Ai 6
05
1Ai 1
05
02i 7
04i 2
04i 2
0C
0Ao 6
0D
1Ai 7
1Ai 3
05
0C
0Ao 22
0D
1Ai 4
05
1Ai 8
05
1Ai 1
05
04i 2
0C
0Ao 6
0D
1Ai 7
1Ai 9
05
04i 3
01
} colored-list join disabled reset #f]
02i 0
1Ai 0
07
0D
1Ai 1
05
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
04i 2
1Ai 6
04i 2
1Ai 7
1Ai 8
1Ai 9
1Ai 10
17
04i 2
1Ai 11
07
0D
1Ai 4
05
1Ai 12
05
1Ai 11
05
1Ai 6
04i 2
1Ai 13
05
0C
0Ao 14
0D
1Ai 14
05
0C
0Ao 6
0D
1Ai 15
04i 2
01
} reprint-line [text width] #@[source: [[when-not width [set! width 20]] [print "\r"] [dotimes [i width] [print " "]] [print "\r"] [print text]]] #{##[width print "\r" i " " text]
1Ai 0
05
0Bo 7
24
09o 8
02i 20
1Ai 0
08
0D
1Ai 1
05
1Ai 2
04i 1
0D
15
02i 0
1Ai 3
07
0D
24
1B
09o 22
0D
1C
1Ai 1
05
1Ai 4
04i 1
0D
02i 1
1Ai 3
05
03
1Ai 3
08
1Ai 3
05
1Ai 0
05
1E
0Ao -26
0D
24
16
0D
1Ai 1
05
1Ai 2
04i 1
0D
1Ai 1
05
1Ai 5
05
04i 1
01
}]
1Ai 0
05
1Ai 1
15
1Ai 2
05
24
04i 1
1Ai 3
07
0D
1Ai 1
1Ai 4
07
0D
1Ai 5
1Ai 6
07
0D
1Ai 7
05
1Ai 3
05
1Ai 8
1Ai 8
1Ai 9
1Ai 10
1Ai 11
17
1Ai 8
07
04i 3
0D
1Ai 12
1Ai 13
07
0D
1Ai 14
1Ai 15
07
0D
1Ai 16
1Ai 17
07
0D
1Ai 18
05
1Ai 19
1Ai 20
1Ai 21
1Ai 22
1Ai 23
1Ai 24
1Ai 25
1Ai 26
1Ai 27
1Ai 28
1Ai 29
1Ai 30
1Ai 31
1Ai 32
1Ai 33
1Ai 34
04i 16
1Ai 35
07
0D
1Ai 18
05
1Ai 36
1Ai 37
1Ai 38
1Ai 39
1Ai 40
1Ai 41
1Ai 42
1Ai 43
04i 8
1Ai 44
07
0D
1Ai 7
05
1Ai 3
05
1Ai 45
1Ai 45
1Ai 46
1Ai 47
1Ai 48
17
1Ai 45
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 49
1Ai 49
1Ai 50
1Ai 51
1Ai 52
17
1Ai 49
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 53
1Ai 53
1Ai 50
1Ai 54
1Ai 55
17
1Ai 53
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 56
1Ai 56
1Ai 50
1Ai 57
1Ai 58
17
1Ai 56
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 59
1Ai 60
1Ai 50
1Ai 61
1Ai 62
17
1Ai 60
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 63
1Ai 63
1Ai 50
1Ai 64
1Ai 65
17
1Ai 63
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 66
1Ai 66
1Ai 50
1Ai 67
1Ai 68
17
1Ai 66
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 69
1Ai 69
1Ai 50
1Ai 70
1Ai 71
17
1Ai 69
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 72
1Ai 72
1Ai 50
1Ai 73
1Ai 74
17
1Ai 72
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 75
1Ai 75
1Ai 50
1Ai 76
1Ai 77
17
1Ai 75
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 78
1Ai 78
1Ai 50
1Ai 79
1Ai 80
17
1Ai 78
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 81
1Ai 81
1Ai 50
1Ai 82
1Ai 83
17
1Ai 81
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 84
1Ai 84
1Ai 50
1Ai 85
1Ai 86
17
1Ai 84
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 87
1Ai 87
1Ai 50
1Ai 88
1Ai 89
17
1Ai 87
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 90
1Ai 90
1Ai 50
1Ai 91
1Ai 92
17
1Ai 90
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 93
1Ai 93
1Ai 50
1Ai 94
1Ai 95
17
1Ai 93
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 96
1Ai 96
1Ai 50
1Ai 97
1Ai 98
17
1Ai 96
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 99
1Ai 99
1Ai 50
1Ai 100
1Ai 101
17
1Ai 99
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 102
1Ai 102
1Ai 50
1Ai 103
1Ai 104
17
1Ai 102
07
04i 3
0D
1Ai 7
05
1Ai 3
05
1Ai 105
1Ai 105
1Ai 106
1Ai 107
1Ai 108
17
1Ai 105
07
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[module/insert :serialization/json tree/new exports *module* tree->json [v] #@[documentation: "Converts a tree into a JSON encoded string, you should prefer VAL->JSON" source: ["Converts a tree into a JSON encoded string, you should prefer VAL->JSON" [cat "{" [join [map [tree/keys v] [fn [k] [cat "\"" [keyword->string k] "\": " [val->json [tree/ref v k]]]]] ",\n"] "}"]]] #{##[cat "{" join map tree/keys v anonymous [k] #@[source: [[cat "\"" [keyword->string k] "\": " [val->json [tree/ref v k]]]]] #{##[cat "\"" keyword->string k "\": " val->json tree/ref v]
1Ai 0
05
1Ai 1
1Ai 2
05
1Ai 3
05
04i 1
1Ai 4
1Ai 5
05
1Ai 6
05
1Ai 7
05
1Ai 3
05
04i 2
04i 1
04i 4
01
} ",\n" "}"]
1Ai 0
05
1Ai 1
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
05
04i 1
1Ai 6
1Ai 7
1Ai 8
1Ai 9
17
04i 2
1Ai 10
04i 2
1Ai 11
04i 3
01
} tree/set! serialize val->json [v] #@[documentation: "Return V as a JSON encoded string" source: ["Return V as a JSON encoded string" [case [type-of v] [:nil "null"] [[:int :float] [string v]] [:bool [if v "true" "false"]] [[:array :pair] [cat "[" [join [map v val->json] ","] "]"]] [:string [string/write v]] [:symbol [cat "\"" [symbol->string v] "\""]] [:keyword [cat "\"" [keyword->string v] "\""]] [:tree [tree->json v]] [otherwise [throw [list :type-error "Can't encode the value into JSON" v [current-lambda]]]]]]] #{##[type-of v ΓεnΣym-1 :nil "null" :int :float #f string :bool "true" "false" :array :pair cat "[" join map val->json "," "]" :string string/write :symbol "\"" symbol->string :keyword keyword->string :tree tree->json throw list :type-error "Can't encode the value into JSON" current-lambda]
15
1Ai 0
05
1Ai 1
05
04i 1
1Ai 2
07
0D
1Ai 2
05
1Ai 3
20
0Bo 8
1Ai 4
09o 243
1Ai 2
05
1Ai 5
20
0C
0Ao 17
0D
1Ai 2
05
1Ai 6
20
0C
0Ao 6
0D
1Ai 7
0Bo 14
1Ai 8
05
1Ai 1
05
04i 1
09o 205
1Ai 2
05
1Ai 9
20
0Bo 19
1Ai 1
05
0Bo 8
1Ai 10
09o 5
1Ai 11
09o 180
1Ai 2
05
1Ai 12
20
0C
0Ao 17
0D
1Ai 2
05
1Ai 13
20
0C
0Ao 6
0D
1Ai 7
0Bo 33
1Ai 14
05
1Ai 15
1Ai 16
05
1Ai 17
05
1Ai 1
05
1Ai 18
05
04i 2
1Ai 19
04i 2
1Ai 20
04i 3
09o 123
1Ai 2
05
1Ai 21
20
0Bo 14
1Ai 22
05
1Ai 1
05
04i 1
09o 103
1Ai 2
05
1Ai 23
20
0Bo 23
1Ai 14
05
1Ai 24
1Ai 25
05
1Ai 1
05
04i 1
1Ai 24
04i 3
09o 74
1Ai 2
05
1Ai 26
20
0Bo 23
1Ai 14
05
1Ai 24
1Ai 27
05
1Ai 1
05
04i 1
1Ai 24
04i 3
09o 45
1Ai 2
05
1Ai 28
20
0Bo 14
1Ai 29
05
1Ai 1
05
04i 1
09o 25
1Ai 30
05
1Ai 31
05
1Ai 32
1Ai 33
1Ai 1
05
1Ai 34
05
04i 0
04i 4
04i 1
16
01
}]
1Ai 0
05
1Ai 1
15
1Ai 2
05
24
04i 1
1Ai 3
07
0D
1Ai 1
1Ai 4
07
0D
1Ai 5
1Ai 6
1Ai 7
1Ai 8
17
1Ai 5
07
0D
1Ai 9
05
1Ai 3
05
1Ai 10
1Ai 11
1Ai 12
1Ai 13
1Ai 14
17
1Ai 11
07
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[module/insert :test tree/new exports *module* test-list test-count nujel-start success-count error-count #t print-errors #f print-passes tree/set! add* test/add* [result expr] #@[source: [[set! test-list [cons [cons result expr] test-list]] [set! test-count [+ test-count 1]]]] #{##[result expr test-list test-count]
1Ai 0
05
1Ai 1
05
14
1Ai 2
05
14
1Ai 2
08
0D
1Ai 3
05
02i 1
25
1Ai 3
08
01
} add test/add [result . expr] #@[documentation: "Add a test where EXPR must eval to RESULT" source: ["Add a test where EXPR must eval to RESULT" [quasiquote [[unquote test/add*] [unquote result] [unquote [list 'quote [cons 'do expr]]]]]]] #{##[test/add* result list quote do expr]
1Ai 0
05
1Ai 1
05
1Ai 2
05
1Ai 3
1Ai 4
1Ai 5
05
14
04i 2
24
14
14
14
01
} reset! [] #@[source: [[set! test-list [cons 4 '[+ 3 1]]] [set! test-count 1]]] #{##[[+ 3 1] test-list test-count]
02i 4
1Ai 0
14
1Ai 1
08
0D
02i 1
1Ai 2
08
01
} display-results [description] #@[documentation: "Prints the result Message" source: ["Prints the result Message" [random/seed-initialize!] [efmtln "{} {} - [{} / {}] in {} ms" [if [and [zero? error-count] [> test-count 0]] [if [zero? success-count] [ansi-yellow "?"] [ansi-green "✓"]] [ansi-red "✗"]] description [if [zero? success-count] [ansi-yellow success-count] [ansi-green success-count]] [if [zero? error-count] [ansi-gray error-count] [ansi-red error-count]] [- [time/milliseconds] nujel-start]]]] #{##[random/seed-initialize! errorln error-count test-count success-count ansi-yellow "?" ansi-green "✓" ansi-red "✗" fmt-arg-0 description fmt-arg-1 fmt-arg-2 ansi-gray fmt-arg-3 time/milliseconds nujel-start fmt-arg-4 cat " " " - [" " / " "] in " " ms"]
1Ai 0
05
04i 0
0D
1Ai 1
05
15
1Ai 2
05
2A
0C
0Bo 10
0D
1Ai 3
05
02i 0
22
0Bo 30
1Ai 4
05
2A
0Bo 13
1Ai 5
05
1Ai 6
04i 1
09o 10
1Ai 7
05
1Ai 8
04i 1
09o 10
1Ai 9
05
1Ai 10
04i 1
1Ai 11
07
0D
1Ai 12
05
1Ai 13
07
0D
1Ai 4
05
2A
0Bo 14
1Ai 5
05
1Ai 4
05
04i 1
09o 11
1Ai 7
05
1Ai 4
05
04i 1
1Ai 14
07
0D
1Ai 2
05
2A
0Bo 14
1Ai 15
05
1Ai 2
05
04i 1
09o 11
1Ai 9
05
1Ai 2
05
04i 1
1Ai 16
07
0D
1Ai 17
05
04i 0
1Ai 18
05
26
1Ai 19
07
0D
1Ai 20
05
1Ai 11
05
1Ai 21
1Ai 13
05
1Ai 22
1Ai 14
05
1Ai 23
1Ai 16
05
1Ai 24
1Ai 19
05
1Ai 25
04i 10
16
04i 1
01
} test-success [res-should res-is expr] #@[documentation: "Should be called after a test has finished successfully" source: ["Should be called after a test has finished successfully" [when print-passes [efmtln "{} == {}\r\n{}\r\n\r\n" [ansi-green [string/write res-is]] [ansi-green [string/write res-should]] [string/write expr]]] [set! success-count [+ 1 success-count]]]] #{##[print-passes errorln ansi-green string/write res-is fmt-arg-0 res-should fmt-arg-1 expr fmt-arg-2 cat " == " "\r\n" "\r\n\r\n" success-count]
1Ai 0
05
0Bo 79
1Ai 1
05
15
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 1
04i 1
1Ai 5
07
0D
1Ai 2
05
1Ai 3
05
1Ai 6
05
04i 1
04i 1
1Ai 7
07
0D
1Ai 3
05
1Ai 8
05
04i 1
1Ai 9
07
0D
1Ai 10
05
1Ai 5
05
1Ai 11
1Ai 7
05
1Ai 12
1Ai 9
05
1Ai 13
04i 6
16
04i 1
09o 4
24
0D
02i 1
1Ai 14
05
25
1Ai 14
08
01
} test-failure [res-should res-is expr] #@[documentation: "Should be called if EXPR does not equal RES" source: ["Should be called if EXPR does not equal RES" [when print-errors [pfmtln "{} != {}\r\n{}\r\n\r\n" [ansi-red [string/write res-is]] [ansi-green [string/write res-should]] [string/write expr]]] [set! error-count [+ 1 error-count]]]] #{##[print-errors println ansi-red string/write res-is fmt-arg-0 ansi-green res-should fmt-arg-1 expr fmt-arg-2 cat " != " "\r\n" "\r\n\r\n" error-count]
1Ai 0
05
0Bo 79
1Ai 1
05
15
1Ai 2
05
1Ai 3
05
1Ai 4
05
04i 1
04i 1
1Ai 5
07
0D
1Ai 6
05
1Ai 3
05
1Ai 7
05
04i 1
04i 1
1Ai 8
07
0D
1Ai 3
05
1Ai 9
05
04i 1
1Ai 10
07
0D
1Ai 11
05
1Ai 5
05
1Ai 12
1Ai 8
05
1Ai 13
1Ai 10
05
1Ai 14
04i 6
16
04i 1
09o 4
24
0D
02i 1
1Ai 15
05
25
1Ai 15
08
01
} run-test! [result rawexpr i] #@[documentation: "Tests that RAWEXPR evaluates to RESULT" source: ["Tests that RAWEXPR evaluates to RESULT" [try [fn [err] [display/error err] [test-failure result [list :exception-caught err] rawexpr]] [def expr [eval rawexpr]] [if [equal? result expr] [test-success result expr rawexpr] [test-failure result expr rawexpr]]]]] #{##[anonymous [err] #@[source: [[display/error err] [test-failure result [list :exception-caught err] rawexpr]]] #{##[display/error err test-failure result list :exception-caught rawexpr]
1Ai 0
05
1Ai 1
05
04i 1
0D
1Ai 2
05
1Ai 3
05
1Ai 4
05
1Ai 5
1Ai 1
05
04i 2
1Ai 6
05
04i 3
01
} eval-in current-closure rawexpr expr equal? result test-success test-failure]
1Ai 0
1Ai 1
1Ai 2
1Ai 3
17
19o 66
1Ai 4
05
1Ai 5
05
04i 0
1Ai 6
05
04i 2
1Ai 7
07
0D
1Ai 8
05
1Ai 9
05
1Ai 7
05
04i 2
0Bo 20
1Ai 10
05
1Ai 9
05
1Ai 7
05
1Ai 6
05
04i 3
09o 17
1Ai 11
05
1Ai 9
05
1Ai 7
05
1Ai 6
05
04i 3
16
01
} init! [output-passes hide-errors] #@[documentation: "Initialize the testing framework" source: ["Initialize the testing framework" [set! print-errors [not [boolean hide-errors]]] [set! print-passes [boolean output-passes]] [set! nujel-start [time/milliseconds]] [set! success-count 0] [set! error-count 0]]] #{##[hide-errors #t #f print-errors output-passes print-passes time/milliseconds nujel-start success-count error-count]
1Ai 0
05
0Bo 8
1Ai 1
09o 5
1Ai 2
0Bo 8
1Ai 2
09o 5
1Ai 1
1Ai 3
08
0D
1Ai 4
05
0Bo 8
1Ai 1
09o 5
1Ai 2
1Ai 5
08
0D
1Ai 6
05
04i 0
1Ai 7
08
0D
02i 0
1Ai 8
08
0D
02i 0
1Ai 9
08
01
} finish! [description] #@[source: [[display-results description] [return error-count]]] #{##[display-results description error-count]
1Ai 0
05
1Ai 1
05
04i 1
0D
1Ai 2
05
01
01
} run [output-passes hide-errors] #@[documentation: "Run through all automated Tests" source: ["Run through all automated Tests" [init!] [doseq [cur-test test-list] [run-test! [car cur-test] [cdr cur-test]]] [finish! [fmt "{} {} [{System/OS} {System/Architecture}]" [ansi-blue ":core"] [ansi-rainbow "Nujel"]]]]] #{##[init! test-list ΓεnΣym-1 cur-test run-test! finish! ansi-blue ":core" fmt-arg-0 ansi-rainbow "Nujel" fmt-arg-1 cat " " " [" System/OS System/Architecture "]"]
1Ai 0
05
04i 0
0D
15
1Ai 1
05
1Ai 2
07
0D
1Ai 2
05
0Bo 48
24
1B
09o 34
0D
1C
1Ai 2
05
11
1Ai 3
07
0D
1Ai 4
05
1Ai 3
05
11
1Ai 3
05
12
04i 2
0D
1Ai 2
05
12
1Ai 2
08
1Ai 2
05
0Ao -34
09o 4
24
16
0D
1Ai 5
05
15
1Ai 6
05
1Ai 7
04i 1
1Ai 8
07
0D
1Ai 9
05
1Ai 10
04i 1
1Ai 11
07
0D
1Ai 12
05
1Ai 8
05
1Ai 13
1Ai 11
05
1Ai 14
1Ai 15
05
1Ai 13
1Ai 16
05
1Ai 17
04i 8
16
04i 1
01
}]
1Ai 0
05
1Ai 1
15
1Ai 2
05
24
04i 1
1Ai 3
07
0D
1Ai 1
1Ai 4
07
0D
24
1Ai 5
07
0D
02i 0
1Ai 6
07
0D
02i 0
1Ai 7
07
0D
02i 0
1Ai 8
07
0D
02i 0
1Ai 9
07
0D
1Ai 10
1Ai 11
07
0D
1Ai 12
1Ai 13
07
0D
1Ai 14
05
1Ai 3
05
1Ai 15
1Ai 16
1Ai 17
1Ai 18
1Ai 19
17
1Ai 16
07
04i 3
0D
1Ai 14
05
1Ai 3
05
1Ai 20
1Ai 21
1Ai 22
1Ai 23
1Ai 24
18
1Ai 21
07
04i 3
0D
1Ai 14
05
1Ai 3
05
1Ai 25
1Ai 25
1Ai 26
1Ai 27
1Ai 28
17
1Ai 25
07
04i 3
0D
1Ai 29
1Ai 30
1Ai 31
1Ai 32
17
1Ai 29
07
0D
1Ai 33
1Ai 34
1Ai 35
1Ai 36
17
1Ai 33
07
0D
1Ai 37
1Ai 38
1Ai 39
1Ai 40
17
1Ai 37
07
0D
1Ai 14
05
1Ai 3
05
1Ai 41
1Ai 41
1Ai 42
1Ai 43
1Ai 44
17
1Ai 41
07
04i 3
0D
1Ai 14
05
1Ai 3
05
1Ai 45
1Ai 45
1Ai 46
1Ai 47
1Ai 48
17
1Ai 45
07
04i 3
0D
1Ai 14
05
1Ai 3
05
1Ai 49
1Ai 49
1Ai 50
1Ai 51
1Ai 52
17
1Ai 49
07
04i 3
0D
1Ai 14
05
1Ai 3
05
1Ai 53
1Ai 53
1Ai 54
1Ai 55
1Ai 56
17
1Ai 53
07
04i 3
0D
1Ai 25
05
04i 0
0D
24
0D
13
16
04i 2
01
}#{##[module/insert :time tree/new exports *module* tree/set! seconds [timestamp] #@[documentation: "Return the seconds part of TIMESTAMP, defaults to current time" source: ["Return the seconds part of TIMESTAMP, defaults to current time" [rem [or timestamp [time]] 60]]] #{##[timestamp time #f]
1Ai 0
05
0C
0Ao 16
0D
1Ai 1
05
04i 0
0C
0Ao 6
0D
1Ai 2
02i 60
29
01
} minutes [timestamp] #@[documentation: "Return the minutes part of TIMESTAMP, defaults to current time" source: ["Return the minutes part of TIMESTAMP, defaults to current time" [rem [/ [or timestamp [time]] 60] 60]]] #{##[timestamp time #f]
1Ai 0
05
0C
0Ao 16
0D
1Ai 1
05
04i 0
0C
0Ao 6
0D
1Ai 2
02i 60
28
02i 60
29
01
} hours [timestamp] #@[documentation: "Return the hours part of TIMESTAMP, defaults to current time" source: ["Return the hours part of TIMESTAMP, defaults to current time" [rem [/ [or timestamp [time]] 3600] 24]]] #{##[timestamp time #f 3600]
1Ai 0
05
0C
0Ao 16
0D
1Ai 1
05
04i 0
0C
0Ao 6
0D
1Ai 2
1Ai 3
28
02i 24
29
01
}]
1Ai 0
05
1Ai 1
15
1Ai 2
05
24
04i 1
1Ai 3
07
0D
1Ai 1
1Ai 4
07
0D
1Ai 5
05
1Ai 3
05
1Ai 6
1Ai 6
1Ai 7
1Ai 8
1Ai 9
17
1Ai 6
07
04i 3
0D
1Ai 5
05
1Ai 3
05
1Ai 10
1Ai 10
1Ai 11
1Ai 12
1Ai 13
17
1Ai 10
07
04i 3
0D
1Ai 5
05
1Ai 3
05
1Ai 14
1Ai 14
1Ai 15
1Ai 16
1Ai 17
17
1Ai 14
07
04i 3
0D
24
0D
13
16
04i 2
01
}