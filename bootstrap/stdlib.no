#{
25v lognand v l v #@[documentation: "Returns the Nand of its arguments" source: ["Returns the Nand of its arguments" [lognot [apply logand l]]]] v #{
05v lognot
05v apply
10s logand
10s l
04i 2
04i 1
01
}
0Es lognand
0D
25v bit-set? v [α i] v #@[documentation: "Returns #t if bit I is set in Α" source: ["Returns #t if bit I is set in Α" [typecheck/only α :int] [typecheck/only i :int] [not [zero? [logand α [ash 1 i]]]]]] v #{
05v type-of
10s α
04i 1
05v :int
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :int"
10s α
05v current-lambda
04i 0
04i 4
04i 1
0D
05v type-of
10s i
04i 1
05v :int
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :int"
10s i
05v current-lambda
04i 0
04i 4
04i 1
0D
02i 0
05v logand
10s α
05v ash
02i 1
10s i
04i 2
04i 2
20
0Bo 10
05v #f
09o 7
05v #t
01
}
0Es bit-set?
0D
25v bit-set?! v [i] v #@[documentation: "Returns a function that checks if bit I is set in the provided number" source: ["Returns a function that checks if bit I is set in the provided number" [typecheck/only i :int] [def mask [ash 1 i]] [fn [α] [not [zero? [logand α mask]]]]]] v #{
05v type-of
10s i
04i 1
05v :int
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :int"
10s i
05v current-lambda
04i 0
04i 4
04i 1
0D
05v ash
02i 1
10s i
04i 2
0Es mask
0D
25v anonymous v [α] v #@[source: [[not [zero? [logand α mask]]]]] v #{
02i 0
05v logand
10s α
10s mask
04i 2
20
0Bo 10
05v #f
09o 7
05v #t
01
}
01
}
0Es bit-set?!
0D
25v bit-clear?! v [i] v #@[documentation: "Returns a function that checks if bit I is clear in the provided number" source: ["Returns a function that checks if bit I is clear in the provided number" [typecheck/only i :int] [def mask [ash 1 i]] [fn [α] [zero? [logand α mask]]]]] v #{
05v type-of
10s i
04i 1
05v :int
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :int"
10s i
05v current-lambda
04i 0
04i 4
04i 1
0D
05v ash
02i 1
10s i
04i 2
0Es mask
0D
25v anonymous v [α] v #@[source: [[zero? [logand α mask]]]] v #{
02i 0
05v logand
10s α
10s mask
04i 2
20
01
}
01
}
0Es bit-clear?!
0D
25v test-function v [i] v #@[documentation: "Returns a function that checks if bit I is clear in the provided number" source: ["Returns a function that checks if bit I is clear in the provided number" [def mask [ash 1 i]] [fn [α] [zero? [logand α mask]]]]] v #{
05v ash
02i 1
10s i
04i 2
0Es mask
0D
25v anonymous v [α] v #@[source: [[zero? [logand α mask]]]] v #{
02i 0
05v logand
10s α
10s mask
04i 2
20
01
}
01
}
0Es test-function
01
}#{
25v array/2d/allocate v [width height] v #@[source: [[tree/new :data [-> [array/allocate [* width height]] [array/fill! 0]] :width width :height height]]] v #{
05v tree/new
05v :data
05v array/fill!
05v array/allocate
05v *
10s width
10s height
04i 2
04i 1
02i 0
04i 2
05v :width
10s width
05v :height
10s height
04i 6
01
}
0Es array/2d/allocate
0D
25v array/2d/fill! v [data v] v #@[source: [[array/fill! [tree/ref data :data] v] data]] v #{
05v array/fill!
05v tree/ref
10s data
05v :data
04i 2
10s v
04i 2
0D
10s data
01
}
0Es array/2d/fill!
0D
25v array/2d/ref v [data x y oob-val] v #@[source: [[if [or [>= x [tree/ref data :width]] [>= y [tree/ref data :height]] [< x 0] [< y 0]] oob-val [array/ref [tree/ref data :data] [+ x [* y [tree/ref data :width]]]]]]] v #{
10s x
05v tree/ref
10s data
05v :width
04i 2
21
0C
0Ao 56
0D
10s y
05v tree/ref
10s data
05v :height
04i 2
21
0C
0Ao 32
0D
10s x
02i 0
1E
0C
0Ao 20
0D
10s y
02i 0
1E
0C
0Ao 8
0D
05v #f
0Bo 10
10s oob-val
09o 57
05v array/ref
05v tree/ref
10s data
05v :data
04i 2
05v +
10s x
05v *
10s y
05v tree/ref
10s data
05v :width
04i 2
04i 2
04i 2
04i 2
01
}
0Es array/2d/ref
0D
25v array/2d/set! v [data x y val] v #@[source: [[if [or [>= x [tree/ref data :width]] [>= y [tree/ref data :height]] [< x 0] [< y 0]] [throw [list :out-of-bounds "Trying to set an array out of bounds" data [current-lambda]]] [array/set! [tree/ref data :data] [+ x [* y [tree/ref data :width]]] val]] data]] v #{
10s x
05v tree/ref
10s data
05v :width
04i 2
21
0C
0Ao 56
0D
10s y
05v tree/ref
10s data
05v :height
04i 2
21
0C
0Ao 32
0D
10s x
02i 0
1E
0C
0Ao 20
0D
10s y
02i 0
1E
0C
0Ao 8
0D
05v #f
0Bo 36
05v throw
05v list
05v :out-of-bounds
05v "Trying to set an array out of bounds"
10s data
05v current-lambda
04i 0
04i 4
04i 1
09o 61
05v array/set!
05v tree/ref
10s data
05v :data
04i 2
05v +
10s x
05v *
10s y
05v tree/ref
10s data
05v :width
04i 2
04i 2
04i 2
10s val
04i 3
0D
10s data
01
}
0Es array/2d/set!
0D
25v array/2d/print v [data] v #@[source: [[for [y 0 [tree/ref data :height]] [for [x 0 [tree/ref data :width]] [display [cat [array/2d/ref data x y] " "]]] [newline]] data]] v #{
15
02i 0
0Es y
0D
05v tree/ref
10s data
05v :height
04i 2
0Es ΓεnΣym-24
0D
02i 0
1B
1C
10s y
10s ΓεnΣym-24
1E
0Bo 120
0D
15
02i 0
0Es x
0D
05v tree/ref
10s data
05v :width
04i 2
0Es ΓεnΣym-25
0D
02i 0
1B
1C
10s x
10s ΓεnΣym-25
1E
0Bo 53
0D
05v print
05v cat
05v array/2d/ref
10s data
10s x
10s y
04i 3
05v " "
04i 2
04i 1
0D
02i 1
10s x
03
0Fs x
09o -60
16
0D
05v newline
04i 0
0D
02i 1
10s y
03
0Fs y
09o -127
16
0D
10s data
01
}
0Es array/2d/print
01
}#{
25v array/+= v [a i v] v #@[documentation: "Add V to the value in A at position I and store the result in A returning A" source: ["Add V to the value in A at position I and store the result in A returning A" [array/set! a i [+ v [array/ref a i]]]]] v #{
05v array/set!
10s a
10s i
05v +
10s v
05v array/ref
10s a
10s i
04i 2
04i 2
04i 3
01
}
0Es array/+=
0D
25v array/++ v [a i] v #@[documentation: "Increment position I in A and return A" source: ["Increment position I in A and return A" [array/+= a i 1]]] v #{
05v array/+=
10s a
10s i
02i 1
04i 3
01
}
0Es array/++
0D
25v array/fill! v [a v] v #@[documentation: "Fills array a with value v" source: ["Fills array a with value v" [def len [array/length a]] [for [i 0 len] [array/set! a i v]] [return a]]] v #{
05v array/length
10s a
04i 1
0Es len
0D
15
02i 0
0Es i
0D
10s len
0Es ΓεnΣym-13
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-13
1E
0Bo 37
0D
05v array/set!
10s a
10s i
10s v
04i 3
0D
02i 1
10s i
03
0Fs i
09o -44
16
0D
10s a
01
01
}
0Es array/fill!
0D
25v array/append v [a b] v #@[documentation: "Append array A to array B" source: ["Append array A to array B" [when-not [and [array? a] [array? b]] [throw [list :type-error "array/append expects two arrays as its arguments" #nil [current-lambda]]]] [def ret [array/allocate [+ [array/length a] [array/length b]]]] [for [i 0 [array/length a]] [array/set! ret i [array/ref a i]]] [for [i [array/length a] [array/length ret]] [array/set! ret i [array/ref b [- i [array/length a]]]]] [return ret]]] v #{
05v array?
10s a
04i 1
0C
0Bo 14
0D
05v array?
10s b
04i 1
0Bo 7
24
09o 30
05v throw
05v list
05v :type-error
05v "array/append expects two arrays as its arguments"
24
05v current-lambda
04i 0
04i 4
04i 1
0D
05v array/allocate
05v +
05v array/length
10s a
04i 1
05v array/length
10s b
04i 1
04i 2
04i 1
0Es ret
0D
15
02i 0
0Es i
0D
05v array/length
10s a
04i 1
0Es ΓεnΣym-14
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-14
1E
0Bo 47
0D
05v array/set!
10s ret
10s i
05v array/ref
10s a
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -54
16
0D
15
05v array/length
10s a
04i 1
0Es i
0D
05v array/length
10s ret
04i 1
0Es ΓεnΣym-15
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-15
1E
0Bo 63
0D
05v array/set!
10s ret
10s i
05v array/ref
10s b
05v -
10s i
05v array/length
10s a
04i 1
04i 2
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -70
16
0D
10s ret
01
01
}
0Es array/append
0D
25v array/dup v [a] v #@[documentation: "Duplicate Array A" source: ["Duplicate Array A" [def ret [array/allocate [array/length a]]] [for [i 0 [array/length a]] [array/set! ret i [array/ref a i]]] [return ret]]] v #{
05v array/allocate
05v array/length
10s a
04i 1
04i 1
0Es ret
0D
15
02i 0
0Es i
0D
05v array/length
10s a
04i 1
0Es ΓεnΣym-16
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-16
1E
0Bo 47
0D
05v array/set!
10s ret
10s i
05v array/ref
10s a
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -54
16
0D
10s ret
01
01
}
0Es array/dup
0D
25v array/reduce v [arr fun α] v #@[documentation: "Reduce an array, [reduce] should be preferred" source: ["Reduce an array, [reduce] should be preferred" [def len [array/length arr]] [for [i 0 len] [set! α [fun α [array/ref arr i]]]] [return α]]] v #{
05v array/length
10s arr
04i 1
0Es len
0D
15
02i 0
0Es i
0D
10s len
0Es ΓεnΣym-17
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-17
1E
0Bo 47
0D
10s fun
10s α
05v array/ref
10s arr
10s i
04i 2
04i 2
0Fs α
0D
02i 1
10s i
03
0Fs i
09o -54
16
0D
10s α
01
01
}
0Es array/reduce
0D
25v array/map v [arr fun] v #@[documentation: "Map an array, [map] should be preferred" source: ["Map an array, [map] should be preferred" [def len [array/length arr]] [for [i 0 len] [array/set! arr i [fun [array/ref arr i]]]] [return arr]]] v #{
05v array/length
10s arr
04i 1
0Es len
0D
15
02i 0
0Es i
0D
10s len
0Es ΓεnΣym-18
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-18
1E
0Bo 53
0D
05v array/set!
10s arr
10s i
10s fun
05v array/ref
10s arr
10s i
04i 2
04i 1
04i 3
0D
02i 1
10s i
03
0Fs i
09o -60
16
0D
10s arr
01
01
}
0Es array/map
0D
25v array/filter v [arr pred] v #@[documentation: "Filter an array, [filter] should be preferred" source: ["Filter an array, [filter] should be preferred" [def ri 0] [def len [array/length arr]] [def ret [array/allocate len]] [for [ai 0 len] [when [pred [array/ref arr ai]] [array/set! ret ri [array/ref arr ai]] [++ ri]]] [array/length! ret ri]]] v #{
02i 0
0Es ri
0D
05v array/length
10s arr
04i 1
0Es len
0D
05v array/allocate
10s len
04i 1
0Es ret
0D
15
02i 0
0Es ai
0D
10s len
0Es ΓεnΣym-19
0D
02i 0
1B
1C
10s ai
10s ΓεnΣym-19
1E
0Bo 91
0D
10s pred
05v array/ref
10s arr
10s ai
04i 2
04i 1
0Bo 51
05v array/set!
10s ret
10s ri
05v array/ref
10s arr
10s ai
04i 2
04i 3
0D
05v +
02i 1
10s ri
04i 2
0Fs ri
09o 4
24
0D
02i 1
10s ai
03
0Fs ai
09o -98
16
0D
05v array/length!
10s ret
10s ri
04i 2
01
}
0Es array/filter
0D
25v array/equal? v [a b] v #@[source: [[if [or [not [array? a]] [not [array? b]] [!= [array/length a] [array/length b]]] [return #f] [let [[ret #t]] [for [i 0 [array/length a]] [when-not [equal? [array/ref a i] [array/ref b i]] [set! ret #f] [set! i [array/length a]]]] [return ret]]]]] v #{
05v array?
10s a
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 68
0D
05v array?
10s b
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 39
0D
05v !=
05v array/length
10s a
04i 1
05v array/length
10s b
04i 1
04i 2
0C
0Ao 8
0D
05v #f
0Bo 11
05v #f
01
09o 140
15
05v #t
0Es ret
0D
15
02i 0
0Es i
0D
05v array/length
10s a
04i 1
0Es ΓεnΣym-20
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-20
1E
0Bo 83
0D
05v equal?
05v array/ref
10s a
10s i
04i 2
05v array/ref
10s b
10s i
04i 2
04i 2
0Bo 7
24
09o 26
05v #f
0Fs ret
0D
05v array/length
10s a
04i 1
0Fs i
0D
02i 1
10s i
03
0Fs i
09o -90
16
0D
10s ret
01
16
01
}
0Es array/equal?
0D
25v array/push v [arr val] v #@[documentation: "Append VAL to ARR" source: ["Append VAL to ARR" [-> arr [array/length! [+ 1 [array/length arr]]] [array/set! [- [array/length arr] 1] val]]]] v #{
05v array/set!
05v array/length!
10s arr
05v +
02i 1
05v array/length
10s arr
04i 1
04i 2
04i 2
05v -
05v array/length
10s arr
04i 1
02i 1
04i 2
10s val
04i 3
01
}
0Es array/push
0D
25v array/swap v [arr i j] v #@[documentation: "Swap values at I and J in ARR" source: ["Swap values at I and J in ARR" [def tmp [array/ref arr i]] [-> arr [array/set! i [array/ref arr j]] [array/set! j tmp]]]] v #{
05v array/ref
10s arr
10s i
04i 2
0Es tmp
0D
05v array/set!
05v array/set!
10s arr
10s i
05v array/ref
10s arr
10s j
04i 2
04i 3
10s j
10s tmp
04i 3
01
}
0Es array/swap
0D
25v array/heapify v [arr n at] v #@[documentation: "bubble up the element from index AT to until the max-heap property is satisfied" source: ["bubble up the element from index AT to until the max-heap property is satisfied" [def top at] [def looping #t] [while looping [def l [+ [ash at 1] 1]] [def r [+ [ash at 1] 2]] [when [and [< l n] [> [array/ref arr l] [array/ref arr top]]] [set! top l]] [when [and [< r n] [> [array/ref arr r] [array/ref arr top]]] [set! top r]] [if [== top at] [set! looping #f] [do [array/swap arr at top] [set! at top]]]] [return arr]]] v #{
10s at
0Es top
0D
05v #t
0Es looping
0D
02i 0
1B
1C
10s looping
0Bo 225
0D
05v +
05v ash
10s at
02i 1
04i 2
02i 1
04i 2
0Es l
0D
05v +
05v ash
10s at
02i 1
04i 2
02i 2
04i 2
0Es r
0D
10s l
10s n
1E
0C
0Bo 33
0D
05v array/ref
10s arr
10s l
04i 2
05v array/ref
10s arr
10s top
04i 2
22
0Bo 14
10s l
0Fs top
09o 4
24
0D
10s r
10s n
1E
0C
0Bo 33
0D
05v array/ref
10s arr
10s r
04i 2
05v array/ref
10s arr
10s top
04i 2
22
0Bo 14
10s r
0Fs top
09o 4
24
0D
10s top
10s at
20
0Bo 14
05v #f
0Fs looping
09o 30
05v array/swap
10s arr
10s at
10s top
04i 3
0D
10s top
0Fs at
09o -227
0D
10s arr
01
01
}
0Es array/heapify
0D
25v array/make-heap v [arr] v #@[source: [[def l [array/length arr]] [def l2 [/ l 2]] [while [>= l2 0] [array/heapify arr l l2] [-- l2]] [return arr]]] v #{
05v array/length
10s arr
04i 1
0Es l
0D
05v /
10s l
02i 2
04i 2
0Es l2
0D
02i 0
1B
1C
10s l2
02i 0
21
0Bo 42
0D
05v array/heapify
10s arr
10s l
10s l2
04i 3
0D
05v +
02i -1
10s l2
04i 2
0Fs l2
09o -47
0D
10s arr
01
01
}
0Es array/make-heap
0D
25v array/heap-sort v [arr] v #@[source: [[array/make-heap arr] [def l [array/length arr]] [while [> l 0] [-- l] [array/swap arr 0 l] [array/heapify arr l 0]] [return arr]]] v #{
05v array/make-heap
10s arr
04i 1
0D
05v array/length
10s arr
04i 1
0Es l
0D
02i 0
1B
1C
10s l
02i 0
22
0Bo 57
0D
05v +
02i -1
10s l
04i 2
0Fs l
0D
05v array/swap
10s arr
02i 0
10s l
04i 3
0D
05v array/heapify
10s arr
10s l
02i 0
04i 3
09o -62
0D
10s arr
01
01
}
0Es array/heap-sort
0D
10s array/heap-sort
0Es array/sort
0D
25v array/cut v [arr start end] v #@[documentation: "Return a newly allocated array with the values of ARR from START to END" source: ["Return a newly allocated array with the values of ARR from START to END" [set! start [max 0 start]] [set! end [min [array/length arr] end]] [def ret [array/allocate [max 0 [- end start]]]] [for [i start end] [array/set! ret [- i start] [array/ref arr i]]] [return ret]]] v #{
05v max
02i 0
10s start
04i 2
0Fs start
0D
05v min
05v array/length
10s arr
04i 1
10s end
04i 2
0Fs end
0D
05v array/allocate
05v max
02i 0
05v -
10s end
10s start
04i 2
04i 2
04i 1
0Es ret
0D
15
10s start
0Es i
0D
10s end
0Es ΓεnΣym-21
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-21
1E
0Bo 57
0D
05v array/set!
10s ret
05v -
10s i
10s start
04i 2
05v array/ref
10s arr
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -64
16
0D
10s ret
01
01
}
0Es array/cut
01
}#{
05v :e
0Es avl/empty
0D
25v avl/empty? v [n] v #@[source: [[== :e n]]] v #{
05v :e
10s n
20
01
}
0Es avl/empty?
0D
25v avl/default-cmp v [x y] v #@[source: [[if [< x y] -1 [if [> x y] 1 0]]]] v #{
10s x
10s y
1E
0Bo 8
02i -1
09o 22
10s x
10s y
22
0Bo 8
02i 1
09o 5
02i 0
01
}
0Es avl/default-cmp
0D
25v avl/typecheck v [r k] v #@[source: [[or [avl/empty? [avl/root r]] [== [type-of k] [type-of [avl/key [avl/root r]]]] [throw [list :type-error "AVL trees can only contains keys of a single type" k [current-lambda]]]]]] v #{
05v avl/empty?
05v avl/root
10s r
04i 1
04i 1
0C
0Ao 81
0D
05v type-of
10s k
04i 1
05v type-of
05v avl/key
05v avl/root
10s r
04i 1
04i 1
04i 1
20
0C
0Ao 43
0D
05v throw
05v list
05v :type-error
05v "AVL trees can only contains keys of a single type"
10s k
05v current-lambda
04i 0
04i 4
04i 1
0C
0Ao 8
0D
05v #f
01
}
0Es avl/typecheck
0D
25v avl/tree v [cmp] v #@[source: [[array/new avl/empty [or cmp avl/default-cmp]]]] v #{
05v array/new
10s avl/empty
10s cmp
0C
0Ao 17
0D
10s avl/default-cmp
0C
0Ao 8
0D
05v #f
04i 2
01
}
0Es avl/tree
0D
25v avl/height v [n] v #@[source: [[if [avl/empty? n] 0 [array/ref n 0]]]] v #{
05v avl/empty?
10s n
04i 1
0Bo 8
02i 0
09o 15
05v array/ref
10s n
02i 0
04i 2
01
}
0Es avl/height
0D
25v avl/key v [n] v #@[source: [[array/ref n 1]]] v #{
05v array/ref
10s n
02i 1
04i 2
01
}
0Es avl/key
0D
25v avl/left v [n] v #@[source: [[array/ref n 2]]] v #{
05v array/ref
10s n
02i 2
04i 2
01
}
0Es avl/left
0D
25v avl/right v [n] v #@[source: [[array/ref n 3]]] v #{
05v array/ref
10s n
02i 3
04i 2
01
}
0Es avl/right
0D
25v avl/root v [r] v #@[source: [[array/ref r 0]]] v #{
05v array/ref
10s r
02i 0
04i 2
01
}
0Es avl/root
0D
25v avl/cmp v [r] v #@[source: [[array/ref r 1]]] v #{
05v array/ref
10s r
02i 1
04i 2
01
}
0Es avl/cmp
0D
25v avl/min-node v [n] v #@[source: [[if [avl/empty? n] avl/empty [let [[l [avl/left n]]] [if [avl/empty? l] n [avl/min-mode l]]]]]] v #{
05v avl/empty?
10s n
04i 1
0Bo 10
10s avl/empty
09o 50
15
05v avl/left
10s n
04i 1
0Es l
0D
05v avl/empty?
10s l
04i 1
0Bo 10
10s n
09o 13
10s avl/min-mode
10s l
04i 1
16
01
}
0Es avl/min-node
0D
25v avl/update-left v [n l] v #@[source: [[array/set! [array/dup n] 2 l]]] v #{
05v array/set!
05v array/dup
10s n
04i 1
02i 2
10s l
04i 3
01
}
0Es avl/update-left
0D
25v avl/update-right v [n r] v #@[source: [[array/set! [array/dup n] 3 r]]] v #{
05v array/set!
05v array/dup
10s n
04i 1
02i 3
10s r
04i 3
01
}
0Es avl/update-right
0D
25v avl/update-key v [n k] v #@[source: [[array/set! [array/dup n] 1 k]]] v #{
05v array/set!
05v array/dup
10s n
04i 1
02i 1
10s k
04i 3
01
}
0Es avl/update-key
0D
25v avl/update-root v [t r] v #@[source: [[array/set! [array/dup t] 0 r]]] v #{
05v array/set!
05v array/dup
10s t
04i 1
02i 0
10s r
04i 3
01
}
0Es avl/update-root
0D
25v avl/update-height v [n] v #@[source: [[array/set! [array/dup n] 0 [+ 1 [max [avl/height [avl/left n]] [avl/height [avl/right n]]]]]]] v #{
05v array/set!
05v array/dup
10s n
04i 1
02i 0
05v +
02i 1
05v max
05v avl/height
05v avl/left
10s n
04i 1
04i 1
05v avl/height
05v avl/right
10s n
04i 1
04i 1
04i 2
04i 2
04i 3
01
}
0Es avl/update-height
0D
25v avl/rotate-right v [y] v #@[source: [[let [[x [avl/left y]]] [avl/update-height [avl/update-right x [avl/update-height [avl/update-left y [avl/right x]]]]]]]] v #{
15
05v avl/left
10s y
04i 1
0Es x
0D
05v avl/update-height
05v avl/update-right
10s x
05v avl/update-height
05v avl/update-left
10s y
05v avl/right
10s x
04i 1
04i 2
04i 1
04i 2
04i 1
16
01
}
0Es avl/rotate-right
0D
25v avl/rotate-left v [x] v #@[source: [[let [[y [avl/right x]]] [avl/update-height [avl/update-left y [avl/update-height [avl/update-right x [avl/left y]]]]]]]] v #{
15
05v avl/right
10s x
04i 1
0Es y
0D
05v avl/update-height
05v avl/update-left
10s y
05v avl/update-height
05v avl/update-right
10s x
05v avl/left
10s y
04i 1
04i 2
04i 1
04i 2
04i 1
16
01
}
0Es avl/rotate-left
0D
25v avl/balance v [n] v #@[source: [[if [avl/empty? n] 0 [- [avl/height [avl/left n]] [avl/height [avl/right n]]]]]] v #{
05v avl/empty?
10s n
04i 1
0Bo 8
02i 0
09o 41
05v -
05v avl/height
05v avl/left
10s n
04i 1
04i 1
05v avl/height
05v avl/right
10s n
04i 1
04i 1
04i 2
01
}
0Es avl/balance
0D
25v avl/insert-rebalance v [n cmp v] v #@[source: [[let [[b [avl/balance n]]] [cond [[> b 1] [case [cmp v [avl/key [avl/left n]]] [-1 [avl/rotate-right n]] [1 [avl/rotate-right [avl/update-left n [avl/rotate-left [avl/left n]]]]] [0 n]]] [[< b -1] [case [cmp v [avl/key [avl/right n]]] [1 [avl/rotate-left n]] [-1 [avl/rotate-left [avl/update-right n [avl/rotate-right [avl/right n]]]]] [0 n]]] [#t n]]]]] v #{
15
05v avl/balance
10s n
04i 1
0Es b
0D
10s b
02i 1
22
0Bo 125
15
10s cmp
10s v
05v avl/key
05v avl/left
10s n
04i 1
04i 1
04i 2
0Es ΓεnΣym-31
0D
10s ΓεnΣym-31
02i -1
20
0Bo 16
05v avl/rotate-right
10s n
04i 1
09o 66
10s ΓεnΣym-31
02i 1
20
0Bo 38
05v avl/rotate-right
05v avl/update-left
10s n
05v avl/rotate-left
05v avl/left
10s n
04i 1
04i 1
04i 2
04i 1
09o 21
10s ΓεnΣym-31
02i 0
20
0Bo 10
10s n
09o 4
24
16
09o 150
10s b
02i -1
1E
0Bo 125
15
10s cmp
10s v
05v avl/key
05v avl/right
10s n
04i 1
04i 1
04i 2
0Es ΓεnΣym-32
0D
10s ΓεnΣym-32
02i 1
20
0Bo 16
05v avl/rotate-left
10s n
04i 1
09o 66
10s ΓεnΣym-32
02i -1
20
0Bo 38
05v avl/rotate-left
05v avl/update-right
10s n
05v avl/rotate-right
05v avl/right
10s n
04i 1
04i 1
04i 2
04i 1
09o 21
10s ΓεnΣym-32
02i 0
20
0Bo 10
10s n
09o 4
24
16
09o 18
05v #t
0Bo 10
10s n
09o 4
24
16
01
}
0Es avl/insert-rebalance
0D
25v avl/node-insert v [n cmp v] v #@[source: [[if [avl/empty? n] [array/new 1 v avl/empty avl/empty] [case [cmp v [avl/key n]] [-1 [avl/insert-rebalance [avl/update-height [avl/update-left n [avl/node-insert [avl/left n] cmp v]]] cmp v]] [1 [avl/insert-rebalance [avl/update-height [avl/update-right n [avl/node-insert [avl/right n] cmp v]]] cmp v]] [0 [avl/update-key n v]]]]]] v #{
05v avl/empty?
10s n
04i 1
0Bo 26
05v array/new
02i 1
10s v
10s avl/empty
10s avl/empty
04i 4
09o 192
15
10s cmp
10s v
05v avl/key
10s n
04i 1
04i 2
0Es ΓεnΣym-33
0D
10s ΓεnΣym-33
02i -1
20
0Bo 60
05v avl/insert-rebalance
05v avl/update-height
05v avl/update-left
10s n
05v avl/node-insert
05v avl/left
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
04i 1
10s cmp
10s v
04i 3
09o 98
10s ΓεnΣym-33
02i 1
20
0Bo 60
05v avl/insert-rebalance
05v avl/update-height
05v avl/update-right
10s n
05v avl/node-insert
05v avl/right
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
04i 1
10s cmp
10s v
04i 3
09o 31
10s ΓεnΣym-33
02i 0
20
0Bo 20
05v avl/update-key
10s n
10s v
04i 2
09o 4
24
16
01
}
0Es avl/node-insert
0D
25v avl/insert v [t v] v #@[documentation: "Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" source: ["Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" [avl/typecheck t v] [avl/update-root t [avl/node-insert [avl/root t] [avl/cmp t] v]]]] v #{
05v avl/typecheck
10s t
10s v
04i 2
0D
05v avl/update-root
10s t
05v avl/node-insert
05v avl/root
10s t
04i 1
05v avl/cmp
10s t
04i 1
10s v
04i 3
04i 2
01
}
0Es avl/insert
0D
25v avl/node-get v [n cmp v] v #@[source: [[if [avl/empty? n] #nil [case [cmp v [avl/key n]] [0 [avl/key n]] [-1 [avl/node-get [avl/left n] cmp v]] [1 [avl/node-get [avl/right n] cmp v]]]]]] v #{
05v avl/empty?
10s n
04i 1
0Bo 7
24
09o 128
15
10s cmp
10s v
05v avl/key
10s n
04i 1
04i 2
0Es ΓεnΣym-34
0D
10s ΓεnΣym-34
02i 0
20
0Bo 16
05v avl/key
10s n
04i 1
09o 78
10s ΓεnΣym-34
02i -1
20
0Bo 30
05v avl/node-get
05v avl/left
10s n
04i 1
10s cmp
10s v
04i 3
09o 41
10s ΓεnΣym-34
02i 1
20
0Bo 30
05v avl/node-get
05v avl/right
10s n
04i 1
10s cmp
10s v
04i 3
09o 4
24
16
01
}
0Es avl/node-get
0D
25v avl/get v [t v] v #@[documentation: "Retrieve the key V from tree T, or #nil if V is not in it" source: ["Retrieve the key V from tree T, or #nil if V is not in it" [if [or [avl/empty? [avl/root t]] [!= [type-of v] [type-of [avl/key [avl/root t]]]]] #nil [avl/node-get [avl/root t] [avl/cmp t] v]]]] v #{
05v avl/empty?
05v avl/root
10s t
04i 1
04i 1
0C
0Ao 51
0D
05v !=
05v type-of
10s v
04i 1
05v type-of
05v avl/key
05v avl/root
10s t
04i 1
04i 1
04i 1
04i 2
0C
0Ao 8
0D
05v #f
0Bo 7
24
09o 33
05v avl/node-get
05v avl/root
10s t
04i 1
05v avl/cmp
10s t
04i 1
10s v
04i 3
01
}
0Es avl/get
0D
25v avl/from-list v [l cmp] v #@[documentation: "Create a new avl tree using the keys in L and the comparison function CMP" source: ["Create a new avl tree using the keys in L and the comparison function CMP" [list/reduce l avl/insert [avl/tree cmp]]]] v #{
05v list/reduce
10s l
10s avl/insert
05v avl/tree
10s cmp
04i 1
04i 3
01
}
0Es avl/from-list
0D
25v avl/remove-rebalance v [n] v #@[source: [[if [avl/empty? n] n [let [[b [avl/balance n]] [l [avl/left n]] [r [avl/right n]]] [cond [[> b 1] [if [>= [avl/balance l] 0] [avl/rotate-right n] [avl/rotate-right [avl/update-left n [avl/rotate-left l]]]]] [[< b -1] [if [<= [avl/balance r] 0] [avl/rotate-left n] [avl/rotate-left [avl/update-right n [avl/rotate-right r]]]]] [#t n]]]]]] v #{
05v avl/empty?
10s n
04i 1
0Bo 10
10s n
09o 201
15
05v avl/balance
10s n
04i 1
0Es b
0D
05v avl/left
10s n
04i 1
0Es l
0D
05v avl/right
10s n
04i 1
0Es r
0D
10s b
02i 1
22
0Bo 61
05v avl/balance
10s l
04i 1
02i 0
21
0Bo 16
05v avl/rotate-right
10s n
04i 1
09o 29
05v avl/rotate-right
05v avl/update-left
10s n
05v avl/rotate-left
10s l
04i 1
04i 2
04i 1
09o 86
10s b
02i -1
1E
0Bo 61
05v avl/balance
10s r
04i 1
02i 0
1F
0Bo 16
05v avl/rotate-left
10s n
04i 1
09o 29
05v avl/rotate-left
05v avl/update-right
10s n
05v avl/rotate-right
10s r
04i 1
04i 2
04i 1
09o 18
05v #t
0Bo 10
10s n
09o 4
24
16
01
}
0Es avl/remove-rebalance
0D
25v avl/node-remove v [n cmp v] v #@[source: [[if [avl/empty? n] n [let [[root [case [cmp v [avl/key n]] [-1 [avl/update-left n [avl/node-remove [avl/left n] cmp v]]] [1 [avl/update-right n [avl/node-remove [avl/right n] cmp v]]] [0 [cond [[avl/empty? [avl/left n]] [avl/right n]] [[avl/empty? [avl/right n]] [avl/left n]] [#t [let [[k [avl/key [avl/min-node [avl/right n]]]]] [avl/update-key [avl/update-right [avl/right n] [avl/node-remove [avl/right n] cmp v]] k]]]]]]]] [set! root [avl/update-height root]] [avl/remove-rebalance root]]]]] v #{
05v avl/empty?
10s n
04i 1
0Bo 10
10s n
09o 324
15
15
10s cmp
10s v
05v avl/key
10s n
04i 1
04i 2
0Es ΓεnΣym-35
0D
10s ΓεnΣym-35
02i -1
20
0Bo 40
05v avl/update-left
10s n
05v avl/node-remove
05v avl/left
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
09o 218
10s ΓεnΣym-35
02i 1
20
0Bo 40
05v avl/update-right
10s n
05v avl/node-remove
05v avl/right
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
09o 171
10s ΓεnΣym-35
02i 0
20
0Bo 160
05v avl/empty?
05v avl/left
10s n
04i 1
04i 1
0Bo 16
05v avl/right
10s n
04i 1
09o 125
05v avl/empty?
05v avl/right
10s n
04i 1
04i 1
0Bo 16
05v avl/left
10s n
04i 1
09o 93
05v #t
0Bo 85
15
05v avl/key
05v avl/min-node
05v avl/right
10s n
04i 1
04i 1
04i 1
0Es k
0D
05v avl/update-key
05v avl/update-right
05v avl/right
10s n
04i 1
05v avl/node-remove
05v avl/right
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
10s k
04i 2
16
09o 4
24
09o 4
24
16
0Es root
0D
05v avl/update-height
10s root
04i 1
0Fs root
0D
05v avl/remove-rebalance
10s root
04i 1
16
01
}
0Es avl/node-remove
0D
25v avl/remove v [t v] v #@[documentation: "Remove the key V from tree T if it is contained within it" source: ["Remove the key V from tree T if it is contained within it" [avl/update-root t [avl/node-remove [avl/root t] [avl/cmp t] v]]]] v #{
05v avl/update-root
10s t
05v avl/node-remove
05v avl/root
10s t
04i 1
05v avl/cmp
10s t
04i 1
10s v
04i 3
04i 2
01
}
0Es avl/remove
0D
25v avl/equal-node? v [a b] v #@[source: [[if [avl/empty? a] [avl/empty? b] [and [equal? [avl/key a] [avl/key b]] [avl/equal-node? [avl/left a] [avl/left b]] [avl/equal-node? [avl/right a] [avl/right b]]]]]] v #{
05v avl/empty?
10s a
04i 1
0Bo 16
05v avl/empty?
10s b
04i 1
09o 91
05v equal?
05v avl/key
10s a
04i 1
05v avl/key
10s b
04i 1
04i 2
0C
0Bo 61
0D
05v avl/equal-node?
05v avl/left
10s a
04i 1
05v avl/left
10s b
04i 1
04i 2
0C
0Bo 30
0D
05v avl/equal-node?
05v avl/right
10s a
04i 1
05v avl/right
10s b
04i 1
04i 2
01
}
0Es avl/equal-node?
0D
25v avl/equal? v [a b] v #@[documentation: "Test if two avl trees are equal" source: ["Test if two avl trees are equal" [avl/equal-node? [avl/root a] [avl/root b]]]] v #{
05v avl/equal-node?
05v avl/root
10s a
04i 1
05v avl/root
10s b
04i 1
04i 2
01
}
0Es avl/equal?
0D
25v avl/reduce-node v [node o s] v #@[source: [[if [avl/empty? node] s [o [avl/key node] [avl/reduce-node [avl/right node] o [avl/reduce-node [avl/left node] o s]]]]]] v #{
05v avl/empty?
10s node
04i 1
0Bo 10
10s s
09o 63
10s o
05v avl/key
10s node
04i 1
05v avl/reduce-node
05v avl/right
10s node
04i 1
10s o
05v avl/reduce-node
05v avl/left
10s node
04i 1
10s o
10s s
04i 3
04i 3
04i 2
01
}
0Es avl/reduce-node
0D
25v avl/reduce v [t o s] v #@[documentation: "Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" source: ["Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" [avl/reduce-node [avl/root t] o s]]] v #{
05v avl/reduce-node
05v avl/root
10s t
04i 1
10s o
10s s
04i 3
01
}
0Es avl/reduce
0D
25v avl/reduce-node-bin v [n o s] v #@[source: [[if [avl/empty? n] s [o [o [avl/key n] [avl/reduce-node-bin [avl/left n] o s]] [avl/reduce-node-bin [avl/right n] o s]]]]] v #{
05v avl/empty?
10s n
04i 1
0Bo 10
10s s
09o 73
10s o
10s o
05v avl/key
10s n
04i 1
05v avl/reduce-node-bin
05v avl/left
10s n
04i 1
10s o
10s s
04i 3
04i 2
05v avl/reduce-node-bin
05v avl/right
10s n
04i 1
10s o
10s s
04i 3
04i 2
01
}
0Es avl/reduce-node-bin
0D
25v avl/reduce-bin v [t o s] v #@[documentation: "Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" source: ["Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" [avl/reduce-node-bin [avl/root t] o s]]] v #{
05v avl/reduce-node-bin
05v avl/root
10s t
04i 1
10s o
10s s
04i 3
01
}
0Es avl/reduce-bin
0D
25v avl/map v [t f] v #@[documentation: "Create a new avl tree by mapping each key in T using F, using the same comparison function as T" source: ["Create a new avl tree by mapping each key in T using F, using the same comparison function as T" [avl/reduce t [fn [x acc] [avl/insert acc [f x]]] [avl/tree [avl/cmp t]]]]] v #{
05v avl/reduce
10s t
25v anonymous v [x acc] v #@[source: [[avl/insert acc [f x]]]] v #{
05v avl/insert
10s acc
10s f
10s x
04i 1
04i 2
01
}
05v avl/tree
05v avl/cmp
10s t
04i 1
04i 1
04i 3
01
}
0Es avl/map
0D
25v avl/map-to v [t f cmp] v #@[documentation: "Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" source: ["Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" [avl/reduce t [fn [x acc] [avl/insert acc [f x]]] [avl/tree cmp]]]] v #{
05v avl/reduce
10s t
25v anonymous v [x acc] v #@[source: [[avl/insert acc [f x]]]] v #{
05v avl/insert
10s acc
10s f
10s x
04i 1
04i 2
01
}
05v avl/tree
10s cmp
04i 1
04i 3
01
}
0Es avl/map-to
0D
25v avl/to-list v [t] v #@[source: [[avl/reduce t cons #nil]]] v #{
05v avl/reduce
10s t
10s cons
24
04i 3
01
}
0Es avl/to-list
01
}#{
25v sum v [c] v #@[documentation: "Return the sum of every value in collection C" source: ["Return the sum of every value in collection C" [reduce c + 0]]] v #{
05v reduce
10s c
10s +
02i 0
04i 3
01
}
0Es sum
0D
25v join v [l glue] v #@[documentation: "Join every element of α together into a string with GLUE inbetween" source: ["Join every element of α together into a string with GLUE inbetween" [when-not glue [set! glue ""]] [if-not l "" [reduce l [fn [a b] [if a [cat a glue b] b]] #nil]]]] v #{
10s glue
0Bo 7
24
09o 11
05v ""
0Fs glue
0D
10s l
0Bo 30
05v reduce
10s l
25v anonymous v [a b] v #@[source: [[if a [cat a glue b] b]]] v #{
10s a
0Bo 24
05v cat
10s a
10s glue
10s b
04i 3
09o 7
10s b
01
}
24
04i 3
09o 7
05v ""
01
}
0Es join
0D
25v for-each v [l f] v #@[documentation: "Runs F over every item in collection L" source: ["Runs F over every item in collection L" [reduce l [fn [a b] [f b]] #nil]]] v #{
05v reduce
10s l
25v anonymous v [a b] v #@[source: [[f b]]] v #{
10s f
10s b
04i 1
01
}
24
04i 3
01
}
0Es for-each
0D
25v count v [l p] v #@[documentation: "Count the number of items in L where P is true" source: ["Count the number of items in L where P is true" [if p [reduce l [fn [a b] [+ a [if [p b] 1 0]]] 0] [reduce l [fn [a b] [+ a 1]] 0]]]] v #{
10s p
0Bo 31
05v reduce
10s l
25v anonymous v [a b] v #@[source: [[+ a [if [p b] 1 0]]]] v #{
05v +
10s a
10s p
10s b
04i 1
0Bo 8
02i 1
09o 5
02i 0
04i 2
01
}
02i 0
04i 3
09o 28
05v reduce
10s l
25v anonymous v [a b] v #@[source: [[+ a 1]]] v #{
05v +
10s a
02i 1
04i 2
01
}
02i 0
04i 3
01
}
0Es count
0D
25v min v l v #@[documentation: "Returns the minimum value of its arguments, or collection" source: ["Returns the minimum value of its arguments, or collection" [reduce [if [cdr l] l [car l]] [fn [a b] [if [< a b] a b]]]]] v #{
05v reduce
10s l
12
0Bo 10
10s l
09o 8
10s l
11
25v anonymous v [a b] v #@[source: [[if [< a b] a b]]] v #{
10s a
10s b
1E
0Bo 10
10s a
09o 7
10s b
01
}
04i 2
01
}
0Es min
0D
25v max v l v #@[documentation: "Returns the minimum value of its arguments, or collection" source: ["Returns the minimum value of its arguments, or collection" [reduce [if [cdr l] l [car l]] [fn [a b] [if [> a b] a b]]]]] v #{
05v reduce
10s l
12
0Bo 10
10s l
09o 8
10s l
11
25v anonymous v [a b] v #@[source: [[if [> a b] a b]]] v #{
10s a
10s b
22
0Bo 10
10s a
09o 7
10s b
01
}
04i 2
01
}
0Es max
0D
25v delete v [l e] v #@[documentation: "Returns a filtered list l with all elements equal to e omitted" source: ["Returns a filtered list l with all elements equal to e omitted" [filter l [fn [a] [not [== a e]]]]]] v #{
05v filter
10s l
25v anonymous v [a] v #@[source: [[not [== a e]]]] v #{
10s a
10s e
20
0Bo 10
05v #f
09o 7
05v #t
01
}
04i 2
01
}
0Es delete
0D
25v remove v [l p] v #@[documentation: "Returns a filtered list l with all elements where P equal true removed" source: ["Returns a filtered list l with all elements where P equal true removed" [filter l [fn [a] [not [p a]]]]]] v #{
05v filter
10s l
25v anonymous v [a] v #@[source: [[not [p a]]]] v #{
10s p
10s a
04i 1
0Bo 10
05v #f
09o 7
05v #t
01
}
04i 2
01
}
0Es remove
0D
25v flatten/λ v [a b] v #@[source: [[cond [[collection? b] [append [reduce b flatten/λ #nil] a]] [#t [cons b a]]]]] v #{
05v collection?
10s b
04i 1
0Bo 31
05v append
05v reduce
10s b
10s flatten/λ
24
04i 3
10s a
04i 2
09o 23
05v #t
0Bo 15
10s b
10s a
14
09o 4
24
01
}
0Es flatten/λ
0D
25v flatten v [l] v #@[documentation: "Flatten a collection of collections into a simple list" source: ["Flatten a collection of collections into a simple list" [if-not [collection? l] l [nreverse [reduce l flatten/λ #nil]]]]] v #{
05v collection?
10s l
04i 1
0Bo 27
05v nreverse
05v reduce
10s l
10s flatten/λ
24
04i 3
04i 1
09o 7
10s l
01
}
0Es flatten
01
}#{
25v ref v [l i] v #@[documentation: "Return whatver is at position I in L" source: ["Return whatver is at position I in L" [case [type-of l] [:nil #nil] [:tree [tree/ref l i]] [:string [char-at l i]] [:array [array/ref l i]] [:pair [list/ref l i]] [otherwise [throw [list :type-error "You can only use ref with a collection" l [current-lambda]]]]]]] v #{
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-45
0D
10s ΓεnΣym-45
05v :nil
20
0Bo 7
24
09o 149
10s ΓεnΣym-45
05v :tree
20
0Bo 20
05v tree/ref
10s l
10s i
04i 2
09o 120
10s ΓεnΣym-45
05v :string
20
0Bo 20
05v char-at
10s l
10s i
04i 2
09o 91
10s ΓεnΣym-45
05v :array
20
0Bo 20
05v array/ref
10s l
10s i
04i 2
09o 62
10s ΓεnΣym-45
05v :pair
20
0Bo 20
05v list/ref
10s l
10s i
04i 2
09o 33
05v throw
05v list
05v :type-error
05v "You can only use ref with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es ref
0D
25v filter v [l p] v #@[documentation: "Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" source: ["Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" [case [type-of l] [:nil #nil] [:tree [tree/filter l p]] [:pair [list/filter l p]] [:array [array/filter l p]] [otherwise [throw [list :type-error "You can only use filter with a collection" l [current-lambda]]]]]]] v #{
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-46
0D
10s ΓεnΣym-46
05v :nil
20
0Bo 7
24
09o 120
10s ΓεnΣym-46
05v :tree
20
0Bo 20
05v tree/filter
10s l
10s p
04i 2
09o 91
10s ΓεnΣym-46
05v :pair
20
0Bo 20
05v list/filter
10s l
10s p
04i 2
09o 62
10s ΓεnΣym-46
05v :array
20
0Bo 20
05v array/filter
10s l
10s p
04i 2
09o 33
05v throw
05v list
05v :type-error
05v "You can only use filter with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es filter
0D
25v reduce v [l f α] v #@[documentation: "Combine all elements in collection l using operation F and starting value α" source: ["Combine all elements in collection l using operation F and starting value α" [case [type-of l] [:nil α] [:tree [tree/reduce l f α]] [:pair [list/reduce l f α]] [:array [array/reduce l f α]] [otherwise [f α l]]]]] v #{
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-47
0D
10s ΓεnΣym-47
05v :nil
20
0Bo 10
10s α
09o 116
10s ΓεnΣym-47
05v :tree
20
0Bo 24
05v tree/reduce
10s l
10s f
10s α
04i 3
09o 83
10s ΓεnΣym-47
05v :pair
20
0Bo 24
05v list/reduce
10s l
10s f
10s α
04i 3
09o 50
10s ΓεnΣym-47
05v :array
20
0Bo 24
05v array/reduce
10s l
10s f
10s α
04i 3
09o 17
10s f
10s α
10s l
04i 2
16
01
}
0Es reduce
0D
25v length v [α] v #@[documentation: "Returns the length of collection α" source: ["Returns the length of collection α" [case [type-of α] [:nil 0] [:array [array/length α]] [:pair [list/length α]] [:string [string/length α]] [:tree [tree/size α]] [otherwise [throw [list :type-error "You can only use length with a collection" α [current-lambda]]]]]]] v #{
15
05v type-of
10s α
04i 1
0Es ΓεnΣym-48
0D
10s ΓεnΣym-48
05v :nil
20
0Bo 8
02i 0
09o 133
10s ΓεnΣym-48
05v :array
20
0Bo 16
05v array/length
10s α
04i 1
09o 108
10s ΓεnΣym-48
05v :pair
20
0Bo 16
05v list/length
10s α
04i 1
09o 83
10s ΓεnΣym-48
05v :string
20
0Bo 16
05v string/length
10s α
04i 1
09o 58
10s ΓεnΣym-48
05v :tree
20
0Bo 16
05v tree/size
10s α
04i 1
09o 33
05v throw
05v list
05v :type-error
05v "You can only use length with a collection"
10s α
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es length
0D
25v map v [l f] v #@[documentation: "Runs f over every item in collection l and returns the resulting list" source: ["Runs f over every item in collection l and returns the resulting list" [case [type-of l] [:nil #nil] [:pair [list/map l f]] [:array [array/map l f]] [otherwise [throw [list :type-error "You can only use map with a collection" l [current-lambda]]]]]]] v #{
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-49
0D
10s ΓεnΣym-49
05v :nil
20
0Bo 7
24
09o 91
10s ΓεnΣym-49
05v :pair
20
0Bo 20
05v list/map
10s l
10s f
04i 2
09o 62
10s ΓεnΣym-49
05v :array
20
0Bo 20
05v array/map
10s l
10s f
04i 2
09o 33
05v throw
05v list
05v :type-error
05v "You can only use map with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es map
0D
25v sort v [l] v #@[documentation: "Sorts the collection L" source: ["Sorts the collection L" [case [type-of l] [:nil #nil] [:pair [list/sort l]] [:array [array/sort l]] [otherwise [throw [list :type-error "You can only use sort with a collection" l [current-lambda]]]]]]] v #{
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-50
0D
10s ΓεnΣym-50
05v :nil
20
0Bo 7
24
09o 83
10s ΓεnΣym-50
05v :pair
20
0Bo 16
05v list/sort/merge
10s l
04i 1
09o 58
10s ΓεnΣym-50
05v :array
20
0Bo 16
05v array/heap-sort
10s l
04i 1
09o 33
05v throw
05v list
05v :type-error
05v "You can only use sort with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es sort
0D
25v member v [l m] v #@[documentation: "Returns the first pair/item of collection l whose car is equal to m" source: ["Returns the first pair/item of collection l whose car is equal to m" [case [type-of l] [:pair [list/member l m]] [otherwise [throw [list :type-error "You can only use member with a collection" l [current-lambda]]]]]]] v #{
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-51
0D
10s ΓεnΣym-51
05v :pair
20
0Bo 20
05v list/member
10s l
10s m
04i 2
09o 33
05v throw
05v list
05v :type-error
05v "You can only use member with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es member
0D
25v cut v [l start end] v #@[documentation: "Return a subcollection of L from START to END" source: ["Return a subcollection of L from START to END" [case [type-of l] [:array [array/cut l start end]] [:pair [list/cut l start end]] [:string [string/cut l start end]] [otherwise [throw [list :type-error "You can only use member with a collection" l [current-lambda]]]]]]] v #{
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-52
0D
10s ΓεnΣym-52
05v :array
20
0Bo 24
05v array/cut
10s l
10s start
10s end
04i 3
09o 99
10s ΓεnΣym-52
05v :pair
20
0Bo 24
05v list/cut
10s l
10s start
10s end
04i 3
09o 66
10s ΓεnΣym-52
05v :string
20
0Bo 24
05v string/cut
10s l
10s start
10s end
04i 3
09o 33
05v throw
05v list
05v :type-error
05v "You can only use member with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es cut
0D
25v collection? v [l] v #@[source: [[case [type-of l] [[:pair :array :tree] #t] [otherwise #f]]]] v #{
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-53
0D
10s ΓεnΣym-53
05v :pair
20
0C
0Ao 36
0D
10s ΓεnΣym-53
05v :array
20
0C
0Ao 22
0D
10s ΓεnΣym-53
05v :tree
20
0C
0Ao 8
0D
05v #f
0Bo 10
05v #t
09o 7
05v #f
16
01
}
0Es collection?
01
}#{
25v array->list v [arr] v #@[source: [[def i [- [array/length arr] 1]] [def ret #nil] [while [>= i 0] [set! ret [cons [array/ref arr i] ret]] [-- i]] [return ret]]] v #{
05v -
05v array/length
10s arr
04i 1
02i 1
04i 2
0Es i
0D
24
0Es ret
0D
02i 0
1B
1C
10s i
02i 0
21
0Bo 47
0D
05v array/ref
10s arr
10s i
04i 2
10s ret
14
0Fs ret
0D
05v +
02i -1
10s i
04i 2
0Fs i
09o -52
0D
10s ret
01
01
}
0Es array->list
0D
25v except-last-pair/iter v [list rest] v #@[documentation: "Iterator for except-last-pair" source: ["Iterator for except-last-pair" [if [nil? [cdr list]] [reverse rest] [except-last-pair/iter [cdr list] [cons [car list] rest]]]]] v #{
05v nil?
10s list
12
04i 1
0Bo 16
05v reverse
10s rest
04i 1
09o 24
05v except-last-pair/iter
10s list
12
10s list
11
10s rest
14
04i 2
01
}
0Es except-last-pair/iter
0D
25v except-last-pair v [list] v #@[documentation: "Return a copy of LIST without the last pair" source: ["Return a copy of LIST without the last pair" [except-last-pair/iter list #nil]]] v #{
05v except-last-pair/iter
10s list
24
04i 2
01
}
0Es except-last-pair
0D
25v last-pair v [list] v #@[documentation: "Return the last pair of LIST" source: ["Return the last pair of LIST" [while [cdr list] [cdr! list]] list]] v #{
02i 0
1B
1C
10s list
12
0Bo 16
0D
10s list
12
0Fs list
09o -19
0D
10s list
01
}
0Es last-pair
0D
25v make-list v [number value] v #@[documentation: "Return a list of NUMBER elements containing VALUE in every car" source: ["Return a list of NUMBER elements containing VALUE in every car" [def list #nil] [while [>= [-- number] 0] [set! list [cons value list]]] list]] v #{
24
0Es list
0D
02i 0
1B
1C
05v +
02i -1
10s number
04i 2
0Fs number
02i 0
21
0Bo 20
0D
10s value
10s list
14
0Fs list
09o -37
0D
10s list
01
}
0Es make-list
0D
25v range v [end start step] v #@[documentation: "Return a list containing values from START (inclusive) to END (exclusive) by STEP" source: ["Return a list containing values from START (inclusive) to END (exclusive) by STEP" [when-not end [throw [list :arity-error "[range] needs at least a specific end"]]] [when-not start [set! start 0]] [when-not step [set! step 1]] [def pred [if [pos? step] < >]] [def ret #nil] [while [pred start end] [set! ret [cons start ret]] [set! start [+ start step]]] [nreverse ret]]] v #{
10s end
0Bo 7
24
09o 23
05v throw
05v list
05v :arity-error
05v "[range] needs at least a specific end"
04i 2
04i 1
0D
10s start
0Bo 7
24
09o 9
02i 0
0Fs start
0D
10s step
0Bo 7
24
09o 9
02i 1
0Fs step
0D
10s step
05v 0.0
21
0Bo 10
10s <
09o 7
10s >
0Es pred
0D
24
0Es ret
0D
02i 0
1B
1C
10s pred
10s start
10s end
04i 2
0Bo 39
0D
10s start
10s ret
14
0Fs ret
0D
05v +
10s start
10s step
04i 2
0Fs start
09o -51
0D
05v nreverse
10s ret
04i 1
01
}
0Es range
0D
25v list/reduce v [l o s] v #@[documentation: "Combine all elements in l using operation o and starting value s" source: ["Combine all elements in l using operation o and starting value s" [for-in [e l] [set! s [o s e]]] s]] v #{
15
10s l
0Es ΓεnΣym-60
0D
10s ΓεnΣym-60
0Bo 59
02i 0
1B
1C
10s ΓεnΣym-60
0Bo 45
0D
10s ΓεnΣym-60
11
0Es e
0D
10s o
10s s
10s e
04i 2
0Fs s
0D
10s ΓεnΣym-60
12
0Fs ΓεnΣym-60
09o -47
09o 4
24
16
0D
10s s
01
}
0Es list/reduce
0D
25v list/ref v [l i] v #@[documentation: "Returns the the element of list l at location i" source: ["Returns the the element of list l at location i" [while [and l [> i 0]] [-- i] [cdr! l]] [car l]]] v #{
02i 0
1B
1C
10s l
0C
0Bo 11
0D
10s i
02i 0
22
0Bo 33
0D
05v +
02i -1
10s i
04i 2
0Fs i
0D
10s l
12
0Fs l
09o -47
0D
10s l
11
01
}
0Es list/ref
0D
25v reverse v [l] v #@[documentation: "Return the list l in reverse order" source: ["Return the list l in reverse order" [def ret] [for-in [e l] [set! ret [cons e ret]]] ret]] v #{
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-61
0D
10s ΓεnΣym-61
0Bo 54
02i 0
1B
1C
10s ΓεnΣym-61
0Bo 40
0D
10s ΓεnΣym-61
11
0Es e
0D
10s e
10s ret
14
0Fs ret
0D
10s ΓεnΣym-61
12
0Fs ΓεnΣym-61
09o -42
09o 4
24
16
0D
10s ret
01
}
0Es reverse
0D
25v list/length v [l] v #@[documentation: "Returns the length of list l" source: ["Returns the length of list l" [def ret 0] [for-in [e l] [++ ret]] ret]] v #{
02i 0
0Es ret
0D
15
10s l
0Es ΓεnΣym-62
0D
10s ΓεnΣym-62
0Bo 57
02i 0
1B
1C
10s ΓεnΣym-62
0Bo 43
0D
10s ΓεnΣym-62
11
0Es e
0D
05v +
02i 1
10s ret
04i 2
0Fs ret
0D
10s ΓεnΣym-62
12
0Fs ΓεnΣym-62
09o -45
09o 4
24
16
0D
10s ret
01
}
0Es list/length
0D
25v list/filter v [l p] v #@[documentation: "Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" source: ["Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" [def ret #nil] [for-in [e l] [when [p e] [set! ret [cons e ret]]]] [nreverse ret]]] v #{
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-63
0D
10s ΓεnΣym-63
0Bo 71
02i 0
1B
1C
10s ΓεnΣym-63
0Bo 57
0D
10s ΓεnΣym-63
11
0Es e
0D
10s p
10s e
04i 1
0Bo 19
10s e
10s ret
14
0Fs ret
09o 4
24
0D
10s ΓεnΣym-63
12
0Fs ΓεnΣym-63
09o -59
09o 4
24
16
0D
05v nreverse
10s ret
04i 1
01
}
0Es list/filter
0D
25v list/map v [l f] v #@[documentation: "Runs f over every item in list l and returns the resulting list" source: ["Runs f over every item in list l and returns the resulting list" [def ret #nil] [for-in [e l] [set! ret [cons [f e] ret]]] [nreverse ret]]] v #{
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-64
0D
10s ΓεnΣym-64
0Bo 60
02i 0
1B
1C
10s ΓεnΣym-64
0Bo 46
0D
10s ΓεnΣym-64
11
0Es e
0D
10s f
10s e
04i 1
10s ret
14
0Fs ret
0D
10s ΓεnΣym-64
12
0Fs ΓεnΣym-64
09o -48
09o 4
24
16
0D
05v nreverse
10s ret
04i 1
01
}
0Es list/map
0D
25v append v [a b] v #@[documentation: "Appends two lists A and B together" source: ["Appends two lists A and B together" [def ret b] [set! a [reverse a]] [for-in [t a] [set! ret [cons t ret]]] ret]] v #{
10s b
0Es ret
0D
05v reverse
10s a
04i 1
0Fs a
0D
15
10s a
0Es ΓεnΣym-65
0D
10s ΓεnΣym-65
0Bo 54
02i 0
1B
1C
10s ΓεnΣym-65
0Bo 40
0D
10s ΓεnΣym-65
11
0Es t
0D
10s t
10s ret
14
0Fs ret
0D
10s ΓεnΣym-65
12
0Fs ΓεnΣym-65
09o -42
09o 4
24
16
0D
10s ret
01
}
0Es append
0D
25v sublist v [l start end ret] v #@[documentation: "Returns a new list containing all elements of l from start to end" source: ["Returns a new list containing all elements of l from start to end" [cond [[nil? l] [reverse ret]] [[neg? end] [sublist l start [+ [length l] end]]] [[zero? end] [reverse ret]] [[> start 0] [sublist [cdr l] [+ -1 start] [+ -1 end] #nil]] [[> end 0] [sublist [cdr l] 0 [+ -1 end] [cons [car l] ret]]]]]] v #{
05v nil?
10s l
04i 1
0Bo 16
05v reverse
10s ret
04i 1
09o 173
10s end
05v 0.0
1E
0Bo 40
05v sublist
10s l
10s start
05v +
05v length
10s l
04i 1
10s end
04i 2
04i 3
09o 124
02i 0
10s end
20
0Bo 16
05v reverse
10s ret
04i 1
09o 101
10s start
02i 0
22
0Bo 42
05v sublist
10s l
12
05v +
02i -1
10s start
04i 2
05v +
02i -1
10s end
04i 2
24
04i 4
09o 52
10s end
02i 0
22
0Bo 41
05v sublist
10s l
12
02i 0
05v +
02i -1
10s end
04i 2
10s l
11
10s ret
14
04i 4
09o 4
24
01
}
0Es sublist
0D
25v list-head v [l k] v #@[documentation: "Returns the first k elements of list l" source: ["Returns the first k elements of list l" [sublist l 0 k]]] v #{
05v sublist
10s l
02i 0
10s k
04i 3
01
}
0Es list-head
0D
25v list-tail v [l k] v #@[documentation: "Returns the sublist of l obtained by omitting the first l elements" source: ["Returns the sublist of l obtained by omitting the first l elements" [sublist l k [length l]]]] v #{
05v sublist
10s l
10s k
05v length
10s l
04i 1
04i 3
01
}
0Es list-tail
0D
25v list/member v [l m] v #@[documentation: "Returns the first pair of list l whose car is equal to m" source: ["Returns the first pair of list l whose car is equal to m" [cond [[nil? l] #f] [[== [car l] m] l] [#t [list/member [cdr l] m]]]]] v #{
05v nil?
10s l
04i 1
0Bo 10
05v #f
09o 49
10s l
11
10s m
20
0Bo 10
10s l
09o 29
05v #t
0Bo 21
05v list/member
10s l
12
10s m
04i 2
09o 4
24
01
}
0Es list/member
0D
25v getf v [l key] v #@[documentation: "Return the value in LIST following KEY" source: ["Return the value in LIST following KEY" [cond [[nil? l] #nil] [[== key [car l]] [cadr l]] [#t [getf [cdr l] key]]]]] v #{
05v nil?
10s l
04i 1
0Bo 7
24
09o 51
10s key
10s l
11
20
0Bo 12
10s l
12
11
09o 29
05v #t
0Bo 21
05v getf
10s l
12
10s key
04i 2
09o 4
24
01
}
0Es getf
0D
25v list/sort/bubble v [l] v #@[documentation: "Terribly slow way to sort a list, though it was simple to write" source: ["Terribly slow way to sort a list, though it was simple to write" [if-not l #nil [do [def top [car l]] [def next #nil] [cdr! l] [while l [if [<= [car l] top] [do [set! next [cons top next]] [set! top [car l]]] [set! next [cons [car l] next]]] [cdr! l]] [cons top [list/sort/bubble next]]]]]] v #{
10s l
0Bo 126
10s l
11
0Es top
0D
24
0Es next
0D
10s l
12
0Fs l
0D
02i 0
1B
1C
10s l
0Bo 70
0D
10s l
11
10s top
1F
0Bo 29
10s top
10s next
14
0Fs next
0D
10s l
11
0Fs top
09o 17
10s l
11
10s next
14
0Fs next
0D
10s l
12
0Fs l
09o -72
0D
10s top
05v list/sort/bubble
10s next
04i 1
14
09o 4
24
01
}
0Es list/sort/bubble
0D
25v list/merge-sorted-lists v [l1 l2] v #@[source: [[cond [[nil? l1] l2] [[nil? l2] l1] [#t [if [< [car l1] [car l2]] [cons [car l1] [list/merge-sorted-lists [cdr l1] l2]] [cons [car l2] [list/merge-sorted-lists l1 [cdr l2]]]]]]]] v #{
05v nil?
10s l1
04i 1
0Bo 10
10s l2
09o 93
05v nil?
10s l2
04i 1
0Bo 10
10s l1
09o 73
05v #t
0Bo 65
10s l1
11
10s l2
11
1E
0Bo 27
10s l1
11
05v list/merge-sorted-lists
10s l1
12
10s l2
04i 2
14
09o 24
10s l2
11
05v list/merge-sorted-lists
10s l1
10s l2
12
04i 2
14
09o 4
24
01
}
0Es list/merge-sorted-lists
0D
25v list/split-half-rec v [l acc1 acc2] v #@[source: [[cond [[nil? l] [cons acc1 acc2]] [[nil? [cdr l]] [cons [cons [car l] acc1] acc2]] [#t [list/split-half-rec [cddr l] [cons [car l] acc1] [cons [cadr l] acc2]]]]]] v #{
05v nil?
10s l
04i 1
0Bo 15
10s acc1
10s acc2
14
09o 79
05v nil?
10s l
12
04i 1
0Bo 21
10s l
11
10s acc1
14
10s acc2
14
09o 47
05v #t
0Bo 39
05v list/split-half-rec
10s l
12
12
10s l
11
10s acc1
14
10s l
12
11
10s acc2
14
04i 3
09o 4
24
01
}
0Es list/split-half-rec
0D
25v list/split-half v [l] v #@[source: [[list/split-half-rec l #nil #nil]]] v #{
05v list/split-half-rec
10s l
24
24
04i 3
01
}
0Es list/split-half
0D
25v list/sort/merge v [l] v #@[documentation: "Sorts a list" source: ["Sorts a list" [if [nil? [cdr l]] l [do [def parts [list/split-half l]] [list/merge-sorted-lists [list/sort/merge [car parts]] [list/sort/merge [cdr parts]]]]]]] v #{
05v nil?
10s l
12
04i 1
0Bo 10
10s l
09o 46
05v list/split-half
10s l
04i 1
0Es parts
0D
05v list/merge-sorted-lists
05v list/sort/merge
10s parts
11
04i 1
05v list/sort/merge
10s parts
12
04i 1
04i 2
01
}
0Es list/sort/merge
0D
10s list/sort/merge
0Es list/sort
0D
25v list/equal? v [a b] v #@[documentation: "#t if A and B are equal" source: ["#t if A and B are equal" [if [pair? a] [and [list/equal? [car a] [car b]] [list/equal? [cdr a] [cdr b]]] [equal? a b]]]] v #{
05v pair?
10s a
04i 1
0Bo 43
05v list/equal?
10s a
11
10s b
11
04i 2
0C
0Bo 20
0D
05v list/equal?
10s a
12
10s b
12
04i 2
09o 17
05v equal?
10s a
10s b
04i 2
01
}
0Es list/equal?
0D
25v list/take v [l count] v #@[documentation: "Take the first COUNT elements from list L" source: ["Take the first COUNT elements from list L" [if [<= count 0] #nil [cons [car l] [list/take [cdr l] [- count 1]]]]]] v #{
10s count
02i 0
1F
0Bo 7
24
09o 32
10s l
11
05v list/take
10s l
12
05v -
10s count
02i 1
04i 2
04i 2
14
01
}
0Es list/take
0D
25v list/drop v [l count] v #@[documentation: "Drop the final COUNT elements from list L" source: ["Drop the final COUNT elements from list L" [if [<= count 0] l [list/drop [cdr l] [- count 1]]]]] v #{
10s count
02i 0
1F
0Bo 10
10s l
09o 26
05v list/drop
10s l
12
05v -
10s count
02i 1
04i 2
04i 2
01
}
0Es list/drop
0D
25v list/cut v [l start end] v #@[documentation: "Return a subsequence of L from START to END" source: ["Return a subsequence of L from START to END" [list/take [list/drop l [max 0 start]] [- end [max 0 start]]]]] v #{
05v list/take
05v list/drop
10s l
05v max
02i 0
10s start
04i 2
04i 2
05v -
10s end
05v max
02i 0
10s start
04i 2
04i 2
04i 2
01
}
0Es list/cut
0D
25v list/replace v [l search-for replace-with] v #@[documentation: "Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH\nUses [equal?] so we can search/replace lists/trees and other complex data structures" source: ["Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH" "" "Uses [equal?] so we can search/replace lists/trees and other complex data structures" [cond [[not l] #nil] [[equal? l search-for] replace-with] [[equal? [car l] search-for] [cons replace-with [list/replace [cdr l] search-for replace-with]]] [#t [cons [if [pair? [car l]] [list/replace [car l] search-for replace-with] [car l]] [list/replace [cdr l] search-for replace-with]]]]]] v #{
10s l
0Bo 10
05v #f
09o 7
05v #t
0Bo 7
24
09o 144
05v equal?
10s l
10s search-for
04i 2
0Bo 10
10s replace-with
09o 120
05v equal?
10s l
11
10s search-for
04i 2
0Bo 30
10s replace-with
05v list/replace
10s l
12
10s search-for
10s replace-with
04i 3
14
09o 75
05v #t
0Bo 67
05v pair?
10s l
11
04i 1
0Bo 25
05v list/replace
10s l
11
10s search-for
10s replace-with
04i 3
09o 8
10s l
11
05v list/replace
10s l
12
10s search-for
10s replace-with
04i 3
14
09o 4
24
01
}
0Es list/replace
01
}#{
25v tree/zip v [keys values] v #@[documentation: "Return a tree where KEYS point to VALUES" source: ["Return a tree where KEYS point to VALUES" [def ret [tree/new #nil]] [for-in [key keys] [tree/set! ret key [car values]] [cdr! values]] ret]] v #{
05v tree/new
24
04i 1
0Es ret
0D
15
10s keys
0Es ΓεnΣym-68
0D
10s ΓεnΣym-68
0Bo 70
02i 0
1B
1C
10s ΓεnΣym-68
0Bo 56
0D
10s ΓεnΣym-68
11
0Es key
0D
05v tree/set!
10s ret
10s key
10s values
11
04i 3
0D
10s values
12
0Fs values
0D
10s ΓεnΣym-68
12
0Fs ΓεnΣym-68
09o -58
09o 4
24
16
0D
10s ret
01
}
0Es tree/zip
0D
25v tree/+= v [t k v] v #@[documentation: "Increment value at K in T by V" source: ["Increment value at K in T by V" [tree/set! t k [+ v [int [or [tree/ref t k] 0]]]]]] v #{
05v tree/set!
10s t
10s k
05v +
10s v
05v int
05v tree/ref
10s t
10s k
04i 2
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
04i 1
04i 2
04i 3
01
}
0Es tree/+=
0D
26v tree/-= v [t k v] v #@[documentation: "Decrement value at K in T by V" source: ["Decrement value at K in T by V" [quasiquote [tree/+= [unquote t] [unquote k] [- [unquote v]]]]]] v #{
23s tree/+=
10s t
10s k
23s -
10s v
24
14
14
24
14
14
14
14
01
}
0Es tree/-=
0D
26v tree/++ v [t k] v #@[documentation: "Increment value at K in T by 1" source: ["Increment value at K in T by 1" [quasiquote [tree/+= [unquote t] [unquote k] 1]]]] v #{
23s tree/+=
10s t
10s k
02i 1
24
14
14
14
14
01
}
0Es tree/++
0D
26v tree/-- v [t k] v #@[documentation: "Increment value at K in T by 1" source: ["Increment value at K in T by 1" [quasiquote [tree/-= [unquote t] [unquote k] 1]]]] v #{
23s tree/-=
10s t
10s k
02i 1
24
14
14
14
14
01
}
0Es tree/--
0D
25v tree/equal? v [a b] v #@[documentation: "Compares two trees for equality" source: ["Compares two trees for equality" [if [and [tree? a] [tree? b]] [and [== [tree/key* a] [tree/key* b]] [equal? [tree/value* a] [tree/value* b]] [tree/equal? [tree/left* a] [tree/left* b]] [tree/equal? [tree/right* a] [tree/right* b]]] [equal? a b]]]] v #{
05v tree?
10s a
04i 1
0C
0Bo 14
0D
05v tree?
10s b
04i 1
0Bo 120
05v tree/key*
10s a
04i 1
05v tree/key*
10s b
04i 1
20
0C
0Bo 92
0D
05v equal?
05v tree/value*
10s a
04i 1
05v tree/value*
10s b
04i 1
04i 2
0C
0Bo 61
0D
05v tree/equal?
05v tree/left*
10s a
04i 1
05v tree/left*
10s b
04i 1
04i 2
0C
0Bo 30
0D
05v tree/equal?
05v tree/right*
10s a
04i 1
05v tree/right*
10s b
04i 1
04i 2
09o 17
05v equal?
10s a
10s b
04i 2
01
}
0Es tree/equal?
0D
25v tree/reduce v [l o s] v #@[documentation: "Combine all elements in l using operation o and starting value s" source: ["Combine all elements in l using operation o and starting value s" [list/reduce [tree/values l] o s]]] v #{
05v list/reduce
05v tree/values
10s l
04i 1
10s o
10s s
04i 3
01
}
0Es tree/reduce
0D
25v tree/filter v [l f] v #@[documentation: "Return a new tree with all elements from L where F retunrs true" source: ["Return a new tree with all elements from L where F retunrs true" [def ret [tree/new #nil]] [for-in [e [tree/keys l]] [def t [tree/ref l e]] [when [f t] [tree/set! ret e t]]] ret]] v #{
05v tree/new
24
04i 1
0Es ret
0D
15
05v tree/keys
10s l
04i 1
0Es ΓεnΣym-69
0D
10s ΓεnΣym-69
0Bo 95
02i 0
1B
1C
10s ΓεnΣym-69
0Bo 81
0D
10s ΓεnΣym-69
11
0Es e
0D
05v tree/ref
10s l
10s e
04i 2
0Es t
0D
10s f
10s t
04i 1
0Bo 24
05v tree/set!
10s ret
10s e
10s t
04i 3
09o 4
24
0D
10s ΓεnΣym-69
12
0Fs ΓεnΣym-69
09o -83
09o 4
24
16
0D
10s ret
01
}
0Es tree/filter
01
}#{
25v $nop v [] v #@[documentation: "[] -> []\nDo nothing" source: ["[] -> []" "Do nothing" :inline '[#$0]] inline: #t] v #{
05v [#$0]
01
}
0Es $nop
0D
25v $ret v [] v #@[documentation: "[a] -> []\nReturn top of value stack" source: ["[a] -> []" "Return top of value stack" :inline '[#$1]] inline: #t] v #{
05v [#$1]
01
}
0Es $ret
0D
25v $add/int v [] v #@[documentation: "[a b] -> [result]\nAdds the two topmost values and pushes the result" source: ["[a b] -> [result]" "Adds the two topmost values and pushes the result" :inline '[#$3]] inline: #t] v #{
05v [#$3]
01
}
0Es $add/int
0D
25v $dup v [] v #@[documentation: "[a] -> [a a]\nDuplicates the value that is on the top of the stack" source: ["[a] -> [a a]" "Duplicates the value that is on the top of the stack" :inline '[#$C]] inline: #t] v #{
05v [#$C]
01
}
0Es $dup
0D
25v $drop v [] v #@[documentation: "[a] -> []\nDrop whatever is on top of the stack" source: ["[a] -> []" "Drop whatever is on top of the stack" :inline '[#$D]] inline: #t] v #{
05v [#$D]
01
}
0Es $drop
0D
25v $closure/push v [] v #@[documentation: "[] -> [closure]\nPush the current closure as a λ on the stack" source: ["[] -> [closure]" "Push the current closure as a λ on the stack" :inline '[#$13]] inline: #t] v #{
05v [#$13]
01
}
0Es $closure/push
0D
25v $let v [] v #@[documentation: "[] -> []\nCreate a new let closure and switch to it" source: ["[] -> []" "Create a new let closure and switch to it" :inline '[#$15]] inline: #t] v #{
05v [#$15]
01
}
0Es $let
0D
25v $closure/pop v [] v #@[documentation: "[] -> []\nLeave the current closure and return to the parent one" source: ["[] -> []" "Leave the current closure and return to the parent one" :inline '[#$16]] inline: #t] v #{
05v [#$16]
01
}
0Es $closure/pop
0D
25v $roots/save v [] v #@[documentation: "[] -> []\nStore the current root stack pointer used for guarding allocations into the current closure" source: ["[] -> []" "Store the current root stack pointer used for guarding allocations into the current closure" :inline '[#$1B]] inline: #t] v #{
05v [#$1B]
01
}
0Es $roots/save
0D
25v $roots/restore v [] v #@[documentation: "[] -> []\nRestore the current root stack pointer to what is stored within the current closure" source: ["[] -> []" "Restore the current root stack pointer to what is stored within the current closure" :inline '[#$1C]] inline: #t] v #{
05v [#$1C]
01
}
0Es $roots/restore
0D
25v $< v [] v #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$1E]] inline: #t] v #{
05v [#$1E]
01
}
0Es $<
0D
25v $<= v [] v #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$1F]] inline: #t] v #{
05v [#$1F]
01
}
0Es $<=
0D
25v $== v [] v #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$20]] inline: #t] v #{
05v [#$20]
01
}
0Es $==
0D
25v $>= v [] v #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$21]] inline: #t] v #{
05v [#$21]
01
}
0Es $>=
0D
25v $> v [] v #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$22]] inline: #t] v #{
05v [#$22]
01
}
0Es $>
0D
25v $push/nil v [] v #@[documentation: "[] -> [nil]\nPush a #nil on the stack" source: ["[] -> [nil]" "Push a #nil on the stack" :inline '[#$24]] inline: #t] v #{
05v [#$24]
01
}
0Es $push/nil
0D
25v $car v [] v #@[documentation: "[l] -> [car]\nReplace L with its car" source: ["[l] -> [car]" "Replace L with its car" :inline '[#$11]] inline: #t] v #{
05v [#$11]
01
}
0Es $car
0D
25v $cdr v [] v #@[documentation: "[l] -> [cdr]\nReplace L with its cdr" source: ["[l] -> [cdr]" "Replace L with its cdr" :inline '[#$12]] inline: #t] v #{
05v [#$12]
01
}
0Es $cdr
0D
25v $cons v [] v #@[documentation: "[car cdr] -> [pair]\nCons CAR and CDR together and put it on the stack" source: ["[car cdr] -> [pair]" "Cons CAR and CDR together and put it on the stack" :inline '[#$14]] inline: #t] v #{
05v [#$14]
01
}
0Es $cons
01
}#{
25v val->bytecode-op v [v] v #@[source: [[def i [val->index v]] [list [int->bytecode-op [logand [>> i 16] 255]] [int->bytecode-op [logand [>> i 8] 255]] [int->bytecode-op [logand i 255]]]]] v #{
05v val->index
10s v
04i 1
0Es i
0D
05v list
05v int->bytecode-op
05v logand
05v >>
10s i
02i 16
04i 2
05v 255
04i 2
04i 1
05v int->bytecode-op
05v logand
05v >>
10s i
02i 8
04i 2
05v 255
04i 2
04i 1
05v int->bytecode-op
05v logand
10s i
05v 255
04i 2
04i 1
04i 3
01
}
0Es val->bytecode-op
0D
25v sym->bytecode-op v [v] v #@[source: [[def i [sym->index v]] [list [int->bytecode-op [logand [>> i 16] 255]] [int->bytecode-op [logand [>> i 8] 255]] [int->bytecode-op [logand i 255]]]]] v #{
05v sym->index
10s v
04i 1
0Es i
0D
05v list
05v int->bytecode-op
05v logand
05v >>
10s i
02i 16
04i 2
05v 255
04i 2
04i 1
05v int->bytecode-op
05v logand
05v >>
10s i
02i 8
04i 2
05v 255
04i 2
04i 1
05v int->bytecode-op
05v logand
10s i
05v 255
04i 2
04i 1
04i 3
01
}
0Es sym->bytecode-op
0D
25v int-fit-in-byte? v [a] v #@[source: [[and [<= a 127] [>= a -128]]]] v #{
10s a
02i 127
1F
0C
0Bo 11
0D
10s a
02i -128
21
01
}
0Es int-fit-in-byte?
0D
25v $push/int v [a] v #@[documentation: "[] -> [a]\nPush A on the stack as an :int" source: ["[] -> [a]" "Push A on the stack as an :int" [if [int-fit-in-byte? a] [$push/int/byte a] [$push/lval a]]]] v #{
05v int-fit-in-byte?
10s a
04i 1
0Bo 16
05v $push/int/byte
10s a
04i 1
09o 13
05v $push/lval
10s a
04i 1
01
}
0Es $push/int
0D
25v $push/int/byte v [a] v #@[documentation: "[] -> [a]\nPush A on the stack as an :int that fits within a byte" source: ["[] -> [a]" "Push A on the stack as an :int that fits within a byte" [when-not [int-fit-in-byte? a] [throw [list :invalid-bc-op "$push/int/byte can only push a signed 8-bit value" a [current-lambda]]]] [list #$2 [int->bytecode-op a]]]] v #{
05v int-fit-in-byte?
10s a
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :invalid-bc-op
05v "$push/int/byte can only push a signed 8-bit value"
10s a
05v current-lambda
04i 0
04i 4
04i 1
0D
05v list
05v #$2
05v int->bytecode-op
10s a
04i 1
04i 2
01
}
0Es $push/int/byte
0D
25v $push/lval v [v] v #@[documentation: "[] -> [v]\nPushes v onto the stack" source: ["[] -> [v]" "Pushes v onto the stack" [when [nil? v] [throw [list :invalid-bc-op "Can't push #nil as a normal lVal" v [current-lambda]]]] [list #$5 [val->bytecode-op v]]]] v #{
05v nil?
10s v
04i 1
0Bo 36
05v throw
05v list
05v :invalid-bc-op
05v "Can't push #nil as a normal lVal"
10s v
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v list
05v #$5
05v val->bytecode-op
10s v
04i 1
04i 2
01
}
0Es $push/lval
0D
25v $push/symbol v [sym] v #@[documentation: "[] -> [sym]\nPushes v onto the stack" source: ["[] -> [sym]" "Pushes v onto the stack" [list #$23 [sym->bytecode-op sym]]]] v #{
05v list
05v #$23
05v sym->bytecode-op
10s sym
04i 1
04i 2
01
}
0Es $push/symbol
0D
25v $def v [sym] v #@[documentation: "[val] -> [val]\nDefine a new binding for SYM and associate VAL to it" source: ["[val] -> [val]" "Define a new binding for SYM and associate VAL to it" [list #$E [sym->bytecode-op sym]]]] v #{
05v list
05v #$E
05v sym->bytecode-op
10s sym
04i 1
04i 2
01
}
0Es $def
0D
25v $set v [sym] v #@[documentation: "[val] -> [val]\nUpdate the binding for SYM and associate VAL to it" source: ["[val] -> [val]" "Update the binding for SYM and associate VAL to it" [list #$F [sym->bytecode-op sym]]]] v #{
05v list
05v #$F
05v sym->bytecode-op
10s sym
04i 1
04i 2
01
}
0Es $set
0D
25v $get v [sym] v #@[documentation: "[] -> [val]\nPush whatever value is associated to SYM on the stack" source: ["[] -> [val]" "Push whatever value is associated to SYM on the stack" [list #$10 [sym->bytecode-op sym]]]] v #{
05v list
05v #$10
05v sym->bytecode-op
10s sym
04i 1
04i 2
01
}
0Es $get
0D
25v $apply/optimize? v [fun] v #@[source: [[case fun [[car cdr add/int cons < <= == >= >] #t]]]] v #{
15
10s fun
0Es ΓεnΣym-77
0D
10s ΓεnΣym-77
10s car
20
0C
0Ao 120
0D
10s ΓεnΣym-77
10s cdr
20
0C
0Ao 106
0D
10s ΓεnΣym-77
10s add/int
20
0C
0Ao 92
0D
10s ΓεnΣym-77
10s cons
20
0C
0Ao 78
0D
10s ΓεnΣym-77
10s <
20
0C
0Ao 64
0D
10s ΓεnΣym-77
10s <=
20
0C
0Ao 50
0D
10s ΓεnΣym-77
10s ==
20
0C
0Ao 36
0D
10s ΓεnΣym-77
10s >=
20
0C
0Ao 22
0D
10s ΓεnΣym-77
10s >
20
0C
0Ao 8
0D
05v #f
0Bo 10
05v #t
09o 4
24
16
01
}
0Es $apply/optimize?
0D
25v $apply v [arg-count fun] v #@[documentation: "arguments -> [result]\nRead arg-count arguments from the stack, apply the to fun and push the result on the stack" source: ["arguments -> [result]" "Read arg-count arguments from the stack, apply the to fun and push the result on the stack" [case arg-count [1 [case fun [car [$car]] [cdr [$cdr]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]] [2 [case fun [add/int [$add/int]] [cons [$cons]] [< [$<]] [<= [$<=]] [== [$==]] [>= [$>=]] [> [$>]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]]] v #{
15
10s arg-count
0Es ΓεnΣym-78
0D
10s ΓεnΣym-78
02i 1
20
0Bo 85
15
10s fun
0Es ΓεnΣym-79
0D
10s ΓεnΣym-79
10s car
20
0Bo 10
05v [#$11]
09o 52
10s ΓεnΣym-79
10s cdr
20
0Bo 10
05v [#$12]
09o 33
05v throw
05v list
05v :arity-error
05v "Wrong number of arguments for that function"
10s fun
05v current-lambda
04i 0
04i 4
04i 1
16
09o 220
10s ΓεnΣym-78
02i 2
20
0Bo 180
15
10s fun
0Es ΓεnΣym-80
0D
10s ΓεnΣym-80
10s add/int
20
0Bo 10
05v [#$3]
09o 147
10s ΓεnΣym-80
10s cons
20
0Bo 10
05v [#$14]
09o 128
10s ΓεnΣym-80
10s <
20
0Bo 10
05v [#$1E]
09o 109
10s ΓεnΣym-80
10s <=
20
0Bo 10
05v [#$1F]
09o 90
10s ΓεnΣym-80
10s ==
20
0Bo 10
05v [#$20]
09o 71
10s ΓεnΣym-80
10s >=
20
0Bo 10
05v [#$21]
09o 52
10s ΓεnΣym-80
10s >
20
0Bo 10
05v [#$22]
09o 33
05v throw
05v list
05v :arity-error
05v "Wrong number of arguments for that function"
10s fun
05v current-lambda
04i 0
04i 4
04i 1
16
09o 33
05v throw
05v list
05v :arity-error
05v "Wrong number of arguments for that function"
10s fun
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es $apply
0D
25v $apply/dynamic v [arg-count fun] v #@[source: [[list #$4 [int->bytecode-op arg-count]]]] v #{
05v list
05v #$4
05v int->bytecode-op
10s arg-count
04i 1
04i 2
01
}
0Es $apply/dynamic
0D
25v $try v [target] v #@[documentation: "[] -> []\nTry something, jumping to target if an exception occurs" source: ["[] -> []" "Try something, jumping to target if an exception occurs" [list #$19 [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] v #{
05v list
05v #$19
05v list
05v :relocate
10s target
02i 8
02i 0
05v int->bytecode-op
02i 0
04i 1
04i 5
05v list
05v :relocate
10s target
02i 0
02i 1
05v int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
}
0Es $try
0D
25v $jmp v [target] v #@[source: [[list #$9 [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] v #{
05v list
05v #$9
05v list
05v :relocate
10s target
02i 8
02i 0
05v int->bytecode-op
02i 0
04i 1
04i 5
05v list
05v :relocate
10s target
02i 0
02i 1
05v int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
}
0Es $jmp
0D
25v $jt v [target] v #@[source: [[list #$A [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] v #{
05v list
05v #$A
05v list
05v :relocate
10s target
02i 8
02i 0
05v int->bytecode-op
02i 0
04i 1
04i 5
05v list
05v :relocate
10s target
02i 0
02i 1
05v int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
}
0Es $jt
0D
25v $jf v [target] v #@[source: [[list #$B [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] v #{
05v list
05v #$B
05v list
05v :relocate
10s target
02i 8
02i 0
05v int->bytecode-op
02i 0
04i 1
04i 5
05v list
05v :relocate
10s target
02i 0
02i 1
05v int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
}
0Es $jf
0D
25v $fn v [name args docs body] v #@[source: [[list #$25 [val->bytecode-op name] [val->bytecode-op args] [val->bytecode-op docs] [val->bytecode-op body]]]] v #{
05v list
05v #$25
05v val->bytecode-op
10s name
04i 1
05v val->bytecode-op
10s args
04i 1
05v val->bytecode-op
10s docs
04i 1
05v val->bytecode-op
10s body
04i 1
04i 5
01
}
0Es $fn
0D
25v $macro* v [name args docs body] v #@[source: [[list #$26 [val->bytecode-op name] [val->bytecode-op args] [val->bytecode-op docs] [val->bytecode-op body]]]] v #{
05v list
05v #$26
05v val->bytecode-op
10s name
04i 1
05v val->bytecode-op
10s args
04i 1
05v val->bytecode-op
10s docs
04i 1
05v val->bytecode-op
10s body
04i 1
04i 5
01
}
0Es $macro*
0D
25v assemble/build-sym-map v [code sym-map pos] v #@[source: [[while code [case [type-of [car code]] [:bytecode-op [tree/set! sym-map :last-op [++ pos]]] [[:symbol :keyword] [and [== [car code] :label] [tree/set! sym-map [cadr code] pos]]] [:pair [set! pos [assemble/build-sym-map [car code] sym-map pos]]]] [cdr! code]] [when [zero? 123] 123] [return pos]]] v #{
02i 0
1B
1C
10s code
0Bo 192
0D
15
05v type-of
10s code
11
04i 1
0Es ΓεnΣym-81
0D
10s ΓεnΣym-81
05v :bytecode-op
20
0Bo 36
05v tree/set!
10s sym-map
05v :last-op
05v +
02i 1
10s pos
04i 2
0Fs pos
04i 3
09o 115
10s ΓεnΣym-81
05v :symbol
20
0C
0Ao 22
0D
10s ΓεnΣym-81
05v :keyword
20
0C
0Ao 8
0D
05v #f
0Bo 41
10s code
11
05v :label
20
0C
0Bo 24
0D
05v tree/set!
10s sym-map
10s code
12
11
10s pos
04i 3
09o 42
10s ΓεnΣym-81
05v :pair
20
0Bo 29
05v assemble/build-sym-map
10s code
11
10s sym-map
10s pos
04i 3
0Fs pos
09o 4
24
16
0D
10s code
12
0Fs code
09o -194
0D
02i 0
02i 123
20
0Bo 8
02i 123
09o 4
24
0D
10s pos
01
01
}
0Es assemble/build-sym-map
0D
25v assemble/relocate-op v [code sym-map pos out] v #@[source: [[def target [tree/ref sym-map [cadr code]]] [def off [- [+ target [cadddr code]] pos]] [array/set! out [++ pos] [int->bytecode-op [logand [>> off [caddr code]] 255]]] [return pos]]] v #{
05v tree/ref
10s sym-map
10s code
12
11
04i 2
0Es target
0D
05v -
05v +
10s target
05v cadddr
10s code
04i 1
04i 2
10s pos
04i 2
0Es off
0D
05v array/set!
10s out
05v +
02i 1
10s pos
04i 2
0Fs pos
05v int->bytecode-op
05v logand
05v >>
10s off
05v caddr
10s code
04i 1
04i 2
05v 255
04i 2
04i 1
04i 3
0D
10s pos
01
01
}
0Es assemble/relocate-op
0D
25v assemble/emit-relocated-ops v [code sym-map pos out] v #@[source: [[if [== [car code] :relocate] [set! pos [assemble/relocate-op code sym-map pos out]] [for-in [op code] [case [type-of op] [:bytecode-op [array/set! out [++ pos] op]] [:pair [set! pos [assemble/emit-relocated-ops op sym-map pos out]]]]]] [return pos]]] v #{
10s code
11
05v :relocate
20
0Bo 32
05v assemble/relocate-op
10s code
10s sym-map
10s pos
10s out
04i 4
0Fs pos
09o 164
15
10s code
0Es ΓεnΣym-82
0D
10s ΓεnΣym-82
0Bo 145
02i 0
1B
1C
10s ΓεnΣym-82
0Bo 131
0D
10s ΓεnΣym-82
11
0Es op
0D
15
05v type-of
10s op
04i 1
0Es ΓεnΣym-83
0D
10s ΓεnΣym-83
05v :bytecode-op
20
0Bo 36
05v array/set!
10s out
05v +
02i 1
10s pos
04i 2
0Fs pos
10s op
04i 3
09o 45
10s ΓεnΣym-83
05v :pair
20
0Bo 32
05v assemble/emit-relocated-ops
10s op
10s sym-map
10s pos
10s out
04i 4
0Fs pos
09o 4
24
16
0D
10s ΓεnΣym-82
12
0Fs ΓεnΣym-82
09o -133
09o 4
24
16
0D
10s pos
01
01
}
0Es assemble/emit-relocated-ops
0D
05v #f
0Es assemble/verbose
0D
25v assemble* v [code] v #@[documentation: "Assemble all arguments into a single :bytecode-array" source: ["Assemble all arguments into a single :bytecode-array" [def sym-map [tree/new #nil]] [and assemble/verbose [println [cat [ansi-blue "Input:\n" [str/write code]]]]] [assemble/build-sym-map code sym-map 0] [and assemble/verbose [println [cat [ansi-yellow "Symbol Map:\n" [str/write sym-map]]]]] [def out [array/allocate [tree/ref sym-map :last-op]]] [assemble/emit-relocated-ops code sym-map -1 out] [and assemble/verbose [println [cat [ansi-green "Output:\n" [str/write out]]]]] [arr->bytecode-arr out]]] v #{
05v tree/new
24
04i 1
0Es sym-map
0D
10s assemble/verbose
0C
0Bo 36
0D
05v println
05v cat
05v ansi-blue
05v "Input:\n"
05v str/write
10s code
04i 1
04i 2
04i 1
04i 1
0D
05v assemble/build-sym-map
10s code
10s sym-map
02i 0
04i 3
0D
10s assemble/verbose
0C
0Bo 36
0D
05v println
05v cat
05v ansi-yellow
05v "Symbol Map:\n"
05v str/write
10s sym-map
04i 1
04i 2
04i 1
04i 1
0D
05v array/allocate
05v tree/ref
10s sym-map
05v :last-op
04i 2
04i 1
0Es out
0D
05v assemble/emit-relocated-ops
10s code
10s sym-map
02i -1
10s out
04i 4
0D
10s assemble/verbose
0C
0Bo 36
0D
05v println
05v cat
05v ansi-green
05v "Output:\n"
05v str/write
10s out
04i 1
04i 2
04i 1
04i 1
0D
05v arr->bytecode-arr
10s out
04i 1
01
}
0Es assemble*
0D
25v assemble v l v #@[documentation: "Assemble all arguments into a single :bytecode-array" source: ["Assemble all arguments into a single :bytecode-array" [assemble* l]]] v #{
05v assemble*
10s l
04i 1
01
}
0Es assemble
0D
26v asmrun v ops v #@[documentation: "Assemble and evaluate all bytecode arguments" source: ["Assemble and evaluate all bytecode arguments" [quasiquote [bytecode-eval [assemble [unquote-splicing ops]]]]]] v #{
23s bytecode-eval
23s assemble
05v append
10s ops
24
04i 2
14
24
14
14
01
}
0Es asmrun
0D
26v asmdebug v ops v #@[documentation: "Assemble and evaluate all bytecode arguments" source: ["Assemble and evaluate all bytecode arguments" [quasiquote [bytecode-eval [assemble [unquote-splicing ops]] [environment*] #t]]]] v #{
23s bytecode-eval
23s assemble
05v append
10s ops
24
04i 2
14
23s environment*
24
14
05v #t
24
14
14
14
14
01
}
0Es asmdebug
01
}#{
02i 0
0Es bytecompile/gen-label/counter
0D
25v bytecompile/gen-label v [prefix] v #@[source: [[++ bytecompile/gen-label/counter] [str->sym [cat prefix "label-" bytecompile/gen-label/counter]]]] v #{
05v +
02i 1
10s bytecompile/gen-label/counter
04i 2
0Fs bytecompile/gen-label/counter
0D
05v str->sym
05v cat
10s prefix
05v "label-"
10s bytecompile/gen-label/counter
04i 3
04i 1
01
}
0Es bytecompile/gen-label
0D
25v bytecompile/literal v [source] v #@[source: [[case [type-of source] [[:symbol :keyword] [if [keyword? source] [$push/lval source] [$get source]]] [:int [$push/int source]] [:nil [$push/nil]] [otherwise [$push/lval source]]]]] v #{
15
05v type-of
10s source
04i 1
0Es ΓεnΣym-89
0D
10s ΓεnΣym-89
05v :symbol
20
0C
0Ao 22
0D
10s ΓεnΣym-89
05v :keyword
20
0C
0Ao 8
0D
05v #f
0Bo 42
05v keyword?
10s source
04i 1
0Bo 16
05v $push/lval
10s source
04i 1
09o 13
05v $get
10s source
04i 1
09o 57
10s ΓεnΣym-89
05v :int
20
0Bo 16
05v $push/int
10s source
04i 1
09o 32
10s ΓεnΣym-89
05v :nil
20
0Bo 10
05v [#$24]
09o 13
05v $push/lval
10s source
04i 1
16
01
}
0Es bytecompile/literal
0D
25v bytecompile/quote v [source] v #@[source: [[case [type-of source] [:int [$push/int source]] [:symbol [$push/symbol source]] [otherwise [$push/lval source]]]]] v #{
15
05v type-of
10s source
04i 1
0Es ΓεnΣym-90
0D
10s ΓεnΣym-90
05v :int
20
0Bo 16
05v $push/int
10s source
04i 1
09o 38
10s ΓεnΣym-90
05v :symbol
20
0Bo 16
05v $push/symbol
10s source
04i 1
09o 13
05v $push/lval
10s source
04i 1
16
01
}
0Es bytecompile/quote
0D
25v bytecompile/do/form v [source env] v #@[source: [[when source [cons [cons [bytecompile* [car source] env] [if [last? source] #nil [cons [$drop] #nil]]] [bytecompile/do/form [cdr source] env]]]]] v #{
10s source
0Bo 62
05v bytecompile*
10s source
11
10s env
04i 2
05v nil?
10s source
12
04i 1
0Bo 7
24
09o 9
05v [#$D]
24
14
14
05v bytecompile/do/form
10s source
12
10s env
04i 2
14
09o 4
24
01
}
0Es bytecompile/do/form
0D
25v bytecompile/do v [source env] v #@[source: [[list [bytecompile/do/form [cdr source] env]]]] v #{
05v list
05v bytecompile/do/form
10s source
12
10s env
04i 2
04i 1
01
}
0Es bytecompile/do
0D
25v bytecompile/procedure v [op source env] v #@[source: [[def args [map [cdr source] bytecompile*]] [list args [$apply [length args] op]]]] v #{
05v map
10s source
12
10s bytecompile*
04i 2
0Es args
0D
05v list
10s args
05v $apply
05v length
10s args
04i 1
10s op
04i 2
04i 2
01
}
0Es bytecompile/procedure
0D
25v bytecompile/def v [source env] v #@[source: [[when [or [not [symbol? [cadr source]]] [not [cddr source]]] [throw [list :type-error "[def] needs a symbol name and a value as arguments" #nil env]]] [list [bytecompile* [caddr source] env] [$def [cadr source]]]]] v #{
05v symbol?
10s source
12
11
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 33
0D
10s source
12
12
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 8
0D
05v #f
0Bo 31
05v throw
05v list
05v :type-error
05v "[def] needs a symbol name and a value as arguments"
24
10s env
04i 4
04i 1
09o 4
24
0D
05v list
05v bytecompile*
05v caddr
10s source
04i 1
10s env
04i 2
05v $def
10s source
12
11
04i 1
04i 2
01
}
0Es bytecompile/def
0D
25v bytecompile/set! v [source env] v #@[source: [[when [or [not [symbol? [cadr source]]] [not [cddr source]]] [throw [list :type-error "[set!] needs a symbol name and a value as arguments" #nil env]]] [list [bytecompile* [caddr source] env] [$set [cadr source]]]]] v #{
05v symbol?
10s source
12
11
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 33
0D
10s source
12
12
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 8
0D
05v #f
0Bo 31
05v throw
05v list
05v :type-error
05v "[set!] needs a symbol name and a value as arguments"
24
10s env
04i 4
04i 1
09o 4
24
0D
05v list
05v bytecompile*
05v caddr
10s source
04i 1
10s env
04i 2
05v $set
10s source
12
11
04i 1
04i 2
01
}
0Es bytecompile/set!
0D
25v bytecompile/if v [source env] v #@[source: [[let [[sym-else [bytecompile/gen-label]] [sym-after [bytecompile/gen-label]]] [list [bytecompile* [cadr source] env] [$jf sym-else] [bytecompile* [caddr source] env] [$jmp sym-after] [list :label sym-else] [bytecompile* [cadddr source] env] [list :label sym-after]]]]] v #{
15
05v bytecompile/gen-label
04i 0
0Es sym-else
0D
05v bytecompile/gen-label
04i 0
0Es sym-after
0D
05v list
05v bytecompile*
10s source
12
11
10s env
04i 2
05v $jf
10s sym-else
04i 1
05v bytecompile*
05v caddr
10s source
04i 1
10s env
04i 2
05v $jmp
10s sym-after
04i 1
05v list
05v :label
10s sym-else
04i 2
05v bytecompile*
05v cadddr
10s source
04i 1
10s env
04i 2
05v list
05v :label
10s sym-after
04i 2
04i 7
16
01
}
0Es bytecompile/if
0D
25v bytecompile/while v [source env] v #@[source: [[def sym-start [bytecompile/gen-label]] [def sym-end [bytecompile/gen-label]] [list [$push/int 0] [$roots/save] [list :label sym-start] [$roots/restore] [bytecompile* [cadr source] env] [$jf sym-end] [$drop] [bytecompile/do/form [cddr source] env] [$jmp sym-start] [list :label sym-end]]]] v #{
05v bytecompile/gen-label
04i 0
0Es sym-start
0D
05v bytecompile/gen-label
04i 0
0Es sym-end
0D
05v list
05v $push/int
02i 0
04i 1
05v [#$1B]
05v list
05v :label
10s sym-start
04i 2
05v [#$1C]
05v bytecompile*
10s source
12
11
10s env
04i 2
05v $jf
10s sym-end
04i 1
05v [#$D]
05v bytecompile/do/form
10s source
12
12
10s env
04i 2
05v $jmp
10s sym-start
04i 1
05v list
05v :label
10s sym-end
04i 2
04i 10
01
}
0Es bytecompile/while
0D
25v bytecompile/procedure/arg v [source env] v #@[source: [[if [last? source] [bytecompile* [car source] env] [cons [bytecompile* [car source] env] [bytecompile/procedure/arg [cdr source] env]]]]] v #{
05v nil?
10s source
12
04i 1
0Bo 21
05v bytecompile*
10s source
11
10s env
04i 2
09o 34
05v bytecompile*
10s source
11
10s env
04i 2
05v bytecompile/procedure/arg
10s source
12
10s env
04i 2
14
01
}
0Es bytecompile/procedure/arg
0D
25v bytecompile/procedure/inline? v [op] v #@[source: [[case [type-of op] [:lambda [closure/meta op :inline]] [#t #f]]]] v #{
15
05v type-of
10s op
04i 1
0Es ΓεnΣym-91
0D
10s ΓεnΣym-91
05v :lambda
20
0Bo 20
05v closure/meta
10s op
05v :inline
04i 2
09o 23
10s ΓεnΣym-91
05v #t
20
0Bo 10
05v #f
09o 4
24
16
01
}
0Es bytecompile/procedure/inline?
0D
25v bytecompile/procedure/inline v [op args env] v #@[source: [[def arg-count [length args]] [when [> arg-count 1] [throw [list :compiler-error "For now only monadic functions can be inlined" op [current-lambda]]]] [def form [macroexpand/do [closure/meta op :source] env]] [def arg-name [car [tree/ref [closure op] :arguments]]] [if args [bytecompile* [list/replace form arg-name [car args]] env] [bytecompile* form env]]]] v #{
05v length
10s args
04i 1
0Es arg-count
0D
10s arg-count
02i 1
22
0Bo 36
05v throw
05v list
05v :compiler-error
05v "For now only monadic functions can be inlined"
10s op
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v macroexpand/do
05v closure/meta
10s op
05v :source
04i 2
10s env
04i 2
0Es form
0D
05v tree/ref
05v closure
10s op
04i 1
05v :arguments
04i 2
11
0Es arg-name
0D
10s args
0Bo 35
05v bytecompile*
05v list/replace
10s form
10s arg-name
10s args
11
04i 3
10s env
04i 2
09o 17
05v bytecompile*
10s form
10s env
04i 2
01
}
0Es bytecompile/procedure/inline
0D
25v bytecompile/procedure v [op args env] v #@[source: [[if [bytecompile/procedure/inline? op] [bytecompile/procedure/inline op args env] [bytecompile/procedure/default op args env]]]] v #{
05v bytecompile/procedure/inline?
10s op
04i 1
0Bo 24
05v bytecompile/procedure/inline
10s op
10s args
10s env
04i 3
09o 21
05v bytecompile/procedure/default
10s op
10s args
10s env
04i 3
01
}
0Es bytecompile/procedure
0D
25v bytecompile/procedure/default v [op args env] v #@[source: [[def arg-count [length args]] [if [$apply/optimize? op] [list [when args [bytecompile/procedure/arg args]] [$apply arg-count op]] [list [bytecompile* op env] [when args [bytecompile/procedure/arg args]] [$apply/dynamic arg-count]]]]] v #{
05v length
10s args
04i 1
0Es arg-count
0D
05v $apply/optimize?
10s op
04i 1
0Bo 47
05v list
10s args
0Bo 16
05v bytecompile/procedure/arg
10s args
04i 1
09o 4
24
05v $apply
10s arg-count
10s op
04i 2
04i 2
09o 54
05v list
05v bytecompile*
10s op
10s env
04i 2
10s args
0Bo 16
05v bytecompile/procedure/arg
10s args
04i 1
09o 4
24
05v $apply/dynamic
10s arg-count
04i 1
04i 3
01
}
0Es bytecompile/procedure/default
0D
25v bytecompile/and/rec v [source env label-end] v #@[source: [[list [bytecompile* [car source] env] [when [cdr source] [list [$dup] [$jf label-end] [$drop] [bytecompile/and/rec [cdr source] env label-end]]]]]] v #{
05v list
05v bytecompile*
10s source
11
10s env
04i 2
10s source
12
0Bo 49
05v list
05v [#$C]
05v $jf
10s label-end
04i 1
05v [#$D]
05v bytecompile/and/rec
10s source
12
10s env
10s label-end
04i 3
04i 4
09o 4
24
04i 2
01
}
0Es bytecompile/and/rec
0D
25v bytecompile/and v [source env] v #@[source: [[def label-end [bytecompile/gen-label]] [list [bytecompile/and/rec [cdr source] env label-end] [list :label label-end]]]] v #{
05v bytecompile/gen-label
04i 0
0Es label-end
0D
05v list
05v bytecompile/and/rec
10s source
12
10s env
10s label-end
04i 3
05v list
05v :label
10s label-end
04i 2
04i 2
01
}
0Es bytecompile/and
0D
25v bytecompile/or/rec v [source env label-end] v #@[source: [[when source [list [bytecompile* [car source] env] [$dup] [$jt label-end] [$drop] [bytecompile/or/rec [cdr source] env label-end]]]]] v #{
10s source
0Bo 64
05v list
05v bytecompile*
10s source
11
10s env
04i 2
05v [#$C]
05v $jt
10s label-end
04i 1
05v [#$D]
05v bytecompile/or/rec
10s source
12
10s env
10s label-end
04i 3
04i 5
09o 4
24
01
}
0Es bytecompile/or/rec
0D
25v bytecompile/or v [source env] v #@[source: [[def label-end [bytecompile/gen-label]] [list [bytecompile/or/rec [cdr source] env label-end] [$push/lval #f] [list :label label-end]]]] v #{
05v bytecompile/gen-label
04i 0
0Es label-end
0D
05v list
05v bytecompile/or/rec
10s source
12
10s env
10s label-end
04i 3
05v $push/lval
05v #f
04i 1
05v list
05v :label
10s label-end
04i 2
04i 3
01
}
0Es bytecompile/or
0D
25v bytecompile/string v [source env] v #@[source: [[bytecompile/procedure cat source env]]] v #{
05v bytecompile/procedure
10s cat
10s source
10s env
04i 3
01
}
0Es bytecompile/string
0D
25v bytecompile/array v [source env] v #@[source: [[bytecompile/procedure array/ref source env]]] v #{
05v bytecompile/procedure
10s array/ref
10s source
10s env
04i 3
01
}
0Es bytecompile/array
0D
25v bytecompile/tree v [source env] v #@[source: [[bytecompile/procedure tree/ref source env]]] v #{
05v bytecompile/procedure
10s tree/ref
10s source
10s env
04i 3
01
}
0Es bytecompile/tree
0D
25v bytecompile/fn* v [source env] v #@[source: [[apply $fn [cdr source]]]] v #{
05v apply
10s $fn
10s source
12
04i 2
01
}
0Es bytecompile/fn*
0D
25v bytecompile/macro* v [source env] v #@[source: [[apply $macro* [cdr source]]]] v #{
05v apply
10s $macro*
10s source
12
04i 2
01
}
0Es bytecompile/macro*
0D
25v bytecompile/ω* v [source env] v #@[source: [[list [$let] [bytecompile/do/form [cdr source] env] [$drop] [$closure/push] [$closure/pop]]]] v #{
05v list
05v [#$15]
05v bytecompile/do/form
10s source
12
10s env
04i 2
05v [#$D]
05v [#$13]
05v [#$16]
04i 5
01
}
0Es bytecompile/ω*
0D
25v bytecompile/let* v [source env] v #@[source: [[list [$let] [bytecompile/do [cadr source] env] [$closure/pop]]]] v #{
05v list
05v [#$15]
05v bytecompile/do
10s source
12
11
10s env
04i 2
05v [#$16]
04i 3
01
}
0Es bytecompile/let*
0D
25v bytecompile/return v [source env] v #@[source: [[list [bytecompile* [cadr source] env] [$ret]]]] v #{
05v list
05v bytecompile*
10s source
12
11
10s env
04i 2
05v [#$1]
04i 2
01
}
0Es bytecompile/return
0D
25v bytecompile/try v [source env] v #@[source: [[def end-sym [bytecompile/gen-label]] [list [bytecompile* [cadr source] env] [$try end-sym] [bytecompile/do/form [cddr source] env] [$closure/pop] [list :label end-sym]]]] v #{
05v bytecompile/gen-label
04i 0
0Es end-sym
0D
05v list
05v bytecompile*
10s source
12
11
10s env
04i 2
05v $try
10s end-sym
04i 1
05v bytecompile/do/form
10s source
12
12
10s env
04i 2
05v [#$16]
05v list
05v :label
10s end-sym
04i 2
04i 5
01
}
0Es bytecompile/try
0D
25v bytecompile* v [source env] v #@[documentation: "Compile the forms in source" source: ["Compile the forms in source" [def op [if [resolves? [car source] env] [resolve [car source] env] [car source]]] [case [type-of op] [[:lambda :native-function] [case op [do [bytecompile/do source env]] [let* [bytecompile/let* source env]] [def [bytecompile/def source env]] [set! [bytecompile/set! source env]] [if [bytecompile/if source env]] [while [bytecompile/while source env]] [and [bytecompile/and source env]] [or [bytecompile/or source env]] [fn* [bytecompile/fn* source env]] [macro* [bytecompile/macro* source env]] [ω* [bytecompile/ω* source env]] [try [bytecompile/try source env]] [return [bytecompile/return source env]] '[bytecompile/quote [cadr source]] [otherwise [bytecompile/procedure op [cdr source] env]]]] [[:pair :symbol] [bytecompile/procedure op [cdr source] env]] [:string [bytecompile/string source env]] [:array [bytecompile/array source env]] [:tree [bytecompile/tree source env]] [otherwise [bytecompile/literal source]]]]] v #{
05v resolves?
10s source
11
10s env
04i 2
0Bo 21
05v resolve
10s source
11
10s env
04i 2
09o 8
10s source
11
0Es op
0D
15
05v type-of
10s op
04i 1
0Es ΓεnΣym-92
0D
10s ΓεnΣym-92
05v :lambda
20
0C
0Ao 22
0D
10s ΓεnΣym-92
05v :native-function
20
0C
0Ao 8
0D
05v #f
0Bo 440
15
10s op
0Es ΓεnΣym-93
0D
10s ΓεnΣym-93
10s do
20
0Bo 20
05v bytecompile/do
10s source
10s env
04i 2
09o 397
10s ΓεnΣym-93
10s let*
20
0Bo 20
05v bytecompile/let*
10s source
10s env
04i 2
09o 368
10s ΓεnΣym-93
10s def
20
0Bo 20
05v bytecompile/def
10s source
10s env
04i 2
09o 339
10s ΓεnΣym-93
10s set!
20
0Bo 20
05v bytecompile/set!
10s source
10s env
04i 2
09o 310
10s ΓεnΣym-93
10s if
20
0Bo 20
05v bytecompile/if
10s source
10s env
04i 2
09o 281
10s ΓεnΣym-93
10s while
20
0Bo 20
05v bytecompile/while
10s source
10s env
04i 2
09o 252
10s ΓεnΣym-93
10s and
20
0Bo 20
05v bytecompile/and
10s source
10s env
04i 2
09o 223
10s ΓεnΣym-93
10s or
20
0Bo 20
05v bytecompile/or
10s source
10s env
04i 2
09o 194
10s ΓεnΣym-93
10s fn*
20
0Bo 20
05v bytecompile/fn*
10s source
10s env
04i 2
09o 165
10s ΓεnΣym-93
10s macro*
20
0Bo 20
05v bytecompile/macro*
10s source
10s env
04i 2
09o 136
10s ΓεnΣym-93
10s ω*
20
0Bo 20
05v bytecompile/ω*
10s source
10s env
04i 2
09o 107
10s ΓεnΣym-93
10s try
20
0Bo 20
05v bytecompile/try
10s source
10s env
04i 2
09o 78
10s ΓεnΣym-93
10s return
20
0Bo 20
05v bytecompile/return
10s source
10s env
04i 2
09o 49
10s ΓεnΣym-93
10s quote
20
0Bo 18
05v bytecompile/quote
10s source
12
11
04i 1
09o 22
05v bytecompile/procedure
10s op
10s source
12
10s env
04i 3
16
09o 157
10s ΓεnΣym-92
05v :pair
20
0C
0Ao 22
0D
10s ΓεnΣym-92
05v :symbol
20
0C
0Ao 8
0D
05v #f
0Bo 25
05v bytecompile/procedure
10s op
10s source
12
10s env
04i 3
09o 100
10s ΓεnΣym-92
05v :string
20
0Bo 20
05v bytecompile/string
10s source
10s env
04i 2
09o 71
10s ΓεnΣym-92
05v :array
20
0Bo 20
05v bytecompile/array
10s source
10s env
04i 2
09o 42
10s ΓεnΣym-92
05v :tree
20
0Bo 20
05v bytecompile/tree
10s source
10s env
04i 2
09o 13
05v bytecompile/literal
10s source
04i 1
16
01
}
0Es bytecompile*
0D
25v bytecompile v [form environment] v #@[source: [[list [bytecompile* form environment] [$ret]]]] v #{
05v list
05v bytecompile*
10s form
10s environment
04i 2
05v [#$1]
04i 2
01
}
0Es bytecompile
01
}#{
25v load/forms v [source environment] v #@[documentation: "Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" source: ["Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" [for-in [form source] [-> [macroexpand form environment] bytecompile assemble* [bytecode-eval environment]]]]] v #{
15
10s source
0Es ΓεnΣym-97
0D
10s ΓεnΣym-97
0Bo 77
02i 0
1B
1C
10s ΓεnΣym-97
0Bo 63
0D
10s ΓεnΣym-97
11
0Es form
0D
05v bytecode-eval
05v assemble*
05v bytecompile
05v macroexpand
10s form
10s environment
04i 2
04i 1
04i 1
10s environment
04i 2
0D
10s ΓεnΣym-97
12
0Fs ΓεnΣym-97
09o -65
09o 4
24
16
01
}
0Es load/forms
0D
25v macroexpand/forms v [source-raw environment] v #@[documentation: "Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined." source: ["Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined." [when-not environment [set! environment [ω]]] [load/forms source-raw environment] [macroexpand source-raw environment]]] v #{
10s environment
0Bo 7
24
09o 12
15
24
0D
13
16
0Fs environment
0D
05v load/forms
10s source-raw
10s environment
04i 2
0D
05v macroexpand
10s source-raw
10s environment
04i 2
01
}
0Es macroexpand/forms
0D
25v compile/debug v [expr] v #@[source: [[-> [macroexpand expr] bytecompile assemble* disassemble]]] v #{
05v disassemble
05v assemble*
05v bytecompile
05v macroexpand
10s expr
04i 1
04i 1
04i 1
04i 1
01
}
0Es compile/debug
0D
25v compile* v [source environment] v #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [-> [macroexpand source environment] bytecompile assemble*]]] v #{
05v assemble*
05v bytecompile
05v macroexpand
10s source
10s environment
04i 2
04i 1
04i 1
01
}
0Es compile*
0D
25v compile/do* v [source environment] v #@[source: [[compile* [cons do source] environment]]] v #{
05v compile*
10s do
10s source
14
10s environment
04i 2
01
}
0Es compile/do*
0D
26v compile v [source] v #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [quasiquote [compile* [unquote source] [current-closure]]]]] v #{
23s compile*
10s source
23s current-closure
24
14
24
14
14
14
01
}
0Es compile
0D
26v compile/do v [source] v #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [quasiquote [compile* [cons do [unquote source]] [current-closure]]]]] v #{
23s compile*
23s cons
23s do
10s source
24
14
14
14
23s current-closure
24
14
24
14
14
14
01
}
0Es compile/do
0D
25v meta/parse/body v [type args body] v #@[source: [[def meta [tree/new #nil]] [for-in [v body] [case [type-of v] [:pair [return meta]] [:string [tree/set! meta :documentation [trim [cat [string [tree/ref meta :documentation]] "\n" v]]]] [:keyword [tree/set! meta v #t]]]] [return meta]]] v #{
05v tree/new
24
04i 1
0Es meta
0D
15
10s body
0Es ΓεnΣym-98
0D
10s ΓεnΣym-98
0Bo 181
02i 0
1B
1C
10s ΓεnΣym-98
0Bo 167
0D
10s ΓεnΣym-98
11
0Es v
0D
15
05v type-of
10s v
04i 1
0Es ΓεnΣym-99
0D
10s ΓεnΣym-99
05v :pair
20
0Bo 11
10s meta
01
09o 106
10s ΓεnΣym-99
05v :string
20
0Bo 60
05v tree/set!
10s meta
05v :documentation
05v trim
05v cat
05v string
05v tree/ref
10s meta
05v :documentation
04i 2
04i 1
05v "\n"
10s v
04i 3
04i 1
04i 3
09o 37
10s ΓεnΣym-99
05v :keyword
20
0Bo 24
05v tree/set!
10s meta
10s v
05v #t
04i 3
09o 4
24
16
0D
10s ΓεnΣym-98
12
0Fs ΓεnΣym-98
09o -169
09o 4
24
16
0D
10s meta
01
01
}
0Es meta/parse/body
0D
26v defmacro v [name args . body] v #@[documentation: "Define a new macro" source: ["Define a new macro" [quasiquote [def [unquote name] [macro* [unquote name] [unquote args] [unquote [tree/set! [meta/parse/body :macro args body] :source body]] [unquote [compile/do* body [current-closure]]]]]]]] v #{
23s def
10s name
23s macro*
10s name
10s args
05v tree/set!
05v meta/parse/body
05v :macro
10s args
10s body
04i 3
05v :source
10s body
04i 3
05v compile/do*
10s body
05v current-closure
04i 0
04i 2
24
14
14
14
14
14
24
14
14
14
01
}
0Es defmacro
0D
26v fn v [args . body] v #@[documentation: "Define an anonymous function" source: ["Define an anonymous function" [quasiquote [fn* anonymous [unquote args] [unquote [tree/set! [meta/parse/body :lambda args body] :source body]] [unquote [compile/do* body [current-closure]]]]]]] v #{
23s fn*
23s anonymous
10s args
05v tree/set!
05v meta/parse/body
05v :lambda
10s args
10s body
04i 3
05v :source
10s body
04i 3
05v compile/do*
10s body
05v current-closure
04i 0
04i 2
24
14
14
14
14
14
01
}
0Es fn
0D
26v defn v [name args . body] v #@[documentation: "Define a new function" source: ["Define a new function" [quasiquote [def [unquote name] [fn* [unquote name] [unquote args] [unquote [tree/set! [meta/parse/body :lambda args body] :source body]] [unquote [compile/do* body [current-closure]]]]]]]] v #{
23s def
10s name
23s fn*
10s name
10s args
05v tree/set!
05v meta/parse/body
05v :lambda
10s args
10s body
04i 3
05v :source
10s body
04i 3
05v compile/do*
10s body
05v current-closure
04i 0
04i 2
24
14
14
14
14
14
24
14
14
14
01
}
0Es defn
0D
26v ω v body v #@[documentation: "Defines and returns new object after evaluating body within" source: ["Defines and returns new object after evaluating body within" [macroexpand [cons 'ω* body]]]] v #{
05v macroexpand
23s ω*
10s body
14
04i 1
01
}
0Es ω
0D
10s ω
0Es defobj
0D
25v eval-in v [closure expr] v #@[documentation: "Compile and the immediatly evaluate the result\nMostly used by lRun()" source: ["Compile and the immediatly evaluate the result" "" "Mostly used by lRun()" [try display/error [-> [compile* expr closure] [bytecode-eval closure]]]]] v #{
10s display/error
19o 28
05v bytecode-eval
05v compile*
10s expr
10s closure
04i 2
10s closure
04i 2
16
01
}
0Es eval-in
0D
25v eval-in/trace v [closure expr] v #@[documentation: "Compile and the immediatly evaluate the result\nmostly used by lRun()" source: ["Compile and the immediatly evaluate the result" "" "mostly used by lRun()" [try display/error [def bc [compile* expr closure]] [println [str/write bc]] [bytecode-eval bc closure]]]] v #{
10s display/error
19o 54
05v compile*
10s expr
10s closure
04i 2
0Es bc
0D
05v println
05v str/write
10s bc
04i 1
04i 1
0D
05v bytecode-eval
10s bc
10s closure
04i 2
16
01
}
0Es eval-in/trace
0D
26v eval v [expr] v #@[documentation: "Compile, Evaluate and then return the result of EXPR" source: ["Compile, Evaluate and then return the result of EXPR" [quasiquote [eval-in [current-closure] [unquote expr]]]]] v #{
23s eval-in
23s current-closure
24
14
10s expr
24
14
14
14
01
}
0Es eval
0D
26v typecheck/only v [v t] v #@[source: [[quasiquote [when-not [== [type-of [unquote v]] [unquote t]] [throw [list :type-error [unquote [fmt "Expected a value of type {t}"]] [unquote v] [current-lambda]]]]]]] v #{
23s when-not
23s ==
23s type-of
10s v
24
14
14
10s t
24
14
14
14
23s throw
23s list
05v :type-error
05v cat
05v "Expected a value of type "
10s t
04i 2
10s v
23s current-lambda
24
14
24
14
14
14
14
14
24
14
14
24
14
14
14
01
}
0Es typecheck/only
01
}#{
25v disassemble/length v [op] v #@[documentation: "Return the length in bytes of a bytecode operation and all its arguments" source: ["Return the length in bytes of a bytecode operation and all its arguments" [case op [[#$0 #$1 #$3 #$C #$D #$11 #$12 #$13 #$14 #$15 #$16 #$1B #$1C #$1E #$1F #$20 #$21 #$22 #$24] 1] [[#$2 #$4 #$7 #$1A] 2] [[#$9 #$A #$B #$18 #$19] 3] [[#$5 #$E #$F #$10 #$23] 4] [[#$25 #$26] 13] [otherwise [throw [list :unknown-op "This op needs its length specified for disassembly to work" op [current-lambda]]]]]]] v #{
15
10s op
0Es ΓεnΣym-104
0D
10s ΓεnΣym-104
05v #$0
20
0C
0Ao 260
0D
10s ΓεnΣym-104
05v #$1
20
0C
0Ao 246
0D
10s ΓεnΣym-104
05v #$3
20
0C
0Ao 232
0D
10s ΓεnΣym-104
05v #$C
20
0C
0Ao 218
0D
10s ΓεnΣym-104
05v #$D
20
0C
0Ao 204
0D
10s ΓεnΣym-104
05v #$11
20
0C
0Ao 190
0D
10s ΓεnΣym-104
05v #$12
20
0C
0Ao 176
0D
10s ΓεnΣym-104
05v #$13
20
0C
0Ao 162
0D
10s ΓεnΣym-104
05v #$14
20
0C
0Ao 148
0D
10s ΓεnΣym-104
05v #$15
20
0C
0Ao 134
0D
10s ΓεnΣym-104
05v #$16
20
0C
0Ao 120
0D
10s ΓεnΣym-104
05v #$1B
20
0C
0Ao 106
0D
10s ΓεnΣym-104
05v #$1C
20
0C
0Ao 92
0D
10s ΓεnΣym-104
05v #$1E
20
0C
0Ao 78
0D
10s ΓεnΣym-104
05v #$1F
20
0C
0Ao 64
0D
10s ΓεnΣym-104
05v #$20
20
0C
0Ao 50
0D
10s ΓεnΣym-104
05v #$21
20
0C
0Ao 36
0D
10s ΓεnΣym-104
05v #$22
20
0C
0Ao 22
0D
10s ΓεnΣym-104
05v #$24
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 1
09o 305
10s ΓεnΣym-104
05v #$2
20
0C
0Ao 50
0D
10s ΓεnΣym-104
05v #$4
20
0C
0Ao 36
0D
10s ΓεnΣym-104
05v #$7
20
0C
0Ao 22
0D
10s ΓεnΣym-104
05v #$1A
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 2
09o 237
10s ΓεnΣym-104
05v #$9
20
0C
0Ao 64
0D
10s ΓεnΣym-104
05v #$A
20
0C
0Ao 50
0D
10s ΓεnΣym-104
05v #$B
20
0C
0Ao 36
0D
10s ΓεnΣym-104
05v #$18
20
0C
0Ao 22
0D
10s ΓεnΣym-104
05v #$19
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 3
09o 155
10s ΓεnΣym-104
05v #$5
20
0C
0Ao 64
0D
10s ΓεnΣym-104
05v #$E
20
0C
0Ao 50
0D
10s ΓεnΣym-104
05v #$F
20
0C
0Ao 36
0D
10s ΓεnΣym-104
05v #$10
20
0C
0Ao 22
0D
10s ΓεnΣym-104
05v #$23
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 4
09o 73
10s ΓεnΣym-104
05v #$25
20
0C
0Ao 22
0D
10s ΓεnΣym-104
05v #$26
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 13
09o 33
05v throw
05v list
05v :unknown-op
05v "This op needs its length specified for disassembly to work"
10s op
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es disassemble/length
0D
25v bytecode/nil-catcher v [error] v #@[source: [[if [== [car error] :type-error] #nil [throw error]]]] v #{
10s error
11
05v :type-error
20
0Bo 7
24
09o 13
05v throw
10s error
04i 1
01
}
0Es bytecode/nil-catcher
0D
25v bytecode-op->val v [a b c] v #@[documentation: "Turn three bytecode ops representing an encoded value into an actual value" source: ["Turn three bytecode ops representing an encoded value into an actual value" [index->val [logior [ash [bytecode-op->int a] 16] [ash [bytecode-op->int b] 8] [bytecode-op->int c]]]]] v #{
05v index->val
05v logior
05v ash
05v bytecode-op->int
10s a
04i 1
02i 16
04i 2
05v ash
05v bytecode-op->int
10s b
04i 1
02i 8
04i 2
05v bytecode-op->int
10s c
04i 1
04i 3
04i 1
01
}
0Es bytecode-op->val
0D
25v bytecode-arr->val v [a i] v #@[documentation: "Read a bytecode encoded value in A at I and return it" source: ["Read a bytecode encoded value in A at I and return it" [try bytecode/nil-catcher [bytecode-op->val [ref a i] [ref a [+ 1 i]] [ref a [+ 2 i]]]]]] v #{
10s bytecode/nil-catcher
19o 68
05v bytecode-op->val
05v ref
10s a
10s i
04i 2
05v ref
10s a
05v +
02i 1
10s i
04i 2
04i 2
05v ref
10s a
05v +
02i 2
10s i
04i 2
04i 2
04i 3
16
01
}
0Es bytecode-arr->val
0D
25v bytecode-op->sym v [a b c] v #@[documentation: "Turn three bytecode ops representing an encoded symbol into an actual symbol" source: ["Turn three bytecode ops representing an encoded symbol into an actual symbol" [index->sym [logior [ash [bytecode-op->int a] 16] [ash [bytecode-op->int b] 8] [bytecode-op->int c]]]]] v #{
05v index->sym
05v logior
05v ash
05v bytecode-op->int
10s a
04i 1
02i 16
04i 2
05v ash
05v bytecode-op->int
10s b
04i 1
02i 8
04i 2
05v bytecode-op->int
10s c
04i 1
04i 3
04i 1
01
}
0Es bytecode-op->sym
0D
25v bytecode-arr->sym v [a i] v #@[documentation: "Read a bytecode encoded symbol in A at I and return it" source: ["Read a bytecode encoded symbol in A at I and return it" [try bytecode/nil-catcher [bytecode-op->sym [ref a i] [ref a [+ 1 i]] [ref a [+ 2 i]]]]]] v #{
10s bytecode/nil-catcher
19o 68
05v bytecode-op->sym
05v ref
10s a
10s i
04i 2
05v ref
10s a
05v +
02i 1
10s i
04i 2
04i 2
05v ref
10s a
05v +
02i 2
10s i
04i 2
04i 2
04i 3
16
01
}
0Es bytecode-arr->sym
0D
25v bytecode-op->offset v [a b] v #@[documentation: "Turn two bytecode ops encoding an offset into the integer representation" source: ["Turn two bytecode ops encoding an offset into the integer representation" [def t [logior [ash [bytecode-op->int a] 8] [bytecode-op->int b]]] [if-not [> t 32768] t [- [- 65536 t]]]]] v #{
05v logior
05v ash
05v bytecode-op->int
10s a
04i 1
02i 8
04i 2
05v bytecode-op->int
10s b
04i 1
04i 2
0Es t
0D
10s t
05v 32768
22
0Bo 26
05v -
05v -
05v 65536
10s t
04i 2
04i 1
09o 7
10s t
01
}
0Es bytecode-op->offset
0D
25v bytecode-arr->offset v [a i] v #@[documentation: "Read a bytecode encoded offset in A at I and return it as a signed integer" source: ["Read a bytecode encoded offset in A at I and return it as a signed integer" [bytecode-op->offset [ref a i] [ref a [+ 1 i]]]]] v #{
05v bytecode-op->offset
05v ref
10s a
10s i
04i 2
05v ref
10s a
05v +
02i 1
10s i
04i 2
04i 2
04i 2
01
}
0Es bytecode-arr->offset
0D
25v disassemble/op v [a i] v #@[documentation: "Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" source: ["Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" [case [ref a i] [#$0 '[$nop]] [#$1 '[$ret]] [#$2 [quasiquote [$push/int/byte [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$3 '[$add/int]] [#$4 [quasiquote [$apply/dynamic [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$5 [quasiquote [$push/lval [unquote [bytecode-arr->val a [+ i 1]]]]]] [#$7 [quasiquote [$apply/dynamic/new [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$9 [quasiquote [$jmp* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$A [quasiquote [$jt* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$B [quasiquote [$jf* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$C '[$dup]] [#$D '[$drop]] [#$E [quasiquote [$def [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$F [quasiquote [$set [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$10 [quasiquote [$get [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$11 '[$car]] [#$12 '[$cdr]] [#$13 '[$closure/push]] [#$14 '[$cons]] [#$15 '[$let]] [#$16 '[$closure/pop]] [#$18 [quasiquote [$try/old [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$19 [quasiquote [$try [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$1A [quasiquote [$apply/dynamic [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$1B [quasiquote [$roots/push]]] [#$1C [quasiquote [$roots/pop]]] [#$1E [quasiquote [$<]]] [#$1F [quasiquote [$<=]]] [#$20 [quasiquote [$==]]] [#$21 [quasiquote [$>=]]] [#$22 [quasiquote [$>]]] [#$23 [quasiquote [$push/symbol [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$24 [quasiquote [$push/nil]]] [#$25 [quasiquote [$fn [unquote [bytecode-arr->val a [+ i 1]]] [unquote [bytecode-arr->val a [+ i 4]]] [unquote [bytecode-arr->val a [+ i 7]]] [unquote [bytecode-arr->val a [+ i 10]]]]]] [#$26 [quasiquote [$macro* [unquote [bytecode-arr->val a [+ i 1]]] [unquote [bytecode-arr->val a [+ i 4]]] [unquote [bytecode-arr->val a [+ i 7]]] [unquote [bytecode-arr->val a [+ i 10]]]]]] [otherwise :unknown-op]]]] v #{
15
05v ref
10s a
10s i
04i 2
0Es ΓεnΣym-105
0D
10s ΓεnΣym-105
05v #$0
20
0Bo 10
05v [$nop]
09o 1231
10s ΓεnΣym-105
05v #$1
20
0Bo 10
05v [$ret]
09o 1212
10s ΓεnΣym-105
05v #$2
20
0Bo 41
23s $push/int/byte
05v bytecode-op->int
05v ref
10s a
05v +
10s i
02i 1
04i 2
04i 2
04i 1
24
14
14
09o 1162
10s ΓεnΣym-105
05v #$3
20
0Bo 10
05v [$add/int]
09o 1143
10s ΓεnΣym-105
05v #$4
20
0Bo 41
23s $apply/dynamic
05v bytecode-op->int
05v ref
10s a
05v +
10s i
02i 1
04i 2
04i 2
04i 1
24
14
14
09o 1093
10s ΓεnΣym-105
05v #$5
20
0Bo 35
23s $push/lval
05v bytecode-arr->val
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 1049
10s ΓεnΣym-105
05v #$7
20
0Bo 41
23s $apply/dynamic/new
05v bytecode-op->int
05v ref
10s a
05v +
10s i
02i 1
04i 2
04i 2
04i 1
24
14
14
09o 999
10s ΓεnΣym-105
05v #$9
20
0Bo 35
23s $jmp*
05v bytecode-arr->offset
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 955
10s ΓεnΣym-105
05v #$A
20
0Bo 35
23s $jt*
05v bytecode-arr->offset
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 911
10s ΓεnΣym-105
05v #$B
20
0Bo 35
23s $jf*
05v bytecode-arr->offset
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 867
10s ΓεnΣym-105
05v #$C
20
0Bo 10
05v [$dup]
09o 848
10s ΓεnΣym-105
05v #$D
20
0Bo 10
05v [$drop]
09o 829
10s ΓεnΣym-105
05v #$E
20
0Bo 35
23s $def
05v bytecode-arr->sym
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 785
10s ΓεnΣym-105
05v #$F
20
0Bo 35
23s $set
05v bytecode-arr->sym
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 741
10s ΓεnΣym-105
05v #$10
20
0Bo 35
23s $get
05v bytecode-arr->sym
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 697
10s ΓεnΣym-105
05v #$11
20
0Bo 10
05v [$car]
09o 678
10s ΓεnΣym-105
05v #$12
20
0Bo 10
05v [$cdr]
09o 659
10s ΓεnΣym-105
05v #$13
20
0Bo 10
05v [$closure/push]
09o 640
10s ΓεnΣym-105
05v #$14
20
0Bo 10
05v [$cons]
09o 621
10s ΓεnΣym-105
05v #$15
20
0Bo 10
05v [$let]
09o 602
10s ΓεnΣym-105
05v #$16
20
0Bo 10
05v [$closure/pop]
09o 583
10s ΓεnΣym-105
05v #$18
20
0Bo 35
23s $try/old
05v bytecode-arr->offset
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 539
10s ΓεnΣym-105
05v #$19
20
0Bo 35
23s $try
05v bytecode-arr->offset
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 495
10s ΓεnΣym-105
05v #$1A
20
0Bo 41
23s $apply/dynamic
05v bytecode-op->int
05v ref
10s a
05v +
10s i
02i 1
04i 2
04i 2
04i 1
24
14
14
09o 445
10s ΓεnΣym-105
05v #$1B
20
0Bo 12
23s $roots/push
24
14
09o 424
10s ΓεnΣym-105
05v #$1C
20
0Bo 12
23s $roots/pop
24
14
09o 403
10s ΓεnΣym-105
05v #$1E
20
0Bo 12
23s $<
24
14
09o 382
10s ΓεnΣym-105
05v #$1F
20
0Bo 12
23s $<=
24
14
09o 361
10s ΓεnΣym-105
05v #$20
20
0Bo 12
23s $==
24
14
09o 340
10s ΓεnΣym-105
05v #$21
20
0Bo 12
23s $>=
24
14
09o 319
10s ΓεnΣym-105
05v #$22
20
0Bo 12
23s $>
24
14
09o 298
10s ΓεnΣym-105
05v #$23
20
0Bo 35
23s $push/symbol
05v bytecode-arr->sym
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 254
10s ΓεnΣym-105
05v #$24
20
0Bo 12
23s $push/nil
24
14
09o 233
10s ΓεnΣym-105
05v #$25
20
0Bo 104
23s $fn
05v bytecode-arr->val
10s a
05v +
10s i
02i 1
04i 2
04i 2
05v bytecode-arr->val
10s a
05v +
10s i
02i 4
04i 2
04i 2
05v bytecode-arr->val
10s a
05v +
10s i
02i 7
04i 2
04i 2
05v bytecode-arr->val
10s a
05v +
10s i
02i 10
04i 2
04i 2
24
14
14
14
14
14
09o 120
10s ΓεnΣym-105
05v #$26
20
0Bo 104
23s $macro*
05v bytecode-arr->val
10s a
05v +
10s i
02i 1
04i 2
04i 2
05v bytecode-arr->val
10s a
05v +
10s i
02i 4
04i 2
04i 2
05v bytecode-arr->val
10s a
05v +
10s i
02i 7
04i 2
04i 2
05v bytecode-arr->val
10s a
05v +
10s i
02i 10
04i 2
04i 2
24
14
14
14
14
14
09o 7
05v :unknown-op
16
01
}
0Es disassemble/op
0D
25v disassemble/array v [a i] v #@[documentation: "Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" source: ["Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" [def ret #nil] [while [< i [array/length a]] [set! ret [cons [cons i [disassemble/op a i]] ret]] [set! i [+ i [disassemble/length [ref a i]]]]] [nreverse ret]]] v #{
24
0Es ret
0D
02i 0
1B
1C
10s i
05v array/length
10s a
04i 1
1E
0Bo 70
0D
10s i
05v disassemble/op
10s a
10s i
04i 2
14
10s ret
14
0Fs ret
0D
05v +
10s i
05v disassemble/length
05v ref
10s a
10s i
04i 2
04i 1
04i 2
0Fs i
09o -83
0D
05v nreverse
10s ret
04i 1
01
}
0Es disassemble/array
0D
25v disassemble/bytecode-array v [code] v #@[documentation: "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," source: ["Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," [disassemble/array [bytecode-arr->arr code] 0]]] v #{
05v disassemble/array
05v bytecode-arr->arr
10s code
04i 1
02i 0
04i 2
01
}
0Es disassemble/bytecode-array
0D
25v disassemble/print v [bc] v #@[source: [[for-in [a [disassemble/bytecode-array bc]] [println [cat [ansi-blue [string/pad-start [string [car a]] 6]] " - " [cdr a]]]]]] v #{
15
05v disassemble/bytecode-array
10s bc
04i 1
0Es ΓεnΣym-106
0D
10s ΓεnΣym-106
0Bo 87
02i 0
1B
1C
10s ΓεnΣym-106
0Bo 73
0D
10s ΓεnΣym-106
11
0Es a
0D
05v println
05v cat
05v ansi-blue
05v string/pad-start
05v string
10s a
11
04i 1
02i 6
04i 2
04i 1
05v " - "
10s a
12
04i 3
04i 1
0D
10s ΓεnΣym-106
12
0Fs ΓεnΣym-106
09o -75
09o 4
24
16
01
}
0Es disassemble/print
0D
25v disassemble v [bc] v #@[documentation: "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," source: ["Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," [case [type-of bc] [[:lambda :macro] [disassemble/print [ref [closure bc] :code]]] [:bytecode-array [disassemble/print bc]] [otherwise [throw [list :type-error "Can't disassemble that" bc [current-lambda]]]]]]] v #{
15
05v type-of
10s bc
04i 1
0Es ΓεnΣym-107
0D
10s ΓεnΣym-107
05v :lambda
20
0C
0Ao 22
0D
10s ΓεnΣym-107
05v :macro
20
0C
0Ao 8
0D
05v #f
0Bo 32
05v disassemble/print
05v ref
05v closure
10s bc
04i 1
05v :code
04i 2
04i 1
09o 58
10s ΓεnΣym-107
05v :bytecode-array
20
0Bo 16
05v disassemble/print
10s bc
04i 1
09o 33
05v throw
05v list
05v :type-error
05v "Can't disassemble that"
10s bc
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es disassemble
01
}#{
25v macroexpand/do/args v [args env] v #@[source: [[if [last? args] [cons [macroexpand* [car args] env] #nil] [if [pair? [car args]] [let* [def ocar [macroexpand* [car args] env]] [if [pair? ocar] [cons ocar [macroexpand/do/args [cdr args] env]] [macroexpand/do/args [cdr args] env]]] [macroexpand/do/args [cdr args] env]]]]] v #{
05v nil?
10s args
12
04i 1
0Bo 23
05v macroexpand*
10s args
11
10s env
04i 2
24
14
09o 108
05v pair?
10s args
11
04i 1
0Bo 79
15
05v macroexpand*
10s args
11
10s env
04i 2
0Es ocar
0D
05v pair?
10s ocar
04i 1
0Bo 26
10s ocar
05v macroexpand/do/args
10s args
12
10s env
04i 2
14
09o 18
05v macroexpand/do/args
10s args
12
10s env
04i 2
16
09o 18
05v macroexpand/do/args
10s args
12
10s env
04i 2
01
}
0Es macroexpand/do/args
0D
25v macroexpand/do v [source env] v #@[source: [[def args [macroexpand/do/args source env]] [if [last? args] [car args] [cons 'do args]]]] v #{
05v macroexpand/do/args
10s source
10s env
04i 2
0Es args
0D
05v nil?
10s args
12
04i 1
0Bo 11
10s args
11
09o 12
23s do
10s args
14
01
}
0Es macroexpand/do
0D
25v macroexpand/form v [source env op arity implicit-do? no-expand-bitmap] v #@[source: [[def ret [cons op #nil]] [def l [cdr source]] [for [i 0 arity] [set! ret [cons [if [bit-set? no-expand-bitmap i] [car l] [macroexpand* [car l] env]] ret]] [cdr! l]] [if implicit-do? [set! ret [cons [macroexpand/do l env] ret]] [when l [throw [list :arity-error [cat "form contains more than " arity " arguments"] source [current-lambda]]]]] [return [nreverse ret]]]] v #{
10s op
24
14
0Es ret
0D
10s source
12
0Es l
0D
15
02i 0
0Es i
0D
10s arity
0Es ΓεnΣym-111
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-111
1E
0Bo 78
0D
05v bit-set?
10s no-expand-bitmap
10s i
04i 2
0Bo 11
10s l
11
09o 18
05v macroexpand*
10s l
11
10s env
04i 2
10s ret
14
0Fs ret
0D
10s l
12
0Fs l
0D
02i 1
10s i
03
0Fs i
09o -85
16
0D
10s implicit-do?
0Bo 29
05v macroexpand/do
10s l
10s env
04i 2
10s ret
14
0Fs ret
09o 58
10s l
0Bo 50
05v throw
05v list
05v :arity-error
05v cat
05v "form contains more than "
10s arity
05v " arguments"
04i 3
10s source
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v nreverse
10s ret
04i 1
01
01
}
0Es macroexpand/form
0D
25v macroexpand/fold v [op source env] v #@[source: [[if [cdr source] [if [cddr source] [list op [macroexpand/fold op [except-last-pair source] env] [macroexpand* [car [last-pair source]] env]] [list op [macroexpand* [car source] env] [macroexpand* [cadr source] env]]] [list op [macroexpand* [car source] env]]]]] v #{
10s source
12
0Bo 114
10s source
12
12
0Bo 61
05v list
10s op
05v macroexpand/fold
10s op
05v except-last-pair
10s source
04i 1
10s env
04i 3
05v macroexpand*
05v last-pair
10s source
04i 1
11
10s env
04i 2
04i 3
09o 44
05v list
10s op
05v macroexpand*
10s source
11
10s env
04i 2
05v macroexpand*
10s source
12
11
10s env
04i 2
04i 3
09o 28
05v list
10s op
05v macroexpand*
10s source
11
10s env
04i 2
04i 2
01
}
0Es macroexpand/fold
0D
25v macroexpand* v [source env] v #@[documentation: "Expand all macros within source" source: ["Expand all macros within source" [def op [if [resolves? [car source] env] [resolve [car source] env] [car source]]] [case [type-of op] [:nil source] [:native-function [case op [[+ - * / %] [macroexpand/fold op [cdr source]]] [do [macroexpand/do source env]] [return [macroexpand/form source env op 1 #f 0]] [[try while] [macroexpand/form source env op 1 #t 0]] [[def set!] [macroexpand/form source env op 2 #f 1]] [if [macroexpand/form source env op 3 #f 0]] [[fn* macro*] [macroexpand/form source env op 4 #t 7]] [[let* environment*] [list op [macroexpand/do [cdr source] env]]] 'source [otherwise [map source [fn [α] [macroexpand* α env]]]]]] [:macro [macroexpand* [macro-apply op [cdr source]] env]] [otherwise [map source [fn [α] [macroexpand* α env]]]]]]] v #{
05v resolves?
10s source
11
10s env
04i 2
0Bo 21
05v resolve
10s source
11
10s env
04i 2
09o 8
10s source
11
0Es op
0D
15
05v type-of
10s op
04i 1
0Es ΓεnΣym-112
0D
10s ΓεnΣym-112
05v :nil
20
0Bo 10
10s source
09o 595
10s ΓεnΣym-112
05v :native-function
20
0Bo 520
15
10s op
0Es ΓεnΣym-113
0D
10s ΓεnΣym-113
10s +
20
0C
0Ao 64
0D
10s ΓεnΣym-113
10s -
20
0C
0Ao 50
0D
10s ΓεnΣym-113
10s *
20
0C
0Ao 36
0D
10s ΓεnΣym-113
10s /
20
0C
0Ao 22
0D
10s ΓεnΣym-113
10s %
20
0C
0Ao 8
0D
05v #f
0Bo 21
05v macroexpand/fold
10s op
10s source
12
04i 2
09o 411
10s ΓεnΣym-113
10s do
20
0Bo 20
05v macroexpand/do
10s source
10s env
04i 2
09o 382
10s ΓεnΣym-113
10s return
20
0Bo 32
05v macroexpand/form
10s source
10s env
10s op
02i 1
05v #f
02i 0
04i 6
09o 341
10s ΓεnΣym-113
10s try
20
0C
0Ao 22
0D
10s ΓεnΣym-113
10s while
20
0C
0Ao 8
0D
05v #f
0Bo 32
05v macroexpand/form
10s source
10s env
10s op
02i 1
05v #t
02i 0
04i 6
09o 277
10s ΓεnΣym-113
10s def
20
0C
0Ao 22
0D
10s ΓεnΣym-113
10s set!
20
0C
0Ao 8
0D
05v #f
0Bo 32
05v macroexpand/form
10s source
10s env
10s op
02i 2
05v #f
02i 1
04i 6
09o 213
10s ΓεnΣym-113
10s if
20
0Bo 32
05v macroexpand/form
10s source
10s env
10s op
02i 3
05v #f
02i 0
04i 6
09o 172
10s ΓεnΣym-113
10s fn*
20
0C
0Ao 22
0D
10s ΓεnΣym-113
10s macro*
20
0C
0Ao 8
0D
05v #f
0Bo 32
05v macroexpand/form
10s source
10s env
10s op
02i 4
05v #t
02i 7
04i 6
09o 108
10s ΓεnΣym-113
10s let*
20
0C
0Ao 22
0D
10s ΓεnΣym-113
10s environment*
20
0C
0Ao 8
0D
05v #f
0Bo 31
05v list
10s op
05v macroexpand/do
10s source
12
10s env
04i 2
04i 2
09o 45
10s ΓεnΣym-113
10s quote
20
0Bo 10
10s source
09o 26
05v map
10s source
25v anonymous v [α] v #@[source: [[macroexpand* α env]]] v #{
05v macroexpand*
10s α
10s env
04i 2
01
}
04i 2
16
09o 66
10s ΓεnΣym-112
05v :macro
20
0Bo 31
05v macroexpand*
05v macro-apply
10s op
10s source
12
04i 2
10s env
04i 2
09o 26
05v map
10s source
25v anonymous v [α] v #@[source: [[macroexpand* α env]]] v #{
05v macroexpand*
10s α
10s env
04i 2
01
}
04i 2
16
01
}
0Es macroexpand*
0D
25v macroexpand v [source env] v #@[documentation: "Macroexpand the forms in source" source: ["Macroexpand the forms in source" [macroexpand* source [or env [current-closure]]]]] v #{
05v macroexpand*
10s source
10s env
0C
0Ao 19
0D
05v current-closure
04i 0
0C
0Ao 8
0D
05v #f
04i 2
01
}
0Es macroexpand
01
}#{
24
0Es yield-queue
0D
25v yield v [pred fun] v #@[documentation: "Evaluates FUN once PRED is true" source: ["Evaluates FUN once PRED is true" [set! yield-queue [cons [cons pred fun] yield-queue]] #t]] v #{
10s pred
10s fun
14
10s yield-queue
14
0Fs yield-queue
0D
05v #t
01
}
0Es yield
0D
25v yield-run v [] v #@[documentation: "Executes pending coroutines if their predicate evaluates to #t" source: ["Executes pending coroutines if their predicate evaluates to #t" [def old yield-queue] [set! yield-queue #nil] [for-in [cur old] [if [[car cur]] [[cdr cur]] [set! yield-queue [cons cur yield-queue]]]]]] v #{
10s yield-queue
0Es old
0D
24
0Fs yield-queue
0D
15
10s old
0Es ΓεnΣym-116
0D
10s ΓεnΣym-116
0Bo 74
02i 0
1B
1C
10s ΓεnΣym-116
0Bo 60
0D
10s ΓεnΣym-116
11
0Es cur
0D
10s cur
11
04i 0
0Bo 13
10s cur
12
04i 0
09o 16
10s cur
10s yield-queue
14
0Fs yield-queue
0D
10s ΓεnΣym-116
12
0Fs ΓεnΣym-116
09o -62
09o 4
24
16
01
}
0Es yield-run
0D
25v timeout v [milliseconds] v #@[documentation: "Returns a function that evaluates to true once MILLISECONDS have passed" source: ["Returns a function that evaluates to true once MILLISECONDS have passed" [def goal [+ [time/milliseconds] milliseconds]] [fn [] [> [time/milliseconds] goal]]]] v #{
05v +
05v time/milliseconds
04i 0
10s milliseconds
04i 2
0Es goal
0D
25v anonymous v [] v #@[source: [[> [time/milliseconds] goal]]] v #{
05v time/milliseconds
04i 0
10s goal
22
01
}
01
}
0Es timeout
0D
25v event-bind v [event id handler] v #@[documentation: "Bind handler to be evaluated when event-name fires, overwriting whichever handler has been associated with id before." source: ["Bind handler to be evaluated when event-name fires, overwriting whichever handler has been associated with id before." [tree/set! event id handler]]] v #{
05v tree/set!
10s event
10s id
10s handler
04i 3
01
}
0Es event-bind
0D
26v event-clear v [event] v #@[documentation: "Clears all event handlers for event-name" source: ["Clears all event handlers for event-name" [quasiquote [set! [unquote event] [tree/new #nil]]]]] v #{
23s set!
10s event
23s tree/new
24
24
14
14
24
14
14
14
01
}
0Es event-clear
0D
25v event-fire v [event val] v #@[documentation: "Applies ...val to all event handlers associated with event-name" source: ["Applies ...val to all event handlers associated with event-name" [for-in [h [tree/values event]] [h val]]]] v #{
15
05v tree/values
10s event
04i 1
0Es ΓεnΣym-117
0D
10s ΓεnΣym-117
0Bo 51
02i 0
1B
1C
10s ΓεnΣym-117
0Bo 37
0D
10s ΓεnΣym-117
11
0Es h
0D
10s h
10s val
04i 1
0D
10s ΓεnΣym-117
12
0Fs ΓεnΣym-117
09o -39
09o 4
24
16
01
}
0Es event-fire
01
}#{
25v let/arg v [arg] v #@[source: [[when arg [when [or [not [pair? arg]] [not [symbol? [car arg]]]] [throw [list :invalid-let-form "Please fix the structure of the let form" arg]]] [quasiquote [def [unquote [car arg]] [unquote [cadr arg]]]]]]] v #{
10s arg
0Bo 120
05v pair?
10s arg
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 38
0D
05v symbol?
10s arg
11
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 8
0D
05v #f
0Bo 30
05v throw
05v list
05v :invalid-let-form
05v "Please fix the structure of the let form"
10s arg
04i 3
04i 1
09o 4
24
0D
23s def
10s arg
11
10s arg
12
11
24
14
14
14
09o 4
24
01
}
0Es let/arg
0D
25v let/args v [args] v #@[source: [[if-not args #nil [cons [let/arg [car args]] [let/args [cdr args]]]]]] v #{
10s args
0Bo 29
05v let/arg
10s args
11
04i 1
05v let/args
10s args
12
04i 1
14
09o 4
24
01
}
0Es let/args
0D
26v let v [bindings . body] v #@[documentation: "Evalutes to BODY if PRED is true" source: ["Evalutes to BODY if PRED is true" [quasiquote [let* [do [unquote-splicing [let/args bindings]] [unquote-splicing body]]]]]] v #{
23s let*
23s do
05v append
05v let/args
10s bindings
04i 1
05v append
10s body
24
04i 2
04i 2
14
24
14
14
01
}
0Es let
0D
26v if-let v [binding then else] v #@[source: [[quasiquote [let* [def [unquote [car binding]] [unquote [cadr binding]]] [if [unquote [car binding]] [unquote then] [unquote else]]]]]] v #{
23s let*
23s def
10s binding
11
10s binding
12
11
24
14
14
14
23s if
10s binding
11
10s then
10s else
24
14
14
14
14
24
14
14
14
01
}
0Es if-let
0D
26v when-let v [binding . body] v #@[source: [[quasiquote [if-let [unquote binding] [unquote [cons 'do body]] #nil]]]] v #{
23s if-let
10s binding
23s do
10s body
14
24
24
14
14
14
14
01
}
0Es when-let
01
}#{
05v #t
0Es otherwise
0D
26v comment v body v #@[documentation: "Does nothing" source: ["Does nothing" #nil]] v #{
24
01
}
0Es comment
0D
26v += v [val inc] v #@[source: [[quasiquote [set! [unquote val] [+ [unquote val] [unquote inc]]]]]] v #{
23s set!
10s val
23s +
10s val
10s inc
24
14
14
14
24
14
14
14
01
}
0Es +=
0D
26v cdr! v [l] v #@[documentation: "[set! l [cdr l]]" source: ["[set! l [cdr l]]" [quasiquote [set! [unquote l] [cdr [unquote l]]]]]] v #{
23s set!
10s l
23s cdr
10s l
24
14
14
24
14
14
14
01
}
0Es cdr!
0D
25v not v [v] v #@[documentation: "Return true if V is false" source: [:inline "Return true if V is false" [if v #f #t]] inline: #t] v #{
10s v
0Bo 10
05v #f
09o 7
05v #t
01
}
0Es not
0D
25v identity v [α] v #@[documentation: "Returns its argument" source: [:inline "Returns its argument" α] inline: #t] v #{
10s α
01
}
0Es identity
0D
25v list v arguments v #@[documentation: "Return ARGUMENTS as a list" source: ["Return ARGUMENTS as a list" arguments]] v #{
10s arguments
01
}
0Es list
0D
25v default v [arg default-value] v #@[documentation: "Returns ARG or DEFAULT-VALUE if ARG is #nil" source: ["Returns ARG or DEFAULT-VALUE if ARG is #nil" [if arg arg default-value]]] v #{
10s arg
0Bo 10
10s arg
09o 7
10s default-value
01
}
0Es default
0D
25v caar v [p] v #@[documentation: "[car [car p]]" source: [:inline "[car [car p]]" [car [car p]]] inline: #t] v #{
10s p
11
11
01
}
0Es caar
0D
25v cadr v [p] v #@[documentation: "[car [cdr p]]" source: [:inline "[car [cdr p]]" [car [cdr p]]] inline: #t] v #{
10s p
12
11
01
}
0Es cadr
0D
25v cdar v [p] v #@[documentation: "[cdr [car p]]" source: [:inline "[cdr [car p]]" [cdr [car p]]] inline: #t] v #{
10s p
11
12
01
}
0Es cdar
0D
25v cddr v [p] v #@[documentation: "[cdr [cdr p]]" source: [:inline "[cdr [cdr p]]" [cdr [cdr p]]] inline: #t] v #{
10s p
12
12
01
}
0Es cddr
0D
25v cadar v [p] v #@[documentation: "[cdr [car p]]" source: ["[cdr [car p]]" [car [cdr [car p]]]]] v #{
10s p
11
12
11
01
}
0Es cadar
0D
25v caddr v [p] v #@[documentation: "[car [cdr [cdr p]]]" source: ["[car [cdr [cdr p]]]" [car [cdr [cdr p]]]]] v #{
10s p
12
12
11
01
}
0Es caddr
0D
25v cdddr v [p] v #@[documentation: "[cdr [cdr [cdr p]]]" source: ["[cdr [cdr [cdr p]]]" [cdr [cdr [cdr p]]]]] v #{
10s p
12
12
12
01
}
0Es cdddr
0D
25v cadddr v [p] v #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [car [cdr [cdr [cdr p]]]]]] v #{
10s p
12
12
12
11
01
}
0Es cadddr
0D
25v cddddr v [p] v #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [cdr [cdr [cdr [cdr p]]]]]] v #{
10s p
12
12
12
12
01
}
0Es cddddr
0D
25v caddddr v [p] v #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [car [cdr [cdr [cdr [cdr p]]]]]]] v #{
10s p
12
12
12
12
11
01
}
0Es caddddr
0D
25v cdddddr v [p] v #@[documentation: "[cdr [cdr [cdr [cdr p]]]]" source: ["[cdr [cdr [cdr [cdr p]]]]" [cdr [cdr [cdr [cdr [cdr p]]]]]]] v #{
10s p
12
12
12
12
12
01
}
0Es cdddddr
0D
25v keyword->string v [α] v #@[source: [[when-not [keyword? α] [throw [list :type-error "[keyword->string] can only be called on keywords" α [current-lambda]]]] [sym->str [keyword->symbol α]]]] v #{
05v keyword?
10s α
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "[keyword->string] can only be called on keywords"
10s α
05v current-lambda
04i 0
04i 4
04i 1
0D
05v sym->str
05v keyword->symbol
10s α
04i 1
04i 1
01
}
0Es keyword->string
0D
25v string->keyword v [α] v #@[source: [[when-not [string? α] [throw [list :type-error "[string->keyword] can only be called on strings" α [current-lambda]]]] [symbol->keyword [str->sym α]]]] v #{
05v string?
10s α
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "[string->keyword] can only be called on strings"
10s α
05v current-lambda
04i 0
04i 4
04i 1
0D
05v symbol->keyword
05v str->sym
10s α
04i 1
04i 1
01
}
0Es string->keyword
0D
26v exception v [type description value] v #@[source: [[quasiquote [throw [list [unquote type] [unquote description] [unquote value] [current-lambda]]]]]] v #{
23s throw
23s list
10s type
10s description
10s value
23s current-lambda
24
14
24
14
14
14
14
14
24
14
14
01
}
0Es exception
01
}#{
26v if-not v [pred then else] v #@[source: [[quasiquote [if [unquote pred] [unquote else] [unquote then]]]]] v #{
23s if
10s pred
10s else
10s then
24
14
14
14
14
01
}
0Es if-not
0D
26v when-not v [pred . body] v #@[documentation: "Evalutes to BODY if PRED is false" source: ["Evalutes to BODY if PRED is false" [quasiquote [if [unquote pred] #nil [do [unquote-splicing body]]]]]] v #{
23s if
10s pred
24
23s do
05v append
10s body
24
04i 2
14
24
14
14
14
14
01
}
0Es when-not
0D
26v when v [pred . body] v #@[documentation: "Evalutes to BODY if PRED is true" source: ["Evalutes to BODY if PRED is true" [quasiquote [if [unquote pred] [do [unquote-splicing body]] #nil]]]] v #{
23s if
10s pred
23s do
05v append
10s body
24
04i 2
14
24
24
14
14
14
14
01
}
0Es when
0D
25v case/clauses/multiple v [key-sym cases] v #@[source: [[when cases [cons [list '== key-sym [car cases]] [case/clauses/multiple key-sym [cdr cases]]]]]] v #{
10s cases
0Bo 41
05v list
23s ==
10s key-sym
10s cases
11
04i 3
05v case/clauses/multiple
10s key-sym
10s cases
12
04i 2
14
09o 4
24
01
}
0Es case/clauses/multiple
0D
25v case/clauses v [key-sym clauses] v #@[source: [[when clauses [if [== [caar clauses] 'otherwise] [cons 'do [cdar clauses]] [list 'if [if [pair? [caar clauses]] [if [and [== [car [caar clauses]] 'quote] [last? [cdr [caar clauses]]] [symbol? [cadr [caar clauses]]]] [list '== key-sym [caar clauses]] [cons 'or [case/clauses/multiple key-sym [caar clauses]]]] [list '== key-sym [caar clauses]]] [cons 'do [cdar clauses]] [case/clauses key-sym [cdr clauses]]]]]]] v #{
10s clauses
0Bo 205
10s clauses
11
11
23s otherwise
20
0Bo 17
23s do
10s clauses
11
12
14
09o 174
05v list
23s if
05v pair?
10s clauses
11
11
04i 1
0Bo 103
10s clauses
11
11
11
23s quote
20
0C
0Bo 37
0D
05v nil?
10s clauses
11
11
12
12
04i 1
0C
0Bo 18
0D
05v symbol?
10s clauses
11
11
12
11
04i 1
0Bo 26
05v list
23s ==
10s key-sym
10s clauses
11
11
04i 3
09o 24
23s or
05v case/clauses/multiple
10s key-sym
10s clauses
11
11
04i 2
14
09o 23
05v list
23s ==
10s key-sym
10s clauses
11
11
04i 3
23s do
10s clauses
11
12
14
05v case/clauses
10s key-sym
10s clauses
12
04i 2
04i 4
09o 4
24
01
}
0Es case/clauses
0D
26v case v [key-form . clauses] v #@[source: [[def key-sym [gensym]] [list 'let* [list 'def key-sym key-form] [case/clauses key-sym clauses]]]] v #{
05v gensym
04i 0
0Es key-sym
0D
05v list
23s let*
05v list
23s def
10s key-sym
10s key-form
04i 3
05v case/clauses
10s key-sym
10s clauses
04i 2
04i 3
01
}
0Es case
0D
26v cond v body v #@[documentation: "Contains multiple cond clauses" source: ["Contains multiple cond clauses" [when [and body [caar body]] [list 'if [caar body] [cons 'do [cdar body]] [macro-apply cond [cdr body]]]]]] v #{
10s body
0C
0Bo 10
0D
10s body
11
11
0Bo 48
05v list
23s if
10s body
11
11
23s do
10s body
11
12
14
05v macro-apply
10s cond
10s body
12
04i 2
04i 4
09o 4
24
01
}
0Es cond
0D
26v for v [for-loop . body] v #@[documentation: "For loops, [for [name start stop] body]" source: ["For loops, [for [name start stop] body]" [def symbol-name [car for-loop]] [def loop-start [cadr for-loop]] [def loop-stop [caddr for-loop]] [def stop-var [gensym]] [def dir 1] [when [cadddr for-loop] [set! dir [cadddr for-loop]]] [when-not [symbol? symbol-name] [throw [list :invalid-for "Expected a symbol name within the for loop" symbol-name]]] [when-not loop-start [throw [list :invalid-for "Expected a start value at the second position" for-loop]]] [when-not loop-stop [throw [list :invalid-for "Expected a stop value at the third position" for-loop]]] [def pred [if [> dir 0] < >]] [quasiquote [let [[[unquote symbol-name] [unquote loop-start]] [[unquote stop-var] [unquote loop-stop]]] [while [[unquote pred] [unquote symbol-name] [unquote stop-var]] [unquote-splicing body] [set! [unquote symbol-name] [add/int [unquote dir] [unquote symbol-name]]]]]]]] v #{
10s for-loop
11
0Es symbol-name
0D
10s for-loop
12
11
0Es loop-start
0D
05v caddr
10s for-loop
04i 1
0Es loop-stop
0D
05v gensym
04i 0
0Es stop-var
0D
02i 1
0Es dir
0D
05v cadddr
10s for-loop
04i 1
0Bo 20
05v cadddr
10s for-loop
04i 1
0Fs dir
09o 4
24
0D
05v symbol?
10s symbol-name
04i 1
0Bo 7
24
09o 27
05v throw
05v list
05v :invalid-for
05v "Expected a symbol name within the for loop"
10s symbol-name
04i 3
04i 1
0D
10s loop-start
0Bo 7
24
09o 27
05v throw
05v list
05v :invalid-for
05v "Expected a start value at the second position"
10s for-loop
04i 3
04i 1
0D
10s loop-stop
0Bo 7
24
09o 27
05v throw
05v list
05v :invalid-for
05v "Expected a stop value at the third position"
10s for-loop
04i 3
04i 1
0D
10s dir
02i 0
22
0Bo 10
10s <
09o 7
10s >
0Es pred
0D
23s let
10s symbol-name
10s loop-start
24
14
14
10s stop-var
10s loop-stop
24
14
14
24
14
14
23s while
10s pred
10s symbol-name
10s stop-var
24
14
14
14
05v append
10s body
23s set!
10s symbol-name
23s add/int
10s dir
10s symbol-name
24
14
14
14
24
14
14
14
24
14
04i 2
14
14
24
14
14
14
01
}
0Es for
0D
26v for-in v [for-loop . body] v #@[documentation: "[for-in [l [list 1 2 3 4]] [println l]]" source: ["[for-in [l [list 1 2 3 4]] [println l]]" [def symbol-name [gensym]] [quasiquote [let [[[unquote symbol-name] [unquote [cadr for-loop]]]] [when [unquote symbol-name] [while [unquote symbol-name] [def [unquote [car for-loop]] [car [unquote symbol-name]]] [unquote-splicing body] [cdr! [unquote symbol-name]]]]]]]] v #{
05v gensym
04i 0
0Es symbol-name
0D
23s let
10s symbol-name
10s for-loop
12
11
24
14
14
24
14
23s when
10s symbol-name
23s while
10s symbol-name
23s def
10s for-loop
11
23s car
10s symbol-name
24
14
14
24
14
14
14
05v append
10s body
23s cdr!
10s symbol-name
24
14
14
24
14
04i 2
14
14
14
24
14
14
14
24
14
14
14
01
}
0Es for-in
0D
25v thread/-> v [init fun] v #@[source: [[if-not fun init [if [pair? [car fun]] [quasiquote [[unquote [caar fun]] [unquote [thread/-> init [cdr fun]]] [unquote-splicing [cdar fun]]]] [list [car fun] [thread/-> init [cdr fun]]]]]]] v #{
10s fun
0Bo 85
05v pair?
10s fun
11
04i 1
0Bo 42
10s fun
11
11
05v thread/->
10s init
10s fun
12
04i 2
05v append
10s fun
11
12
24
04i 2
14
14
09o 29
05v list
10s fun
11
05v thread/->
10s init
10s fun
12
04i 2
04i 2
09o 7
10s init
01
}
0Es thread/->
0D
26v -> v [init . fun] v #@[documentation: "Thread init as the first argument through every function in fun" source: ["Thread init as the first argument through every function in fun" [thread/-> init [reverse fun]]]] v #{
05v thread/->
10s init
05v reverse
10s fun
04i 1
04i 2
01
}
0Es ->
0D
25v thread/->> v [init fun] v #@[source: [[if-not fun init [append [car fun] [cons [thread/->> init [cdr fun]] #nil]]]]] v #{
10s fun
0Bo 34
05v append
10s fun
11
05v thread/->>
10s init
10s fun
12
04i 2
24
14
04i 2
09o 7
10s init
01
}
0Es thread/->>
0D
26v ->> v [init . fun] v #@[documentation: "Thread init as the last argument through every function in fun" source: ["Thread init as the last argument through every function in fun" [thread/->> init [reverse fun]]]] v #{
05v thread/->>
10s init
05v reverse
10s fun
04i 1
04i 2
01
}
0Es ->>
01
}#{
25v numeric? v [a] v #@[documentation: "Return #t if a is a number" source: ["Return #t if a is a number" [or [int? a] [float? a] [vec? a]]]] v #{
05v int?
10s a
04i 1
0C
0Ao 38
0D
05v float?
10s a
04i 1
0C
0Ao 23
0D
05v vec?
10s a
04i 1
0C
0Ao 8
0D
05v #f
01
}
0Es numeric?
0D
25v last? v [a] v #@[documentation: "Return #t if a is the last pair in a list" source: [:inline "Return #t if a is the last pair in a list" [nil? [cdr a]]] inline: #t] v #{
05v nil?
10s a
12
04i 1
01
}
0Es last?
0D
25v pos? v [a] v #@[documentation: "Return #t if a is positive" source: [:inline "Return #t if a is positive" [>= a 0.0]] inline: #t] v #{
10s a
05v 0.0
21
01
}
0Es pos?
0D
25v zero-neg? v [a] v #@[documentation: "Return #t if a is zero or negative" source: [:inline "Return #t if a is zero or negative" [<= a 0.0]] inline: #t] v #{
10s a
05v 0.0
1F
01
}
0Es zero-neg?
0D
25v neg? v [a] v #@[documentation: "Returns #t if a is negative" source: [:inline "Returns #t if a is negative" [< a 0.0]] inline: #t] v #{
10s a
05v 0.0
1E
01
}
0Es neg?
0D
25v odd? v [a] v #@[documentation: "Predicate that returns #t if a is odd" source: ["Predicate that returns #t if a is odd" [== [% [int a] 2] 1]]] v #{
05v %
05v int
10s a
04i 1
02i 2
04i 2
02i 1
20
01
}
0Es odd?
0D
25v even? v [a] v #@[documentation: "Predicate that returns #t if a is even" source: ["Predicate that returns #t if a is even" [== [mod/int [int a] 2] 0]]] v #{
05v mod/int
05v int
10s a
04i 1
02i 2
04i 2
02i 0
20
01
}
0Es even?
0D
25v zero? v [val] v #@[documentation: "#t if VAL is zero" source: [:inline "#t if VAL is zero" [== 0 val]] inline: #t] v #{
02i 0
10s val
20
01
}
0Es zero?
0D
25v not-zero? v [val] v #@[documentation: "#t if VAL is not zero" source: [:inline "#t if VAL is not zero" [!= 0 val]] inline: #t] v #{
05v !=
02i 0
10s val
04i 2
01
}
0Es not-zero?
0D
25v equal? v [a b] v #@[documentation: "High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." source: ["High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." [def cur-type [type-of a]] [if [!= cur-type [type-of b]] #f [case cur-type [:array [array/equal? a b]] [:tree [tree/equal? a b]] [:pair [list/equal? a b]] [otherwise [== a b]]]]]] v #{
05v type-of
10s a
04i 1
0Es cur-type
0D
05v !=
10s cur-type
05v type-of
10s b
04i 1
04i 2
0Bo 10
05v #f
09o 110
15
10s cur-type
0Es ΓεnΣym-119
0D
10s ΓεnΣym-119
05v :array
20
0Bo 20
05v array/equal?
10s a
10s b
04i 2
09o 70
10s ΓεnΣym-119
05v :tree
20
0Bo 20
05v tree/equal?
10s a
10s b
04i 2
09o 41
10s ΓεnΣym-119
05v :pair
20
0Bo 20
05v list/equal?
10s a
10s b
04i 2
09o 12
10s a
10s b
20
16
01
}
0Es equal?
0D
25v inequal? v [a b] v #@[documentation: "High level inequality comparator" source: ["High level inequality comparator" [not [equal? a b]]]] v #{
05v equal?
10s a
10s b
04i 2
0Bo 10
05v #f
09o 7
05v #t
01
}
0Es inequal?
0D
25v int? v [val] v #@[documentation: "#t if VAL is a integer" source: ["#t if VAL is a integer" [== :int [type-of val]]]] v #{
05v :int
05v type-of
10s val
04i 1
20
01
}
0Es int?
0D
25v float? v [val] v #@[documentation: "#t if VAL is a floating-point number" source: ["#t if VAL is a floating-point number" [== :float [type-of val]]]] v #{
05v :float
05v type-of
10s val
04i 1
20
01
}
0Es float?
0D
25v vec? v [val] v #@[documentation: "#t if VAL is a vector" source: ["#t if VAL is a vector" [== :vec [type-of val]]]] v #{
05v :vec
05v type-of
10s val
04i 1
20
01
}
0Es vec?
0D
25v bool? v [val] v #@[documentation: "#t if VAL is a boolean" source: ["#t if VAL is a boolean" [== :bool [type-of val]]]] v #{
05v :bool
05v type-of
10s val
04i 1
20
01
}
0Es bool?
0D
25v pair? v [val] v #@[documentation: "#t if VAL is a pair" source: ["#t if VAL is a pair" [== :pair [type-of val]]]] v #{
05v :pair
05v type-of
10s val
04i 1
20
01
}
0Es pair?
0D
25v array? v [val] v #@[documentation: "#t if VAL is an array" source: ["#t if VAL is an array" [== :array [type-of val]]]] v #{
05v :array
05v type-of
10s val
04i 1
20
01
}
0Es array?
0D
25v string? v [val] v #@[documentation: "#t if VAL is a string" source: ["#t if VAL is a string" [== :string [type-of val]]]] v #{
05v :string
05v type-of
10s val
04i 1
20
01
}
0Es string?
0D
25v symbol? v [val] v #@[documentation: "#t if VAL is a symbol" source: ["#t if VAL is a symbol" [== :symbol [type-of val]]]] v #{
05v :symbol
05v type-of
10s val
04i 1
20
01
}
0Es symbol?
0D
25v object? v [val] v #@[documentation: "#t if VAL is an object" source: ["#t if VAL is an object" [== :object [type-of val]]]] v #{
05v :object
05v type-of
10s val
04i 1
20
01
}
0Es object?
0D
25v tree? v [val] v #@[documentation: "#t if VAL is an object" source: ["#t if VAL is an object" [== :tree [type-of val]]]] v #{
05v :tree
05v type-of
10s val
04i 1
20
01
}
0Es tree?
0D
25v macro? v [val] v #@[documentation: "#t if VAL is an object" source: ["#t if VAL is an object" [== :macro [type-of val]]]] v #{
05v :macro
05v type-of
10s val
04i 1
20
01
}
0Es macro?
0D
25v lambda? v [val] v #@[documentation: "#t if VAL is a lambda" source: ["#t if VAL is a lambda" [or [== :lambda [type-of val]]]]] v #{
05v :lambda
05v type-of
10s val
04i 1
20
0C
0Ao 8
0D
05v #f
01
}
0Es lambda?
0D
25v native? v [val] v #@[documentation: "#t if VAL is a native function" source: ["#t if VAL is a native function" [== :native-function [type-of val]]]] v #{
05v :native-function
05v type-of
10s val
04i 1
20
01
}
0Es native?
0D
25v procedure? v [val] v #@[documentation: "#t if VAL is a native or lisp function" source: ["#t if VAL is a native or lisp function" [or [lambda? val] [native? val]]]] v #{
05v lambda?
10s val
04i 1
0C
0Ao 23
0D
05v native?
10s val
04i 1
0C
0Ao 8
0D
05v #f
01
}
0Es procedure?
0D
25v bytecode-array? v [v] v #@[source: [[== :bytecode-array [type-of v]]]] v #{
05v :bytecode-array
05v type-of
10s v
04i 1
20
01
}
0Es bytecode-array?
0D
25v bytecode-op? v [v] v #@[source: [[== :bytecode-op [type-of v]]]] v #{
05v :bytecode-op
05v type-of
10s v
04i 1
20
01
}
0Es bytecode-op?
0D
25v in-range? v [v min max] v #@[source: [[and [>= v min] [<= v max]]]] v #{
10s v
10s min
21
0C
0Bo 13
0D
10s v
10s max
1F
01
}
0Es in-range?
01
}#{
25v quasiquote-real v [l depth] v #@[source: [[if [nil? l] #nil [if [pair? l] [if [== [caar l] 'unquote-splicing] [if [zero? depth] [list 'append [cadr [car l]] [quasiquote-real [cdr l] depth]] [list 'unquote-splicing [quasiquote-real [cadr l] [+ -1 depth]]]] [if [== [car l] 'unquote] [if [zero? depth] [cadr l] [list 'unquote [quasiquote-real [cadr l] [+ -1 depth]]]] [if [== [car l] 'quasiquote] [quasiquote-real [quasiquote-real [cadr l] [+ 1 depth]] depth] [if [zero? depth] [list 'cons [quasiquote-real [car l] depth] [quasiquote-real [cdr l] depth]] [cons [quasiquote-real [car l] depth] [quasiquote-real [cdr l] depth]]]]]] [if [and [zero? depth] [symbol? l]] [cons 'quote [cons l #nil]] l]]]]] v #{
05v nil?
10s l
04i 1
0Bo 7
24
09o 361
05v pair?
10s l
04i 1
0Bo 305
10s l
11
11
23s unquote-splicing
20
0Bo 85
02i 0
10s depth
20
0Bo 38
05v list
23s append
10s l
11
12
11
05v quasiquote-real
10s l
12
10s depth
04i 2
04i 3
09o 37
05v list
23s unquote-splicing
05v quasiquote-real
10s l
12
11
05v +
02i -1
10s depth
04i 2
04i 2
04i 2
09o 206
10s l
11
23s unquote
20
0Bo 59
02i 0
10s depth
20
0Bo 12
10s l
12
11
09o 37
05v list
23s unquote
05v quasiquote-real
10s l
12
11
05v +
02i -1
10s depth
04i 2
04i 2
04i 2
09o 137
10s l
11
23s quasiquote
20
0Bo 40
05v quasiquote-real
05v quasiquote-real
10s l
12
11
05v +
02i 1
10s depth
04i 2
04i 2
10s depth
04i 2
09o 87
02i 0
10s depth
20
0Bo 46
05v list
23s cons
05v quasiquote-real
10s l
11
10s depth
04i 2
05v quasiquote-real
10s l
12
10s depth
04i 2
04i 3
09o 34
05v quasiquote-real
10s l
11
10s depth
04i 2
05v quasiquote-real
10s l
12
10s depth
04i 2
14
09o 46
02i 0
10s depth
20
0C
0Bo 14
0D
05v symbol?
10s l
04i 1
0Bo 17
23s quote
10s l
24
14
14
09o 7
10s l
01
}
0Es quasiquote-real
0D
26v quasiquote v [l] v #@[source: [[quasiquote-real l 0]]] v #{
05v quasiquote-real
10s l
02i 0
04i 2
01
}
0Es quasiquote
0D
25v unquote v [expr] v #@[source: [[throw [list :unquote-without-quasiquote "unquote should only occur inside a quasiquote, never evaluated directly"]]]] v #{
05v throw
05v list
05v :unquote-without-quasiquote
05v "unquote should only occur inside a quasiquote, never evaluated directly"
04i 2
04i 1
01
}
0Es unquote
0D
25v unquote-splicing v [expr] v #@[source: [[throw [list :unquote-splicing-without-quasiq "unquote-splicing should only occur inside a quasiquote, never evaluated directly"]]]] v #{
05v throw
05v list
05v :unquote-splicing-without-quasiq
05v "unquote-splicing should only occur inside a quasiquote, never evaluated directly"
04i 2
04i 1
01
}
0Es unquote-splicing
01
}#{
25v describe/closure v [c i] v #@[source: [[when c [if [== c root-closure] [cat [ansi-blue [cat [int [or i 0]] "# <root environment>"]] "\r\n"] [do [def info [closure c]] [when info [def data [ref info :data]] [def l [length data]] [cat [ansi-blue [cat [int [or i 0]] "# " [str/write c]]] " - " [if [< l 16] [str/write data] "-+- Very big tree structure -+-"] "\r\n" [describe/closure [closure/caller c] [+ [int [or i 0]] 1]]]]]]]]] v #{
10s c
0Bo 276
10s c
10s root-closure
20
0Bo 58
05v cat
05v ansi-blue
05v cat
05v int
10s i
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
04i 1
05v "# <root environment>"
04i 2
04i 1
05v "\r\n"
04i 2
09o 206
05v closure
10s c
04i 1
0Es info
0D
10s info
0Bo 183
05v ref
10s info
05v :data
04i 2
0Es data
0D
05v length
10s data
04i 1
0Es l
0D
05v cat
05v ansi-blue
05v cat
05v int
10s i
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
04i 1
05v "# "
05v str/write
10s c
04i 1
04i 3
04i 1
05v " - "
10s l
02i 16
1E
0Bo 16
05v str/write
10s data
04i 1
09o 7
05v "-+- Very big tree structure -+-"
05v "\r\n"
05v describe/closure
05v closure/caller
10s c
04i 1
05v +
05v int
10s i
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
04i 1
02i 1
04i 2
04i 2
04i 5
09o 4
24
09o 4
24
01
}
0Es describe/closure
0D
25v stacktrace v [] v #@[source: [[display [describe/closure [closure/caller [current-lambda]]]]]] v #{
05v print
05v describe/closure
05v closure/caller
05v current-lambda
04i 0
04i 1
04i 1
04i 1
01
}
0Es stacktrace
01
}#{
25v time/seconds v [timestamp] v #@[documentation: "Return the seconds part of TIMESTAMP, defaults to current time" source: ["Return the seconds part of TIMESTAMP, defaults to current time" [% [default timestamp [time]] 60]]] v #{
05v %
05v default
10s timestamp
05v time
04i 0
04i 2
02i 60
04i 2
01
}
0Es time/seconds
0D
25v time/minutes v [timestamp] v #@[documentation: "Return the minutes part of TIMESTAMP, defaults to current time" source: ["Return the minutes part of TIMESTAMP, defaults to current time" [% [/ [default timestamp [time]] 60] 60]]] v #{
05v %
05v /
05v default
10s timestamp
05v time
04i 0
04i 2
02i 60
04i 2
02i 60
04i 2
01
}
0Es time/minutes
0D
25v time/hours v [timestamp] v #@[documentation: "Return the hours part of TIMESTAMP, defaults to current time" source: ["Return the hours part of TIMESTAMP, defaults to current time" [% [/ [default timestamp [time]] 3600] 24]]] v #{
05v %
05v /
05v default
10s timestamp
05v time
04i 0
04i 2
05v 3600
04i 2
02i 24
04i 2
01
}
0Es time/hours
0D
25v profile-form v [raw] v #@[source: [[def start-time [time/milliseconds]] [def val [eval raw]] [def end-time [time/milliseconds]] [display [cat "Evaluating " [ansi-yellow [str/write raw]] " to " [ansi-green [str/write val]] " took " [ansi-red [cat [- end-time start-time] "ms"] "\n"]]]]] v #{
05v time/milliseconds
04i 0
0Es start-time
0D
05v eval-in
05v current-closure
04i 0
10s raw
04i 2
0Es val
0D
05v time/milliseconds
04i 0
0Es end-time
0D
05v print
05v cat
05v "Evaluating "
05v ansi-yellow
05v str/write
10s raw
04i 1
04i 1
05v " to "
05v ansi-green
05v str/write
10s val
04i 1
04i 1
05v " took "
05v ansi-red
05v cat
05v -
10s end-time
10s start-time
04i 2
05v "ms"
04i 2
05v "\n"
04i 2
04i 6
04i 1
01
}
0Es profile-form
0D
26v profile v body v #@[documentation: "Measure and display how much time and ressources it takes for BODY to be evaluated" source: ["Measure and display how much time and ressources it takes for BODY to be evaluated" [quasiquote [profile-form '[unquote [if [last? body] [car body] [cons 'do body]]]]]]] v #{
23s profile-form
23s quote
05v nil?
10s body
12
04i 1
0Bo 11
10s body
11
09o 12
23s do
10s body
14
24
14
14
24
14
14
01
}
0Es profile
01
}#{
25v hash/adler32 v [data] v #@[source: [[def a 1] [def b 0] [for [i 0 [string/length data]] [set! a [mod/int [add/int a [char-at data i]] 65521]] [set! b [mod/int [add/int a b] 65521]]] [logior a [ash b 16]]]] v #{
02i 1
0Es a
0D
02i 0
0Es b
0D
15
02i 0
0Es i
0D
05v string/length
10s data
04i 1
0Es ΓεnΣym-121
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-121
1E
0Bo 76
0D
05v mod/int
10s a
05v char-at
10s data
10s i
04i 2
03
05v 65521
04i 2
0Fs a
0D
05v mod/int
10s a
10s b
03
05v 65521
04i 2
0Fs b
0D
02i 1
10s i
03
0Fs i
09o -83
16
0D
05v logior
10s a
05v ash
10s b
02i 16
04i 2
04i 2
01
}
0Es hash/adler32
01
}#{
05v 3.14159
0Es PI
0D
05v 3.14159
0Es π
0D
26v ++ v [i] v #@[documentation: "Increment I by 1 and store the result in I" source: ["Increment I by 1 and store the result in I" [quasiquote [set! [unquote i] [+ 1 [unquote i]]]]]] v #{
23s set!
10s i
23s +
02i 1
10s i
24
14
14
14
24
14
14
14
01
}
0Es ++
0D
26v -- v [i] v #@[documentation: "Decrement I by 1 and store the result in I" source: ["Decrement I by 1 and store the result in I" [quasiquote [set! [unquote i] [+ -1 [unquote i]]]]]] v #{
23s set!
10s i
23s +
02i -1
10s i
24
14
14
14
24
14
14
14
01
}
0Es --
0D
25v +x v [α] v #@[documentation: "Return a function that adds α to it's argument, useful for mapping" source: ["Return a function that adds α to it's argument, useful for mapping" [fn [β] [+ α β]]]] v #{
25v anonymous v [β] v #@[source: [[+ α β]]] v #{
05v +
10s α
10s β
04i 2
01
}
01
}
0Es +x
0D
25v >> v [val amount] v #@[documentation: "Shifts VAL by AMOUNT bits to the right" source: ["Shifts VAL by AMOUNT bits to the right" [ash val [- amount]]]] v #{
05v ash
10s val
05v -
10s amount
04i 1
04i 2
01
}
0Es >>
0D
25v fib v [i] v #@[documentation: "Terribly inefficient, but, useful for testing the GC" source: ["Terribly inefficient, but, useful for testing the GC" [if [< i 2] i [+ [fib [- i 2]] [fib [- i 1]]]]]] v #{
10s i
02i 2
1E
0Bo 10
10s i
09o 45
05v +
05v fib
05v -
10s i
02i 2
04i 2
04i 1
05v fib
05v -
10s i
02i 1
04i 2
04i 1
04i 2
01
}
0Es fib
0D
25v wrap-value v [val min max] v #@[documentation: "Constrains VAL to be within MIN and MAX, wrapping it around" source: ["Constrains VAL to be within MIN and MAX, wrapping it around" [+ min [% [- val min] [- max min]]]]] v #{
05v +
10s min
05v %
05v -
10s val
10s min
04i 2
05v -
10s max
10s min
04i 2
04i 2
04i 2
01
}
0Es wrap-value
0D
26v +1 v [v] v #@[source: [[quasiquote [+ 1 [unquote v]]]]] v #{
23s +
02i 1
10s v
24
14
14
14
01
}
0Es +1
0D
25v radians v [degrees] v #@[documentation: "Convert a quantity in degrees to radians" source: ["Convert a quantity in degrees to radians" [/ [* π degrees] 180.0]]] v #{
05v /
05v *
10s π
10s degrees
04i 2
05v 180.0
04i 2
01
}
0Es radians
01
}#{
25v display/error/wrap v [i text] v #@[source: [[case i [0 [ansi-red text]] [1 [string text]] [2 [ansi-yellow [str/write text]]] [3 [describe/closure text]] [otherwise text]]]] v #{
15
10s i
0Es ΓεnΣym-123
0D
10s ΓεnΣym-123
02i 0
20
0Bo 16
05v ansi-red
10s text
04i 1
09o 82
10s ΓεnΣym-123
02i 1
20
0Bo 16
05v string
10s text
04i 1
09o 59
10s ΓεnΣym-123
02i 2
20
0Bo 22
05v ansi-yellow
05v str/write
10s text
04i 1
04i 1
09o 30
10s ΓεnΣym-123
02i 3
20
0Bo 16
05v describe/closure
10s text
04i 1
09o 7
10s text
16
01
}
0Es display/error/wrap
0D
25v display/error/iter v [error i] v #@[source: [[if error [cons [display/error/wrap i [car error]] [display/error/iter [cdr error] [+ 1 i]]] [cons "" #nil]]]] v #{
10s error
0Bo 45
05v display/error/wrap
10s i
10s error
11
04i 2
05v display/error/iter
10s error
12
05v +
02i 1
10s i
04i 2
04i 2
14
09o 9
05v ""
24
14
01
}
0Es display/error/iter
0D
25v display/error v [error] v #@[documentation: "Display ERROR in a nice, human readable way" source: ["Display ERROR in a nice, human readable way" [display [join [display/error/iter error 0] "\r\n"]]]] v #{
05v print
05v join
05v display/error/iter
10s error
02i 0
04i 2
05v "\r\n"
04i 2
04i 1
01
}
0Es display/error
0D
25v closure/arguments v [o] v #@[source: [[ref [closure o] :arguments]]] v #{
05v ref
05v closure
10s o
04i 1
05v :arguments
04i 2
01
}
0Es closure/arguments
0D
25v closure/documentation v [o] v #@[source: [[closure/meta o :documentation]]] v #{
05v closure/meta
10s o
05v :documentation
04i 2
01
}
0Es closure/documentation
0D
25v describe/thing v [o] v #@[documentation: "Describe a specific value O" source: ["Describe a specific value O" [def documentation [closure/documentation o]] [def arguments [closure/arguments o]] [fmt "{arguments:?} - {documentation}"]]] v #{
05v closure/documentation
10s o
04i 1
0Es documentation
0D
05v closure/arguments
10s o
04i 1
0Es arguments
0D
05v cat
05v str/write
10s arguments
04i 1
05v " - "
10s documentation
04i 3
01
}
0Es describe/thing
0D
25v describe/string v [a] v #@[documentation: "Descibe whatever value string A resolves to" source: ["Descibe whatever value string A resolves to" [describe/thing [resolve [str->sym a]]]]] v #{
05v describe/thing
05v resolve
05v str->sym
10s a
04i 1
04i 1
04i 1
01
}
0Es describe/string
0D
25v describe v [fun] v #@[documentation: "Describe FUN, if there is documentation available" source: ["Describe FUN, if there is documentation available" [if [string? fun] [describe/string fun] [describe/thing fun]]]] v #{
05v string?
10s fun
04i 1
0Bo 16
05v describe/string
10s fun
04i 1
09o 13
05v describe/thing
10s fun
04i 1
01
}
0Es describe
0D
25v symbol-table v [off len environment] v #@[documentation: "Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" source: ["Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" [when-not environment [set! environment root-closure]] [when-not off [set! off 0]] [when-not len [set! len 9999999]] [sublist [eval-in environment '[symbol-table*]] off [+ off len] #nil]]] v #{
10s environment
0Bo 7
24
09o 11
10s root-closure
0Fs environment
0D
10s off
0Bo 7
24
09o 9
02i 0
0Fs off
0D
10s len
0Bo 7
24
09o 11
05v 9999999
0Fs len
0D
05v sublist
05v eval-in
10s environment
05v [symbol-table*]
04i 2
10s off
05v +
10s off
10s len
04i 2
24
04i 4
01
}
0Es symbol-table
0D
02i 0
0Es gensym/counter
0D
25v gensym v [prefix] v #@[source: [[++ gensym/counter] [str->sym [cat prefix "ΓεnΣym-" gensym/counter]]]] v #{
05v +
02i 1
10s gensym/counter
04i 2
0Fs gensym/counter
0D
05v str->sym
05v cat
10s prefix
05v "ΓεnΣym-"
10s gensym/counter
04i 3
04i 1
01
}
0Es gensym
0D
05v current-closure
04i 0
0Es root-closure
01
}#{
02i 0
0Es random/seed
0D
25v random/seed-initialize! v [] v #@[source: [[set! random/seed [logxor [time] [time/milliseconds]]]]] v #{
05v logxor
05v time
04i 0
05v time/milliseconds
04i 0
04i 2
0Fs random/seed
01
}
0Es random/seed-initialize!
0D
25v random/rng! v [] v #@[source: [[set! random/seed [+ 12345 [* random/seed 1103515245]]] [logior [ash [logand random/seed 65535] 16] [logand [ash random/seed -16] 65535]]]] v #{
05v +
05v 12345
05v *
10s random/seed
05v 1103515245
04i 2
04i 2
0Fs random/seed
0D
05v logior
05v ash
05v logand
10s random/seed
05v 65535
04i 2
02i 16
04i 2
05v logand
05v ash
10s random/seed
02i -16
04i 2
05v 65535
04i 2
04i 2
01
}
0Es random/rng!
0D
25v random/seed! v [new-seed] v #@[documentation: "Set a new seed value for the RNG" source: ["Set a new seed value for the RNG" [set! seed new-seed]]] v #{
10s new-seed
0Fs seed
01
}
0Es random/seed!
0D
25v random/seed v [] v #@[documentation: "Return the current RNG seed value" source: ["Return the current RNG seed value" seed]] v #{
10s seed
01
}
0Es random/seed
0D
25v random v [max] v #@[documentation: "Return a value from 0 to MAX, or, if left out, a random int" source: ["Return a value from 0 to MAX, or, if left out, a random int" [if [numeric? max] [% [abs [random/rng!]] max] [random/rng!]]]] v #{
05v numeric?
10s max
04i 1
0Bo 28
05v %
05v abs
05v random/rng!
04i 0
04i 1
10s max
04i 2
09o 9
05v random/rng!
04i 0
01
}
0Es random
0D
05v random/seed-initialize!
04i 0
01
}#{
25v tree->json v [v] v #@[documentation: "Converts a tree into a JSON encoded string, you should prefer VAL->JSON" source: ["Converts a tree into a JSON encoded string, you should prefer VAL->JSON" [cat "{" [join [map [tree/keys v] [fn [k] [cat "\"" [keyword->string k] "\": " [val->json [tree/ref v k]]]]] ",\n"] "}"]]] v #{
05v cat
05v "{"
05v join
05v map
05v tree/keys
10s v
04i 1
25v anonymous v [k] v #@[source: [[cat "\"" [keyword->string k] "\": " [val->json [tree/ref v k]]]]] v #{
05v cat
05v "\""
05v keyword->string
10s k
04i 1
05v "\": "
05v val->json
05v tree/ref
10s v
10s k
04i 2
04i 1
04i 4
01
}
04i 2
05v ",\n"
04i 2
05v "}"
04i 3
01
}
0Es tree->json
0D
25v val->json v [v] v #@[documentation: "Return V as a JSON encoded string" source: ["Return V as a JSON encoded string" [case [type-of v] [:nil "null"] [[:int :float] [string v]] [:bool [if v "true" "false"]] [[:array :pair] [cat "[" [join [map v val->json] ","] "]"]] [:string [str/write v]] [:symbol [cat "\"" [sym->str v] "\""]] [:keyword [cat "\"" [keyword->string v] "\""]] [:tree [tree->json v]] [otherwise [throw [list :type-error "Can't encode the value into JSON" v [current-lambda]]]]]]] v #{
15
05v type-of
10s v
04i 1
0Es ΓεnΣym-125
0D
10s ΓεnΣym-125
05v :nil
20
0Bo 10
05v "null"
09o 318
10s ΓεnΣym-125
05v :int
20
0C
0Ao 22
0D
10s ΓεnΣym-125
05v :float
20
0C
0Ao 8
0D
05v #f
0Bo 16
05v string
10s v
04i 1
09o 270
10s ΓεnΣym-125
05v :bool
20
0Bo 24
10s v
0Bo 10
05v "true"
09o 7
05v "false"
09o 237
10s ΓεnΣym-125
05v :array
20
0C
0Ao 22
0D
10s ΓεnΣym-125
05v :pair
20
0C
0Ao 8
0D
05v #f
0Bo 44
05v cat
05v "["
05v join
05v map
10s v
10s val->json
04i 2
05v ","
04i 2
05v "]"
04i 3
09o 161
10s ΓεnΣym-125
05v :string
20
0Bo 16
05v str/write
10s v
04i 1
09o 136
10s ΓεnΣym-125
05v :symbol
20
0Bo 30
05v cat
05v "\""
05v sym->str
10s v
04i 1
05v "\""
04i 3
09o 97
10s ΓεnΣym-125
05v :keyword
20
0Bo 30
05v cat
05v "\""
05v keyword->string
10s v
04i 1
05v "\""
04i 3
09o 58
10s ΓεnΣym-125
05v :tree
20
0Bo 16
05v tree->json
10s v
04i 1
09o 33
05v throw
05v list
05v :type-error
05v "Can't encode the value into JSON"
10s v
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es val->json
01
}#{
05v #f
0Es ansi/disabled
0D
05v "\e[0m"
0Es ansi-reset
0D
05v "\e[0;39m"
0Es ansi-fg-reset
0D
05v "\e[49m"
0Es ansi-bg-reset
0D
05v array/new
05v "\e[0;30m"
05v "\e[0;31m"
05v "\e[0;32m"
05v "\e[0;33m"
05v "\e[0;34m"
05v "\e[0;35m"
05v "\e[0;36m"
05v "\e[0;37m"
05v "\e[1;30m"
05v "\e[1;31m"
05v "\e[1;32m"
05v "\e[1;33m"
05v "\e[1;34m"
05v "\e[1;35m"
05v "\e[1;36m"
05v "\e[1;37m"
04i 16
0Es ansi-fg
0D
05v "\e[0m"
0Es ansi-reset
0D
05v array/new
05v "\e[40m"
05v "\e[41m"
05v "\e[42m"
05v "\e[43m"
05v "\e[44m"
05v "\e[45m"
05v "\e[46m"
05v "\e[47m"
04i 8
0Es ansi-bg
0D
25v ansi-wrap v [code string] v #@[documentation: "Wrap STRING in the ansi color CODE" source: ["Wrap STRING in the ansi color CODE" [cat [or ansi/disabled [array/ref ansi-fg code]] string [or ansi/disabled ansi-reset]]]] v #{
05v cat
10s ansi/disabled
0C
0Ao 27
0D
05v array/ref
10s ansi-fg
10s code
04i 2
0C
0Ao 8
0D
05v #f
10s string
10s ansi/disabled
0C
0Ao 17
0D
10s ansi-reset
0C
0Ao 8
0D
05v #f
04i 3
01
}
0Es ansi-wrap
0D
25v ansi-black v args v #@[documentation: "Wrap ARGS in black" source: ["Wrap ARGS in black" [ansi-wrap 0 [apply cat args]]]] v #{
05v ansi-wrap
02i 0
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-black
0D
25v ansi-dark-red v args v #@[documentation: "Wrap ARGS in dark red" source: ["Wrap ARGS in dark red" [ansi-wrap 1 [apply cat args]]]] v #{
05v ansi-wrap
02i 1
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-dark-red
0D
25v ansi-dark-green v args v #@[documentation: "Wrap ARGS in dark green" source: ["Wrap ARGS in dark green" [ansi-wrap 2 [apply cat args]]]] v #{
05v ansi-wrap
02i 2
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-dark-green
0D
25v ansi-brown v args v #@[documentation: "Wrap ARGS in brown" source: ["Wrap ARGS in brown" [ansi-wrap 3 [apply cat args]]]] v #{
05v ansi-wrap
02i 3
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-brown
0D
25v ansi-dark-blue v args v #@[documentation: "Wrap ARGS in dark blue" source: ["Wrap ARGS in dark blue" [ansi-wrap 4 [apply cat args]]]] v #{
05v ansi-wrap
02i 4
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-dark-blue
0D
25v ansi-purple v args v #@[documentation: "Wrap ARGS in purple" source: ["Wrap ARGS in purple" [ansi-wrap 5 [apply cat args]]]] v #{
05v ansi-wrap
02i 5
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-purple
0D
25v ansi-teal v args v #@[documentation: "Wrap ARGS in teal" source: ["Wrap ARGS in teal" [ansi-wrap 6 [apply cat args]]]] v #{
05v ansi-wrap
02i 6
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-teal
0D
25v ansi-dark-gray v args v #@[documentation: "Wrap ARGS in dark gray" source: ["Wrap ARGS in dark gray" [ansi-wrap 7 [apply cat args]]]] v #{
05v ansi-wrap
02i 7
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-dark-gray
0D
25v ansi-gray v args v #@[documentation: "Wrap ARGS in gray" source: ["Wrap ARGS in gray" [ansi-wrap 8 [apply cat args]]]] v #{
05v ansi-wrap
02i 8
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-gray
0D
25v ansi-red v args v #@[documentation: "Wrap ARGS in red" source: ["Wrap ARGS in red" [ansi-wrap 9 [apply cat args]]]] v #{
05v ansi-wrap
02i 9
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-red
0D
25v ansi-green v args v #@[documentation: "Wrap ARGS in green" source: ["Wrap ARGS in green" [ansi-wrap 10 [apply cat args]]]] v #{
05v ansi-wrap
02i 10
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-green
0D
25v ansi-yellow v args v #@[documentation: "Wrap ARGS in yellow" source: ["Wrap ARGS in yellow" [ansi-wrap 11 [apply cat args]]]] v #{
05v ansi-wrap
02i 11
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-yellow
0D
25v ansi-blue v args v #@[documentation: "Wrap ARGS in blue" source: ["Wrap ARGS in blue" [ansi-wrap 12 [apply cat args]]]] v #{
05v ansi-wrap
02i 12
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-blue
0D
25v ansi-pink v args v #@[documentation: "Wrap ARGS in pink" source: ["Wrap ARGS in pink" [ansi-wrap 13 [apply cat args]]]] v #{
05v ansi-wrap
02i 13
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-pink
0D
25v ansi-cyan v args v #@[documentation: "Wrap ARGS in cyan" source: ["Wrap ARGS in cyan" [ansi-wrap 14 [apply cat args]]]] v #{
05v ansi-wrap
02i 14
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-cyan
0D
25v ansi-white v args v #@[documentation: "Wrap ARGS in white" source: ["Wrap ARGS in white" [ansi-wrap 15 [apply cat args]]]] v #{
05v ansi-wrap
02i 15
05v apply
10s cat
10s args
04i 2
04i 2
01
}
0Es ansi-white
0D
25v ansi-rainbow v args v #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [let* [def count 0] [cat [join [map [split [apply cat args] ""] [fn [a] [set! count [logand [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] ""] [or ansi/disabled ansi-fg-reset]]]]] v #{
15
02i 0
0Es count
0D
05v cat
05v join
05v map
05v split
05v apply
10s cat
10s args
04i 2
05v ""
04i 2
25v anonymous v [a] v #@[source: [[set! count [logand [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] v #{
05v logand
05v +
02i 1
10s count
04i 2
02i 7
04i 2
0Fs count
0D
05v cat
10s ansi/disabled
0C
0Ao 50
0D
05v array/ref
10s ansi-fg
02i 0
10s count
20
0Bo 8
02i 7
09o 15
05v +
10s count
02i 8
04i 2
04i 2
0C
0Ao 8
0D
05v #f
10s a
04i 2
01
}
04i 2
05v ""
04i 2
10s ansi/disabled
0C
0Ao 17
0D
10s ansi-fg-reset
0C
0Ao 8
0D
05v #f
04i 2
16
01
}
0Es ansi-rainbow
0D
25v ansi-rainbow-bg v args v #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [def count 0] [def colored-list [map [split [apply cat args] ""] [fn [a] [set! count [logand [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [logxor count 7]]] [or ansi/disabled [array/ref ansi-bg count]] a]]]] [cat [join colored-list ""] [or ansi/disabled ansi-reset]]]] v #{
02i 0
0Es count
0D
05v map
05v split
05v apply
10s cat
10s args
04i 2
05v ""
04i 2
25v anonymous v [a] v #@[source: [[set! count [logand [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [logxor count 7]]] [or ansi/disabled [array/ref ansi-bg count]] a]]] v #{
05v logand
05v +
02i 1
10s count
04i 2
02i 7
04i 2
0Fs count
0D
05v cat
10s ansi/disabled
0C
0Ao 35
0D
05v array/ref
10s ansi-fg
05v logxor
10s count
02i 7
04i 2
04i 2
0C
0Ao 8
0D
05v #f
10s ansi/disabled
0C
0Ao 27
0D
05v array/ref
10s ansi-bg
10s count
04i 2
0C
0Ao 8
0D
05v #f
10s a
04i 3
01
}
04i 2
0Es colored-list
0D
05v cat
05v join
10s colored-list
05v ""
04i 2
10s ansi/disabled
0C
0Ao 17
0D
10s ansi-reset
0C
0Ao 8
0D
05v #f
04i 2
01
}
0Es ansi-rainbow-bg
0D
25v reprint-line v [text width] v #@[source: [[when-not width [set! width 20]] [print "\r"] [for [i 0 width] [print " "]] [print "\r"] [print text]]] v #{
10s width
0Bo 7
24
09o 9
02i 20
0Fs width
0D
05v print
05v "\r"
04i 1
0D
15
02i 0
0Es i
0D
10s width
0Es ΓεnΣym-127
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-127
1E
0Bo 29
0D
05v print
05v " "
04i 1
0D
02i 1
10s i
03
0Fs i
09o -36
16
0D
05v print
05v "\r"
04i 1
0D
05v print
10s text
04i 1
01
}
0Es reprint-line
01
}#{
05v tree/new
05v :align
05v :right
05v :debug
05v #f
05v :base
05v #f
05v :width
24
05v :padding-char
05v " "
04i 10
0Es fmt/format-arg/default
0D
25v fmt/find-non-digit-from-right v [s i] v #@[source: [[if [< i 0] -1 [do [def char [char-at s i]] [if [and [>= char 48] [<= char 57]] [fmt/find-non-digit-from-right s [- i 1]] i]]]]] v #{
10s i
02i 0
1E
0Bo 8
02i -1
09o 73
05v char-at
10s s
10s i
04i 2
0Es char
0D
10s char
02i 48
21
0C
0Bo 11
0D
10s char
02i 57
1F
0Bo 28
05v fmt/find-non-digit-from-right
10s s
05v -
10s i
02i 1
04i 2
04i 2
09o 7
10s i
01
}
0Es fmt/find-non-digit-from-right
0D
25v fmt/parse-spec v [opts spec] v #@[source: [[if [zero? [string/length spec]] opts [case [char-at spec [- [string/length spec] 1]] [[48 49 50 51 52 53 54 55 56 57] [def next-non-digit [fmt/find-non-digit-from-right spec [- [string/length spec] 1]]] [def number [string/cut spec [+ 1 next-non-digit] [string/length spec]]] [tree/set! opts :width [read/single number]] [when [== 48 [char-at number 0]] [tree/set! opts :padding-char "0"]] [fmt/parse-spec opts [string/cut spec 0 [+ 1 next-non-digit]]]] [63 [fmt/parse-spec [tree/set! opts :debug #t] [string/cut spec 0 [- [string/length spec] 1]]]] [88 [fmt/parse-spec [tree/set! opts :base :HEXADECIMAL] [string/cut spec 0 [- [string/length spec] 1]]]] [120 [fmt/parse-spec [tree/set! opts :base :hexadecimal] [string/cut spec 0 [- [string/length spec] 1]]]] [100 [fmt/parse-spec [tree/set! opts :base :decimal] [string/cut spec 0 [- [string/length spec] 1]]]] [111 [fmt/parse-spec [tree/set! opts :base :octal] [string/cut spec 0 [- [string/length spec] 1]]]] [98 [fmt/parse-spec [tree/set! opts :base :binary] [string/cut spec 0 [- [string/length spec] 1]]]] [60 [fmt/parse-spec [tree/set! opts :align :left] [string/cut spec 0 [- [string/length spec] 1]]]] [94 [fmt/parse-spec [tree/set! opts :align :center] [string/cut spec 0 [- [string/length spec] 1]]]] [62 [fmt/parse-spec [tree/set! opts :align :right] [string/cut spec 0 [- [string/length spec] 1]]]] [46 [fmt/parse-spec [tree/set! opts :precision [tree/ref opts :width]] [string/cut spec 0 [- [string/length spec] 1]]]] [otherwise [throw [list :format-error "Unknown form-spec option" spec [current-closure]]]]]]]] v #{
02i 0
05v string/length
10s spec
04i 1
20
0Bo 10
10s opts
09o 1048
15
05v char-at
10s spec
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 2
0Es ΓεnΣym-136
0D
10s ΓεnΣym-136
02i 48
20
0C
0Ao 116
0D
10s ΓεnΣym-136
02i 49
20
0C
0Ao 104
0D
10s ΓεnΣym-136
02i 50
20
0C
0Ao 92
0D
10s ΓεnΣym-136
02i 51
20
0C
0Ao 80
0D
10s ΓεnΣym-136
02i 52
20
0C
0Ao 68
0D
10s ΓεnΣym-136
02i 53
20
0C
0Ao 56
0D
10s ΓεnΣym-136
02i 54
20
0C
0Ao 44
0D
10s ΓεnΣym-136
02i 55
20
0C
0Ao 32
0D
10s ΓεnΣym-136
02i 56
20
0C
0Ao 20
0D
10s ΓεnΣym-136
02i 57
20
0C
0Ao 8
0D
05v #f
0Bo 176
05v fmt/find-non-digit-from-right
10s spec
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 2
0Es next-non-digit
0D
05v string/cut
10s spec
05v +
02i 1
10s next-non-digit
04i 2
05v string/length
10s spec
04i 1
04i 3
0Es number
0D
05v tree/set!
10s opts
05v :width
05v read/single
10s number
04i 1
04i 3
0D
02i 48
05v char-at
10s number
02i 0
04i 2
20
0Bo 24
05v tree/set!
10s opts
05v :padding-char
05v "0"
04i 3
09o 4
24
0D
05v fmt/parse-spec
10s opts
05v string/cut
10s spec
02i 0
05v +
02i 1
10s next-non-digit
04i 2
04i 3
04i 2
09o 713
10s ΓεnΣym-136
02i 63
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :debug
05v #t
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 646
10s ΓεnΣym-136
02i 88
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :base
05v :HEXADECIMAL
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 579
10s ΓεnΣym-136
02i 120
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :base
05v :hexadecimal
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 512
10s ΓεnΣym-136
02i 100
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :base
05v :decimal
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 445
10s ΓεnΣym-136
02i 111
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :base
05v :octal
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 378
10s ΓεnΣym-136
02i 98
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :base
05v :binary
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 311
10s ΓεnΣym-136
02i 60
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :align
05v :left
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 244
10s ΓεnΣym-136
02i 94
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :align
05v :center
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 177
10s ΓεnΣym-136
02i 62
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :align
05v :right
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 110
10s ΓεnΣym-136
02i 46
20
0Bo 70
05v fmt/parse-spec
05v tree/set!
10s opts
05v :precision
05v tree/ref
10s opts
05v :width
04i 2
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 33
05v throw
05v list
05v :format-error
05v "Unknown form-spec option"
10s spec
05v current-closure
04i 0
04i 4
04i 1
16
01
}
0Es fmt/parse-spec
0D
25v fmt/debug v [opts] v #@[source: [[if-not [tree/ref opts :debug] opts [tree/set! opts :argument [list str/write [tree/ref opts :argument]]]]]] v #{
05v tree/ref
10s opts
05v :debug
04i 2
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s str/write
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 7
10s opts
01
}
0Es fmt/debug
0D
25v fmt/number-format v [opts] v #@[source: [[case [tree/ref opts :base] [:binary [tree/set! opts :argument [list int->string/binary [tree/ref opts :argument]]]] [:octal [tree/set! opts :argument [list int->string/octal [tree/ref opts :argument]]]] [:decimal [tree/set! opts :argument [list int->string/decimal [tree/ref opts :argument]]]] [:hexadecimal [tree/set! opts :argument [list int->string/hex [tree/ref opts :argument]]]] [:HEXADECIMAL [tree/set! opts :argument [list int->string/HEX [tree/ref opts :argument]]]] [otherwise opts]]]] v #{
15
05v tree/ref
10s opts
05v :base
04i 2
0Es ΓεnΣym-137
0D
10s ΓεnΣym-137
05v :binary
20
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s int->string/binary
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 219
10s ΓεnΣym-137
05v :octal
20
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s int->string/octal
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 166
10s ΓεnΣym-137
05v :decimal
20
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s int->string/decimal
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 113
10s ΓεnΣym-137
05v :hexadecimal
20
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s int->string/hex
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 60
10s ΓεnΣym-137
05v :HEXADECIMAL
20
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s int->string/HEX
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 7
10s opts
16
01
}
0Es fmt/number-format
0D
05v tree/new
05v :binary
05v "#b"
05v :octal
05v "#o"
05v :decimal
05v "#d"
05v :hexadecimal
05v "#x"
05v :HEXADECIMAL
05v "#x"
04i 10
0Es fmt/number-format-prefixex
0D
25v fmt/number-format-prefix v [opts] v #@[source: [[if [or [not [tree/ref opts :debug]] [not [tree/ref opts :base]]] opts [-> [if [member '[:binary :octal :decimal :hexadecimal :HEXADECIMAL] [tree/ref opts :base]] [tree/set! opts :argument [list cat [tree/ref fmt/number-format-prefixex [tree/ref opts :base]] [tree/ref opts :argument]]] opts] [tree/set! :debug #f]]]]] v #{
05v tree/ref
10s opts
05v :debug
04i 2
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 41
0D
05v tree/ref
10s opts
05v :base
04i 2
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 8
0D
05v #f
0Bo 10
10s opts
09o 113
05v tree/set!
05v member
05v [:binary :octal :decimal :hexadecimal :HEXADECIMAL]
05v tree/ref
10s opts
05v :base
04i 2
04i 2
0Bo 68
05v tree/set!
10s opts
05v :argument
05v list
10s cat
05v tree/ref
10s fmt/number-format-prefixex
05v tree/ref
10s opts
05v :base
04i 2
04i 2
05v tree/ref
10s opts
05v :argument
04i 2
04i 3
04i 3
09o 7
10s opts
05v :debug
05v #f
04i 3
01
}
0Es fmt/number-format-prefix
0D
25v fmt/add-padding v [opts] v #@[source: [[if-not [tree/ref opts :width] opts [tree/set! opts :argument [list [case [tree/ref opts :align] [:right string/pad-start] [:center string/pad-middle] [:left string/pad-end]] [tree/ref opts :argument] [if [and [tree/ref opts :debug] [tree/ref opts :base]] [- [tree/ref opts :width] 2] [tree/ref opts :width]] [tree/ref opts :padding-char]]]]]] v #{
05v tree/ref
10s opts
05v :width
04i 2
0Bo 208
05v tree/set!
10s opts
05v :argument
05v list
15
05v tree/ref
10s opts
05v :align
04i 2
0Es ΓεnΣym-138
0D
10s ΓεnΣym-138
05v :right
20
0Bo 10
10s string/pad-start
09o 42
10s ΓεnΣym-138
05v :center
20
0Bo 10
10s string/pad-middle
09o 23
10s ΓεnΣym-138
05v :left
20
0Bo 10
10s string/pad-end
09o 4
24
16
05v tree/ref
10s opts
05v :argument
04i 2
05v tree/ref
10s opts
05v :debug
04i 2
0C
0Bo 18
0D
05v tree/ref
10s opts
05v :base
04i 2
0Bo 28
05v -
05v tree/ref
10s opts
05v :width
04i 2
02i 2
04i 2
09o 17
05v tree/ref
10s opts
05v :width
04i 2
05v tree/ref
10s opts
05v :padding-char
04i 2
04i 4
04i 3
09o 7
10s opts
01
}
0Es fmt/add-padding
0D
25v fmt/precision v [opts] v #@[source: [[if-not [tree/ref opts :precision] opts [tree/set! opts :argument [list string/round [tree/ref opts :argument] [tree/ref opts :precision]]]]]] v #{
05v tree/ref
10s opts
05v :precision
04i 2
0Bo 58
05v tree/set!
10s opts
05v :argument
05v list
10s string/round
05v tree/ref
10s opts
05v :argument
04i 2
05v tree/ref
10s opts
05v :precision
04i 2
04i 3
04i 3
09o 7
10s opts
01
}
0Es fmt/precision
0D
25v fmt/truncate v [opts] v #@[source: [[if-not [tree/ref opts :width] opts [tree/set! opts :argument [list string/cut [tree/ref opts :argument] 0 [+ 1 [tree/ref opts :width]]]]]]] v #{
05v tree/ref
10s opts
05v :width
04i 2
0Bo 68
05v tree/set!
10s opts
05v :argument
05v list
10s string/cut
05v tree/ref
10s opts
05v :argument
04i 2
02i 0
05v +
02i 1
05v tree/ref
10s opts
05v :width
04i 2
04i 2
04i 4
04i 3
09o 7
10s opts
01
}
0Es fmt/truncate
0D
25v fmt/output v [opts] v #@[source: [[tree/ref opts :argument]]] v #{
05v tree/ref
10s opts
05v :argument
04i 2
01
}
0Es fmt/output
0D
25v fmt/format-arg v [spec argument] v #@[source: [[-> [tree/set! [fmt/parse-spec [tree/dup fmt/format-arg/default] spec] :argument argument] fmt/number-format fmt/precision fmt/add-padding fmt/truncate fmt/number-format-prefix fmt/debug fmt/output]]] v #{
05v fmt/output
05v fmt/debug
05v fmt/number-format-prefix
05v fmt/truncate
05v fmt/add-padding
05v fmt/precision
05v fmt/number-format
05v tree/set!
05v fmt/parse-spec
05v tree/dup
10s fmt/format-arg/default
04i 1
10s spec
04i 2
05v :argument
10s argument
04i 3
04i 1
04i 1
04i 1
04i 1
04i 1
04i 1
04i 1
01
}
0Es fmt/format-arg
0D
25v fmt/valid-argument? v [argument] v #@[source: [[or [int? argument] [symbol? argument]]]] v #{
05v int?
10s argument
04i 1
0C
0Ao 23
0D
05v symbol?
10s argument
04i 1
0C
0Ao 8
0D
05v #f
01
}
0Es fmt/valid-argument?
0D
25v fmt/arg-sym v [v] v #@[source: [[case [type-of v] [:int [fmt/arg-sym [cat "fmt-arg-" [string v]]]] [:symbol v] [:string [str->sym v]] [otherwise [throw [list :type-error "Invalid fmt argument name" v [current-lambda]]]]]]] v #{
15
05v type-of
10s v
04i 1
0Es ΓεnΣym-139
0D
10s ΓεnΣym-139
05v :int
20
0Bo 32
05v fmt/arg-sym
05v cat
05v "fmt-arg-"
05v string
10s v
04i 1
04i 2
04i 1
09o 77
10s ΓεnΣym-139
05v :symbol
20
0Bo 10
10s v
09o 58
10s ΓεnΣym-139
05v :string
20
0Bo 16
05v str->sym
10s v
04i 1
09o 33
05v throw
05v list
05v :type-error
05v "Invalid fmt argument name"
10s v
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
0Es fmt/arg-sym
0D
25v fmt/expr v [expr arguments-used opts] v #@[source: [[when-not [string? expr] [throw [list :format-error "fmt needs a string literal as a first argument, since it is implemented as a macro" expr [current-lambda]]]] [def split-expr [split expr ":"]] [def argument [car split-expr]] [def format-spec [or [cadr split-expr] ""]] [if [== "" argument] [do [tree/-- opts :expr-count] [array/set! arguments-used [tree/ref opts :expr-count] #t] [fmt/format-arg format-spec [fmt/arg-sym [tree/ref opts :expr-count]]]] [let [[read-vals [read argument]]] [when [cdr read-vals] [throw [list :format-error "Format argument specifier contains more than a single atom" argument [current-lambda]]]] [when-not [fmt/valid-argument? [car read-vals]] [throw [list :format-error "Format argument specifier should be either an integer or a symbol" argument [current-lambda]]]] [when [int? [car read-vals]] [when [or [< [car read-vals] 0] [>= [car read-vals] [array/length arguments-used]]] [throw [list :format-error "fmt numbered argument is out of bounds" argument [current-lambda]]]] [array/set! arguments-used [car read-vals] #t]] [fmt/format-arg format-spec [fmt/arg-sym [car read-vals]]]]]]] v #{
05v string?
10s expr
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :format-error
05v "fmt needs a string literal as a first argument, since it is implemented as a macro"
10s expr
05v current-lambda
04i 0
04i 4
04i 1
0D
05v split
10s expr
05v ":"
04i 2
0Es split-expr
0D
10s split-expr
11
0Es argument
0D
10s split-expr
12
11
0C
0Ao 17
0D
05v ""
0C
0Ao 8
0D
05v #f
0Es format-spec
0D
05v ""
10s argument
20
0Bo 88
05v tree/+=
10s opts
05v :expr-count
05v -
02i 1
04i 1
04i 3
0D
05v array/set!
10s arguments-used
05v tree/ref
10s opts
05v :expr-count
04i 2
05v #t
04i 3
0D
05v fmt/format-arg
10s format-spec
05v fmt/arg-sym
05v tree/ref
10s opts
05v :expr-count
04i 2
04i 1
04i 2
09o 247
15
05v read
10s argument
04i 1
0Es read-vals
0D
10s read-vals
12
0Bo 36
05v throw
05v list
05v :format-error
05v "Format argument specifier contains more than a single atom"
10s argument
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v fmt/valid-argument?
10s read-vals
11
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :format-error
05v "Format argument specifier should be either an integer or a symbol"
10s argument
05v current-lambda
04i 0
04i 4
04i 1
0D
05v int?
10s read-vals
11
04i 1
0Bo 101
10s read-vals
11
02i 0
1E
0C
0Ao 29
0D
10s read-vals
11
05v array/length
10s arguments-used
04i 1
21
0C
0Ao 8
0D
05v #f
0Bo 36
05v throw
05v list
05v :format-error
05v "fmt numbered argument is out of bounds"
10s argument
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v array/set!
10s arguments-used
10s read-vals
11
05v #t
04i 3
09o 4
24
0D
05v fmt/format-arg
10s format-spec
05v fmt/arg-sym
10s read-vals
11
04i 1
04i 2
16
01
}
0Es fmt/expr
0D
26v fmt v [format-string . args] v #@[documentation: "Return a formatted string" source: ["Return a formatted string" [when-not [string? format-string] [throw [list :type-error "fmt needs a string literal as a first argument, since it is implemented as a macro" format-string [current-lambda]]]] [def cuts #nil] [for [i 0 [string/length format-string]] [case [char-at format-string i] [123 [do [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]] [set! cuts [cons i cuts]]]] [125 [do [when-not [int? [car cuts]] [throw [list :format-error "fmt expects all brackets to be closed" format-string [current-lambda]]]] [set! cuts [cons [cons [car cuts] i] [cdr cuts]]]]]]] [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]] [def expr-list #nil] [def last-pos [string/length format-string]] [def arguments-used [-> [array/allocate [length args]] [array/fill! #f]]] [def opts [tree/new :expr-count [array/length arguments-used]]] [for-in [c cuts] [def lit [string/cut format-string [+ [cdr c] 1] last-pos]] [when-not [== "" lit] [set! expr-list [cons lit expr-list]]] [def expr [fmt/expr [string/cut format-string [+ 1 [car c]] [cdr c]] arguments-used opts]] [set! expr-list [cons expr expr-list]] [set! last-pos [car c]]] [when [> last-pos 0] [def lit [string/cut format-string 0 last-pos]] [set! expr-list [cons lit expr-list]]] [for [i 0 [array/length arguments-used]] [when-not [array/ref arguments-used i] [throw [list :format-error "fmt expects all arguments to be used" [list format-string [list/ref args i]] [current-lambda]]]]] [def expr [if [cdr expr-list] [cons 'cat expr-list] [if [string? [car expr-list]] [car expr-list] [cons 'string expr-list]]]] [def fmt/args/map-fun/count 0] [defn fmt/args/map-fun [arg] [def s [str->sym [cat "fmt-arg-" [string fmt/args/map-fun/count]]]] [++ fmt/args/map-fun/count] [list 'def s arg]] [if args [quasiquote [let* [unquote-splicing [map args fmt/args/map-fun]] [unquote expr]]] expr]]] v #{
05v string?
10s format-string
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "fmt needs a string literal as a first argument, since it is implemented as a macro"
10s format-string
05v current-lambda
04i 0
04i 4
04i 1
0D
24
0Es cuts
0D
15
02i 0
0Es i
0D
05v string/length
10s format-string
04i 1
0Es ΓεnΣym-140
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-140
1E
0Bo 198
0D
15
05v char-at
10s format-string
10s i
04i 2
0Es ΓεnΣym-141
0D
10s ΓεnΣym-141
02i 123
20
0Bo 68
05v int?
10s cuts
11
04i 1
0Bo 36
05v throw
05v list
05v :format-error
05v "fmt placeholders can't be nested"
10s format-string
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s i
10s cuts
14
0Fs cuts
09o 86
10s ΓεnΣym-141
02i 125
20
0Bo 75
05v int?
10s cuts
11
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :format-error
05v "fmt expects all brackets to be closed"
10s format-string
05v current-lambda
04i 0
04i 4
04i 1
0D
10s cuts
11
10s i
14
10s cuts
12
14
0Fs cuts
09o 4
24
16
0D
02i 1
10s i
03
0Fs i
09o -205
16
0D
05v int?
10s cuts
11
04i 1
0Bo 36
05v throw
05v list
05v :format-error
05v "fmt placeholders can't be nested"
10s format-string
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
24
0Es expr-list
0D
05v string/length
10s format-string
04i 1
0Es last-pos
0D
05v array/fill!
05v array/allocate
05v length
10s args
04i 1
04i 1
05v #f
04i 2
0Es arguments-used
0D
05v tree/new
05v :expr-count
05v array/length
10s arguments-used
04i 1
04i 2
0Es opts
0D
15
10s cuts
0Es ΓεnΣym-142
0D
10s ΓεnΣym-142
0Bo 173
02i 0
1B
1C
10s ΓεnΣym-142
0Bo 159
0D
10s ΓεnΣym-142
11
0Es c
0D
05v string/cut
10s format-string
05v +
10s c
12
02i 1
04i 2
10s last-pos
04i 3
0Es lit
0D
05v ""
10s lit
20
0Bo 7
24
09o 16
10s lit
10s expr-list
14
0Fs expr-list
0D
05v fmt/expr
05v string/cut
10s format-string
05v +
02i 1
10s c
11
04i 2
10s c
12
04i 3
10s arguments-used
10s opts
04i 3
0Es expr
0D
10s expr
10s expr-list
14
0Fs expr-list
0D
10s c
11
0Fs last-pos
0D
10s ΓεnΣym-142
12
0Fs ΓεnΣym-142
09o -161
09o 4
24
16
0D
10s last-pos
02i 0
22
0Bo 40
05v string/cut
10s format-string
02i 0
10s last-pos
04i 3
0Es lit
0D
10s lit
10s expr-list
14
0Fs expr-list
09o 4
24
0D
15
02i 0
0Es i
0D
05v array/length
10s arguments-used
04i 1
0Es ΓεnΣym-143
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-143
1E
0Bo 90
0D
05v array/ref
10s arguments-used
10s i
04i 2
0Bo 7
24
09o 53
05v throw
05v list
05v :format-error
05v "fmt expects all arguments to be used"
05v list
10s format-string
05v list/ref
10s args
10s i
04i 2
04i 2
05v current-lambda
04i 0
04i 4
04i 1
0D
02i 1
10s i
03
0Fs i
09o -97
16
0D
10s expr-list
12
0Bo 15
23s cat
10s expr-list
14
09o 34
05v string?
10s expr-list
11
04i 1
0Bo 11
10s expr-list
11
09o 12
23s string
10s expr-list
14
0Es expr
0D
02i 0
0Es fmt/args/map-fun/count
0D
25v fmt/args/map-fun v [arg] v #@[source: [[def s [str->sym [cat "fmt-arg-" [string fmt/args/map-fun/count]]]] [++ fmt/args/map-fun/count] [list 'def s arg]]] v #{
05v str->sym
05v cat
05v "fmt-arg-"
05v string
10s fmt/args/map-fun/count
04i 1
04i 2
04i 1
0Es s
0D
05v +
02i 1
10s fmt/args/map-fun/count
04i 2
0Fs fmt/args/map-fun/count
0D
05v list
23s def
10s s
10s arg
04i 3
01
}
0Es fmt/args/map-fun
0D
10s args
0Bo 37
23s let*
05v append
05v map
10s args
10s fmt/args/map-fun
04i 2
10s expr
24
14
04i 2
14
09o 7
10s expr
01
}
0Es fmt
0D
26v pfmt v [format-string . args] v #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [print [fmt [unquote format-string] [unquote-splicing args]]]]]] v #{
23s print
23s fmt
10s format-string
05v append
10s args
24
04i 2
14
14
24
14
14
01
}
0Es pfmt
0D
26v efmt v [format-string . args] v #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [error [fmt [unquote format-string] [unquote-splicing args]]]]]] v #{
23s error
23s fmt
10s format-string
05v append
10s args
24
04i 2
14
14
24
14
14
01
}
0Es efmt
0D
26v pfmtln v [format-string . args] v #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [println [fmt [unquote format-string] [unquote-splicing args]]]]]] v #{
23s println
23s fmt
10s format-string
05v append
10s args
24
04i 2
14
14
24
14
14
01
}
0Es pfmtln
0D
26v efmtln v [format-string . args] v #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [errorln [fmt [unquote format-string] [unquote-splicing args]]]]]] v #{
23s errorln
23s fmt
10s format-string
05v append
10s args
24
04i 2
14
14
24
14
14
01
}
0Es efmtln
01
}#{
25v string->keyword v [α] v #@[documentation: "Return string α as a keyword" source: [:inline "Return string α as a keyword" [symbol->keyword [str->sym α]]] inline: #t] v #{
05v symbol->keyword
05v str->sym
10s α
04i 1
04i 1
01
}
0Es string->keyword
0D
25v string->byte-array v [a] v #@[documentation: "Turn a string into an UTF-8 encoded byte array" source: ["Turn a string into an UTF-8 encoded byte array" [def ret [array/allocate [string/length a]]] [for [i 0 [string/length a]] [array/set! ret i [char-at a i]]] ret]] v #{
05v array/allocate
05v string/length
10s a
04i 1
04i 1
0Es ret
0D
15
02i 0
0Es i
0D
05v string/length
10s a
04i 1
0Es ΓεnΣym-147
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-147
1E
0Bo 47
0D
05v array/set!
10s ret
10s i
05v char-at
10s a
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -54
16
0D
10s ret
01
}
0Es string->byte-array
0D
25v println v [str] v #@[documentation: "Print STR on a single line" source: ["Print STR on a single line" [print [cat str "\r\n"]]]] v #{
05v print
05v cat
10s str
05v "\r\n"
04i 2
04i 1
01
}
0Es println
0D
25v errorln v [str] v #@[documentation: "Print to stderr STR on a single line" source: ["Print to stderr STR on a single line" [error [cat str "\r\n"]]]] v #{
05v error
05v cat
10s str
05v "\r\n"
04i 2
04i 1
01
}
0Es errorln
0D
25v display v [value] v #@[documentation: "Display VALUE" source: [:inline "Display VALUE" [print value]] inline: #t] v #{
05v print
10s value
04i 1
01
}
0Es display
0D
25v newline v [] v #@[documentation: "Print a single line feed character" source: ["Print a single line feed character" [display "\r\n"]]] v #{
05v print
05v "\r\n"
04i 1
01
}
0Es newline
0D
25v br v [num] v #@[documentation: "Return NUM=1 linebreaks" source: ["Return NUM=1 linebreaks" [if [or [nil? num] [<= [int num] 1]] "\n" [cat "\n" [br [+ -1 num]]]]]] v #{
05v nil?
10s num
04i 1
0C
0Ao 26
0D
05v int
10s num
04i 1
02i 1
1F
0C
0Ao 8
0D
05v #f
0Bo 10
05v "\n"
09o 31
05v cat
05v "\n"
05v br
05v +
02i -1
10s num
04i 2
04i 1
04i 2
01
}
0Es br
0D
25v path/ext?! v [ext] v #@[documentation: "Return a predicate that checks if a path ends on EXT" source: ["Return a predicate that checks if a path ends on EXT" [case [type-of ext] [:string [fn [path] [== ext [lowercase [path/extension path]]]]] [:pair [fn [path] [def cext [lowercase [path/extension path]]] [reduce ext [fn [α β] [or α [== β cext]]]]]] [otherwise [throw [list :type-error "Expected a :string or :list" ext]]]]]] v #{
15
05v type-of
10s ext
04i 1
0Es ΓεnΣym-148
0D
10s ΓεnΣym-148
05v :string
20
0Bo 19
25v anonymous v [path] v #@[source: [[== ext [lowercase [path/extension path]]]]] v #{
10s ext
05v lowercase
05v path/extension
10s path
04i 1
04i 1
20
01
}
09o 55
10s ΓεnΣym-148
05v :pair
20
0Bo 19
25v anonymous v [path] v #@[source: [[def cext [lowercase [path/extension path]]] [reduce ext [fn [α β] [or α [== β cext]]]]]] v #{
05v lowercase
05v path/extension
10s path
04i 1
04i 1
0Es cext
0D
05v reduce
10s ext
25v anonymous v [α β] v #@[source: [[or α [== β cext]]]] v #{
10s α
0C
0Ao 22
0D
10s β
10s cext
20
0C
0Ao 8
0D
05v #f
01
}
04i 2
01
}
09o 27
05v throw
05v list
05v :type-error
05v "Expected a :string or :list"
10s ext
04i 3
04i 1
16
01
}
0Es path/ext?!
0D
25v path/extension v [path] v #@[documentation: "Return the extension of PATH" source: ["Return the extension of PATH" [def last-period [last-index-of path "."]] [if [>= last-period 0] [string/cut path [+ 1 last-period] [string/length path]] path]]] v #{
05v last-index-of
10s path
05v "."
04i 2
0Es last-period
0D
10s last-period
02i 0
21
0Bo 38
05v string/cut
10s path
05v +
02i 1
10s last-period
04i 2
05v string/length
10s path
04i 1
04i 3
09o 7
10s path
01
}
0Es path/extension
0D
25v path/without-extension v [path] v #@[documentation: "Return PATH, but without the extension part" source: ["Return PATH, but without the extension part" [def last-period [last-index-of path "."]] [if [>= last-period 0] [string/cut path 0 last-period] path]]] v #{
05v last-index-of
10s path
05v "."
04i 2
0Es last-period
0D
10s last-period
02i 0
21
0Bo 22
05v string/cut
10s path
02i 0
10s last-period
04i 3
09o 7
10s path
01
}
0Es path/without-extension
0D
25v int->string/binary v [α] v #@[documentation: "Turn α into a its **binary** string representation" source: ["Turn α into a its **binary** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [while [not-zero? α] [set! ret [cat [from-char-code [+ 48 [logand α 1]]] ret]] [set! α [ash α -1]]] ret]] v #{
05v ""
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
02i 0
10s α
20
0Bo 14
05v "0"
0Fs ret
09o 4
24
0D
02i 0
1B
1C
05v !=
02i 0
10s α
04i 2
0Bo 64
0D
05v cat
05v from-char-code
05v +
02i 48
05v logand
10s α
02i 1
04i 2
04i 2
04i 1
10s ret
04i 2
0Fs ret
0D
05v ash
10s α
02i -1
04i 2
0Fs α
09o -74
0D
10s ret
01
}
0Es int->string/binary
0D
25v int->string/octal v [α] v #@[documentation: "Turn α into a its **octal** string representation" source: ["Turn α into a its **octal** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [while [not-zero? α] [set! ret [cat [from-char-code [+ 48 [logand α 7]]] ret]] [set! α [ash α -3]]] ret]] v #{
05v ""
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
02i 0
10s α
20
0Bo 14
05v "0"
0Fs ret
09o 4
24
0D
02i 0
1B
1C
05v !=
02i 0
10s α
04i 2
0Bo 64
0D
05v cat
05v from-char-code
05v +
02i 48
05v logand
10s α
02i 7
04i 2
04i 2
04i 1
10s ret
04i 2
0Fs ret
0D
05v ash
10s α
02i -3
04i 2
0Fs α
09o -74
0D
10s ret
01
}
0Es int->string/octal
0D
05v array/new
05v "0"
05v "1"
05v "2"
05v "3"
05v "4"
05v "5"
05v "6"
05v "7"
05v "8"
05v "9"
05v "A"
05v "B"
05v "C"
05v "D"
05v "E"
05v "F"
04i 16
0Es int->string/hex/conversion-arr
0D
25v int->string/HEX v [α] v #@[documentation: "Turn α into a its **hexadecimal** string representation" source: ["Turn α into a its **hexadecimal** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [when [< α 0] [throw [list :type-error "Can't print negative numbers in hex for now" α [current-lambda]]]] [while [not-zero? α] [set! ret [cat [array/ref int->string/hex/conversion-arr [logand α 15]] ret]] [set! α [ash α -4]]] ret]] v #{
05v ""
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
02i 0
10s α
20
0Bo 14
05v "0"
0Fs ret
09o 4
24
0D
10s α
02i 0
1E
0Bo 36
05v throw
05v list
05v :type-error
05v "Can't print negative numbers in hex for now"
10s α
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
02i 0
1B
1C
05v !=
02i 0
10s α
04i 2
0Bo 60
0D
05v cat
05v array/ref
10s int->string/hex/conversion-arr
05v logand
10s α
02i 15
04i 2
04i 2
10s ret
04i 2
0Fs ret
0D
05v ash
10s α
02i -4
04i 2
0Fs α
09o -70
0D
10s ret
01
}
0Es int->string/HEX
0D
25v int->string/hex v [α] v #@[documentation: "Turn α into a its **hexadecimal** string representation" source: ["Turn α into a its **hexadecimal** string representation" [lowercase [int->string/HEX α]]]] v #{
05v lowercase
05v int->string/HEX
10s α
04i 1
04i 1
01
}
0Es int->string/hex
0D
25v int->string/decimal v [α] v #@[documentation: "Turn α into a its **decimal** string representation" source: ["Turn α into a its **decimal** string representation" [string α]]] v #{
05v string
10s α
04i 1
01
}
0Es int->string/decimal
0D
10s int->string/decimal
0Es int->string
0D
25v string/pad-start v [text goal-length char] v #@[documentation: "Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat char text]]] [if [> [string/length text] goal-length] [string/cut text [- [string/length text] goal-length] [string/length text]] text]]] v #{
10s char
0Bo 7
24
09o 11
05v " "
0Fs char
0D
05v string?
10s text
04i 1
0Bo 7
24
09o 17
05v string
10s text
04i 1
0Fs text
0D
05v string?
10s char
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "string/pad-start needs char as a string, so that one can pad with multiple characters"
10s char
05v current-lambda
04i 0
04i 4
04i 1
0D
02i 0
1B
1C
05v string/length
10s text
04i 1
10s goal-length
1E
0Bo 25
0D
05v cat
10s char
10s text
04i 2
0Fs text
09o -38
0D
05v string/length
10s text
04i 1
10s goal-length
22
0Bo 46
05v string/cut
10s text
05v -
05v string/length
10s text
04i 1
10s goal-length
04i 2
05v string/length
10s text
04i 1
04i 3
09o 7
10s text
01
}
0Es string/pad-start
0D
25v string/pad-end v [text goal-length char] v #@[documentation: "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat text char]]] [if [> [string/length text] goal-length] [string/cut text 0 goal-length] text]]] v #{
10s char
0Bo 7
24
09o 11
05v " "
0Fs char
0D
05v string?
10s text
04i 1
0Bo 7
24
09o 17
05v string
10s text
04i 1
0Fs text
0D
05v string?
10s char
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "string/pad-start needs char as a string, so that one can pad with multiple characters"
10s char
05v current-lambda
04i 0
04i 4
04i 1
0D
02i 0
1B
1C
05v string/length
10s text
04i 1
10s goal-length
1E
0Bo 25
0D
05v cat
10s text
10s char
04i 2
0Fs text
09o -38
0D
05v string/length
10s text
04i 1
10s goal-length
22
0Bo 22
05v string/cut
10s text
02i 0
10s goal-length
04i 3
09o 7
10s text
01
}
0Es string/pad-end
0D
25v string/pad-middle v [text goal-length char] v #@[documentation: "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-middle needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat char text char]]] [if [> [string/length text] goal-length] [let [[end-overflow [/ [- [string/length text] goal-length] 2]] [start-overflow [- [- [string/length text] goal-length] end-overflow]]] [string/cut text start-overflow [+ start-overflow goal-length]]] text]]] v #{
10s char
0Bo 7
24
09o 11
05v " "
0Fs char
0D
05v string?
10s text
04i 1
0Bo 7
24
09o 17
05v string
10s text
04i 1
0Fs text
0D
05v string?
10s char
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "string/pad-middle needs char as a string, so that one can pad with multiple characters"
10s char
05v current-lambda
04i 0
04i 4
04i 1
0D
02i 0
1B
1C
05v string/length
10s text
04i 1
10s goal-length
1E
0Bo 29
0D
05v cat
10s char
10s text
10s char
04i 3
0Fs text
09o -42
0D
05v string/length
10s text
04i 1
10s goal-length
22
0Bo 104
15
05v /
05v -
05v string/length
10s text
04i 1
10s goal-length
04i 2
02i 2
04i 2
0Es end-overflow
0D
05v -
05v -
05v string/length
10s text
04i 1
10s goal-length
04i 2
10s end-overflow
04i 2
0Es start-overflow
0D
05v string/cut
10s text
10s start-overflow
05v +
10s start-overflow
10s goal-length
04i 2
04i 3
16
09o 7
10s text
01
}
0Es string/pad-middle
0D
25v string/round v [text decimal-digits] v #@[documentation: "Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" source: ["Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" [def pos [last-index-of text "."]] [if [>= pos 0] [string/cut text 0 [+ pos 1 decimal-digits]] text]]] v #{
05v last-index-of
10s text
05v "."
04i 2
0Es pos
0D
10s pos
02i 0
21
0Bo 40
05v string/cut
10s text
02i 0
05v +
05v +
10s pos
02i 1
04i 2
10s decimal-digits
04i 2
04i 3
09o 7
10s text
01
}
0Es string/round
0D
25v split/empty v [str separator] v #@[source: [[def slen [string/length str]] [def start 0] [def ret #nil] [while [< start slen] [set! ret [cons [string/cut str start [+ 1 start]] ret]] [++ start]] [reverse ret]]] v #{
05v string/length
10s str
04i 1
0Es slen
0D
02i 0
0Es start
0D
24
0Es ret
0D
02i 0
1B
1C
10s start
10s slen
1E
0Bo 59
0D
05v string/cut
10s str
10s start
05v +
02i 1
10s start
04i 2
04i 3
10s ret
14
0Fs ret
0D
05v +
02i 1
10s start
04i 2
0Fs start
09o -66
0D
05v reverse
10s ret
04i 1
01
}
0Es split/empty
0D
25v split/string v [str separator start] v #@[source: [[when-not start [set! start 0]] [def pos-found [index-of str separator start]] [if [>= pos-found 0] [cons [string/cut str start pos-found] [split/string str separator [+ pos-found [string/length separator]]]] [cons [string/cut str start [string/length str]] #nil]]]] v #{
10s start
0Bo 7
24
09o 9
02i 0
0Fs start
0D
05v index-of
10s str
10s separator
10s start
04i 3
0Es pos-found
0D
10s pos-found
02i 0
21
0Bo 59
05v string/cut
10s str
10s start
10s pos-found
04i 3
05v split/string
10s str
10s separator
05v +
10s pos-found
05v string/length
10s separator
04i 1
04i 2
04i 3
14
09o 29
05v string/cut
10s str
10s start
05v string/length
10s str
04i 1
04i 3
24
14
01
}
0Es split/string
0D
25v split v [str separator] v #@[documentation: "Splits STR into a list at every occurunse of SEPARATOR" source: ["Splits STR into a list at every occurunse of SEPARATOR" [typecheck/only str :string] [typecheck/only separator :string] [case [string/length separator] [0 [split/empty str]] [otherwise [split/string str separator 0]]]]] v #{
05v type-of
10s str
04i 1
05v :string
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :string"
10s str
05v current-lambda
04i 0
04i 4
04i 1
0D
05v type-of
10s separator
04i 1
05v :string
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :string"
10s separator
05v current-lambda
04i 0
04i 4
04i 1
0D
15
05v string/length
10s separator
04i 1
0Es ΓεnΣym-149
0D
10s ΓεnΣym-149
02i 0
20
0Bo 16
05v split/empty
10s str
04i 1
09o 19
05v split/string
10s str
10s separator
02i 0
04i 3
16
01
}
0Es split
0D
25v read/single v [text] v #@[documentation: "Uses the reader and returns the first single value read from string TEXT" source: ["Uses the reader and returns the first single value read from string TEXT" [typecheck/only text :string] [car [read text]]]] v #{
05v type-of
10s text
04i 1
05v :string
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :string"
10s text
05v current-lambda
04i 0
04i 4
04i 1
0D
05v read
10s text
04i 1
11
01
}
0Es read/single
0D
25v read/int v [text] v #@[documentation: "Reads the first string from TEXT" source: ["Reads the first string from TEXT" [int [read/single text]]]] v #{
05v int
05v read/single
10s text
04i 1
04i 1
01
}
0Es read/int
0D
25v read/float v [text] v #@[documentation: "Reads the first float from TEXT" source: ["Reads the first float from TEXT" [float [read/single text]]]] v #{
05v float
05v read/single
10s text
04i 1
04i 1
01
}
0Es read/float
0D
25v string/length?! v [chars] v #@[source: [[fn [a] [== chars [string/length a]]]]] v #{
25v anonymous v [a] v #@[source: [[== chars [string/length a]]]] v #{
10s chars
05v string/length
10s a
04i 1
20
01
}
01
}
0Es string/length?!
0D
25v contains-any? v [str chars] v #@[source: [[apply or [map [split chars ""] [fn [a] [>= [index-of str a] 0]]]]]] v #{
05v apply
10s or
05v map
05v split
10s chars
05v ""
04i 2
25v anonymous v [a] v #@[source: [[>= [index-of str a] 0]]] v #{
05v index-of
10s str
10s a
04i 2
02i 0
21
01
}
04i 2
04i 2
01
}
0Es contains-any?
0D
25v contains-all? v [str chars] v #@[source: [[apply and [map [split chars ""] [fn [a] [>= [index-of str a] 0]]]]]] v #{
05v apply
10s and
05v map
05v split
10s chars
05v ""
04i 2
25v anonymous v [a] v #@[source: [[>= [index-of str a] 0]]] v #{
05v index-of
10s str
10s a
04i 2
02i 0
21
01
}
04i 2
04i 2
01
}
0Es contains-all?
01
}#{
05v "Nujel"
0Es test-context
0D
25v test/reset v [] v #@[source: [[set! test-list #nil] [set! test-count 0] [test/add 4 [+ 3 1]]]] v #{
24
0Fs test-list
0D
02i 0
0Fs test-count
0D
05v test/add*
02i 4
05v [do [+ 3 1]]
04i 2
01
}
0Es test/reset
0D
24
0Es test-list
0D
02i 0
0Es test-count
0D
02i 0
0Es nujel-start
0D
02i 0
0Es success-count
0D
02i 0
0Es error-count
0D
05v #t
0Es print-errors
0D
05v #f
0Es print-passes
0D
25v test/add* v [result expr] v #@[source: [[set! test-list [cons [cons result expr] test-list]] [set! test-count [+ test-count 1]]]] v #{
10s result
10s expr
14
10s test-list
14
0Fs test-list
0D
05v +
10s test-count
02i 1
04i 2
0Fs test-count
01
}
0Es test/add*
0D
26v test/add v [result . expr] v #@[documentation: "Add a test where EXPR must eval to RESULT" source: ["Add a test where EXPR must eval to RESULT" [quasiquote [test/add* [unquote result] [unquote [list 'quote [cons 'do expr]]]]]]] v #{
23s test/add*
10s result
05v list
23s quote
23s do
10s expr
14
04i 2
24
14
14
14
01
}
0Es test/add
0D
25v display-results v [] v #@[documentation: "Prints the result Message" source: ["Prints the result Message" [random/seed-initialize!] [efmtln "{test-context} [{System/OS} {System/Architecture}] - {} - [{} / {}] in {} ms - {}" [if [and [zero? error-count] [> test-count 0]] "Success" "Failed!"] [ansi-green success-count] [ansi-red error-count] [- [time/milliseconds] nujel-start] [if [and [zero? error-count] [> test-count 0]] [ansi-rainbow "Everything is working, very nice!"] [ansi-red "Better fix those!"]]]]] v #{
05v random/seed-initialize!
04i 0
0D
05v errorln
15
02i 0
10s error-count
20
0C
0Bo 11
0D
10s test-count
02i 0
22
0Bo 10
05v "Success"
09o 7
05v "Failed!"
0Es fmt-arg-0
0D
05v ansi-green
10s success-count
04i 1
0Es fmt-arg-1
0D
05v ansi-red
10s error-count
04i 1
0Es fmt-arg-2
0D
05v -
05v time/milliseconds
04i 0
10s nujel-start
04i 2
0Es fmt-arg-3
0D
02i 0
10s error-count
20
0C
0Bo 11
0D
10s test-count
02i 0
22
0Bo 16
05v ansi-rainbow
05v "Everything is working, very nice!"
04i 1
09o 13
05v ansi-red
05v "Better fix those!"
04i 1
0Es fmt-arg-4
0D
05v cat
10s test-context
05v " ["
10s System/OS
05v " "
10s System/Architecture
05v "] - "
10s fmt-arg-0
05v " - ["
10s fmt-arg-1
05v " / "
10s fmt-arg-2
05v "] in "
10s fmt-arg-3
05v " ms - "
10s fmt-arg-4
04i 15
16
04i 1
01
}
0Es display-results
0D
25v test-success v [res-should res-is expr i] v #@[documentation: "Should be called after a test has finished successfully" source: ["Should be called after a test has finished successfully" [when print-passes [efmtln "{} == {}\r\n{}\r\n\r\n" [ansi-green [str/write res-is]] [ansi-green [str/write res-should]] [str/write expr]]] [set! success-count [+ 1 success-count]]]] v #{
10s print-passes
0Bo 101
05v errorln
15
05v ansi-green
05v str/write
10s res-is
04i 1
04i 1
0Es fmt-arg-0
0D
05v ansi-green
05v str/write
10s res-should
04i 1
04i 1
0Es fmt-arg-1
0D
05v str/write
10s expr
04i 1
0Es fmt-arg-2
0D
05v cat
10s fmt-arg-0
05v " == "
10s fmt-arg-1
05v "\r\n"
10s fmt-arg-2
05v "\r\n\r\n"
04i 6
16
04i 1
09o 4
24
0D
05v +
02i 1
10s success-count
04i 2
0Fs success-count
01
}
0Es test-success
0D
25v test-failure v [res-should res-is expr i] v #@[documentation: "Should be called if EXPR does not equal RES" source: ["Should be called if EXPR does not equal RES" [when print-errors [pfmtln "{} != {}\r\n{}\r\n\r\n" [ansi-red [str/write res-is]] [ansi-green [str/write res-should]] [str/write expr]]] [set! error-count [+ 1 error-count]]]] v #{
10s print-errors
0Bo 101
05v println
15
05v ansi-red
05v str/write
10s res-is
04i 1
04i 1
0Es fmt-arg-0
0D
05v ansi-green
05v str/write
10s res-should
04i 1
04i 1
0Es fmt-arg-1
0D
05v str/write
10s expr
04i 1
0Es fmt-arg-2
0D
05v cat
10s fmt-arg-0
05v " != "
10s fmt-arg-1
05v "\r\n"
10s fmt-arg-2
05v "\r\n\r\n"
04i 6
16
04i 1
09o 4
24
0D
05v +
02i 1
10s error-count
04i 2
0Fs error-count
01
}
0Es test-failure
0D
25v test-default v [result rawexpr i] v #@[documentation: "Tests that RAWEXPR evaluates to RESULT" source: ["Tests that RAWEXPR evaluates to RESULT" [try [fn [err] [display/error err] [test-failure result [list :exception-caught err] rawexpr i]] [def expr [eval rawexpr]] [if [equal? result expr] [test-success result expr rawexpr i] [test-failure result expr rawexpr i]]]]] v #{
25v anonymous v [err] v #@[source: [[display/error err] [test-failure result [list :exception-caught err] rawexpr i]]] v #{
05v display/error
10s err
04i 1
0D
05v test-failure
10s result
05v list
05v :exception-caught
10s err
04i 2
10s rawexpr
10s i
04i 4
01
}
19o 89
05v eval-in
05v current-closure
04i 0
10s rawexpr
04i 2
0Es expr
0D
05v equal?
10s result
10s expr
04i 2
0Bo 28
05v test-success
10s result
10s expr
10s rawexpr
10s i
04i 4
09o 25
05v test-failure
10s result
10s expr
10s rawexpr
10s i
04i 4
16
01
}
0Es test-default
0D
25v test-run-real v [test] v #@[source: [[set! nujel-start [time/milliseconds]] [set! success-count 0] [set! error-count 0] [def i [+ test-count 1]] [for-in [cur-test test-list] [test [car cur-test] [cdr cur-test] [-- i]]] [display-results] error-count]] v #{
05v time/milliseconds
04i 0
0Fs nujel-start
0D
02i 0
0Fs success-count
0D
02i 0
0Fs error-count
0D
05v +
10s test-count
02i 1
04i 2
0Es i
0D
15
10s test-list
0Es ΓεnΣym-151
0D
10s ΓεnΣym-151
0Bo 73
02i 0
1B
1C
10s ΓεnΣym-151
0Bo 59
0D
10s ΓεnΣym-151
11
0Es cur-test
0D
10s test
10s cur-test
11
10s cur-test
12
05v +
02i -1
10s i
04i 2
0Fs i
04i 3
0D
10s ΓεnΣym-151
12
0Fs ΓεnΣym-151
09o -61
09o 4
24
16
0D
05v display-results
04i 0
0D
10s error-count
01
}
0Es test-run-real
0D
25v test-run v [output-passes hide-errors] v #@[documentation: "Run through all automated Tests" source: ["Run through all automated Tests" [set! print-errors [not [bool hide-errors]]] [set! print-passes [bool output-passes]] [test-run-real test-default]]] v #{
05v bool
10s hide-errors
04i 1
0Bo 10
05v #f
09o 7
05v #t
0Fs print-errors
0D
05v bool
10s output-passes
04i 1
0Fs print-passes
0D
05v test-run-real
10s test-default
04i 1
01
}
0Es test-run
0D
05v test/reset
04i 0
01
}#{
25v dup v [l] v #@[source: [[case [type-of l] [:tree [tree/dup l]] [:array [array/dup l]] [otherwise l]]]] v #{
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-154
0D
10s ΓεnΣym-154
05v :tree
20
0Bo 16
05v tree/dup
10s l
04i 1
09o 32
10s ΓεnΣym-154
05v :array
20
0Bo 16
05v array/dup
10s l
04i 1
09o 7
10s l
16
01
}
0Es dup
0D
25v make-instance v [parent] v #@[source: [[when [and [not [nil? parent]] [!= [type-of parent] :tree]] [throw [list :type-error "Parents can only be trees or nil" parent [current-lambda]]]] [def ret [tree/new #nil]] [for-in [k [tree/keys parent]] [when [!= k :parent] [def pv [tree/get parent k]] [when-not [== [type-of pv] :lambda] [tree/set! ret k [dup pv]]]]] [tree/set! ret :parent parent]]] v #{
05v nil?
10s parent
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Bo 24
0D
05v !=
05v type-of
10s parent
04i 1
05v :tree
04i 2
0Bo 36
05v throw
05v list
05v :type-error
05v "Parents can only be trees or nil"
10s parent
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v tree/new
24
04i 1
0Es ret
0D
15
05v tree/keys
10s parent
04i 1
0Es ΓεnΣym-155
0D
10s ΓεnΣym-155
0Bo 127
02i 0
1B
1C
10s ΓεnΣym-155
0Bo 113
0D
10s ΓεnΣym-155
11
0Es k
0D
05v !=
10s k
05v :parent
04i 2
0Bo 71
10s tree/get
10s parent
10s k
04i 2
0Es pv
0D
05v type-of
10s pv
04i 1
05v :lambda
20
0Bo 7
24
09o 27
05v tree/set!
10s ret
10s k
05v dup
10s pv
04i 1
04i 3
09o 4
24
0D
10s ΓεnΣym-155
12
0Fs ΓεnΣym-155
09o -115
09o 4
24
16
0D
05v tree/set!
10s ret
05v :parent
10s parent
04i 3
01
}
0Es make-instance
0D
25v nos/funcall* v [o method-name args] v #@[source: [[if o [do [def v [tree/get o method-name]] [if v [apply v args] [nos/funcall* [tree/get o :parent] method-name args]]] [throw [list :missing-method "Can't find that method" o [current-lambda]]]]]] v #{
10s o
0Bo 77
10s tree/get
10s o
10s method-name
04i 2
0Es v
0D
10s v
0Bo 20
05v apply
10s v
10s args
04i 2
09o 31
05v nos/funcall*
10s tree/get
10s o
05v :parent
04i 2
10s method-name
10s args
04i 3
09o 33
05v throw
05v list
05v :missing-method
05v "Can't find that method"
10s o
05v current-lambda
04i 0
04i 4
04i 1
01
}
0Es nos/funcall*
0D
25v nos/funcall v [o method-name . args] v #@[source: [[nos/funcall* o method-name [cons o args]]]] v #{
05v nos/funcall*
10s o
10s method-name
10s o
10s args
14
04i 3
01
}
0Es nos/funcall
0D
25v nos/funcall*/try v [o method-name args] v #@[source: [[when o [def v [tree/get o method-name]] [if v [apply v args] [nos/funcall* [tree/get o :parent] method-name args]]]]] v #{
10s o
0Bo 77
10s tree/get
10s o
10s method-name
04i 2
0Es v
0D
10s v
0Bo 20
05v apply
10s v
10s args
04i 2
09o 31
05v nos/funcall*
10s tree/get
10s o
05v :parent
04i 2
10s method-name
10s args
04i 3
09o 4
24
01
}
0Es nos/funcall*/try
0D
25v nos/funcall/try v [o method-name . args] v #@[source: [[nos/funcall*/try o method-name [cons o args]]]] v #{
05v nos/funcall*/try
10s o
10s method-name
10s o
10s args
14
04i 3
01
}
0Es nos/funcall/try
0D
26v defobject v [parent] v #@[source: [[quasiquote [make-instance [unquote parent]]]]] v #{
23s make-instance
10s parent
24
14
14
01
}
0Es defobject
0D
26v defproperty v [o name val] v #@[source: [[quasiquote [tree/set! [unquote o] [unquote name] [unquote val]]]]] v #{
23s tree/set!
10s o
10s name
10s val
24
14
14
14
14
01
}
0Es defproperty
0D
26v defmethod v [o name args . body] v #@[source: [[quasiquote [tree/set! [unquote o] [unquote name] [fn [unquote [cons 'this args]] [unquote-splicing body]]]]]] v #{
23s tree/set!
10s o
10s name
23s fn
23s this
10s args
14
05v append
10s body
24
04i 2
14
14
24
14
14
14
14
01
}
0Es defmethod
0D
26v _ v [o name . args] v #@[source: [[quasiquote [nos/funcall [unquote o] [unquote name] [unquote-splicing args]]]]] v #{
23s nos/funcall
10s o
10s name
05v append
10s args
24
04i 2
14
14
14
01
}
0Es _
01
}