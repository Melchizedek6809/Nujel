#{##[#@[documentation: "Returns the Nand of its arguments" source: ["Returns the Nand of its arguments" [bit-not [apply bit-and l]]]] #{##[]
10s bit-not
10s apply
10s bit-and
10s l
04i 2
04i 1
01
} [x y] #@[documentation: "Bitwise and with complement" source: ["Bitwise and with complement" [bit-and x [bit-not y]]]] #{##[]
10s bit-and
10s x
10s bit-not
10s y
04i 1
04i 2
01
} [α i] #@[documentation: "Test bit at position i" source: ["Test bit at position i" [typecheck/only α :int] [typecheck/only i :int] [not [zero? [bit-and α [bit-shift-left 1 i]]]]]] #{##[:int :type-error "Expected a value of type :int" #f #t]
10s type-of
10s α
04i 1
1Ai 0
20
0Bo 7
24
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s α
10s current-lambda
04i 0
04i 4
04i 1
0D
10s type-of
10s i
04i 1
1Ai 0
20
0Bo 7
24
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s i
10s current-lambda
04i 0
04i 4
04i 1
0D
10s bit-and
10s α
10s bit-shift-left
02i 1
10s i
04i 2
04i 2
2A
0Bo 8
1Ai 3
09o 5
1Ai 4
01
} [α i] #@[documentation: "Bitwise shift right" source: ["Bitwise shift right" [bit-shift-left α [- i]]]] #{##[]
10s bit-shift-left
10s α
10s -
10s i
04i 1
04i 2
01
} [x i] #@[documentation: "Set bit at i" source: ["Set bit at i" [bit-or x [bit-shift-left 1 i]]]] #{##[]
10s bit-or
10s x
10s bit-shift-left
02i 1
10s i
04i 2
04i 2
01
} [x i] #@[documentation: "Flip bit at i" source: ["Flip bit at i" [bit-xor x [bit-shift-left 1 i]]]] #{##[]
10s bit-xor
10s x
10s bit-shift-left
02i 1
10s i
04i 2
04i 2
01
} [x i] #@[documentation: "Clear bit at i" source: ["Clear bit at i" [bit-and x [bit-not [bit-shift-left 1 i]]]]] #{##[]
10s bit-and
10s x
10s bit-not
10s bit-shift-left
02i 1
10s i
04i 2
04i 1
04i 2
01
}]
23s bit-nand
23s l
1Ai 0
1Ai 1
17
0Es bit-nand
0D
10s bit-nand
0Es lognand
0D
23s bit-and-not
1Ai 2
1Ai 3
1Ai 4
17
0Es bit-and-not
0D
23s bit-test?
1Ai 5
1Ai 6
1Ai 7
17
0Es bit-test?
0D
10s bit-test?
0Es bit-set?
0D
23s bit-shift-right
1Ai 8
1Ai 9
1Ai 10
17
0Es bit-shift-right
0D
23s bit-set
1Ai 11
1Ai 12
1Ai 13
17
0Es bit-set
0D
23s bit-flip
1Ai 14
1Ai 15
1Ai 16
17
0Es bit-flip
0D
23s bit-clear
1Ai 17
1Ai 18
1Ai 19
17
0Es bit-clear
01
}#{##[[a i v] #@[documentation: "Add V to the value in A at position I and store the result in A returning A" source: ["Add V to the value in A at position I and store the result in A returning A" [array/set! a i [+ v [array/ref a i]]]]] #{##[]
10s array/set!
10s a
10s i
10s v
10s array/ref
10s a
10s i
04i 2
25
04i 3
01
} [a i] #@[documentation: "Increment position I in A and return A" source: ["Increment position I in A and return A" [array/+= a i 1]]] #{##[]
10s array/+=
10s a
10s i
02i 1
04i 3
01
} [a v] #@[documentation: "Fills array a with value v" source: ["Fills array a with value v" [def len [array/length a]] [dotimes [i len] [array/set! a i v]] [return a]]] #{##[]
10s array/length
10s a
04i 1
0Es len
0D
15
02i 0
0Es i
0D
24
1B
09o 35
0D
1C
10s array/set!
10s a
10s i
10s v
04i 3
0D
02i 1
10s i
03
0Fs i
10s i
10s len
1E
0Ao -41
0D
24
16
0D
10s a
01
01
} [a b] #@[documentation: "Append array A to array B" source: ["Append array A to array B" [when-not [and [array? a] [array? b]] [throw [list :type-error "array/append expects two arrays as its arguments" #nil [current-lambda]]]] [def ret [array/allocate [+ [array/length a] [array/length b]]]] [dotimes [i [array/length a]] [array/set! ret i [array/ref a i]]] [let [[i [array/length a]] [rl [array/length ret]]] [while [< i rl] [array/set! ret i [array/ref b [- i [array/length a]]]] [set! i [add/int i 1]]]] [return ret]]] #{##[:type-error "array/append expects two arrays as its arguments"]
10s array?
10s a
04i 1
0C
0Bo 14
0D
10s array?
10s b
04i 1
0Bo 7
24
09o 26
10s throw
10s list
1Ai 0
1Ai 1
24
10s current-lambda
04i 0
04i 4
04i 1
0D
10s array/allocate
10s array/length
10s a
04i 1
10s array/length
10s b
04i 1
25
04i 1
0Es ret
0D
15
02i 0
0Es i
0D
24
1B
09o 45
0D
1C
10s array/set!
10s ret
10s i
10s array/ref
10s a
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
10s i
10s array/length
10s a
04i 1
1E
0Ao -57
0D
24
16
0D
15
10s array/length
10s a
04i 1
0Es i
0D
10s array/length
10s ret
04i 1
0Es rl
0D
24
1B
09o 56
0D
1C
10s array/set!
10s ret
10s i
10s array/ref
10s b
10s i
10s array/length
10s a
04i 1
26
04i 2
04i 3
0D
10s i
02i 1
03
0Fs i
10s i
10s rl
1E
0Ao -62
16
0D
10s ret
01
01
} [a] #@[documentation: "Duplicate Array A" source: ["Duplicate Array A" [def ret [array/allocate [array/length a]]] [dotimes [i [array/length a]] [array/set! ret i [array/ref a i]]] [return ret]]] #{##[]
10s array/allocate
10s array/length
10s a
04i 1
04i 1
0Es ret
0D
15
02i 0
0Es i
0D
24
1B
09o 45
0D
1C
10s array/set!
10s ret
10s i
10s array/ref
10s a
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
10s i
10s array/length
10s a
04i 1
1E
0Ao -57
0D
24
16
0D
10s ret
01
01
} [arr fun α] #@[documentation: "Reduce an array, [reduce] should be preferred" source: ["Reduce an array, [reduce] should be preferred" [def len [array/length arr]] [dotimes [i len] [set! α [fun α [array/ref arr i]]]] [return α]]] #{##[]
10s array/length
10s arr
04i 1
0Es len
0D
15
02i 0
0Es i
0D
24
1B
09o 45
0D
1C
10s fun
10s α
10s array/ref
10s arr
10s i
04i 2
04i 2
0Fs α
0D
02i 1
10s i
03
0Fs i
10s i
10s len
1E
0Ao -51
0D
24
16
0D
10s α
01
01
} [arr fun] #@[documentation: "Map an array, [map] should be preferred" source: ["Map an array, [map] should be preferred" [def len [array/length arr]] [dotimes [i len] [array/set! arr i [fun [array/ref arr i]]]] [return arr]]] #{##[]
10s array/length
10s arr
04i 1
0Es len
0D
15
02i 0
0Es i
0D
24
1B
09o 51
0D
1C
10s array/set!
10s arr
10s i
10s fun
10s array/ref
10s arr
10s i
04i 2
04i 1
04i 3
0D
02i 1
10s i
03
0Fs i
10s i
10s len
1E
0Ao -57
0D
24
16
0D
10s arr
01
01
} [arr pred] #@[documentation: "Filter an array, [filter] should be preferred" source: ["Filter an array, [filter] should be preferred" [def ri 0] [def len [array/length arr]] [def ret [array/allocate len]] [dotimes [ai len] [when [pred [array/ref arr ai]] [array/set! ret ri [array/ref arr ai]] [inc! ri]]] [array/length! ret ri]]] #{##[]
02i 0
0Es ri
0D
10s array/length
10s arr
04i 1
0Es len
0D
10s array/allocate
10s len
04i 1
0Es ret
0D
15
02i 0
0Es ai
0D
24
1B
09o 84
0D
1C
10s pred
10s array/ref
10s arr
10s ai
04i 2
04i 1
0Bo 46
10s array/set!
10s ret
10s ri
10s array/ref
10s arr
10s ai
04i 2
04i 3
0D
10s ri
02i 1
25
0Fs ri
09o 4
24
0D
02i 1
10s ai
03
0Fs ai
10s ai
10s len
1E
0Ao -90
0D
24
16
0D
10s array/length!
10s ret
10s ri
04i 2
01
} [a b] #@[source: [[if [or [not [array? a]] [not [array? b]] [not= [array/length a] [array/length b]]] [return #f] [let [[ret #t]] [dotimes [i [array/length a]] [when-not [equal? [array/ref a i] [array/ref b i]] [set! ret #f] [set! i [array/length a]]]] [return ret]]]]] #{##[#f #t]
10s array?
10s a
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
0C
0Ao 62
0D
10s array?
10s b
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
0C
0Ao 37
0D
10s not=
10s array/length
10s a
04i 1
10s array/length
10s b
04i 1
04i 2
0C
0Ao 6
0D
1Ai 0
0Bo 9
1Ai 0
01
09o 128
15
1Ai 1
0Es ret
0D
15
02i 0
0Es i
0D
24
1B
09o 79
0D
1C
10s equal?
10s array/ref
10s a
10s i
04i 2
10s array/ref
10s b
10s i
04i 2
04i 2
0Bo 7
24
09o 24
1Ai 0
0Fs ret
0D
10s array/length
10s a
04i 1
0Fs i
0D
02i 1
10s i
03
0Fs i
10s i
10s array/length
10s a
04i 1
1E
0Ao -91
0D
24
16
0D
10s ret
01
16
01
} [arr val] #@[documentation: "Append VAL to ARR" source: ["Append VAL to ARR" [-> arr [array/length! [+ 1 [array/length arr]]] [array/set! [- [array/length arr] 1] val]]]] #{##[]
10s array/set!
10s array/length!
10s arr
02i 1
10s array/length
10s arr
04i 1
25
04i 2
10s array/length
10s arr
04i 1
02i 1
26
10s val
04i 3
01
} [arr i j] #@[documentation: "Swap values at I and J in ARR" source: ["Swap values at I and J in ARR" [def tmp [array/ref arr i]] [-> arr [array/set! i [array/ref arr j]] [array/set! j tmp]]]] #{##[]
10s array/ref
10s arr
10s i
04i 2
0Es tmp
0D
10s array/set!
10s array/set!
10s arr
10s i
10s array/ref
10s arr
10s j
04i 2
04i 3
10s j
10s tmp
04i 3
01
} [arr n at] #@[documentation: "bubble up the element from index AT to until the max-heap property is satisfied" source: ["bubble up the element from index AT to until the max-heap property is satisfied" [def top at] [def looping #t] [while looping [def l [+ [bit-shift-left at 1] 1]] [def r [+ [bit-shift-left at 1] 2]] [when [and [< l n] [> [array/ref arr l] [array/ref arr top]]] [set! top l]] [when [and [< r n] [> [array/ref arr r] [array/ref arr top]]] [set! top r]] [if [= top at] [set! looping #f] [do [array/swap arr at top] [set! at top]]]] [return arr]]] #{##[#t #f]
10s at
0Es top
0D
1Ai 0
0Es looping
0D
24
1B
09o 211
0D
1C
10s bit-shift-left
10s at
02i 1
04i 2
02i 1
25
0Es l
0D
10s bit-shift-left
10s at
02i 1
04i 2
02i 2
25
0Es r
0D
10s l
10s n
1E
0C
0Bo 33
0D
10s array/ref
10s arr
10s l
04i 2
10s array/ref
10s arr
10s top
04i 2
22
0Bo 14
10s l
0Fs top
09o 4
24
0D
10s r
10s n
1E
0C
0Bo 33
0D
10s array/ref
10s arr
10s r
04i 2
10s array/ref
10s arr
10s top
04i 2
22
0Bo 14
10s r
0Fs top
09o 4
24
0D
10s top
10s at
20
0Bo 12
1Ai 1
0Fs looping
09o 30
10s array/swap
10s arr
10s at
10s top
04i 3
0D
10s top
0Fs at
10s looping
0Ao -212
0D
10s arr
01
01
} [arr] #@[source: [[def l [array/length arr]] [def l2 [/ l 2]] [while [>= l2 0] [array/heapify arr l l2] [dec! l2]] [return arr]]] #{##[]
10s array/length
10s arr
04i 1
0Es l
0D
10s l
02i 2
28
0Es l2
0D
24
1B
09o 35
0D
1C
10s array/heapify
10s arr
10s l
10s l2
04i 3
0D
10s l2
02i 1
26
0Fs l2
10s l2
02i 0
21
0Ao -39
0D
10s arr
01
01
} [arr] #@[source: [[array/make-heap arr] [def l [array/length arr]] [while [> l 0] [dec! l] [array/swap arr 0 l] [array/heapify arr l 0]] [return arr]]] #{##[]
10s array/make-heap
10s arr
04i 1
0D
10s array/length
10s arr
04i 1
0Es l
0D
24
1B
09o 50
0D
1C
10s l
02i 1
26
0Fs l
0D
10s array/swap
10s arr
02i 0
10s l
04i 3
0D
10s array/heapify
10s arr
10s l
02i 0
04i 3
10s l
02i 0
22
0Ao -54
0D
10s arr
01
01
} [arr start end] #@[documentation: "Return a newly allocated array with the values of ARR from START to END" source: ["Return a newly allocated array with the values of ARR from START to END" [set! start [max 0 start]] [set! end [min [array/length arr] end]] [def ret [array/allocate [max 0 [- end start]]]] [def i start] [while [< i end] [array/set! ret [- i start] [array/ref arr i]] [set! i [add/int i 1]]] [return ret]]] #{##[]
10s max
02i 0
10s start
04i 2
0Fs start
0D
10s min
10s array/length
10s arr
04i 1
10s end
04i 2
0Fs end
0D
10s array/allocate
10s max
02i 0
10s end
10s start
26
04i 2
04i 1
0Es ret
0D
10s start
0Es i
0D
24
1B
09o 50
0D
1C
10s array/set!
10s ret
10s i
10s start
26
10s array/ref
10s arr
10s i
04i 2
04i 3
0D
10s i
02i 1
03
0Fs i
10s i
10s end
1E
0Ao -56
0D
10s ret
01
01
}]
23s array/+=
1Ai 0
1Ai 1
1Ai 2
17
0Es array/+=
0D
23s array/++
1Ai 3
1Ai 4
1Ai 5
17
0Es array/++
0D
23s array/fill!
1Ai 6
1Ai 7
1Ai 8
17
0Es array/fill!
0D
23s array/append
1Ai 9
1Ai 10
1Ai 11
17
0Es array/append
0D
23s array/dup
1Ai 12
1Ai 13
1Ai 14
17
0Es array/dup
0D
23s array/reduce
1Ai 15
1Ai 16
1Ai 17
17
0Es array/reduce
0D
23s array/map
1Ai 18
1Ai 19
1Ai 20
17
0Es array/map
0D
23s array/filter
1Ai 21
1Ai 22
1Ai 23
17
0Es array/filter
0D
23s array/equal?
1Ai 24
1Ai 25
1Ai 26
17
0Es array/equal?
0D
23s array/push
1Ai 27
1Ai 28
1Ai 29
17
0Es array/push
0D
23s array/swap
1Ai 30
1Ai 31
1Ai 32
17
0Es array/swap
0D
23s array/heapify
1Ai 33
1Ai 34
1Ai 35
17
0Es array/heapify
0D
23s array/make-heap
1Ai 36
1Ai 37
1Ai 38
17
0Es array/make-heap
0D
23s array/heap-sort
1Ai 39
1Ai 40
1Ai 41
17
0Es array/heap-sort
0D
10s array/heap-sort
0Es array/sort
0D
23s array/cut
1Ai 42
1Ai 43
1Ai 44
17
0Es array/cut
01
}#{##[[c] #@[documentation: "Return the sum of every value in collection C" source: ["Return the sum of every value in collection C" [reduce c + 0]]] #{##[]
10s reduce
10s c
10s +
02i 0
04i 3
01
} [l p] #@[documentation: "Returns #t if P is true for every entry of collection L" source: ["Returns #t if P is true for every entry of collection L" [reduce l [fn [a b] [and a [p b]]] #t]]] #{##[[a b] #@[source: [[and a [p b]]]] #{##[]
10s a
0C
0Bo 14
0D
10s p
10s b
04i 1
01
} #t]
10s reduce
10s l
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
1Ai 3
04i 3
01
} [l glue] #@[documentation: "Join every element of α together into a string with GLUE inbetween" source: ["Join every element of α together into a string with GLUE inbetween" [when-not glue [set! glue ""]] [if-not l "" [reduce l [fn [a b] [if a [cat a glue b] b]] #nil]]]] #{##["" [a b] #@[source: [[if a [cat a glue b] b]]] #{##[]
10s a
0Bo 24
10s cat
10s a
10s glue
10s b
04i 3
09o 7
10s b
01
}]
10s glue
0Bo 7
24
09o 9
1Ai 0
0Fs glue
0D
10s l
0Bo 28
10s reduce
10s l
23s anonymous
1Ai 1
1Ai 2
1Ai 3
17
24
04i 3
09o 5
1Ai 0
01
} [l f] #@[documentation: "Runs F over every item in collection L" source: ["Runs F over every item in collection L" [reduce l [fn [a b] [f b]] #nil]]] #{##[[a b] #@[source: [[f b]]] #{##[]
10s f
10s b
04i 1
01
}]
10s reduce
10s l
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
24
04i 3
01
} [l p] #@[documentation: "Count the number of items in L where P is true" source: ["Count the number of items in L where P is true" [if p [reduce l [fn [a b] [+ a [if [p b] 1 0]]] 0] [reduce l [fn [a b] [+ a 1]] 0]]]] #{##[[a b] #@[source: [[+ a [if [p b] 1 0]]]] #{##[]
10s a
10s p
10s b
04i 1
0Bo 8
02i 1
09o 5
02i 0
25
01
} [a b] #@[source: [[+ a 1]]] #{##[]
10s a
02i 1
25
01
}]
10s p
0Bo 29
10s reduce
10s l
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
02i 0
04i 3
09o 26
10s reduce
10s l
23s anonymous
1Ai 3
1Ai 4
1Ai 5
17
02i 0
04i 3
01
} #@[documentation: "Returns the minimum value of its arguments, or collection" source: ["Returns the minimum value of its arguments, or collection" [reduce [if [cdr l] l [car l]] [fn [a b] [if [< a b] a b]]]]] #{##[[a b] #@[source: [[if [< a b] a b]]] #{##[]
10s a
10s b
1E
0Bo 10
10s a
09o 7
10s b
01
}]
10s reduce
10s l
12
0Bo 10
10s l
09o 8
10s l
11
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
04i 2
01
} #@[documentation: "Returns the minimum value of its arguments, or collection" source: ["Returns the minimum value of its arguments, or collection" [reduce [if [cdr l] l [car l]] [fn [a b] [if [> a b] a b]]]]] #{##[[a b] #@[source: [[if [> a b] a b]]] #{##[]
10s a
10s b
22
0Bo 10
10s a
09o 7
10s b
01
}]
10s reduce
10s l
12
0Bo 10
10s l
09o 8
10s l
11
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
04i 2
01
} [l e] #@[documentation: "Returns a filtered list l with all elements equal to e omitted" source: ["Returns a filtered list l with all elements equal to e omitted" [filter l [fn [a] [not [= a e]]]]]] #{##[[a] #@[source: [[not [= a e]]]] #{##[#f #t]
10s a
10s e
20
0Bo 8
1Ai 0
09o 5
1Ai 1
01
}]
10s filter
10s l
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
04i 2
01
} [l p] #@[documentation: "Returns a filtered list l with all elements where P equal true removed" source: ["Returns a filtered list l with all elements where P equal true removed" [filter l [fn [a] [not [p a]]]]]] #{##[[a] #@[source: [[not [p a]]]] #{##[#f #t]
10s p
10s a
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
01
}]
10s filter
10s l
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
04i 2
01
} [a b] #@[source: [[cond [[collection? b] [append [reduce b flatten/λ #nil] a]] [#t [cons b a]]]]] #{##[#t]
10s collection?
10s b
04i 1
0Bo 31
10s append
10s reduce
10s b
10s flatten/λ
24
04i 3
10s a
04i 2
09o 21
1Ai 0
0Bo 15
10s b
10s a
14
09o 4
24
01
} [l] #@[documentation: "Flatten a collection of collections into a simple list" source: ["Flatten a collection of collections into a simple list" [if-not [collection? l] l [nreverse [reduce l flatten/λ #nil]]]]] #{##[]
10s collection?
10s l
04i 1
0Bo 27
10s nreverse
10s reduce
10s l
10s flatten/λ
24
04i 3
04i 1
09o 7
10s l
01
}]
23s sum
1Ai 0
1Ai 1
1Ai 2
17
0Es sum
0D
23s every?
1Ai 3
1Ai 4
1Ai 5
17
0Es every?
0D
23s join
1Ai 6
1Ai 7
1Ai 8
17
0Es join
0D
23s for-each
1Ai 9
1Ai 10
1Ai 11
17
0Es for-each
0D
23s count
1Ai 12
1Ai 13
1Ai 14
17
0Es count
0D
23s min
23s l
1Ai 15
1Ai 16
17
0Es min
0D
23s max
23s l
1Ai 17
1Ai 18
17
0Es max
0D
23s delete
1Ai 19
1Ai 20
1Ai 21
17
0Es delete
0D
23s remove
1Ai 22
1Ai 23
1Ai 24
17
0Es remove
0D
23s flatten/λ
1Ai 25
1Ai 26
1Ai 27
17
0Es flatten/λ
0D
23s flatten
1Ai 28
1Ai 29
1Ai 30
17
0Es flatten
01
}#{##[[l i] #@[documentation: "Return whatver is at position I in L" source: ["Return whatver is at position I in L" [case [type-of l] [:nil #nil] [:tree [tree/ref l i]] [:string [char-at l i]] [:array [array/ref l i]] [:pair [list/ref l i]] [otherwise [throw [list :type-error "You can only use ref with a collection" l [current-lambda]]]]]]] #{##[:nil :tree :string :array :pair :type-error "You can only use ref with a collection"]
15
10s type-of
10s l
04i 1
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
1Ai 0
20
0Bo 7
24
09o 137
10s ΓεnΣym-1
1Ai 1
20
0Bo 20
10s tree/ref
10s l
10s i
04i 2
09o 110
10s ΓεnΣym-1
1Ai 2
20
0Bo 20
10s char-at
10s l
10s i
04i 2
09o 83
10s ΓεnΣym-1
1Ai 3
20
0Bo 20
10s array/ref
10s l
10s i
04i 2
09o 56
10s ΓεnΣym-1
1Ai 4
20
0Bo 20
10s list/ref
10s l
10s i
04i 2
09o 29
10s throw
10s list
1Ai 5
1Ai 6
10s l
10s current-lambda
04i 0
04i 4
04i 1
16
01
} [l p] #@[documentation: "Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" source: ["Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" [case [type-of l] [:nil #nil] [:tree [tree/filter l p]] [:pair [list/filter l p]] [:array [array/filter l p]] [otherwise [throw [list :type-error "You can only use filter with a collection" l [current-lambda]]]]]]] #{##[:nil :tree :pair :array :type-error "You can only use filter with a collection"]
15
10s type-of
10s l
04i 1
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
1Ai 0
20
0Bo 7
24
09o 110
10s ΓεnΣym-2
1Ai 1
20
0Bo 20
10s tree/filter
10s l
10s p
04i 2
09o 83
10s ΓεnΣym-2
1Ai 2
20
0Bo 20
10s list/filter
10s l
10s p
04i 2
09o 56
10s ΓεnΣym-2
1Ai 3
20
0Bo 20
10s array/filter
10s l
10s p
04i 2
09o 29
10s throw
10s list
1Ai 4
1Ai 5
10s l
10s current-lambda
04i 0
04i 4
04i 1
16
01
} [l f α] #@[documentation: "Combine all elements in collection l using operation F and starting value α" source: ["Combine all elements in collection l using operation F and starting value α" [case [type-of l] [:nil α] [:tree [tree/reduce l f α]] [:pair [list/reduce l f α]] [:array [array/reduce l f α]] [otherwise [f α l]]]]] #{##[:nil :tree :pair :array]
15
10s type-of
10s l
04i 1
0Es ΓεnΣym-3
0D
10s ΓεnΣym-3
1Ai 0
20
0Bo 10
10s α
09o 110
10s ΓεnΣym-3
1Ai 1
20
0Bo 24
10s tree/reduce
10s l
10s f
10s α
04i 3
09o 79
10s ΓεnΣym-3
1Ai 2
20
0Bo 24
10s list/reduce
10s l
10s f
10s α
04i 3
09o 48
10s ΓεnΣym-3
1Ai 3
20
0Bo 24
10s array/reduce
10s l
10s f
10s α
04i 3
09o 17
10s f
10s α
10s l
04i 2
16
01
} [α] #@[documentation: "Returns the length of collection α" source: ["Returns the length of collection α" [case [type-of α] [:nil 0] [:array [array/length α]] [:pair [list/length α]] [:string [string/length α]] [:tree [tree/size α]] [otherwise [throw [list :type-error "You can only use length with a collection" α [current-lambda]]]]]]] #{##[:nil :array :pair :string :tree :type-error "You can only use length with a collection"]
15
10s type-of
10s α
04i 1
0Es ΓεnΣym-4
0D
10s ΓεnΣym-4
1Ai 0
20
0Bo 8
02i 0
09o 121
10s ΓεnΣym-4
1Ai 1
20
0Bo 16
10s array/length
10s α
04i 1
09o 98
10s ΓεnΣym-4
1Ai 2
20
0Bo 16
10s list/length
10s α
04i 1
09o 75
10s ΓεnΣym-4
1Ai 3
20
0Bo 16
10s string/length
10s α
04i 1
09o 52
10s ΓεnΣym-4
1Ai 4
20
0Bo 16
10s tree/size
10s α
04i 1
09o 29
10s throw
10s list
1Ai 5
1Ai 6
10s α
10s current-lambda
04i 0
04i 4
04i 1
16
01
} [l f] #@[documentation: "Runs f over every item in collection l and returns the resulting list" source: ["Runs f over every item in collection l and returns the resulting list" [case [type-of l] [:nil #nil] [:pair [list/map l f]] [:array [array/map l f]] [otherwise [throw [list :type-error "You can only use map with a collection" l [current-lambda]]]]]]] #{##[:nil :pair :array :type-error "You can only use map with a collection"]
15
10s type-of
10s l
04i 1
0Es ΓεnΣym-5
0D
10s ΓεnΣym-5
1Ai 0
20
0Bo 7
24
09o 83
10s ΓεnΣym-5
1Ai 1
20
0Bo 20
10s list/map
10s l
10s f
04i 2
09o 56
10s ΓεnΣym-5
1Ai 2
20
0Bo 20
10s array/map
10s l
10s f
04i 2
09o 29
10s throw
10s list
1Ai 3
1Ai 4
10s l
10s current-lambda
04i 0
04i 4
04i 1
16
01
} [l] #@[documentation: "Sorts the collection L" source: ["Sorts the collection L" [case [type-of l] [:nil #nil] [:pair [list/sort l]] [:array [array/sort l]] [otherwise [throw [list :type-error "You can only use sort with a collection" l [current-lambda]]]]]]] #{##[:nil :pair :array :type-error "You can only use sort with a collection"]
15
10s type-of
10s l
04i 1
0Es ΓεnΣym-6
0D
10s ΓεnΣym-6
1Ai 0
20
0Bo 7
24
09o 75
10s ΓεnΣym-6
1Ai 1
20
0Bo 16
10s list/sort/merge
10s l
04i 1
09o 52
10s ΓεnΣym-6
1Ai 2
20
0Bo 16
10s array/heap-sort
10s l
04i 1
09o 29
10s throw
10s list
1Ai 3
1Ai 4
10s l
10s current-lambda
04i 0
04i 4
04i 1
16
01
} [l m] #@[documentation: "Returns the first pair/item of collection l whose car is equal to m" source: ["Returns the first pair/item of collection l whose car is equal to m" [case [type-of l] [:pair [list/member l m]] [otherwise [throw [list :type-error "You can only use member with a collection" l [current-lambda]]]]]]] #{##[:pair :type-error "You can only use member with a collection"]
15
10s type-of
10s l
04i 1
0Es ΓεnΣym-7
0D
10s ΓεnΣym-7
1Ai 0
20
0Bo 20
10s list/member
10s l
10s m
04i 2
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s l
10s current-lambda
04i 0
04i 4
04i 1
16
01
} [l start end] #@[documentation: "Return a subcollection of L from START to END" source: ["Return a subcollection of L from START to END" [case [type-of l] [:array [array/cut l start end]] [:pair [list/cut l start end]] [:string [string/cut l start end]] [otherwise [throw [list :type-error "You can only use member with a collection" l [current-lambda]]]]]]] #{##[:array :pair :string :type-error "You can only use member with a collection"]
15
10s type-of
10s l
04i 1
0Es ΓεnΣym-8
0D
10s ΓεnΣym-8
1Ai 0
20
0Bo 24
10s array/cut
10s l
10s start
10s end
04i 3
09o 91
10s ΓεnΣym-8
1Ai 1
20
0Bo 24
10s list/cut
10s l
10s start
10s end
04i 3
09o 60
10s ΓεnΣym-8
1Ai 2
20
0Bo 24
10s string/cut
10s l
10s start
10s end
04i 3
09o 29
10s throw
10s list
1Ai 3
1Ai 4
10s l
10s current-lambda
04i 0
04i 4
04i 1
16
01
} [l] #@[source: [[case [type-of l] [[:pair :array :tree] #t] [otherwise #f]]]] #{##[:pair :array :tree #f #t]
15
10s type-of
10s l
04i 1
0Es ΓεnΣym-9
0D
10s ΓεnΣym-9
1Ai 0
20
0C
0Ao 30
0D
10s ΓεnΣym-9
1Ai 1
20
0C
0Ao 18
0D
10s ΓεnΣym-9
1Ai 2
20
0C
0Ao 6
0D
1Ai 3
0Bo 8
1Ai 4
09o 5
1Ai 3
16
01
}]
23s ref
1Ai 0
1Ai 1
1Ai 2
17
0Es ref
0D
23s filter
1Ai 3
1Ai 4
1Ai 5
17
0Es filter
0D
23s reduce
1Ai 6
1Ai 7
1Ai 8
17
0Es reduce
0D
23s length
1Ai 9
1Ai 10
1Ai 11
17
0Es length
0D
23s map
1Ai 12
1Ai 13
1Ai 14
17
0Es map
0D
23s sort
1Ai 15
1Ai 16
1Ai 17
17
0Es sort
0D
23s member
1Ai 18
1Ai 19
1Ai 20
17
0Es member
0D
23s cut
1Ai 21
1Ai 22
1Ai 23
17
0Es cut
0D
23s collection?
1Ai 24
1Ai 25
1Ai 26
17
0Es collection?
01
}#{##[[arr] #@[source: [[def i [- [array/length arr] 1]] [def ret #nil] [while [>= i 0] [set! ret [cons [array/ref arr i] ret]] [dec! i]] [return ret]]] #{##[]
10s array/length
10s arr
04i 1
02i 1
26
0Es i
0D
24
0Es ret
0D
24
1B
09o 40
0D
1C
10s array/ref
10s arr
10s i
04i 2
10s ret
14
0Fs ret
0D
10s i
02i 1
26
0Fs i
10s i
02i 0
21
0Ao -44
0D
10s ret
01
01
} [list rest] #@[documentation: "Iterator for except-last-pair" source: ["Iterator for except-last-pair" [if [nil? [cdr list]] [reverse rest] [except-last-pair/iter [cdr list] [cons [car list] rest]]]]] #{##[]
10s nil?
10s list
12
04i 1
0Bo 16
10s reverse
10s rest
04i 1
09o 24
10s except-last-pair/iter
10s list
12
10s list
11
10s rest
14
04i 2
01
} [list] #@[documentation: "Return a copy of LIST without the last pair" source: ["Return a copy of LIST without the last pair" [except-last-pair/iter list #nil]]] #{##[]
10s except-last-pair/iter
10s list
24
04i 2
01
} [list] #@[documentation: "Return the last pair of LIST" source: ["Return the last pair of LIST" [while [cdr list] [cdr! list]] list]] #{##[]
24
1B
09o 14
0D
1C
10s list
12
0Fs list
10s list
12
0Ao -16
0D
10s list
01
} [number value] #@[documentation: "Return a list of NUMBER elements containing VALUE in every car" source: ["Return a list of NUMBER elements containing VALUE in every car" [def list #nil] [while [>= [dec! number] 0] [set! list [cons value list]]] list]] #{##[]
24
0Es list
0D
24
1B
09o 18
0D
1C
10s value
10s list
14
0Fs list
10s number
02i 1
26
0Fs number
02i 0
21
0Ao -29
0D
10s list
01
} [end start step] #@[documentation: "Return a list containing values from START (inclusive) to END (exclusive) by STEP" source: ["Return a list containing values from START (inclusive) to END (exclusive) by STEP" [when-not end [throw [list :arity-error "[range] needs at least a specific end"]]] [when-not start [set! start 0]] [when-not step [set! step 1]] [def pred [if [pos? step] < >]] [def ret #nil] [while [pred start end] [set! ret [cons start ret]] [set! start [+ start step]]] [nreverse ret]]] #{##[:arity-error "[range] needs at least a specific end" 0.0]
10s end
0Bo 7
24
09o 19
10s throw
10s list
1Ai 0
1Ai 1
04i 2
04i 1
0D
10s start
0Bo 7
24
09o 9
02i 0
0Fs start
0D
10s step
0Bo 7
24
09o 9
02i 1
0Fs step
0D
10s step
1Ai 2
21
0Bo 10
10s <
09o 7
10s >
0Es pred
0D
24
0Es ret
0D
24
1B
09o 32
0D
1C
10s start
10s ret
14
0Fs ret
0D
10s start
10s step
25
0Fs start
10s pred
10s start
10s end
04i 2
0Ao -43
0D
10s nreverse
10s ret
04i 1
01
} [l o s] #@[documentation: "Combine all elements in l using operation o and starting value s" source: ["Combine all elements in l using operation o and starting value s" [doseq [e l] [set! s [o s e]]] s]] #{##[]
15
10s l
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
0Bo 58
24
1B
09o 43
0D
1C
10s ΓεnΣym-1
11
0Es e
0D
10s o
10s s
10s e
04i 2
0Fs s
0D
10s ΓεnΣym-1
12
0Fs ΓεnΣym-1
10s ΓεnΣym-1
0Ao -44
09o 4
24
16
0D
10s s
01
} [l i] #@[documentation: "Returns the the element of list l at location i" source: ["Returns the the element of list l at location i" [while [and l [> i 0]] [dec! i] [cdr! l]] [car l]]] #{##[]
24
1B
09o 26
0D
1C
10s i
02i 1
26
0Fs i
0D
10s l
12
0Fs l
10s l
0C
0Bo 11
0D
10s i
02i 0
22
0Ao -39
0D
10s l
11
01
} [l] #@[documentation: "Return the list l in reverse order" source: ["Return the list l in reverse order" [def ret] [doseq [e l] [set! ret [cons e ret]]] ret]] #{##[]
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
0Bo 53
24
1B
09o 38
0D
1C
10s ΓεnΣym-2
11
0Es e
0D
10s e
10s ret
14
0Fs ret
0D
10s ΓεnΣym-2
12
0Fs ΓεnΣym-2
10s ΓεnΣym-2
0Ao -39
09o 4
24
16
0D
10s ret
01
} [l] #@[documentation: "Returns the length of list l" source: ["Returns the length of list l" [def ret 0] [doseq [e l] [inc! ret]] ret]] #{##[]
02i 0
0Es ret
0D
15
10s l
0Es ΓεnΣym-3
0D
10s ΓεnΣym-3
0Bo 51
24
1B
09o 36
0D
1C
10s ΓεnΣym-3
11
0Es e
0D
10s ret
02i 1
25
0Fs ret
0D
10s ΓεnΣym-3
12
0Fs ΓεnΣym-3
10s ΓεnΣym-3
0Ao -37
09o 4
24
16
0D
10s ret
01
} [l p] #@[documentation: "Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" source: ["Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" [def ret #nil] [doseq [e l] [when [p e] [set! ret [cons e ret]]]] [nreverse ret]]] #{##[]
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-4
0D
10s ΓεnΣym-4
0Bo 70
24
1B
09o 55
0D
1C
10s ΓεnΣym-4
11
0Es e
0D
10s p
10s e
04i 1
0Bo 19
10s e
10s ret
14
0Fs ret
09o 4
24
0D
10s ΓεnΣym-4
12
0Fs ΓεnΣym-4
10s ΓεnΣym-4
0Ao -56
09o 4
24
16
0D
10s nreverse
10s ret
04i 1
01
} [l f] #@[documentation: "Runs f over every item in list l and returns the resulting list" source: ["Runs f over every item in list l and returns the resulting list" [def ret #nil] [doseq [e l] [set! ret [cons [f e] ret]]] [nreverse ret]]] #{##[]
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-5
0D
10s ΓεnΣym-5
0Bo 59
24
1B
09o 44
0D
1C
10s ΓεnΣym-5
11
0Es e
0D
10s f
10s e
04i 1
10s ret
14
0Fs ret
0D
10s ΓεnΣym-5
12
0Fs ΓεnΣym-5
10s ΓεnΣym-5
0Ao -45
09o 4
24
16
0D
10s nreverse
10s ret
04i 1
01
} [a b] #@[documentation: "Appends two lists A and B together" source: ["Appends two lists A and B together" [def ret b] [set! a [reverse a]] [doseq [t a] [set! ret [cons t ret]]] ret]] #{##[]
10s b
0Es ret
0D
10s reverse
10s a
04i 1
0Fs a
0D
15
10s a
0Es ΓεnΣym-6
0D
10s ΓεnΣym-6
0Bo 53
24
1B
09o 38
0D
1C
10s ΓεnΣym-6
11
0Es t
0D
10s t
10s ret
14
0Fs ret
0D
10s ΓεnΣym-6
12
0Fs ΓεnΣym-6
10s ΓεnΣym-6
0Ao -39
09o 4
24
16
0D
10s ret
01
} [l start end ret] #@[documentation: "Returns a new list containing all elements of l from start to end" source: ["Returns a new list containing all elements of l from start to end" [cond [[nil? l] [reverse ret]] [[neg? end] [sublist l start [+ [length l] end]]] [[zero? end] [reverse ret]] [[> start 0] [sublist [cdr l] [+ -1 start] [+ -1 end] #nil]] [[> end 0] [sublist [cdr l] 0 [+ -1 end] [cons [car l] ret]]]]]] #{##[0.0]
10s nil?
10s l
04i 1
0Bo 16
10s reverse
10s ret
04i 1
09o 149
10s end
1Ai 0
1E
0Bo 35
10s sublist
10s l
10s start
10s length
10s l
04i 1
10s end
25
04i 3
09o 107
10s end
2A
0Bo 16
10s reverse
10s ret
04i 1
09o 86
10s start
02i 0
22
0Bo 32
10s sublist
10s l
12
02i -1
10s start
25
02i -1
10s end
25
24
04i 4
09o 47
10s end
02i 0
22
0Bo 36
10s sublist
10s l
12
02i 0
02i -1
10s end
25
10s l
11
10s ret
14
04i 4
09o 4
24
01
} [l k] #@[documentation: "Returns the first k elements of list l" source: ["Returns the first k elements of list l" [sublist l 0 k]]] #{##[]
10s sublist
10s l
02i 0
10s k
04i 3
01
} [l k] #@[documentation: "Returns the sublist of l obtained by omitting the first l elements" source: ["Returns the sublist of l obtained by omitting the first l elements" [sublist l k [length l]]]] #{##[]
10s sublist
10s l
10s k
10s length
10s l
04i 1
04i 3
01
} [l m] #@[documentation: "Returns the first pair of list l whose car is equal to m" source: ["Returns the first pair of list l whose car is equal to m" [cond [[nil? l] #f] [[= [car l] m] l] [#t [list/member [cdr l] m]]]]] #{##[#f #t]
10s nil?
10s l
04i 1
0Bo 8
1Ai 0
09o 47
10s l
11
10s m
20
0Bo 10
10s l
09o 27
1Ai 1
0Bo 21
10s list/member
10s l
12
10s m
04i 2
09o 4
24
01
} [l key] #@[documentation: "Return the value in LIST following KEY" source: ["Return the value in LIST following KEY" [cond [[nil? l] #nil] [[= key [car l]] [cadr l]] [#t [getf [cdr l] key]]]]] #{##[#t]
10s nil?
10s l
04i 1
0Bo 7
24
09o 49
10s key
10s l
11
20
0Bo 12
10s l
12
11
09o 27
1Ai 0
0Bo 21
10s getf
10s l
12
10s key
04i 2
09o 4
24
01
} [l] #@[documentation: "Terribly slow way to sort a list, though it was simple to write" source: ["Terribly slow way to sort a list, though it was simple to write" [if-not l #nil [do [def top [car l]] [def next #nil] [cdr! l] [while l [if [<= [car l] top] [do [set! next [cons top next]] [set! top [car l]]] [set! next [cons [car l] next]]] [cdr! l]] [cons top [list/sort/bubble next]]]]]] #{##[]
10s l
0Bo 125
10s l
11
0Es top
0D
24
0Es next
0D
10s l
12
0Fs l
0D
24
1B
09o 68
0D
1C
10s l
11
10s top
1F
0Bo 29
10s top
10s next
14
0Fs next
0D
10s l
11
0Fs top
09o 17
10s l
11
10s next
14
0Fs next
0D
10s l
12
0Fs l
10s l
0Ao -69
0D
10s top
10s list/sort/bubble
10s next
04i 1
14
09o 4
24
01
} [l1 l2] #@[source: [[cond [[nil? l1] l2] [[nil? l2] l1] [#t [if [< [car l1] [car l2]] [cons [car l1] [list/merge-sorted-lists [cdr l1] l2]] [cons [car l2] [list/merge-sorted-lists l1 [cdr l2]]]]]]]] #{##[#t]
10s nil?
10s l1
04i 1
0Bo 10
10s l2
09o 91
10s nil?
10s l2
04i 1
0Bo 10
10s l1
09o 71
1Ai 0
0Bo 65
10s l1
11
10s l2
11
1E
0Bo 27
10s l1
11
10s list/merge-sorted-lists
10s l1
12
10s l2
04i 2
14
09o 24
10s l2
11
10s list/merge-sorted-lists
10s l1
10s l2
12
04i 2
14
09o 4
24
01
} [l acc1 acc2] #@[source: [[cond [[nil? l] [cons acc1 acc2]] [[nil? [cdr l]] [cons [cons [car l] acc1] acc2]] [#t [list/split-half-rec [cddr l] [cons [car l] acc1] [cons [cadr l] acc2]]]]]] #{##[#t]
10s nil?
10s l
04i 1
0Bo 15
10s acc1
10s acc2
14
09o 77
10s nil?
10s l
12
04i 1
0Bo 21
10s l
11
10s acc1
14
10s acc2
14
09o 45
1Ai 0
0Bo 39
10s list/split-half-rec
10s l
12
12
10s l
11
10s acc1
14
10s l
12
11
10s acc2
14
04i 3
09o 4
24
01
} [l] #@[source: [[list/split-half-rec l #nil #nil]]] #{##[]
10s list/split-half-rec
10s l
24
24
04i 3
01
} [l] #@[documentation: "Sorts a list" source: ["Sorts a list" [if [nil? [cdr l]] l [do [def parts [list/split-half l]] [list/merge-sorted-lists [list/sort/merge [car parts]] [list/sort/merge [cdr parts]]]]]]] #{##[]
10s nil?
10s l
12
04i 1
0Bo 10
10s l
09o 46
10s list/split-half
10s l
04i 1
0Es parts
0D
10s list/merge-sorted-lists
10s list/sort/merge
10s parts
11
04i 1
10s list/sort/merge
10s parts
12
04i 1
04i 2
01
} [a] #@[documentation: "Return #t is A is a proper list" source: ["Return #t is A is a proper list" [when-not a [return #f]] [while a [when-not [pair? a] [return #f]] [cdr! a]] [return #t]]] #{##[#f #t]
10s a
0Bo 7
24
09o 6
1Ai 0
01
0D
24
1B
09o 35
0D
1C
10s pair?
10s a
04i 1
0Bo 7
24
09o 6
1Ai 0
01
0D
10s a
12
0Fs a
10s a
0Ao -36
0D
1Ai 1
01
01
} [a b] #@[documentation: "#t if A and B are equal" source: ["#t if A and B are equal" [if [pair? a] [and [list/equal? [car a] [car b]] [list/equal? [cdr a] [cdr b]]] [equal? a b]]]] #{##[]
10s pair?
10s a
04i 1
0Bo 43
10s list/equal?
10s a
11
10s b
11
04i 2
0C
0Bo 20
0D
10s list/equal?
10s a
12
10s b
12
04i 2
09o 17
10s equal?
10s a
10s b
04i 2
01
} [l count] #@[documentation: "Take the first COUNT elements from list L" source: ["Take the first COUNT elements from list L" [if [<= count 0] #nil [cons [car l] [list/take [cdr l] [- count 1]]]]]] #{##[]
10s count
02i 0
1F
0Bo 7
24
09o 27
10s l
11
10s list/take
10s l
12
10s count
02i 1
26
04i 2
14
01
} [l count] #@[documentation: "Drop the final COUNT elements from list L" source: ["Drop the final COUNT elements from list L" [if [<= count 0] l [list/drop [cdr l] [- count 1]]]]] #{##[]
10s count
02i 0
1F
0Bo 10
10s l
09o 21
10s list/drop
10s l
12
10s count
02i 1
26
04i 2
01
} [l start end] #@[documentation: "Return a subsequence of L from START to END" source: ["Return a subsequence of L from START to END" [list/take [list/drop l [max 0 start]] [- end [max 0 start]]]]] #{##[]
10s list/take
10s list/drop
10s l
10s max
02i 0
10s start
04i 2
04i 2
10s end
10s max
02i 0
10s start
04i 2
26
04i 2
01
} [l search-for replace-with] #@[documentation: "Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH\nUses [equal?] so we can search/replace lists/trees and other complex data structures" source: ["Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH" "" "Uses [equal?] so we can search/replace lists/trees and other complex data structures" [cond [[not l] #nil] [[equal? l search-for] replace-with] [[equal? [car l] search-for] [cons replace-with [list/replace [cdr l] search-for replace-with]]] [#t [cons [if [pair? [car l]] [list/replace [car l] search-for replace-with] [car l]] [list/replace [cdr l] search-for replace-with]]]]]] #{##[#f #t]
10s l
0Bo 8
1Ai 0
09o 5
1Ai 1
0Bo 7
24
09o 142
10s equal?
10s l
10s search-for
04i 2
0Bo 10
10s replace-with
09o 118
10s equal?
10s l
11
10s search-for
04i 2
0Bo 30
10s replace-with
10s list/replace
10s l
12
10s search-for
10s replace-with
04i 3
14
09o 73
1Ai 1
0Bo 67
10s pair?
10s l
11
04i 1
0Bo 25
10s list/replace
10s l
11
10s search-for
10s replace-with
04i 3
09o 8
10s l
11
10s list/replace
10s l
12
10s search-for
10s replace-with
04i 3
14
09o 4
24
01
}]
23s array->list
1Ai 0
1Ai 1
1Ai 2
17
0Es array->list
0D
23s except-last-pair/iter
1Ai 3
1Ai 4
1Ai 5
17
0Es except-last-pair/iter
0D
23s except-last-pair
1Ai 6
1Ai 7
1Ai 8
17
0Es except-last-pair
0D
23s last-pair
1Ai 9
1Ai 10
1Ai 11
17
0Es last-pair
0D
23s make-list
1Ai 12
1Ai 13
1Ai 14
17
0Es make-list
0D
23s range
1Ai 15
1Ai 16
1Ai 17
17
0Es range
0D
23s list/reduce
1Ai 18
1Ai 19
1Ai 20
17
0Es list/reduce
0D
23s list/ref
1Ai 21
1Ai 22
1Ai 23
17
0Es list/ref
0D
23s reverse
1Ai 24
1Ai 25
1Ai 26
17
0Es reverse
0D
23s list/length
1Ai 27
1Ai 28
1Ai 29
17
0Es list/length
0D
23s list/filter
1Ai 30
1Ai 31
1Ai 32
17
0Es list/filter
0D
23s list/map
1Ai 33
1Ai 34
1Ai 35
17
0Es list/map
0D
23s append
1Ai 36
1Ai 37
1Ai 38
17
0Es append
0D
23s sublist
1Ai 39
1Ai 40
1Ai 41
17
0Es sublist
0D
23s list-head
1Ai 42
1Ai 43
1Ai 44
17
0Es list-head
0D
23s list-tail
1Ai 45
1Ai 46
1Ai 47
17
0Es list-tail
0D
23s list/member
1Ai 48
1Ai 49
1Ai 50
17
0Es list/member
0D
23s getf
1Ai 51
1Ai 52
1Ai 53
17
0Es getf
0D
23s list/sort/bubble
1Ai 54
1Ai 55
1Ai 56
17
0Es list/sort/bubble
0D
23s list/merge-sorted-lists
1Ai 57
1Ai 58
1Ai 59
17
0Es list/merge-sorted-lists
0D
23s list/split-half-rec
1Ai 60
1Ai 61
1Ai 62
17
0Es list/split-half-rec
0D
23s list/split-half
1Ai 63
1Ai 64
1Ai 65
17
0Es list/split-half
0D
23s list/sort/merge
1Ai 66
1Ai 67
1Ai 68
17
0Es list/sort/merge
0D
10s list/sort/merge
0Es list/sort
0D
23s list?
1Ai 69
1Ai 70
1Ai 71
17
0Es list?
0D
23s list/equal?
1Ai 72
1Ai 73
1Ai 74
17
0Es list/equal?
0D
23s list/take
1Ai 75
1Ai 76
1Ai 77
17
0Es list/take
0D
23s list/drop
1Ai 78
1Ai 79
1Ai 80
17
0Es list/drop
0D
23s list/cut
1Ai 81
1Ai 82
1Ai 83
17
0Es list/cut
0D
23s list/replace
1Ai 84
1Ai 85
1Ai 86
17
0Es list/replace
01
}#{##[[keys values] #@[documentation: "Return a tree where KEYS point to VALUES" source: ["Return a tree where KEYS point to VALUES" [def ret [tree/new #nil]] [doseq [key keys] [tree/set! ret key [car values]] [cdr! values]] ret]] #{##[]
10s tree/new
24
04i 1
0Es ret
0D
15
10s keys
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
0Bo 69
24
1B
09o 54
0D
1C
10s ΓεnΣym-1
11
0Es key
0D
10s tree/set!
10s ret
10s key
10s values
11
04i 3
0D
10s values
12
0Fs values
0D
10s ΓεnΣym-1
12
0Fs ΓεnΣym-1
10s ΓεnΣym-1
0Ao -55
09o 4
24
16
0D
10s ret
01
} [t k v] #@[documentation: "Increment value at K in T by V" source: ["Increment value at K in T by V" [tree/set! t k [+ v [int [or [tree/ref t k] 0]]]]]] #{##[#f]
10s tree/set!
10s t
10s k
10s v
10s int
10s tree/ref
10s t
10s k
04i 2
0C
0Ao 13
0D
02i 0
0C
0Ao 6
0D
1Ai 0
04i 1
25
04i 3
01
} [t k v] #@[documentation: "Decrement value at K in T by V" source: ["Decrement value at K in T by V" [quasiquote [tree/+= [unquote t] [unquote k] [- [unquote v]]]]]] #{##[]
23s tree/+=
10s t
10s k
23s -
10s v
24
14
14
24
14
14
14
14
01
} [t k] #@[documentation: "Increment value at K in T by 1" source: ["Increment value at K in T by 1" [quasiquote [tree/+= [unquote t] [unquote k] 1]]]] #{##[]
23s tree/+=
10s t
10s k
02i 1
24
14
14
14
14
01
} [t k] #@[documentation: "Increment value at K in T by 1" source: ["Increment value at K in T by 1" [quasiquote [tree/-= [unquote t] [unquote k] 1]]]] #{##[]
23s tree/-=
10s t
10s k
02i 1
24
14
14
14
14
01
} [a b] #@[documentation: "Compares two trees for equality" source: ["Compares two trees for equality" [if [and [tree? a] [tree? b]] [and [= [tree/key* a] [tree/key* b]] [equal? [tree/value* a] [tree/value* b]] [tree/equal? [tree/left* a] [tree/left* b]] [tree/equal? [tree/right* a] [tree/right* b]]] [equal? a b]]]] #{##[]
10s tree?
10s a
04i 1
0C
0Bo 14
0D
10s tree?
10s b
04i 1
0Bo 120
10s tree/key*
10s a
04i 1
10s tree/key*
10s b
04i 1
20
0C
0Bo 92
0D
10s equal?
10s tree/value*
10s a
04i 1
10s tree/value*
10s b
04i 1
04i 2
0C
0Bo 61
0D
10s tree/equal?
10s tree/left*
10s a
04i 1
10s tree/left*
10s b
04i 1
04i 2
0C
0Bo 30
0D
10s tree/equal?
10s tree/right*
10s a
04i 1
10s tree/right*
10s b
04i 1
04i 2
09o 17
10s equal?
10s a
10s b
04i 2
01
} [l o s] #@[documentation: "Combine all elements in l using operation o and starting value s" source: ["Combine all elements in l using operation o and starting value s" [list/reduce [tree/values l] o s]]] #{##[]
10s list/reduce
10s tree/values
10s l
04i 1
10s o
10s s
04i 3
01
} [l f] #@[documentation: "Return a new tree with all elements from L where F retunrs true" source: ["Return a new tree with all elements from L where F retunrs true" [def ret [tree/new #nil]] [doseq [e [tree/keys l]] [def t [tree/ref l e]] [when [f t] [tree/set! ret e t]]] ret]] #{##[]
10s tree/new
24
04i 1
0Es ret
0D
15
10s tree/keys
10s l
04i 1
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
0Bo 94
24
1B
09o 79
0D
1C
10s ΓεnΣym-2
11
0Es e
0D
10s tree/ref
10s l
10s e
04i 2
0Es t
0D
10s f
10s t
04i 1
0Bo 24
10s tree/set!
10s ret
10s e
10s t
04i 3
09o 4
24
0D
10s ΓεnΣym-2
12
0Fs ΓεnΣym-2
10s ΓεnΣym-2
0Ao -80
09o 4
24
16
0D
10s ret
01
}]
23s tree/zip
1Ai 0
1Ai 1
1Ai 2
17
0Es tree/zip
0D
23s tree/+=
1Ai 3
1Ai 4
1Ai 5
17
0Es tree/+=
0D
23s tree/-=
1Ai 6
1Ai 7
1Ai 8
18
0Es tree/-=
0D
23s tree/++
1Ai 9
1Ai 10
1Ai 11
18
0Es tree/++
0D
23s tree/--
1Ai 12
1Ai 13
1Ai 14
18
0Es tree/--
0D
23s tree/equal?
1Ai 15
1Ai 16
1Ai 17
17
0Es tree/equal?
0D
23s tree/reduce
1Ai 18
1Ai 19
1Ai 20
17
0Es tree/reduce
0D
23s tree/filter
1Ai 21
1Ai 22
1Ai 23
17
0Es tree/filter
01
}#{##[[expr] #@[source: [expr]] #{##[]
10s expr
01
} [expr] #@[source: [[-> [bytecompile expr] assemble*]]] #{##[]
10s assemble*
10s bytecompile
10s expr
04i 1
04i 1
01
} :bytecode :none [expr] #@[source: [[[tree/ref backend/tree *active-backend*] expr]]] #{##[]
10s tree/ref
10s backend/tree
10s *active-backend*
04i 2
10s expr
04i 1
01
} [backend expr environment] #@[source: [[def last-backend *active-backend*] [def ret #nil] [try [fn [e] [set! *active-backend* last-backend] [throw e]] [set! *active-backend* backend] [set! ret [compile expr environment]] [set! *active-backend* last-backend] [return ret]]]] #{##[[e] #@[source: [[set! *active-backend* last-backend] [throw e]]] #{##[]
10s last-backend
0Fs *active-backend*
0D
10s throw
10s e
04i 1
01
}]
10s *active-backend*
0Es last-backend
0D
24
0Es ret
0D
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
19o 48
10s backend
0Fs *active-backend*
0D
10s compile*
10s expr
10s current-closure
04i 0
04i 2
0Fs ret
0D
10s last-backend
0Fs *active-backend*
0D
10s ret
01
16
01
}]
23s compile/backend/none
1Ai 0
1Ai 1
1Ai 2
17
0Es compile/backend/none
0D
23s compile/backend/bytecode
1Ai 3
1Ai 4
1Ai 5
17
0Es compile/backend/bytecode
0D
1Ai 6
0Es *active-backend*
0D
10s tree/new
1Ai 6
10s compile/backend/bytecode
1Ai 7
10s compile/backend/none
04i 4
0Es backend/tree
0D
23s backend
1Ai 8
1Ai 9
1Ai 10
17
0Es backend
0D
23s compile/for
1Ai 11
1Ai 12
1Ai 13
17
0Es compile/for
01
}#{##[[] #@[documentation: "[] -> []\nDo nothing" source: ["[] -> []" "Do nothing" :inline '[#$0]] inline: #t] #{##[[#$0]]
1Ai 0
01
} [] #@[documentation: "[a] -> []\nReturn top of value stack" source: ["[a] -> []" "Return top of value stack" :inline '[#$1]] inline: #t] #{##[[#$1]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [result]\nAdds the two topmost values and pushes the result" source: ["[a b] -> [result]" "Adds the two topmost values and pushes the result" :inline '[#$3]] inline: #t] #{##[[#$3]]
1Ai 0
01
} [] #@[documentation: "[a] -> [a a]\nDuplicates the value that is on the top of the stack" source: ["[a] -> [a a]" "Duplicates the value that is on the top of the stack" :inline '[#$C]] inline: #t] #{##[[#$C]]
1Ai 0
01
} [] #@[documentation: "[a] -> []\nDrop whatever is on top of the stack" source: ["[a] -> []" "Drop whatever is on top of the stack" :inline '[#$D]] inline: #t] #{##[[#$D]]
1Ai 0
01
} [] #@[documentation: "[] -> [closure]\nPush the current closure as a λ on the stack" source: ["[] -> [closure]" "Push the current closure as a λ on the stack" :inline '[#$13]] inline: #t] #{##[[#$13]]
1Ai 0
01
} [] #@[documentation: "[] -> []\nCreate a new let closure and switch to it" source: ["[] -> []" "Create a new let closure and switch to it" :inline '[#$15]] inline: #t] #{##[[#$15]]
1Ai 0
01
} [] #@[documentation: "[] -> []\nLeave the current closure and return to the parent one" source: ["[] -> []" "Leave the current closure and return to the parent one" :inline '[#$16]] inline: #t] #{##[[#$16]]
1Ai 0
01
} [] #@[documentation: "[] -> []\nStore the current root stack pointer used for guarding allocations into the current closure" source: ["[] -> []" "Store the current root stack pointer used for guarding allocations into the current closure" :inline '[#$1B]] inline: #t] #{##[[#$1B]]
1Ai 0
01
} [] #@[documentation: "[] -> []\nRestore the current root stack pointer to what is stored within the current closure" source: ["[] -> []" "Restore the current root stack pointer to what is stored within the current closure" :inline '[#$1C]] inline: #t] #{##[[#$1C]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$1E]] inline: #t] #{##[[#$1E]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$1F]] inline: #t] #{##[[#$1F]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$20]] inline: #t] #{##[[#$20]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$21]] inline: #t] #{##[[#$21]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$22]] inline: #t] #{##[[#$22]]
1Ai 0
01
} [] #@[documentation: "[] -> [nil]\nPush a #nil on the stack" source: ["[] -> [nil]" "Push a #nil on the stack" :inline '[#$24]] inline: #t] #{##[[#$24]]
1Ai 0
01
} [] #@[documentation: "[l] -> [car]\nReplace L with its car" source: ["[l] -> [car]" "Replace L with its car" :inline '[#$11]] inline: #t] #{##[[#$11]]
1Ai 0
01
} [] #@[documentation: "[l] -> [cdr]\nReplace L with its cdr" source: ["[l] -> [cdr]" "Replace L with its cdr" :inline '[#$12]] inline: #t] #{##[[#$12]]
1Ai 0
01
} [] #@[documentation: "[car cdr] -> [pair]\nCons CAR and CDR together and put it on the stack" source: ["[car cdr] -> [pair]" "Cons CAR and CDR together and put it on the stack" :inline '[#$14]] inline: #t] #{##[[#$14]]
1Ai 0
01
} [] #@[documentation: "[name args docs body] -> [λ]\nCreate a new λ" source: ["[name args docs body] -> [λ]" "Create a new λ" :inline '[#$17]] inline: #t] #{##[[#$17]]
1Ai 0
01
} [] #@[documentation: "[name args docs body] -> [μ]\nCreate a new μ" source: ["[name args docs body] -> [μ]" "Create a new μ" :inline '[#$18]] inline: #t] #{##[[#$18]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$25]] inline: #t] #{##[[#$25]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$26]] inline: #t] #{##[[#$26]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$27]] inline: #t] #{##[[#$27]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$28]] inline: #t] #{##[[#$28]]
1Ai 0
01
} [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$29]] inline: #t] #{##[[#$29]]
1Ai 0
01
} [] #@[documentation: "[a] -> [result]" source: ["[a] -> [result]" :inline '[#$2A]] inline: #t] #{##[[#$2A]]
1Ai 0
01
}]
23s $nop
1Ai 0
1Ai 1
1Ai 2
17
0Es $nop
0D
23s $ret
1Ai 3
1Ai 4
1Ai 5
17
0Es $ret
0D
23s $add/int
1Ai 6
1Ai 7
1Ai 8
17
0Es $add/int
0D
23s $dup
1Ai 9
1Ai 10
1Ai 11
17
0Es $dup
0D
23s $drop
1Ai 12
1Ai 13
1Ai 14
17
0Es $drop
0D
23s $closure/push
1Ai 15
1Ai 16
1Ai 17
17
0Es $closure/push
0D
23s $let
1Ai 18
1Ai 19
1Ai 20
17
0Es $let
0D
23s $closure/pop
1Ai 21
1Ai 22
1Ai 23
17
0Es $closure/pop
0D
23s $roots/save
1Ai 24
1Ai 25
1Ai 26
17
0Es $roots/save
0D
23s $roots/restore
1Ai 27
1Ai 28
1Ai 29
17
0Es $roots/restore
0D
23s $<
1Ai 30
1Ai 31
1Ai 32
17
0Es $<
0D
23s $<=
1Ai 33
1Ai 34
1Ai 35
17
0Es $<=
0D
23s $=
1Ai 36
1Ai 37
1Ai 38
17
0Es $=
0D
23s $>=
1Ai 39
1Ai 40
1Ai 41
17
0Es $>=
0D
23s $>
1Ai 42
1Ai 43
1Ai 44
17
0Es $>
0D
23s $push/nil
1Ai 45
1Ai 46
1Ai 47
17
0Es $push/nil
0D
23s $car
1Ai 48
1Ai 49
1Ai 50
17
0Es $car
0D
23s $cdr
1Ai 51
1Ai 52
1Ai 53
17
0Es $cdr
0D
23s $cons
1Ai 54
1Ai 55
1Ai 56
17
0Es $cons
0D
23s $fn/dynamic
1Ai 57
1Ai 58
1Ai 59
17
0Es $fn/dynamic
0D
23s $macro/dynamic
1Ai 60
1Ai 61
1Ai 62
17
0Es $macro/dynamic
0D
23s $add
1Ai 63
1Ai 64
1Ai 65
17
0Es $add
0D
23s $sub
1Ai 66
1Ai 67
1Ai 68
17
0Es $sub
0D
23s $mul
1Ai 69
1Ai 70
1Ai 71
17
0Es $mul
0D
23s $div
1Ai 72
1Ai 73
1Ai 74
17
0Es $div
0D
23s $rem
1Ai 75
1Ai 76
1Ai 77
17
0Es $rem
0D
23s $zero?
1Ai 78
1Ai 79
1Ai 80
17
0Es $zero?
01
}#{##[[v] #@[source: [[def i [sym->index v]] [list [int->bytecode-op [bit-and [bit-shift-right i 16] 255]] [int->bytecode-op [bit-and [bit-shift-right i 8] 255]] [int->bytecode-op [bit-and i 255]]]]] #{##[255]
10s sym->index
10s v
04i 1
0Es i
0D
10s list
10s int->bytecode-op
10s bit-and
10s bit-shift-right
10s i
02i 16
04i 2
1Ai 0
04i 2
04i 1
10s int->bytecode-op
10s bit-and
10s bit-shift-right
10s i
02i 8
04i 2
1Ai 0
04i 2
04i 1
10s int->bytecode-op
10s bit-and
10s i
1Ai 0
04i 2
04i 1
04i 3
01
} [a] #@[source: [[and [<= a 127] [>= a -128]]]] #{##[]
10s a
02i 127
1F
0C
0Bo 11
0D
10s a
02i -128
21
01
} [a] #@[documentation: "[] -> [a]\nPush A on the stack as an :int" source: ["[] -> [a]" "Push A on the stack as an :int" [if [int-fit-in-byte? a] [$push/int/byte a] [$push/val a]]]] #{##[]
10s int-fit-in-byte?
10s a
04i 1
0Bo 16
10s $push/int/byte
10s a
04i 1
09o 13
10s $push/val
10s a
04i 1
01
} [a] #@[documentation: "[] -> [a]\nPush A on the stack as an :int that fits within a byte" source: ["[] -> [a]" "Push A on the stack as an :int that fits within a byte" [when-not [int-fit-in-byte? a] [throw [list :invalid-bc-op "$push/int/byte can only push a signed 8-bit value" a [current-lambda]]]] [list #$2 [int->bytecode-op a]]]] #{##[:invalid-bc-op "$push/int/byte can only push a signed 8-bit value" #$2]
10s int-fit-in-byte?
10s a
04i 1
0Bo 7
24
09o 29
10s throw
10s list
1Ai 0
1Ai 1
10s a
10s current-lambda
04i 0
04i 4
04i 1
0D
10s list
1Ai 2
10s int->bytecode-op
10s a
04i 1
04i 2
01
} [sym] #@[documentation: "[] -> [sym]\nPushes v onto the stack" source: ["[] -> [sym]" "Pushes v onto the stack" [list #$23 [sym->bytecode-op sym]]]] #{##[#$23]
10s list
1Ai 0
10s sym->bytecode-op
10s sym
04i 1
04i 2
01
} [sym] #@[documentation: "[val] -> [val]\nDefine a new binding for SYM and associate VAL to it" source: ["[val] -> [val]" "Define a new binding for SYM and associate VAL to it" [list #$E [sym->bytecode-op sym]]]] #{##[#$E]
10s list
1Ai 0
10s sym->bytecode-op
10s sym
04i 1
04i 2
01
} [sym] #@[documentation: "[val] -> [val]\nUpdate the binding for SYM and associate VAL to it" source: ["[val] -> [val]" "Update the binding for SYM and associate VAL to it" [list #$F [sym->bytecode-op sym]]]] #{##[#$F]
10s list
1Ai 0
10s sym->bytecode-op
10s sym
04i 1
04i 2
01
} [sym] #@[documentation: "[] -> [val]\nPush whatever value is associated to SYM on the stack" source: ["[] -> [val]" "Push whatever value is associated to SYM on the stack" [list #$10 [sym->bytecode-op sym]]]] #{##[#$10]
10s list
1Ai 0
10s sym->bytecode-op
10s sym
04i 1
04i 2
01
} [fun arg-count] #@[source: [[case fun [[+ - * / rem] [= arg-count 2]] [[zero? car cdr add/int cons < <= = >= >] #t]]]] #{##[#f #t]
15
10s fun
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
10s +
20
0C
0Ao 62
0D
10s ΓεnΣym-1
10s -
20
0C
0Ao 48
0D
10s ΓεnΣym-1
10s *
20
0C
0Ao 34
0D
10s ΓεnΣym-1
10s /
20
0C
0Ao 20
0D
10s ΓεnΣym-1
10s rem
20
0C
0Ao 6
0D
1Ai 0
0Bo 13
10s arg-count
02i 2
20
09o 154
10s ΓεnΣym-1
10s zero?
20
0C
0Ao 132
0D
10s ΓεnΣym-1
10s car
20
0C
0Ao 118
0D
10s ΓεnΣym-1
10s cdr
20
0C
0Ao 104
0D
10s ΓεnΣym-1
10s add/int
20
0C
0Ao 90
0D
10s ΓεnΣym-1
10s cons
20
0C
0Ao 76
0D
10s ΓεnΣym-1
10s <
20
0C
0Ao 62
0D
10s ΓεnΣym-1
10s <=
20
0C
0Ao 48
0D
10s ΓεnΣym-1
10s =
20
0C
0Ao 34
0D
10s ΓεnΣym-1
10s >=
20
0C
0Ao 20
0D
10s ΓεnΣym-1
10s >
20
0C
0Ao 6
0D
1Ai 0
0Bo 8
1Ai 1
09o 4
24
16
01
} [arg-count fun] #@[documentation: "arguments -> [result]\nRead arg-count arguments from the stack, apply the to fun and push the result on the stack" source: ["arguments -> [result]" "Read arg-count arguments from the stack, apply the to fun and push the result on the stack" [case arg-count [1 [case fun [car [$car]] [cdr [$cdr]] [zero? [$zero?]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]] [2 [case fun [add/int [$add/int]] [+ [$add]] [- [$sub]] [* [$mul]] [/ [$div]] [rem [$rem]] [cons [$cons]] [< [$<]] [<= [$<=]] [= [$=]] [>= [$>=]] [> [$>]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]]] #{##[[#$11] [#$12] [#$2A] :arity-error "Wrong number of arguments for that function" [#$3] [#$25] [#$26] [#$27] [#$28] [#$29] [#$14] [#$1E] [#$1F] [#$20] [#$21] [#$22]]
15
10s arg-count
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
02i 1
20
0Bo 94
15
10s fun
0Es ΓεnΣym-3
0D
10s ΓεnΣym-3
10s car
20
0Bo 8
1Ai 0
09o 63
10s ΓεnΣym-3
10s cdr
20
0Bo 8
1Ai 1
09o 46
10s ΓεnΣym-3
10s zero?
20
0Bo 8
1Ai 2
09o 29
10s throw
10s list
1Ai 3
1Ai 4
10s fun
10s current-lambda
04i 0
04i 4
04i 1
16
09o 283
10s ΓεnΣym-2
02i 2
20
0Bo 247
15
10s fun
0Es ΓεnΣym-4
0D
10s ΓεnΣym-4
10s add/int
20
0Bo 8
1Ai 5
09o 216
10s ΓεnΣym-4
10s +
20
0Bo 8
1Ai 6
09o 199
10s ΓεnΣym-4
10s -
20
0Bo 8
1Ai 7
09o 182
10s ΓεnΣym-4
10s *
20
0Bo 8
1Ai 8
09o 165
10s ΓεnΣym-4
10s /
20
0Bo 8
1Ai 9
09o 148
10s ΓεnΣym-4
10s rem
20
0Bo 8
1Ai 10
09o 131
10s ΓεnΣym-4
10s cons
20
0Bo 8
1Ai 11
09o 114
10s ΓεnΣym-4
10s <
20
0Bo 8
1Ai 12
09o 97
10s ΓεnΣym-4
10s <=
20
0Bo 8
1Ai 13
09o 80
10s ΓεnΣym-4
10s =
20
0Bo 8
1Ai 14
09o 63
10s ΓεnΣym-4
10s >=
20
0Bo 8
1Ai 15
09o 46
10s ΓεnΣym-4
10s >
20
0Bo 8
1Ai 16
09o 29
10s throw
10s list
1Ai 3
1Ai 4
10s fun
10s current-lambda
04i 0
04i 4
04i 1
16
09o 29
10s throw
10s list
1Ai 3
1Ai 4
10s fun
10s current-lambda
04i 0
04i 4
04i 1
16
01
} [arg-count fun] #@[source: [[list #$4 [int->bytecode-op arg-count]]]] #{##[#$4]
10s list
1Ai 0
10s int->bytecode-op
10s arg-count
04i 1
04i 2
01
} [target] #@[documentation: "[] -> []\nTry something, jumping to target if an exception occurs" source: ["[] -> []" "Try something, jumping to target if an exception occurs" [list #$19 [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[#$19 :relocate]
10s list
1Ai 0
10s list
1Ai 1
10s target
02i 8
02i 0
10s int->bytecode-op
02i 0
04i 1
04i 5
10s list
1Ai 1
10s target
02i 0
02i 1
10s int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
} [target] #@[source: [[list #$9 [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[#$9 :relocate]
10s list
1Ai 0
10s list
1Ai 1
10s target
02i 8
02i 0
10s int->bytecode-op
02i 0
04i 1
04i 5
10s list
1Ai 1
10s target
02i 0
02i 1
10s int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
} [v] #@[documentation: "[] -> [v]\nPushes v onto the stack" source: ["[] -> [v]" "Pushes v onto the stack" [when [nil? v] [throw [list :invalid-bc-op "Can't push #nil as a normal lVal" v [current-lambda]]]] [list #$1A [list :literal v]]]] #{##[:invalid-bc-op "Can't push #nil as a normal lVal" #$1A :literal]
10s nil?
10s v
04i 1
0Bo 32
10s throw
10s list
1Ai 0
1Ai 1
10s v
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s list
1Ai 2
10s list
1Ai 3
10s v
04i 2
04i 2
01
} [target] #@[source: [[list #$A [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[#$A :relocate]
10s list
1Ai 0
10s list
1Ai 1
10s target
02i 8
02i 0
10s int->bytecode-op
02i 0
04i 1
04i 5
10s list
1Ai 1
10s target
02i 0
02i 1
10s int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
} [target] #@[source: [[list #$B [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[#$B :relocate]
10s list
1Ai 0
10s list
1Ai 1
10s target
02i 8
02i 0
10s int->bytecode-op
02i 0
04i 1
04i 5
10s list
1Ai 1
10s target
02i 0
02i 1
10s int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
} [name args docs body] #@[source: [[list #$25 [val->bytecode-op name] [val->bytecode-op args] [val->bytecode-op docs] [val->bytecode-op body]]]] #{##[#$25]
10s list
1Ai 0
10s val->bytecode-op
10s name
04i 1
10s val->bytecode-op
10s args
04i 1
10s val->bytecode-op
10s docs
04i 1
10s val->bytecode-op
10s body
04i 1
04i 5
01
} [name args docs body] #@[source: [[list #$26 [val->bytecode-op name] [val->bytecode-op args] [val->bytecode-op docs] [val->bytecode-op body]]]] #{##[#$26]
10s list
1Ai 0
10s val->bytecode-op
10s name
04i 1
10s val->bytecode-op
10s args
04i 1
10s val->bytecode-op
10s docs
04i 1
10s val->bytecode-op
10s body
04i 1
04i 5
01
} [code sym-map pos] #@[source: [[while code [case [type-of [car code]] [:bytecode-op [tree/set! sym-map :last-op [inc! pos]]] [:keyword [case [car code] [:label [tree/set! sym-map [cadr code] pos] [cdr! code]] [:literal [cdr! code]]]] [:pair [set! pos [assemble/build-sym-map [car code] sym-map pos]]]] [cdr! code]] [return pos]]] #{##[:bytecode-op :last-op :keyword :label :literal :pair]
24
1B
09o 197
0D
1C
15
10s type-of
10s code
11
04i 1
0Es ΓεnΣym-5
0D
10s ΓεnΣym-5
1Ai 0
20
0Bo 29
10s tree/set!
10s sym-map
1Ai 1
10s pos
02i 1
25
0Fs pos
04i 3
09o 131
10s ΓεnΣym-5
1Ai 2
20
0Bo 84
15
10s code
11
0Es ΓεnΣym-6
0D
10s ΓεnΣym-6
1Ai 3
20
0Bo 36
10s tree/set!
10s sym-map
10s code
12
11
10s pos
04i 3
0D
10s code
12
0Fs code
09o 26
10s ΓεnΣym-6
1Ai 4
20
0Bo 15
10s code
12
0Fs code
09o 4
24
16
09o 40
10s ΓεnΣym-5
1Ai 5
20
0Bo 29
10s assemble/build-sym-map
10s code
11
10s sym-map
10s pos
04i 3
0Fs pos
09o 4
24
16
0D
10s code
12
0Fs code
10s code
0Ao -198
0D
10s pos
01
01
} [code sym-map pos out] #@[source: [[def target [tree/ref sym-map [cadr code]]] [def off [- [+ target [cadddr code]] pos]] [array/set! out [inc! pos] [int->bytecode-op [bit-and [bit-shift-right off [caddr code]] 255]]] [return pos]]] #{##[255]
10s tree/ref
10s sym-map
10s code
12
11
04i 2
0Es target
0D
10s target
10s cadddr
10s code
04i 1
25
10s pos
26
0Es off
0D
10s array/set!
10s out
10s pos
02i 1
25
0Fs pos
10s int->bytecode-op
10s bit-and
10s bit-shift-right
10s off
10s caddr
10s code
04i 1
04i 2
1Ai 0
04i 2
04i 1
04i 3
0D
10s pos
01
01
} [code sym-map pos out] #@[source: [[if [= [car code] :relocate] [set! pos [assemble/relocate-op code sym-map pos out]] [doseq [op code] [case [type-of op] [:bytecode-op [array/set! out [inc! pos] op]] [:pair [set! pos [assemble/emit-relocated-ops op sym-map pos out]]]]]] [return pos]]] #{##[:relocate :bytecode-op :pair]
10s code
11
1Ai 0
20
0Bo 32
10s assemble/relocate-op
10s code
10s sym-map
10s pos
10s out
04i 4
0Fs pos
09o 154
15
10s code
0Es ΓεnΣym-7
0D
10s ΓεnΣym-7
0Bo 135
24
1B
09o 120
0D
1C
10s ΓεnΣym-7
11
0Es op
0D
15
10s type-of
10s op
04i 1
0Es ΓεnΣym-8
0D
10s ΓεnΣym-8
1Ai 1
20
0Bo 31
10s array/set!
10s out
10s pos
02i 1
25
0Fs pos
10s op
04i 3
09o 43
10s ΓεnΣym-8
1Ai 2
20
0Bo 32
10s assemble/emit-relocated-ops
10s op
10s sym-map
10s pos
10s out
04i 4
0Fs pos
09o 4
24
16
0D
10s ΓεnΣym-7
12
0Fs ΓεnΣym-7
10s ΓεnΣym-7
0Ao -121
09o 4
24
16
0D
10s pos
01
01
} [i] #@[source: [[if [< i 256] [int->bytecode-op i] [list [int->bytecode-op [bit-and [bit-shift-right i 8] 255]] [int->bytecode-op [bit-and i 255]]]]]] #{##[256 255]
10s i
1Ai 0
1E
0Bo 16
10s int->bytecode-op
10s i
04i 1
09o 53
10s list
10s int->bytecode-op
10s bit-and
10s bit-shift-right
10s i
02i 8
04i 2
1Ai 1
04i 2
04i 1
10s int->bytecode-op
10s bit-and
10s i
1Ai 1
04i 2
04i 1
04i 2
01
} [lit lit-arr] #@[source: [[when [>= [array/length lit-arr] 65535] [exception :out-of-bounds "Can only store up to 255 literals per bytecode-arr" code]] [when [not= [type-of lit] :pair] [dotimes [i [array/length lit-arr]] [when [equal? [array/ref lit-arr i] lit] [return [literal-index->bytecode-op i]]]]] [array/length! lit-arr [+ 1 [array/length lit-arr]]] [array/set! lit-arr [- [array/length lit-arr] 1] lit] [literal-index->bytecode-op [- [array/length lit-arr] 1]]]] #{##[65535 :out-of-bounds "Can only store up to 255 literals per bytecode-arr" :pair]
10s array/length
10s lit-arr
04i 1
1Ai 0
21
0Bo 32
10s throw
10s list
1Ai 1
1Ai 2
10s code
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s not=
10s type-of
10s lit
04i 1
1Ai 3
04i 2
0Bo 96
15
02i 0
0Es i
0D
24
1B
09o 59
0D
1C
10s equal?
10s array/ref
10s lit-arr
10s i
04i 2
10s lit
04i 2
0Bo 17
10s literal-index->bytecode-op
10s i
04i 1
01
09o 4
24
0D
02i 1
10s i
03
0Fs i
10s i
10s array/length
10s lit-arr
04i 1
1E
0Ao -71
0D
24
16
09o 4
24
0D
10s array/length!
10s lit-arr
02i 1
10s array/length
10s lit-arr
04i 1
25
04i 2
0D
10s array/set!
10s lit-arr
10s array/length
10s lit-arr
04i 1
02i 1
26
10s lit
04i 3
0D
10s literal-index->bytecode-op
10s array/length
10s lit-arr
04i 1
02i 1
26
04i 1
01
} [code lit-arr] #@[source: [[when-not code [return #nil]] [cond [[pair? [car code]] [cons [assemble/build-lit-arr [car code] lit-arr] [assemble/build-lit-arr [cdr code] lit-arr]]] [[and [= [car code] #$1A] [= [car [cadr code]] :literal]] [cdr! code] [def index-op [assemble/add-literal [cadar code] lit-arr]] [cons [if [pair? index-op] #$6 #$1A] [cons index-op [assemble/build-lit-arr [cdr code] lit-arr]]]] [[= :literal [car code]] [cdr! code] [cons [assemble/add-literal [car code] lit-arr] [assemble/build-lit-arr [cdr code] lit-arr]]] [otherwise [cons [car code] [assemble/build-lit-arr [cdr code] lit-arr]]]]]] #{##[#$1A :literal #$6]
10s code
0Bo 7
24
09o 5
24
01
0D
10s pair?
10s code
11
04i 1
0Bo 37
10s assemble/build-lit-arr
10s code
11
10s lit-arr
04i 2
10s assemble/build-lit-arr
10s code
12
10s lit-arr
04i 2
14
09o 195
10s code
11
1Ai 0
20
0C
0Bo 14
0D
10s code
12
11
11
1Ai 1
20
0Bo 82
10s code
12
0Fs code
0D
10s assemble/add-literal
10s cadar
10s code
04i 1
10s lit-arr
04i 2
0Es index-op
0D
10s pair?
10s index-op
04i 1
0Bo 8
1Ai 2
09o 5
1Ai 0
10s index-op
10s assemble/build-lit-arr
10s code
12
10s lit-arr
04i 2
14
14
09o 90
1Ai 1
10s code
11
20
0Bo 47
10s code
12
0Fs code
0D
10s assemble/add-literal
10s code
11
10s lit-arr
04i 2
10s assemble/build-lit-arr
10s code
12
10s lit-arr
04i 2
14
09o 35
10s otherwise
0Bo 27
10s code
11
10s assemble/build-lit-arr
10s code
12
10s lit-arr
04i 2
14
09o 4
24
01
} [code ret] #@[source: [[when-not code [return ret]] [when-not [pair? code] [return ret]] [set! ret [assemble/flatten [cdr code] ret]] [if [and [pair? [car code]] [not [keyword? [caar code]]]] [assemble/flatten [car code] ret] [cons [car code] ret]]]] #{##[#f #t]
10s code
0Bo 7
24
09o 8
10s ret
01
0D
10s pair?
10s code
04i 1
0Bo 7
24
09o 8
10s ret
01
0D
10s assemble/flatten
10s code
12
10s ret
04i 2
0Fs ret
0D
10s pair?
10s code
11
04i 1
0C
0Bo 26
0D
10s keyword?
10s code
11
11
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
0Bo 21
10s assemble/flatten
10s code
11
10s ret
04i 2
09o 13
10s code
11
10s ret
14
01
} [code] #@[documentation: "Assemble all arguments into a single :bytecode-array" source: ["Assemble all arguments into a single :bytecode-array" [def sym-map [tree/new #nil]] [def lit-arr [array/new #nil]] [def tmp [-> [assemble/flatten code] [assemble/build-lit-arr lit-arr]]] [assemble/build-sym-map tmp sym-map 0] [def out [array/allocate [tree/ref sym-map :last-op]]] [assemble/emit-relocated-ops tmp sym-map -1 out] [arr->bytecode-arr out lit-arr]]] #{##[:last-op]
10s tree/new
24
04i 1
0Es sym-map
0D
10s array/new
24
04i 1
0Es lit-arr
0D
10s assemble/build-lit-arr
10s assemble/flatten
10s code
04i 1
10s lit-arr
04i 2
0Es tmp
0D
10s assemble/build-sym-map
10s tmp
10s sym-map
02i 0
04i 3
0D
10s array/allocate
10s tree/ref
10s sym-map
1Ai 0
04i 2
04i 1
0Es out
0D
10s assemble/emit-relocated-ops
10s tmp
10s sym-map
02i -1
10s out
04i 4
0D
10s arr->bytecode-arr
10s out
10s lit-arr
04i 2
01
} #@[documentation: "Assemble all arguments into a single :bytecode-array" source: ["Assemble all arguments into a single :bytecode-array" [assemble* l]]] #{##[]
10s assemble*
10s l
04i 1
01
} #@[documentation: "Assemble and evaluate all bytecode arguments" source: ["Assemble and evaluate all bytecode arguments" [quasiquote [apply [current-closure] [assemble [unquote-splicing ops]]]]]] #{##[]
23s apply
23s current-closure
24
14
23s assemble
10s append
10s ops
24
04i 2
14
24
14
14
14
01
} #@[documentation: "Assemble and evaluate all bytecode arguments" source: ["Assemble and evaluate all bytecode arguments" [def bc [apply assemble ops]] [disassemble bc] [pfmtln "Result: {:?}" [apply [current-closure] bc #t]]]] #{##[#t "Result: "]
10s apply
10s assemble
10s ops
04i 2
0Es bc
0D
10s disassemble
10s bc
04i 1
0D
10s println
15
10s apply
10s current-closure
04i 0
10s bc
1Ai 0
04i 3
0Es fmt-arg-0
0D
10s cat
1Ai 1
10s string/write
10s fmt-arg-0
04i 1
04i 2
16
04i 1
01
}]
23s sym->bytecode-op
1Ai 0
1Ai 1
1Ai 2
17
0Es sym->bytecode-op
0D
23s int-fit-in-byte?
1Ai 3
1Ai 4
1Ai 5
17
0Es int-fit-in-byte?
0D
23s $push/int
1Ai 6
1Ai 7
1Ai 8
17
0Es $push/int
0D
23s $push/int/byte
1Ai 9
1Ai 10
1Ai 11
17
0Es $push/int/byte
0D
23s $push/symbol
1Ai 12
1Ai 13
1Ai 14
17
0Es $push/symbol
0D
23s $def
1Ai 15
1Ai 16
1Ai 17
17
0Es $def
0D
23s $set
1Ai 18
1Ai 19
1Ai 20
17
0Es $set
0D
23s $get
1Ai 21
1Ai 22
1Ai 23
17
0Es $get
0D
23s $apply/optimize?
1Ai 24
1Ai 25
1Ai 26
17
0Es $apply/optimize?
0D
23s $apply
1Ai 27
1Ai 28
1Ai 29
17
0Es $apply
0D
23s $apply/dynamic
1Ai 30
1Ai 31
1Ai 32
17
0Es $apply/dynamic
0D
23s $try
1Ai 33
1Ai 34
1Ai 35
17
0Es $try
0D
23s $jmp
1Ai 36
1Ai 37
1Ai 38
17
0Es $jmp
0D
23s $push/val
1Ai 39
1Ai 40
1Ai 41
17
0Es $push/val
0D
10s $push/val
0Es $push/val/ext
0D
23s $jt
1Ai 42
1Ai 43
1Ai 44
17
0Es $jt
0D
23s $jf
1Ai 45
1Ai 46
1Ai 47
17
0Es $jf
0D
23s $fn
1Ai 48
1Ai 49
1Ai 50
17
0Es $fn
0D
23s $macro*
1Ai 51
1Ai 52
1Ai 53
17
0Es $macro*
0D
23s assemble/build-sym-map
1Ai 54
1Ai 55
1Ai 56
17
0Es assemble/build-sym-map
0D
23s assemble/relocate-op
1Ai 57
1Ai 58
1Ai 59
17
0Es assemble/relocate-op
0D
23s assemble/emit-relocated-ops
1Ai 60
1Ai 61
1Ai 62
17
0Es assemble/emit-relocated-ops
0D
23s literal-index->bytecode-op
1Ai 63
1Ai 64
1Ai 65
17
0Es literal-index->bytecode-op
0D
23s assemble/add-literal
1Ai 66
1Ai 67
1Ai 68
17
0Es assemble/add-literal
0D
23s assemble/build-lit-arr
1Ai 69
1Ai 70
1Ai 71
17
0Es assemble/build-lit-arr
0D
23s assemble/flatten
1Ai 72
1Ai 73
1Ai 74
17
0Es assemble/flatten
0D
23s assemble*
1Ai 75
1Ai 76
1Ai 77
17
0Es assemble*
0D
23s assemble
23s l
1Ai 78
1Ai 79
17
0Es assemble
0D
23s asmrun
23s ops
1Ai 80
1Ai 81
18
0Es asmrun
0D
23s asmdebug
23s ops
1Ai 82
1Ai 83
17
0Es asmdebug
01
}#{##[[prefix] #@[source: [[inc! bytecompile/gen-label/counter] [string->symbol [cat prefix "label-" bytecompile/gen-label/counter]]]] #{##["label-"]
10s bytecompile/gen-label/counter
02i 1
25
0Fs bytecompile/gen-label/counter
0D
10s string->symbol
10s cat
10s prefix
1Ai 0
10s bytecompile/gen-label/counter
04i 3
04i 1
01
} [source] #@[source: [[case [type-of source] [:int [$push/int source]] [:nil [$push/nil]] [:symbol [$get source]] [[:native-function :lambda :symbol] [$get [closure/name source]]] [otherwise [$push/val source]]]]] #{##[:int :nil [#$24] :symbol :native-function :lambda #f]
15
10s type-of
10s source
04i 1
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
1Ai 0
20
0Bo 16
10s $push/int
10s source
04i 1
09o 111
10s ΓεnΣym-1
1Ai 1
20
0Bo 8
1Ai 2
09o 96
10s ΓεnΣym-1
1Ai 3
20
0Bo 16
10s $get
10s source
04i 1
09o 73
10s ΓεnΣym-1
1Ai 4
20
0C
0Ao 30
0D
10s ΓεnΣym-1
1Ai 5
20
0C
0Ao 18
0D
10s ΓεnΣym-1
1Ai 3
20
0C
0Ao 6
0D
1Ai 6
0Bo 22
10s $get
10s closure/name
10s source
04i 1
04i 1
09o 13
10s $push/val
10s source
04i 1
16
01
} [source] #@[source: [[case [type-of source] [:int [$push/int source]] [:nil [$push/nil]] [:symbol [$push/symbol source]] [[:native-function :lambda] [$get [closure/name source]]] [otherwise [$push/val source]]]]] #{##[:int :nil [#$24] :symbol :native-function :lambda #f]
15
10s type-of
10s source
04i 1
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
1Ai 0
20
0Bo 16
10s $push/int
10s source
04i 1
09o 99
10s ΓεnΣym-2
1Ai 1
20
0Bo 8
1Ai 2
09o 84
10s ΓεnΣym-2
1Ai 3
20
0Bo 16
10s $push/symbol
10s source
04i 1
09o 61
10s ΓεnΣym-2
1Ai 4
20
0C
0Ao 18
0D
10s ΓεnΣym-2
1Ai 5
20
0C
0Ao 6
0D
1Ai 6
0Bo 22
10s $get
10s closure/name
10s source
04i 1
04i 1
09o 13
10s $push/val
10s source
04i 1
16
01
} [source env] #@[source: [[when source [cons [cons [bytecompile* [car source] env] [if [last? source] #nil [cons [$drop] #nil]]] [bytecompile/do/form [cdr source] env]]]]] #{##[[#$D]]
10s source
0Bo 60
10s bytecompile*
10s source
11
10s env
04i 2
10s nil?
10s source
12
04i 1
0Bo 7
24
09o 7
1Ai 0
24
14
14
10s bytecompile/do/form
10s source
12
10s env
04i 2
14
09o 4
24
01
} [source env] #@[source: [[list [bytecompile/do/form [cdr source] env]]]] #{##[]
10s list
10s bytecompile/do/form
10s source
12
10s env
04i 2
04i 1
01
} [source env] #@[source: [[when [or [not [symbol? [cadr source]]] [not [cddr source]]] [throw [list :type-error "[def] needs a symbol name and a value as arguments" #nil env]]] [list [bytecompile* [caddr source] env] [$def [cadr source]]]]] #{##[#f #t :type-error "[def] needs a symbol name and a value as arguments"]
10s symbol?
10s source
12
11
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
0C
0Ao 27
0D
10s source
12
12
0Bo 8
1Ai 0
09o 5
1Ai 1
0C
0Ao 6
0D
1Ai 0
0Bo 27
10s throw
10s list
1Ai 2
1Ai 3
24
10s env
04i 4
04i 1
09o 4
24
0D
10s list
10s bytecompile*
10s caddr
10s source
04i 1
10s env
04i 2
10s $def
10s source
12
11
04i 1
04i 2
01
} [source env] #@[source: [[when [or [not [symbol? [cadr source]]] [not [cddr source]]] [throw [list :type-error "[set!] needs a symbol name and a value as arguments" #nil env]]] [list [bytecompile* [caddr source] env] [$set [cadr source]]]]] #{##[#f #t :type-error "[set!] needs a symbol name and a value as arguments"]
10s symbol?
10s source
12
11
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
0C
0Ao 27
0D
10s source
12
12
0Bo 8
1Ai 0
09o 5
1Ai 1
0C
0Ao 6
0D
1Ai 0
0Bo 27
10s throw
10s list
1Ai 2
1Ai 3
24
10s env
04i 4
04i 1
09o 4
24
0D
10s list
10s bytecompile*
10s caddr
10s source
04i 1
10s env
04i 2
10s $set
10s source
12
11
04i 1
04i 2
01
} [source env] #@[source: [[let [[sym-else [bytecompile/gen-label]] [sym-after [bytecompile/gen-label]]] [list [bytecompile* [cadr source] env] [$jf sym-else] [bytecompile* [caddr source] env] [$jmp sym-after] [list :label sym-else] [bytecompile* [cadddr source] env] [list :label sym-after]]]]] #{##[:label]
15
10s bytecompile/gen-label
04i 0
0Es sym-else
0D
10s bytecompile/gen-label
04i 0
0Es sym-after
0D
10s list
10s bytecompile*
10s source
12
11
10s env
04i 2
10s $jf
10s sym-else
04i 1
10s bytecompile*
10s caddr
10s source
04i 1
10s env
04i 2
10s $jmp
10s sym-after
04i 1
10s list
1Ai 0
10s sym-else
04i 2
10s bytecompile*
10s cadddr
10s source
04i 1
10s env
04i 2
10s list
1Ai 0
10s sym-after
04i 2
04i 7
16
01
} [source env] #@[source: [[def sym-start [bytecompile/gen-label]] [def sym-end [bytecompile/gen-label]] [list [$push/nil] [$roots/save] [$jmp sym-end] [list :label sym-start] [$drop] [$roots/restore] [bytecompile/do/form [cddr source] env] [list :label sym-end] [bytecompile* [cadr source] env] [$jt sym-start]]]] #{##[[#$24] [#$1B] :label [#$D] [#$1C]]
10s bytecompile/gen-label
04i 0
0Es sym-start
0D
10s bytecompile/gen-label
04i 0
0Es sym-end
0D
10s list
1Ai 0
1Ai 1
10s $jmp
10s sym-end
04i 1
10s list
1Ai 2
10s sym-start
04i 2
1Ai 3
1Ai 4
10s bytecompile/do/form
10s source
12
12
10s env
04i 2
10s list
1Ai 2
10s sym-end
04i 2
10s bytecompile*
10s source
12
11
10s env
04i 2
10s $jt
10s sym-start
04i 1
04i 10
01
} [source env] #@[source: [[if [last? source] [bytecompile* [car source] env] [cons [bytecompile* [car source] env] [bytecompile/procedure/arg [cdr source] env]]]]] #{##[]
10s nil?
10s source
12
04i 1
0Bo 21
10s bytecompile*
10s source
11
10s env
04i 2
09o 34
10s bytecompile*
10s source
11
10s env
04i 2
10s bytecompile/procedure/arg
10s source
12
10s env
04i 2
14
01
} [op] #@[source: [[case [type-of op] [:lambda [meta op :inline]] [#t #f]]]] #{##[:lambda :inline #t #f]
15
10s type-of
10s op
04i 1
0Es ΓεnΣym-3
0D
10s ΓεnΣym-3
1Ai 0
20
0Bo 18
10s meta
10s op
1Ai 1
04i 2
09o 19
10s ΓεnΣym-3
1Ai 2
20
0Bo 8
1Ai 3
09o 4
24
16
01
} [op args env] #@[source: [[def arg-count [length args]] [when [> arg-count 1] [throw [list :compiler-error "For now only monadic functions can be inlined" op [current-lambda]]]] [def form [macroexpand/do [meta op :source] env]] [def arg-name [car [closure/arguments op]]] [if args [bytecompile* [list/replace form arg-name [car args]] env] [bytecompile* form env]]]] #{##[:compiler-error "For now only monadic functions can be inlined" :source]
10s length
10s args
04i 1
0Es arg-count
0D
10s arg-count
02i 1
22
0Bo 32
10s throw
10s list
1Ai 0
1Ai 1
10s op
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s macroexpand/do
10s meta
10s op
1Ai 2
04i 2
10s env
04i 2
0Es form
0D
10s closure/arguments
10s op
04i 1
11
0Es arg-name
0D
10s args
0Bo 35
10s bytecompile*
10s list/replace
10s form
10s arg-name
10s args
11
04i 3
10s env
04i 2
09o 17
10s bytecompile*
10s form
10s env
04i 2
01
} [op args env op-raw] #@[source: [[if [bytecompile/procedure/inline? op] [bytecompile/procedure/inline op args env] [bytecompile/procedure/default op args env op-raw]]]] #{##[]
10s bytecompile/procedure/inline?
10s op
04i 1
0Bo 24
10s bytecompile/procedure/inline
10s op
10s args
10s env
04i 3
09o 25
10s bytecompile/procedure/default
10s op
10s args
10s env
10s op-raw
04i 4
01
} [op args env op-raw] #@[source: [[def arg-count [length args]] [if [$apply/optimize? op arg-count] [list [when args [bytecompile/procedure/arg args]] [$apply arg-count op]] [list [bytecompile* op-raw env] [when args [bytecompile/procedure/arg args]] [$apply/dynamic arg-count]]]]] #{##[]
10s length
10s args
04i 1
0Es arg-count
0D
10s $apply/optimize?
10s op
10s arg-count
04i 2
0Bo 47
10s list
10s args
0Bo 16
10s bytecompile/procedure/arg
10s args
04i 1
09o 4
24
10s $apply
10s arg-count
10s op
04i 2
04i 2
09o 54
10s list
10s bytecompile*
10s op-raw
10s env
04i 2
10s args
0Bo 16
10s bytecompile/procedure/arg
10s args
04i 1
09o 4
24
10s $apply/dynamic
10s arg-count
04i 1
04i 3
01
} [source env label-end] #@[source: [[list [bytecompile* [car source] env] [when [cdr source] [list [$dup] [$jf label-end] [$drop] [bytecompile/and/rec [cdr source] env label-end]]]]]] #{##[[#$C] [#$D]]
10s list
10s bytecompile*
10s source
11
10s env
04i 2
10s source
12
0Bo 45
10s list
1Ai 0
10s $jf
10s label-end
04i 1
1Ai 1
10s bytecompile/and/rec
10s source
12
10s env
10s label-end
04i 3
04i 4
09o 4
24
04i 2
01
} [source env] #@[source: [[def label-end [bytecompile/gen-label]] [list [bytecompile/and/rec [cdr source] env label-end] [list :label label-end]]]] #{##[:label]
10s bytecompile/gen-label
04i 0
0Es label-end
0D
10s list
10s bytecompile/and/rec
10s source
12
10s env
10s label-end
04i 3
10s list
1Ai 0
10s label-end
04i 2
04i 2
01
} [source env label-end] #@[source: [[when source [list [bytecompile* [car source] env] [$dup] [$jt label-end] [$drop] [bytecompile/or/rec [cdr source] env label-end]]]]] #{##[[#$C] [#$D]]
10s source
0Bo 60
10s list
10s bytecompile*
10s source
11
10s env
04i 2
1Ai 0
10s $jt
10s label-end
04i 1
1Ai 1
10s bytecompile/or/rec
10s source
12
10s env
10s label-end
04i 3
04i 5
09o 4
24
01
} [source env] #@[source: [[def label-end [bytecompile/gen-label]] [list [bytecompile/or/rec [cdr source] env label-end] [$push/val #f] [list :label label-end]]]] #{##[#f :label]
10s bytecompile/gen-label
04i 0
0Es label-end
0D
10s list
10s bytecompile/or/rec
10s source
12
10s env
10s label-end
04i 3
10s $push/val
1Ai 0
04i 1
10s list
1Ai 1
10s label-end
04i 2
04i 3
01
} [source env] #@[source: [[def arg-count [length [cdr source]]] [when [not= arg-count 5] [exception :arity-error "[fn*] needs exactly 4 arguments" source]] [cdr! source] [list [bytecompile* [car source] env] [bytecompile* [cadr source] env] [bytecompile* [caddr source] env] [bytecompile* [cadddr source] env] [$fn/dynamic]]]] #{##[:arity-error "[fn*] needs exactly 4 arguments" [#$17]]
10s length
10s source
12
04i 1
0Es arg-count
0D
10s not=
10s arg-count
02i 5
04i 2
0Bo 32
10s throw
10s list
1Ai 0
1Ai 1
10s source
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s source
12
0Fs source
0D
10s list
10s bytecompile*
10s source
11
10s env
04i 2
10s bytecompile*
10s source
12
11
10s env
04i 2
10s bytecompile*
10s caddr
10s source
04i 1
10s env
04i 2
10s bytecompile*
10s cadddr
10s source
04i 1
10s env
04i 2
1Ai 2
04i 5
01
} [source env] #@[source: [[def arg-count [length [cdr source]]] [when [not= arg-count 5] [exception :arity-error "[macro*] needs exactly 4 arguments" source]] [cdr! source] [list [bytecompile* [car source] env] [bytecompile* [cadr source] env] [bytecompile* [caddr source] env] [bytecompile* [cadddr source] env] [$macro/dynamic]]]] #{##[:arity-error "[macro*] needs exactly 4 arguments" [#$18]]
10s length
10s source
12
04i 1
0Es arg-count
0D
10s not=
10s arg-count
02i 5
04i 2
0Bo 32
10s throw
10s list
1Ai 0
1Ai 1
10s source
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s source
12
0Fs source
0D
10s list
10s bytecompile*
10s source
11
10s env
04i 2
10s bytecompile*
10s source
12
11
10s env
04i 2
10s bytecompile*
10s caddr
10s source
04i 1
10s env
04i 2
10s bytecompile*
10s cadddr
10s source
04i 1
10s env
04i 2
1Ai 2
04i 5
01
} [source env] #@[source: [[list [$let] [bytecompile/do/form [cdr source] env] [$drop] [$closure/push] [$closure/pop]]]] #{##[[#$15] [#$D] [#$13] [#$16]]
10s list
1Ai 0
10s bytecompile/do/form
10s source
12
10s env
04i 2
1Ai 1
1Ai 2
1Ai 3
04i 5
01
} [source env] #@[source: [[list [$let] [bytecompile/do [cadr source] env] [$closure/pop]]]] #{##[[#$15] [#$16]]
10s list
1Ai 0
10s bytecompile/do
10s source
12
11
10s env
04i 2
1Ai 1
04i 3
01
} [source env] #@[source: [[list [bytecompile* [cadr source] env] [$ret]]]] #{##[[#$1]]
10s list
10s bytecompile*
10s source
12
11
10s env
04i 2
1Ai 0
04i 2
01
} [source env] #@[source: [[def end-sym [bytecompile/gen-label]] [list [bytecompile* [cadr source] env] [$try end-sym] [bytecompile/do/form [cddr source] env] [$closure/pop] [list :label end-sym]]]] #{##[[#$16] :label]
10s bytecompile/gen-label
04i 0
0Es end-sym
0D
10s list
10s bytecompile*
10s source
12
11
10s env
04i 2
10s $try
10s end-sym
04i 1
10s bytecompile/do/form
10s source
12
12
10s env
04i 2
1Ai 0
10s list
1Ai 1
10s end-sym
04i 2
04i 5
01
} [source env] #@[documentation: "Compile the forms in source" source: ["Compile the forms in source" [def op [if [resolves? [car source] env] [resolve [car source] env] [car source]]] [case [type-of op] [[:lambda :native-function :pair :symbol] [case op [do [bytecompile/do source env]] [let* [bytecompile/let* source env]] [def [bytecompile/def source env]] [set! [bytecompile/set! source env]] [if [bytecompile/if source env]] [while [bytecompile/while source env]] [and [bytecompile/and source env]] [or [bytecompile/or source env]] [fn* [bytecompile/fn* source env]] [macro* [bytecompile/macro* source env]] [environment* [bytecompile/environment* source env]] [try [bytecompile/try source env]] [return [bytecompile/return source env]] '[bytecompile/quote [cadr source]] [otherwise [bytecompile/procedure op [cdr source] env [car source]]]]] [otherwise [bytecompile/literal source]]]]] #{##[:lambda :native-function :pair :symbol #f]
10s resolves?
10s source
11
10s env
04i 2
0Bo 21
10s resolve
10s source
11
10s env
04i 2
09o 8
10s source
11
0Es op
0D
15
10s type-of
10s op
04i 1
0Es ΓεnΣym-4
0D
10s ΓεnΣym-4
1Ai 0
20
0C
0Ao 42
0D
10s ΓεnΣym-4
1Ai 1
20
0C
0Ao 30
0D
10s ΓεnΣym-4
1Ai 2
20
0C
0Ao 18
0D
10s ΓεnΣym-4
1Ai 3
20
0C
0Ao 6
0D
1Ai 4
0Bo 445
15
10s op
0Es ΓεnΣym-5
0D
10s ΓεnΣym-5
10s do
20
0Bo 20
10s bytecompile/do
10s source
10s env
04i 2
09o 402
10s ΓεnΣym-5
10s let*
20
0Bo 20
10s bytecompile/let*
10s source
10s env
04i 2
09o 373
10s ΓεnΣym-5
10s def
20
0Bo 20
10s bytecompile/def
10s source
10s env
04i 2
09o 344
10s ΓεnΣym-5
10s set!
20
0Bo 20
10s bytecompile/set!
10s source
10s env
04i 2
09o 315
10s ΓεnΣym-5
10s if
20
0Bo 20
10s bytecompile/if
10s source
10s env
04i 2
09o 286
10s ΓεnΣym-5
10s while
20
0Bo 20
10s bytecompile/while
10s source
10s env
04i 2
09o 257
10s ΓεnΣym-5
10s and
20
0Bo 20
10s bytecompile/and
10s source
10s env
04i 2
09o 228
10s ΓεnΣym-5
10s or
20
0Bo 20
10s bytecompile/or
10s source
10s env
04i 2
09o 199
10s ΓεnΣym-5
10s fn*
20
0Bo 20
10s bytecompile/fn*
10s source
10s env
04i 2
09o 170
10s ΓεnΣym-5
10s macro*
20
0Bo 20
10s bytecompile/macro*
10s source
10s env
04i 2
09o 141
10s ΓεnΣym-5
10s environment*
20
0Bo 20
10s bytecompile/environment*
10s source
10s env
04i 2
09o 112
10s ΓεnΣym-5
10s try
20
0Bo 20
10s bytecompile/try
10s source
10s env
04i 2
09o 83
10s ΓεnΣym-5
10s return
20
0Bo 20
10s bytecompile/return
10s source
10s env
04i 2
09o 54
10s ΓεnΣym-5
10s quote
20
0Bo 18
10s bytecompile/quote
10s source
12
11
04i 1
09o 27
10s bytecompile/procedure
10s op
10s source
12
10s env
10s source
11
04i 4
16
09o 13
10s bytecompile/literal
10s source
04i 1
16
01
} [form environment] #@[source: [[list [bytecompile* form environment] [$ret]]]] #{##[[#$1]]
10s list
10s bytecompile*
10s form
10s environment
04i 2
1Ai 0
04i 2
01
}]
02i 0
0Es bytecompile/gen-label/counter
0D
23s bytecompile/gen-label
1Ai 0
1Ai 1
1Ai 2
17
0Es bytecompile/gen-label
0D
23s bytecompile/literal
1Ai 3
1Ai 4
1Ai 5
17
0Es bytecompile/literal
0D
23s bytecompile/quote
1Ai 6
1Ai 7
1Ai 8
17
0Es bytecompile/quote
0D
23s bytecompile/do/form
1Ai 9
1Ai 10
1Ai 11
17
0Es bytecompile/do/form
0D
23s bytecompile/do
1Ai 12
1Ai 13
1Ai 14
17
0Es bytecompile/do
0D
23s bytecompile/def
1Ai 15
1Ai 16
1Ai 17
17
0Es bytecompile/def
0D
23s bytecompile/set!
1Ai 18
1Ai 19
1Ai 20
17
0Es bytecompile/set!
0D
23s bytecompile/if
1Ai 21
1Ai 22
1Ai 23
17
0Es bytecompile/if
0D
23s bytecompile/while
1Ai 24
1Ai 25
1Ai 26
17
0Es bytecompile/while
0D
23s bytecompile/procedure/arg
1Ai 27
1Ai 28
1Ai 29
17
0Es bytecompile/procedure/arg
0D
23s bytecompile/procedure/inline?
1Ai 30
1Ai 31
1Ai 32
17
0Es bytecompile/procedure/inline?
0D
23s bytecompile/procedure/inline
1Ai 33
1Ai 34
1Ai 35
17
0Es bytecompile/procedure/inline
0D
23s bytecompile/procedure
1Ai 36
1Ai 37
1Ai 38
17
0Es bytecompile/procedure
0D
23s bytecompile/procedure/default
1Ai 39
1Ai 40
1Ai 41
17
0Es bytecompile/procedure/default
0D
23s bytecompile/and/rec
1Ai 42
1Ai 43
1Ai 44
17
0Es bytecompile/and/rec
0D
23s bytecompile/and
1Ai 45
1Ai 46
1Ai 47
17
0Es bytecompile/and
0D
23s bytecompile/or/rec
1Ai 48
1Ai 49
1Ai 50
17
0Es bytecompile/or/rec
0D
23s bytecompile/or
1Ai 51
1Ai 52
1Ai 53
17
0Es bytecompile/or
0D
23s bytecompile/fn*
1Ai 54
1Ai 55
1Ai 56
17
0Es bytecompile/fn*
0D
23s bytecompile/macro*
1Ai 57
1Ai 58
1Ai 59
17
0Es bytecompile/macro*
0D
23s bytecompile/environment*
1Ai 60
1Ai 61
1Ai 62
17
0Es bytecompile/environment*
0D
23s bytecompile/let*
1Ai 63
1Ai 64
1Ai 65
17
0Es bytecompile/let*
0D
23s bytecompile/return
1Ai 66
1Ai 67
1Ai 68
17
0Es bytecompile/return
0D
23s bytecompile/try
1Ai 69
1Ai 70
1Ai 71
17
0Es bytecompile/try
0D
23s bytecompile*
1Ai 72
1Ai 73
1Ai 74
17
0Es bytecompile*
0D
23s bytecompile
1Ai 75
1Ai 76
1Ai 77
17
0Es bytecompile
01
}#{##[[op] #@[documentation: "Return the length in bytes of a bytecode operation and all its arguments" source: ["Return the length in bytes of a bytecode operation and all its arguments" [case op [[#$0 #$1 #$3 #$C #$D #$11 #$12 #$13 #$14 #$15 #$16 #$1B #$1C #$1E #$1F #$20 #$21 #$22 #$24 #$25 #$26 #$27 #$28 #$29 #$2A] 1] [[#$2 #$4 #$7 #$1A] 2] [[#$6 #$9 #$A #$B #$18 #$19] 3] [[#$E #$F #$10 #$23] 4] [otherwise [throw [list :unknown-op "This op needs its length specified for disassembly to work" op [current-lambda]]]]]]] #{##[#$0 #$1 #$3 #$C #$D #$11 #$12 #$13 #$14 #$15 #$16 #$1B #$1C #$1E #$1F #$20 #$21 #$22 #$24 #$25 #$26 #$27 #$28 #$29 #$2A #f #$2 #$4 #$7 #$1A #$6 #$9 #$A #$B #$18 #$19 #$E #$F #$10 #$23 :unknown-op "This op needs its length specified for disassembly to work"]
15
10s op
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
1Ai 0
20
0C
0Ao 294
0D
10s ΓεnΣym-1
1Ai 1
20
0C
0Ao 282
0D
10s ΓεnΣym-1
1Ai 2
20
0C
0Ao 270
0D
10s ΓεnΣym-1
1Ai 3
20
0C
0Ao 258
0D
10s ΓεnΣym-1
1Ai 4
20
0C
0Ao 246
0D
10s ΓεnΣym-1
1Ai 5
20
0C
0Ao 234
0D
10s ΓεnΣym-1
1Ai 6
20
0C
0Ao 222
0D
10s ΓεnΣym-1
1Ai 7
20
0C
0Ao 210
0D
10s ΓεnΣym-1
1Ai 8
20
0C
0Ao 198
0D
10s ΓεnΣym-1
1Ai 9
20
0C
0Ao 186
0D
10s ΓεnΣym-1
1Ai 10
20
0C
0Ao 174
0D
10s ΓεnΣym-1
1Ai 11
20
0C
0Ao 162
0D
10s ΓεnΣym-1
1Ai 12
20
0C
0Ao 150
0D
10s ΓεnΣym-1
1Ai 13
20
0C
0Ao 138
0D
10s ΓεnΣym-1
1Ai 14
20
0C
0Ao 126
0D
10s ΓεnΣym-1
1Ai 15
20
0C
0Ao 114
0D
10s ΓεnΣym-1
1Ai 16
20
0C
0Ao 102
0D
10s ΓεnΣym-1
1Ai 17
20
0C
0Ao 90
0D
10s ΓεnΣym-1
1Ai 18
20
0C
0Ao 78
0D
10s ΓεnΣym-1
1Ai 19
20
0C
0Ao 66
0D
10s ΓεnΣym-1
1Ai 20
20
0C
0Ao 54
0D
10s ΓεnΣym-1
1Ai 21
20
0C
0Ao 42
0D
10s ΓεnΣym-1
1Ai 22
20
0C
0Ao 30
0D
10s ΓεnΣym-1
1Ai 23
20
0C
0Ao 18
0D
10s ΓεnΣym-1
1Ai 24
20
0C
0Ao 6
0D
1Ai 25
0Bo 8
02i 1
09o 227
10s ΓεnΣym-1
1Ai 26
20
0C
0Ao 42
0D
10s ΓεnΣym-1
1Ai 27
20
0C
0Ao 30
0D
10s ΓεnΣym-1
1Ai 28
20
0C
0Ao 18
0D
10s ΓεnΣym-1
1Ai 29
20
0C
0Ao 6
0D
1Ai 25
0Bo 8
02i 2
09o 169
10s ΓεnΣym-1
1Ai 30
20
0C
0Ao 66
0D
10s ΓεnΣym-1
1Ai 31
20
0C
0Ao 54
0D
10s ΓεnΣym-1
1Ai 32
20
0C
0Ao 42
0D
10s ΓεnΣym-1
1Ai 33
20
0C
0Ao 30
0D
10s ΓεnΣym-1
1Ai 34
20
0C
0Ao 18
0D
10s ΓεnΣym-1
1Ai 35
20
0C
0Ao 6
0D
1Ai 25
0Bo 8
02i 3
09o 87
10s ΓεnΣym-1
1Ai 36
20
0C
0Ao 42
0D
10s ΓεnΣym-1
1Ai 37
20
0C
0Ao 30
0D
10s ΓεnΣym-1
1Ai 38
20
0C
0Ao 18
0D
10s ΓεnΣym-1
1Ai 39
20
0C
0Ao 6
0D
1Ai 25
0Bo 8
02i 4
09o 29
10s throw
10s list
1Ai 40
1Ai 41
10s op
10s current-lambda
04i 0
04i 4
04i 1
16
01
} [error] #@[source: [[if [= [car error] :type-error] #nil [throw error]]]] #{##[:type-error]
10s error
11
1Ai 0
20
0Bo 7
24
09o 13
10s throw
10s error
04i 1
01
} [a b c] #@[documentation: "Turn three bytecode ops representing an encoded value into an actual value" source: ["Turn three bytecode ops representing an encoded value into an actual value" [index->val [bit-or [bit-shift-left [bytecode-op->int a] 16] [bit-shift-left [bytecode-op->int b] 8] [bytecode-op->int c]]]]] #{##[]
10s index->val
10s bit-or
10s bit-or
10s bit-shift-left
10s bytecode-op->int
10s a
04i 1
02i 16
04i 2
10s bit-shift-left
10s bytecode-op->int
10s b
04i 1
02i 8
04i 2
04i 2
10s bytecode-op->int
10s c
04i 1
04i 2
04i 1
01
} [a i] #@[documentation: "Read a bytecode encoded value in A at I and return it" source: ["Read a bytecode encoded value in A at I and return it" [try bytecode/nil-catcher [bytecode-op->val [ref a i] [ref a [+ 1 i]] [ref a [+ 2 i]]]]]] #{##[]
10s bytecode/nil-catcher
19o 58
10s bytecode-op->val
10s ref
10s a
10s i
04i 2
10s ref
10s a
02i 1
10s i
25
04i 2
10s ref
10s a
02i 2
10s i
25
04i 2
04i 3
16
01
} [a b c] #@[documentation: "Turn three bytecode ops representing an encoded symbol into an actual symbol" source: ["Turn three bytecode ops representing an encoded symbol into an actual symbol" [index->sym [bit-or [bit-shift-left [bytecode-op->int a] 16] [bit-shift-left [bytecode-op->int b] 8] [bytecode-op->int c]]]]] #{##[]
10s index->sym
10s bit-or
10s bit-or
10s bit-shift-left
10s bytecode-op->int
10s a
04i 1
02i 16
04i 2
10s bit-shift-left
10s bytecode-op->int
10s b
04i 1
02i 8
04i 2
04i 2
10s bytecode-op->int
10s c
04i 1
04i 2
04i 1
01
} [a i] #@[documentation: "Read a bytecode encoded symbol in A at I and return it" source: ["Read a bytecode encoded symbol in A at I and return it" [try bytecode/nil-catcher [bytecode-op->sym [ref a i] [ref a [+ 1 i]] [ref a [+ 2 i]]]]]] #{##[]
10s bytecode/nil-catcher
19o 58
10s bytecode-op->sym
10s ref
10s a
10s i
04i 2
10s ref
10s a
02i 1
10s i
25
04i 2
10s ref
10s a
02i 2
10s i
25
04i 2
04i 3
16
01
} [a b] #@[documentation: "Turn two bytecode ops encoding an offset into the integer representation" source: ["Turn two bytecode ops encoding an offset into the integer representation" [def t [bit-or [bit-shift-left [bytecode-op->int a] 8] [bytecode-op->int b]]] [if-not [> t 32768] t [- [- 65536 t]]]]] #{##[32768 65536]
10s bit-or
10s bit-shift-left
10s bytecode-op->int
10s a
04i 1
02i 8
04i 2
10s bytecode-op->int
10s b
04i 1
04i 2
0Es t
0D
10s t
1Ai 0
22
0Bo 19
10s -
1Ai 1
10s t
26
04i 1
09o 7
10s t
01
} [a i] #@[documentation: "Read a bytecode encoded offset in A at I and return it as a signed integer" source: ["Read a bytecode encoded offset in A at I and return it as a signed integer" [bytecode-op->offset [ref a i] [ref a [+ 1 i]]]]] #{##[]
10s bytecode-op->offset
10s ref
10s a
10s i
04i 2
10s ref
10s a
02i 1
10s i
25
04i 2
04i 2
01
} [v] #@[documentation: "Quotes symbols but just passes through every other value" source: ["Quotes symbols but just passes through every other value" [if [symbol? v] [list 'quote v] v]]] #{##[]
10s symbol?
10s v
04i 1
0Bo 20
10s list
23s quote
10s v
04i 2
09o 7
10s v
01
} [a i literals] #@[documentation: "Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" source: ["Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" [case [ref a i] [#$0 '[$nop]] [#$1 '[$ret]] [#$2 [quasiquote [$push/int/byte [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$3 '[$add/int]] [#$4 [quasiquote [$apply/dynamic [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$6 [quasiquote [$push/val/ext [unquote [ref literals [bit-or [bytecode-op->int [ref a [+ i 1]]] [bit-shift-left [bytecode-op->int [ref a [+ i 2]]] 8]]]]]]] [#$7 [quasiquote [$apply/dynamic/new [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$9 [quasiquote [$jmp* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$A [quasiquote [$jt* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$B [quasiquote [$jf* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$C '[$dup]] [#$D '[$drop]] [#$E [quasiquote [$def [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$F [quasiquote [$set [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$10 [quasiquote [$get [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$11 '[$car]] [#$12 '[$cdr]] [#$13 '[$closure/push]] [#$14 '[$cons]] [#$15 '[$let]] [#$16 '[$closure/pop]] [#$18 [quasiquote [$try/old [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$19 [quasiquote [$try [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$1A [quasiquote [$push/val [unquote [disassemble/maybe-quote [ref literals [bytecode-op->int [ref a [+ i 1]]]]]]]]] [#$1B '[$roots/push]] [#$1C '[$roots/pop]] [#$1E '[$<]] [#$1F '[$<=]] [#$20 '[$=]] [#$21 '[$>=]] [#$22 '[$>]] [#$23 [quasiquote [$push/symbol [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$24 '[$push/nil]] [#$25 '[$add]] [#$26 '[$sub]] [#$27 '[$mul]] [#$28 '[$div]] [#$29 '[$rem]] [#$2A '[$zero?]] [otherwise :unknown-op]]]] #{##[#$0 [$nop] #$1 [$ret] #$2 #$3 [$add/int] #$4 #$6 #$7 #$9 #$A #$B #$C [$dup] #$D [$drop] #$E #$F #$10 #$11 [$car] #$12 [$cdr] #$13 [$closure/push] #$14 [$cons] #$15 [$let] #$16 [$closure/pop] #$18 #$19 #$1A #$1B [$roots/push] #$1C [$roots/pop] #$1E [$<] #$1F [$<=] #$20 [$=] #$21 [$>=] #$22 [$>] #$23 #$24 [$push/nil] #$25 [$add] #$26 [$sub] #$27 [$mul] #$28 [$div] #$29 [$rem] #$2A [$zero?] :unknown-op]
15
10s ref
10s a
10s i
04i 2
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
1Ai 0
20
0Bo 8
1Ai 1
09o 976
10s ΓεnΣym-2
1Ai 2
20
0Bo 8
1Ai 3
09o 961
10s ΓεnΣym-2
1Ai 4
20
0Bo 36
23s $push/int/byte
10s bytecode-op->int
10s ref
10s a
10s i
02i 1
25
04i 2
04i 1
24
14
14
09o 918
10s ΓεnΣym-2
1Ai 5
20
0Bo 8
1Ai 6
09o 903
10s ΓεnΣym-2
1Ai 7
20
0Bo 36
23s $apply/dynamic
10s bytecode-op->int
10s ref
10s a
10s i
02i 1
25
04i 2
04i 1
24
14
14
09o 860
10s ΓεnΣym-2
1Ai 8
20
0Bo 83
23s $push/val/ext
10s ref
10s literals
10s bit-or
10s bytecode-op->int
10s ref
10s a
10s i
02i 1
25
04i 2
04i 1
10s bit-shift-left
10s bytecode-op->int
10s ref
10s a
10s i
02i 2
25
04i 2
04i 1
02i 8
04i 2
04i 2
04i 2
24
14
14
09o 770
10s ΓεnΣym-2
1Ai 9
20
0Bo 36
23s $apply/dynamic/new
10s bytecode-op->int
10s ref
10s a
10s i
02i 1
25
04i 2
04i 1
24
14
14
09o 727
10s ΓεnΣym-2
1Ai 10
20
0Bo 30
23s $jmp*
10s bytecode-arr->offset
10s a
10s i
02i 1
25
04i 2
24
14
14
09o 690
10s ΓεnΣym-2
1Ai 11
20
0Bo 30
23s $jt*
10s bytecode-arr->offset
10s a
10s i
02i 1
25
04i 2
24
14
14
09o 653
10s ΓεnΣym-2
1Ai 12
20
0Bo 30
23s $jf*
10s bytecode-arr->offset
10s a
10s i
02i 1
25
04i 2
24
14
14
09o 616
10s ΓεnΣym-2
1Ai 13
20
0Bo 8
1Ai 14
09o 601
10s ΓεnΣym-2
1Ai 15
20
0Bo 8
1Ai 16
09o 586
10s ΓεnΣym-2
1Ai 17
20
0Bo 30
23s $def
10s bytecode-arr->sym
10s a
10s i
02i 1
25
04i 2
24
14
14
09o 549
10s ΓεnΣym-2
1Ai 18
20
0Bo 30
23s $set
10s bytecode-arr->sym
10s a
10s i
02i 1
25
04i 2
24
14
14
09o 512
10s ΓεnΣym-2
1Ai 19
20
0Bo 30
23s $get
10s bytecode-arr->sym
10s a
10s i
02i 1
25
04i 2
24
14
14
09o 475
10s ΓεnΣym-2
1Ai 20
20
0Bo 8
1Ai 21
09o 460
10s ΓεnΣym-2
1Ai 22
20
0Bo 8
1Ai 23
09o 445
10s ΓεnΣym-2
1Ai 24
20
0Bo 8
1Ai 25
09o 430
10s ΓεnΣym-2
1Ai 26
20
0Bo 8
1Ai 27
09o 415
10s ΓεnΣym-2
1Ai 28
20
0Bo 8
1Ai 29
09o 400
10s ΓεnΣym-2
1Ai 30
20
0Bo 8
1Ai 31
09o 385
10s ΓεnΣym-2
1Ai 32
20
0Bo 30
23s $try/old
10s bytecode-arr->offset
10s a
10s i
02i 1
25
04i 2
24
14
14
09o 348
10s ΓεnΣym-2
1Ai 33
20
0Bo 30
23s $try
10s bytecode-arr->offset
10s a
10s i
02i 1
25
04i 2
24
14
14
09o 311
10s ΓεnΣym-2
1Ai 34
20
0Bo 52
23s $push/val
10s disassemble/maybe-quote
10s ref
10s literals
10s bytecode-op->int
10s ref
10s a
10s i
02i 1
25
04i 2
04i 1
04i 2
04i 1
24
14
14
09o 252
10s ΓεnΣym-2
1Ai 35
20
0Bo 8
1Ai 36
09o 237
10s ΓεnΣym-2
1Ai 37
20
0Bo 8
1Ai 38
09o 222
10s ΓεnΣym-2
1Ai 39
20
0Bo 8
1Ai 40
09o 207
10s ΓεnΣym-2
1Ai 41
20
0Bo 8
1Ai 42
09o 192
10s ΓεnΣym-2
1Ai 43
20
0Bo 8
1Ai 44
09o 177
10s ΓεnΣym-2
1Ai 45
20
0Bo 8
1Ai 46
09o 162
10s ΓεnΣym-2
1Ai 47
20
0Bo 8
1Ai 48
09o 147
10s ΓεnΣym-2
1Ai 49
20
0Bo 30
23s $push/symbol
10s bytecode-arr->sym
10s a
10s i
02i 1
25
04i 2
24
14
14
09o 110
10s ΓεnΣym-2
1Ai 50
20
0Bo 8
1Ai 51
09o 95
10s ΓεnΣym-2
1Ai 52
20
0Bo 8
1Ai 53
09o 80
10s ΓεnΣym-2
1Ai 54
20
0Bo 8
1Ai 55
09o 65
10s ΓεnΣym-2
1Ai 56
20
0Bo 8
1Ai 57
09o 50
10s ΓεnΣym-2
1Ai 58
20
0Bo 8
1Ai 59
09o 35
10s ΓεnΣym-2
1Ai 60
20
0Bo 8
1Ai 61
09o 20
10s ΓεnΣym-2
1Ai 62
20
0Bo 8
1Ai 63
09o 5
1Ai 64
16
01
} [a i literals] #@[documentation: "Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" source: ["Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" [def ret #nil] [while [< i [array/length a]] [set! ret [cons [cons i [disassemble/op a i literals]] ret]] [set! i [+ i [disassemble/length [ref a i]]]]] [nreverse ret]]] #{##[]
24
0Es ret
0D
24
1B
09o 67
0D
1C
10s i
10s disassemble/op
10s a
10s i
10s literals
04i 3
14
10s ret
14
0Fs ret
0D
10s i
10s disassemble/length
10s ref
10s a
10s i
04i 2
04i 1
25
0Fs i
10s i
10s array/length
10s a
04i 1
1E
0Ao -79
0D
10s nreverse
10s ret
04i 1
01
} [code] #@[documentation: "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," source: ["Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," [disassemble/array [bytecode-arr->arr code] 0 [bytecode-literals code]]]] #{##[]
10s disassemble/array
10s bytecode-arr->arr
10s code
04i 1
02i 0
10s bytecode-literals
10s code
04i 1
04i 3
01
} [bc] #@[source: [[doseq [a [disassemble/bytecode-array bc]] [println [cat [ansi-blue [string/pad-start [string [car a]] 6]] " - " [cdr a]]]]]] #{##[" - "]
15
10s disassemble/bytecode-array
10s bc
04i 1
0Es ΓεnΣym-3
0D
10s ΓεnΣym-3
0Bo 84
24
1B
09o 69
0D
1C
10s ΓεnΣym-3
11
0Es a
0D
10s println
10s cat
10s ansi-blue
10s string/pad-start
10s string
10s a
11
04i 1
02i 6
04i 2
04i 1
1Ai 0
10s a
12
04i 3
04i 1
0D
10s ΓεnΣym-3
12
0Fs ΓεnΣym-3
10s ΓεnΣym-3
0Ao -70
09o 4
24
16
01
} [bc] #@[documentation: "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," source: ["Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," [case [type-of bc] [[:lambda :macro] [disassemble/print [closure/code bc]]] [:bytecode-array [disassemble/print bc]] [otherwise [throw [list :type-error "Can't disassemble that" bc [current-lambda]]]]]]] #{##[:lambda :macro #f :bytecode-array :type-error "Can't disassemble that"]
15
10s type-of
10s bc
04i 1
0Es ΓεnΣym-4
0D
10s ΓεnΣym-4
1Ai 0
20
0C
0Ao 18
0D
10s ΓεnΣym-4
1Ai 1
20
0C
0Ao 6
0D
1Ai 2
0Bo 22
10s disassemble/print
10s closure/code
10s bc
04i 1
04i 1
09o 52
10s ΓεnΣym-4
1Ai 3
20
0Bo 16
10s disassemble/print
10s bc
04i 1
09o 29
10s throw
10s list
1Ai 4
1Ai 5
10s bc
10s current-lambda
04i 0
04i 4
04i 1
16
01
}]
23s disassemble/length
1Ai 0
1Ai 1
1Ai 2
17
0Es disassemble/length
0D
23s bytecode/nil-catcher
1Ai 3
1Ai 4
1Ai 5
17
0Es bytecode/nil-catcher
0D
23s bytecode-op->val
1Ai 6
1Ai 7
1Ai 8
17
0Es bytecode-op->val
0D
23s bytecode-arr->val
1Ai 9
1Ai 10
1Ai 11
17
0Es bytecode-arr->val
0D
23s bytecode-op->sym
1Ai 12
1Ai 13
1Ai 14
17
0Es bytecode-op->sym
0D
23s bytecode-arr->sym
1Ai 15
1Ai 16
1Ai 17
17
0Es bytecode-arr->sym
0D
23s bytecode-op->offset
1Ai 18
1Ai 19
1Ai 20
17
0Es bytecode-op->offset
0D
23s bytecode-arr->offset
1Ai 21
1Ai 22
1Ai 23
17
0Es bytecode-arr->offset
0D
23s disassemble/maybe-quote
1Ai 24
1Ai 25
1Ai 26
17
0Es disassemble/maybe-quote
0D
23s disassemble/op
1Ai 27
1Ai 28
1Ai 29
17
0Es disassemble/op
0D
23s disassemble/array
1Ai 30
1Ai 31
1Ai 32
17
0Es disassemble/array
0D
23s disassemble/bytecode-array
1Ai 33
1Ai 34
1Ai 35
17
0Es disassemble/bytecode-array
0D
23s disassemble/print
1Ai 36
1Ai 37
1Ai 38
17
0Es disassemble/print
0D
23s disassemble
1Ai 39
1Ai 40
1Ai 41
17
0Es disassemble
01
}#{##[[source environment] #@[documentation: "Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" source: ["Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" [doseq [form source] [apply environment [compile* source environment]]]]] #{##[]
15
10s source
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
0Bo 64
24
1B
09o 49
0D
1C
10s ΓεnΣym-1
11
0Es form
0D
10s apply
10s environment
10s compile*
10s source
10s environment
04i 2
04i 2
0D
10s ΓεnΣym-1
12
0Fs ΓεnΣym-1
10s ΓεnΣym-1
0Ao -50
09o 4
24
16
01
} [source-raw environment] #@[documentation: "Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined." source: ["Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined." [when-not environment [set! environment [environment*]]] [load/forms source-raw environment] [macroexpand source-raw environment]]] #{##[]
10s environment
0Bo 7
24
09o 12
15
24
0D
13
16
0Fs environment
0D
10s load/forms
10s source-raw
10s environment
04i 2
0D
10s macroexpand
10s source-raw
10s environment
04i 2
01
} [source environment] #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [-> [macroexpand source environment] constant-fold backend]]] #{##[]
10s backend
10s constant-fold
10s macroexpand
10s source
10s environment
04i 2
04i 1
04i 1
01
} [expr] #@[source: [[disassemble [compile expr]]]] #{##[]
10s disassemble
10s compile*
10s expr
10s current-closure
04i 0
04i 2
04i 1
01
} [source environment] #@[source: [[compile* [cons do source] environment]]] #{##[]
10s compile*
10s do
10s source
14
10s environment
04i 2
01
} [source] #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [quasiquote [compile* [unquote source] [current-closure]]]]] #{##[]
23s compile*
10s source
23s current-closure
24
14
24
14
14
14
01
} [source] #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [quasiquote [compile* [cons do [unquote source]] [current-closure]]]]] #{##[]
23s compile*
23s cons
23s do
10s source
24
14
14
14
23s current-closure
24
14
24
14
14
14
01
} [type args body] #@[source: [[def meta [tree/new #nil]] [doseq [v body] [case [type-of v] [:pair [return meta]] [:string [tree/set! meta :documentation [trim [cat [string [tree/ref meta :documentation]] "\n" v]]]] [:keyword [tree/set! meta v #t]]]] [return meta]]] #{##[:pair :string :documentation "\n" :keyword #t]
10s tree/new
24
04i 1
0Es meta
0D
15
10s body
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
0Bo 166
24
1B
09o 151
0D
1C
10s ΓεnΣym-2
11
0Es v
0D
15
10s type-of
10s v
04i 1
0Es ΓεnΣym-3
0D
10s ΓεnΣym-3
1Ai 0
20
0Bo 11
10s meta
01
09o 94
10s ΓεnΣym-3
1Ai 1
20
0Bo 54
10s tree/set!
10s meta
1Ai 2
10s trim
10s cat
10s string
10s tree/ref
10s meta
1Ai 2
04i 2
04i 1
1Ai 3
10s v
04i 3
04i 1
04i 3
09o 33
10s ΓεnΣym-3
1Ai 4
20
0Bo 22
10s tree/set!
10s meta
10s v
1Ai 5
04i 3
09o 4
24
16
0D
10s ΓεnΣym-2
12
0Fs ΓεnΣym-2
10s ΓεnΣym-2
0Ao -152
09o 4
24
16
0D
10s meta
01
01
} [name args . body] #@[documentation: "Define a new macro" source: ["Define a new macro" [quasiquote [def [unquote name] [macro* '[unquote name] '[unquote args] [unquote [tree/set! [meta/parse/body :macro args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]]] #{##[:macro :source]
23s def
10s name
23s macro*
23s quote
10s name
24
14
14
23s quote
10s args
24
14
14
10s tree/set!
10s meta/parse/body
1Ai 0
10s args
10s body
04i 3
1Ai 1
10s body
04i 3
23s quote
10s compile/do*
10s body
10s current-closure
04i 0
04i 2
24
14
14
24
14
14
14
14
14
24
14
14
14
01
} [args . body] #@[documentation: "Define an anonymous function" source: ["Define an anonymous function" [quasiquote [fn* 'anonymous '[unquote args] [unquote [tree/set! [meta/parse/body :lambda args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]] #{##[:lambda :source]
23s fn*
23s quote
23s anonymous
24
14
14
23s quote
10s args
24
14
14
10s tree/set!
10s meta/parse/body
1Ai 0
10s args
10s body
04i 3
1Ai 1
10s body
04i 3
23s quote
10s compile/do*
10s body
10s current-closure
04i 0
04i 2
24
14
14
24
14
14
14
14
14
01
} [name args . body] #@[documentation: "Define a new function" source: ["Define a new function" [quasiquote [def [unquote name] [fn* '[unquote name] '[unquote args] [unquote [tree/set! [meta/parse/body :lambda args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]]] #{##[:lambda :source]
23s def
10s name
23s fn*
23s quote
10s name
24
14
14
23s quote
10s args
24
14
14
10s tree/set!
10s meta/parse/body
1Ai 0
10s args
10s body
04i 3
1Ai 1
10s body
04i 3
23s quote
10s compile/do*
10s body
10s current-closure
04i 0
04i 2
24
14
14
24
14
14
14
14
14
24
14
14
14
01
} [closure expr] #@[documentation: "Compile and the immediatly evaluate the result\nMostly used by lRun()" source: ["Compile and the immediatly evaluate the result" "" "Mostly used by lRun()" [try display/error [apply closure [compile* expr closure]]]]] #{##[]
10s display/error
19o 28
10s apply
10s closure
10s compile*
10s expr
10s closure
04i 2
04i 2
16
01
} [expr] #@[documentation: "Compile, Evaluate and then return the result of EXPR" source: ["Compile, Evaluate and then return the result of EXPR" [quasiquote [eval-in [current-closure] [unquote expr]]]]] #{##[]
23s eval-in
23s current-closure
24
14
10s expr
24
14
14
14
01
} [v t] #@[source: [[quasiquote [when-not [= [type-of [unquote v]] [unquote t]] [throw [list :type-error [unquote [fmt "Expected a value of type {t}"]] [unquote v] [current-lambda]]]]]]] #{##[:type-error "Expected a value of type "]
23s when-not
23s =
23s type-of
10s v
24
14
14
10s t
24
14
14
14
23s throw
23s list
1Ai 0
10s cat
1Ai 1
10s t
04i 2
10s v
23s current-lambda
24
14
24
14
14
14
14
14
24
14
14
24
14
14
14
01
} [v] #@[source: [[quasiquote [when-not [numeric? [unquote v]] [throw [list :type-error [unquote [fmt "Expected numeric value"]] [unquote v] [current-lambda]]]]]]] #{##[:type-error "Expected numeric value"]
23s when-not
23s numeric?
10s v
24
14
14
23s throw
23s list
1Ai 0
1Ai 1
10s v
23s current-lambda
24
14
24
14
14
14
14
14
24
14
14
24
14
14
14
01
} #@[source: [[map v typecheck/numeric/single]]] #{##[]
10s map
10s v
10s typecheck/numeric/single
04i 2
01
} [raw] #@[source: [[def start-time [time/milliseconds]] [def val [eval raw]] [def end-time [time/milliseconds]] [display [cat "Evaluating " [ansi-yellow [string/write raw]] " to " [ansi-green [string/write val]] " took " [ansi-red [cat [- end-time start-time] "ms"] "\n"]]]]] #{##["Evaluating " " to " " took " "ms" "\n"]
10s time/milliseconds
04i 0
0Es start-time
0D
10s eval-in
10s current-closure
04i 0
10s raw
04i 2
0Es val
0D
10s time/milliseconds
04i 0
0Es end-time
0D
10s print
10s cat
1Ai 0
10s ansi-yellow
10s string/write
10s raw
04i 1
04i 1
1Ai 1
10s ansi-green
10s string/write
10s val
04i 1
04i 1
1Ai 2
10s ansi-red
10s cat
10s end-time
10s start-time
26
1Ai 3
04i 2
1Ai 4
04i 2
04i 6
04i 1
01
} #@[documentation: "Measure and display how much time and ressources it takes for BODY to be evaluated" source: ["Measure and display how much time and ressources it takes for BODY to be evaluated" [quasiquote [profile-form '[unquote [if [last? body] [car body] [cons 'do body]]]]]]] #{##[]
23s profile-form
23s quote
10s nil?
10s body
12
04i 1
0Bo 11
10s body
11
09o 12
23s do
10s body
14
24
14
14
24
14
14
01
}]
23s load/forms
1Ai 0
1Ai 1
1Ai 2
17
0Es load/forms
0D
23s macroexpand/forms
1Ai 3
1Ai 4
1Ai 5
17
0Es macroexpand/forms
0D
23s compile*
1Ai 6
1Ai 7
1Ai 8
17
0Es compile*
0D
23s compile/debug
1Ai 9
1Ai 10
1Ai 11
17
0Es compile/debug
0D
23s compile/do*
1Ai 12
1Ai 13
1Ai 14
17
0Es compile/do*
0D
23s compile
1Ai 15
1Ai 16
1Ai 17
18
0Es compile
0D
23s compile/do
1Ai 18
1Ai 19
1Ai 20
18
0Es compile/do
0D
23s meta/parse/body
1Ai 21
1Ai 22
1Ai 23
17
0Es meta/parse/body
0D
23s defmacro
1Ai 24
1Ai 25
1Ai 26
18
0Es defmacro
0D
23s fn
1Ai 27
1Ai 28
1Ai 29
18
0Es fn
0D
23s defn
1Ai 30
1Ai 31
1Ai 32
18
0Es defn
0D
23s eval-in
1Ai 33
1Ai 34
1Ai 35
17
0Es eval-in
0D
23s eval
1Ai 36
1Ai 37
1Ai 38
18
0Es eval
0D
23s typecheck/only
1Ai 39
1Ai 40
1Ai 41
18
0Es typecheck/only
0D
23s typecheck/numeric/single
1Ai 42
1Ai 43
1Ai 44
17
0Es typecheck/numeric/single
0D
23s typecheck/numeric
23s v
1Ai 45
1Ai 46
18
0Es typecheck/numeric
0D
23s profile-form
1Ai 47
1Ai 48
1Ai 49
17
0Es profile-form
0D
23s profile
23s body
1Ai 50
1Ai 51
18
0Es profile
01
}#{##[[expr] #@[source: [[and [not [pair? expr]] [not [symbol? expr]] #t]]] #{##[#f #t]
10s pair?
10s expr
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
0C
0Bo 31
0D
10s symbol?
10s expr
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
0C
0Bo 6
0D
1Ai 1
01
} [fun] #@[source: [[case fun [[add/int bit-and bit-or bit-xor bit-not bit-shift-left bit-shift-right popcount abs sqrt pow rem + - * / cat trim string/length uppercase lowercase capitalize] #t] [['add/int 'bit-and 'bit-or 'bit-xor 'bit-not 'bit-shift-left 'bit-shift-right 'popcount 'abs 'sqrt 'pow 'rem '+ '- '* '/ 'cat 'trim 'string/length 'uppercase 'lowercase 'capitalize] #t] [#t #f]]]] #{##[#f #t]
15
10s fun
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
10s add/int
20
0C
0Ao 300
0D
10s ΓεnΣym-1
10s bit-and
20
0C
0Ao 286
0D
10s ΓεnΣym-1
10s bit-or
20
0C
0Ao 272
0D
10s ΓεnΣym-1
10s bit-xor
20
0C
0Ao 258
0D
10s ΓεnΣym-1
10s bit-not
20
0C
0Ao 244
0D
10s ΓεnΣym-1
10s bit-shift-left
20
0C
0Ao 230
0D
10s ΓεnΣym-1
10s bit-shift-right
20
0C
0Ao 216
0D
10s ΓεnΣym-1
10s popcount
20
0C
0Ao 202
0D
10s ΓεnΣym-1
10s abs
20
0C
0Ao 188
0D
10s ΓεnΣym-1
10s sqrt
20
0C
0Ao 174
0D
10s ΓεnΣym-1
10s pow
20
0C
0Ao 160
0D
10s ΓεnΣym-1
10s rem
20
0C
0Ao 146
0D
10s ΓεnΣym-1
10s +
20
0C
0Ao 132
0D
10s ΓεnΣym-1
10s -
20
0C
0Ao 118
0D
10s ΓεnΣym-1
10s *
20
0C
0Ao 104
0D
10s ΓεnΣym-1
10s /
20
0C
0Ao 90
0D
10s ΓεnΣym-1
10s cat
20
0C
0Ao 76
0D
10s ΓεnΣym-1
10s trim
20
0C
0Ao 62
0D
10s ΓεnΣym-1
10s string/length
20
0C
0Ao 48
0D
10s ΓεnΣym-1
10s uppercase
20
0C
0Ao 34
0D
10s ΓεnΣym-1
10s lowercase
20
0C
0Ao 20
0D
10s ΓεnΣym-1
10s capitalize
20
0C
0Ao 6
0D
1Ai 0
0Bo 8
1Ai 1
09o 337
10s ΓεnΣym-1
23s add/int
20
0C
0Ao 300
0D
10s ΓεnΣym-1
23s bit-and
20
0C
0Ao 286
0D
10s ΓεnΣym-1
23s bit-or
20
0C
0Ao 272
0D
10s ΓεnΣym-1
23s bit-xor
20
0C
0Ao 258
0D
10s ΓεnΣym-1
23s bit-not
20
0C
0Ao 244
0D
10s ΓεnΣym-1
23s bit-shift-left
20
0C
0Ao 230
0D
10s ΓεnΣym-1
23s bit-shift-right
20
0C
0Ao 216
0D
10s ΓεnΣym-1
23s popcount
20
0C
0Ao 202
0D
10s ΓεnΣym-1
23s abs
20
0C
0Ao 188
0D
10s ΓεnΣym-1
23s sqrt
20
0C
0Ao 174
0D
10s ΓεnΣym-1
23s pow
20
0C
0Ao 160
0D
10s ΓεnΣym-1
23s rem
20
0C
0Ao 146
0D
10s ΓεnΣym-1
23s +
20
0C
0Ao 132
0D
10s ΓεnΣym-1
23s -
20
0C
0Ao 118
0D
10s ΓεnΣym-1
23s *
20
0C
0Ao 104
0D
10s ΓεnΣym-1
23s /
20
0C
0Ao 90
0D
10s ΓεnΣym-1
23s cat
20
0C
0Ao 76
0D
10s ΓεnΣym-1
23s trim
20
0C
0Ao 62
0D
10s ΓεnΣym-1
23s string/length
20
0C
0Ao 48
0D
10s ΓεnΣym-1
23s uppercase
20
0C
0Ao 34
0D
10s ΓεnΣym-1
23s lowercase
20
0C
0Ao 20
0D
10s ΓεnΣym-1
23s capitalize
20
0C
0Ao 6
0D
1Ai 0
0Bo 8
1Ai 1
09o 19
10s ΓεnΣym-1
1Ai 1
20
0Bo 8
1Ai 0
09o 4
24
16
01
} [sym] #@[source: [[when-not [symbol? sym] [return sym]] [resolve sym]]] #{##[]
10s symbol?
10s sym
04i 1
0Bo 7
24
09o 8
10s sym
01
0D
10s resolve
10s sym
04i 1
01
} [expr] #@[source: [[when-not expr [return expr]] [if [pair? [car expr]] [cons [constant-fold [car expr]] [constant-fold/args [cdr expr]]] [cons [car expr] [constant-fold/args [cdr expr]]]]]] #{##[]
10s expr
0Bo 7
24
09o 8
10s expr
01
0D
10s pair?
10s expr
11
04i 1
0Bo 29
10s constant-fold
10s expr
11
04i 1
10s constant-fold/args
10s expr
12
04i 1
14
09o 20
10s expr
11
10s constant-fold/args
10s expr
12
04i 1
14
01
} [expr] #@[documentation: "Will try and evaluate as many constant as possible to make the expression simpler." source: ["Will try and evaluate as many constant as possible to make the expression simpler." [if-not [pair? expr] expr [do [def folded-fun [car expr]] [when [= 'quote folded-fun] [return expr]] [def folded-args [constant-fold/args [cdr expr]]] [if [and [constant-foldable? folded-fun] [every? folded-args pure?]] [try [fn [] [cons folded-fun folded-args]] [apply [constant-fold/resolve folded-fun] folded-args]] [cons folded-fun folded-args]]]]]] #{##[[] #@[source: [[cons folded-fun folded-args]]] #{##[]
10s folded-fun
10s folded-args
14
01
}]
10s pair?
10s expr
04i 1
0Bo 133
10s expr
11
0Es folded-fun
0D
23s quote
10s folded-fun
20
0Bo 11
10s expr
01
09o 4
24
0D
10s constant-fold/args
10s expr
12
04i 1
0Es folded-args
0D
10s constant-foldable?
10s folded-fun
04i 1
0C
0Bo 18
0D
10s every?
10s folded-args
10s pure?
04i 2
0Bo 41
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
19o 24
10s apply
10s constant-fold/resolve
10s folded-fun
04i 1
10s folded-args
04i 2
16
09o 12
10s folded-fun
10s folded-args
14
09o 7
10s expr
01
}]
23s pure?
1Ai 0
1Ai 1
1Ai 2
17
0Es pure?
0D
23s constant-foldable?
1Ai 3
1Ai 4
1Ai 5
17
0Es constant-foldable?
0D
23s constant-fold/resolve
1Ai 6
1Ai 7
1Ai 8
17
0Es constant-fold/resolve
0D
23s constant-fold/args
1Ai 9
1Ai 10
1Ai 11
17
0Es constant-fold/args
0D
23s constant-fold
1Ai 12
1Ai 13
1Ai 14
17
0Es constant-fold
01
}#{##[[args env] #@[source: [[if [last? args] [cons [macroexpand* [car args] env] #nil] [if [pair? [car args]] [let* [def ocar [macroexpand* [car args] env]] [if [pair? ocar] [cons ocar [macroexpand/do/args [cdr args] env]] [macroexpand/do/args [cdr args] env]]] [macroexpand/do/args [cdr args] env]]]]] #{##[]
10s nil?
10s args
12
04i 1
0Bo 23
10s macroexpand*
10s args
11
10s env
04i 2
24
14
09o 108
10s pair?
10s args
11
04i 1
0Bo 79
15
10s macroexpand*
10s args
11
10s env
04i 2
0Es ocar
0D
10s pair?
10s ocar
04i 1
0Bo 26
10s ocar
10s macroexpand/do/args
10s args
12
10s env
04i 2
14
09o 18
10s macroexpand/do/args
10s args
12
10s env
04i 2
16
09o 18
10s macroexpand/do/args
10s args
12
10s env
04i 2
01
} [source env] #@[source: [[def args [macroexpand/do/args source env]] [if [last? args] [car args] [cons 'do args]]]] #{##[]
10s macroexpand/do/args
10s source
10s env
04i 2
0Es args
0D
10s nil?
10s args
12
04i 1
0Bo 11
10s args
11
09o 12
23s do
10s args
14
01
} [source env op arity implicit-do? no-expand-bitmap] #@[source: [[def ret [cons op #nil]] [def l [cdr source]] [dotimes [i arity] [set! ret [cons [if [bit-set? no-expand-bitmap i] [car l] [macroexpand* [car l] env]] ret]] [cdr! l]] [if implicit-do? [set! ret [cons [macroexpand/do l env] ret]] [when l [throw [list :arity-error [cat "form contains more than " arity " arguments"] source [current-lambda]]]]] [return [nreverse ret]]]] #{##[:arity-error "form contains more than " " arguments"]
10s op
24
14
0Es ret
0D
10s source
12
0Es l
0D
15
02i 0
0Es i
0D
24
1B
09o 76
0D
1C
10s bit-test?
10s no-expand-bitmap
10s i
04i 2
0Bo 11
10s l
11
09o 18
10s macroexpand*
10s l
11
10s env
04i 2
10s ret
14
0Fs ret
0D
10s l
12
0Fs l
0D
02i 1
10s i
03
0Fs i
10s i
10s arity
1E
0Ao -82
0D
24
16
0D
10s implicit-do?
0Bo 29
10s macroexpand/do
10s l
10s env
04i 2
10s ret
14
0Fs ret
09o 52
10s l
0Bo 44
10s throw
10s list
1Ai 0
10s cat
1Ai 1
10s arity
1Ai 2
04i 3
10s source
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s nreverse
10s ret
04i 1
01
01
} [op source env] #@[source: [[if [cdr source] [if [cddr source] [list op [macroexpand/fold op [except-last-pair source] env] [macroexpand* [car [last-pair source]] env]] [list op [macroexpand* [car source] env] [macroexpand* [cadr source] env]]] [list op [macroexpand* [car source] env]]]]] #{##[]
10s source
12
0Bo 114
10s source
12
12
0Bo 61
10s list
10s op
10s macroexpand/fold
10s op
10s except-last-pair
10s source
04i 1
10s env
04i 3
10s macroexpand*
10s last-pair
10s source
04i 1
11
10s env
04i 2
04i 3
09o 44
10s list
10s op
10s macroexpand*
10s source
11
10s env
04i 2
10s macroexpand*
10s source
12
11
10s env
04i 2
04i 3
09o 28
10s list
10s op
10s macroexpand*
10s source
11
10s env
04i 2
04i 2
01
} [source env] #@[documentation: "Expand all macros within source" source: ["Expand all macros within source" [def op [if [resolves? [car source] env] [resolve [car source] env] [car source]]] [case [type-of op] [:nil source] [:native-function [case op [[+ - * / rem bit-and bit-or bit-xor] [macroexpand/fold op [cdr source]]] [do [macroexpand/do source env]] [return [macroexpand/form source env op 1 #f 0]] [[try while] [macroexpand/form source env op 1 #t 0]] [[def set!] [macroexpand/form source env op 2 #f 1]] [if [macroexpand/form source env op 3 #f 0]] [[fn* macro*] [macroexpand/form source env op 4 #t 7]] [[let* environment*] [list op [macroexpand/do [cdr source] env]]] 'source [otherwise [map source [fn [α] [macroexpand* α env]]]]]] [:macro [macroexpand* [macro-apply op [cdr source]] env]] [otherwise [map source [fn [α] [macroexpand* α env]]]]]]] #{##[:nil :native-function #f #t [α] #@[source: [[macroexpand* α env]]] #{##[]
10s macroexpand*
10s α
10s env
04i 2
01
} :macro [α] #{##[]
10s macroexpand*
10s α
10s env
04i 2
01
}]
10s resolves?
10s source
11
10s env
04i 2
0Bo 21
10s resolve
10s source
11
10s env
04i 2
09o 8
10s source
11
0Es op
0D
15
10s type-of
10s op
04i 1
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
1Ai 0
20
0Bo 10
10s source
09o 609
10s ΓεnΣym-1
1Ai 1
20
0Bo 540
15
10s op
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
10s +
20
0C
0Ao 104
0D
10s ΓεnΣym-2
10s -
20
0C
0Ao 90
0D
10s ΓεnΣym-2
10s *
20
0C
0Ao 76
0D
10s ΓεnΣym-2
10s /
20
0C
0Ao 62
0D
10s ΓεnΣym-2
10s rem
20
0C
0Ao 48
0D
10s ΓεnΣym-2
10s bit-and
20
0C
0Ao 34
0D
10s ΓεnΣym-2
10s bit-or
20
0C
0Ao 20
0D
10s ΓεnΣym-2
10s bit-xor
20
0C
0Ao 6
0D
1Ai 2
0Bo 21
10s macroexpand/fold
10s op
10s source
12
04i 2
09o 391
10s ΓεnΣym-2
10s do
20
0Bo 20
10s macroexpand/do
10s source
10s env
04i 2
09o 362
10s ΓεnΣym-2
10s return
20
0Bo 30
10s macroexpand/form
10s source
10s env
10s op
02i 1
1Ai 2
02i 0
04i 6
09o 323
10s ΓεnΣym-2
10s try
20
0C
0Ao 20
0D
10s ΓεnΣym-2
10s while
20
0C
0Ao 6
0D
1Ai 2
0Bo 30
10s macroexpand/form
10s source
10s env
10s op
02i 1
1Ai 3
02i 0
04i 6
09o 263
10s ΓεnΣym-2
10s def
20
0C
0Ao 20
0D
10s ΓεnΣym-2
10s set!
20
0C
0Ao 6
0D
1Ai 2
0Bo 30
10s macroexpand/form
10s source
10s env
10s op
02i 2
1Ai 2
02i 1
04i 6
09o 203
10s ΓεnΣym-2
10s if
20
0Bo 30
10s macroexpand/form
10s source
10s env
10s op
02i 3
1Ai 2
02i 0
04i 6
09o 164
10s ΓεnΣym-2
10s fn*
20
0C
0Ao 20
0D
10s ΓεnΣym-2
10s macro*
20
0C
0Ao 6
0D
1Ai 2
0Bo 30
10s macroexpand/form
10s source
10s env
10s op
02i 4
1Ai 3
02i 7
04i 6
09o 104
10s ΓεnΣym-2
10s let*
20
0C
0Ao 20
0D
10s ΓεnΣym-2
10s environment*
20
0C
0Ao 6
0D
1Ai 2
0Bo 31
10s list
10s op
10s macroexpand/do
10s source
12
10s env
04i 2
04i 2
09o 43
10s ΓεnΣym-2
10s quote
20
0Bo 10
10s source
09o 24
10s map
10s source
23s anonymous
1Ai 4
1Ai 5
1Ai 6
17
04i 2
16
09o 62
10s ΓεnΣym-1
1Ai 7
20
0Bo 31
10s macroexpand*
10s macro-apply
10s op
10s source
12
04i 2
10s env
04i 2
09o 24
10s map
10s source
23s anonymous
1Ai 8
1Ai 5
1Ai 9
17
04i 2
16
01
} [source env] #@[documentation: "Macroexpand the forms in source" source: ["Macroexpand the forms in source" [macroexpand* source [or env [current-closure]]]]] #{##[#f]
10s macroexpand*
10s source
10s env
0C
0Ao 17
0D
10s current-closure
04i 0
0C
0Ao 6
0D
1Ai 0
04i 2
01
}]
23s macroexpand/do/args
1Ai 0
1Ai 1
1Ai 2
17
0Es macroexpand/do/args
0D
23s macroexpand/do
1Ai 3
1Ai 4
1Ai 5
17
0Es macroexpand/do
0D
23s macroexpand/form
1Ai 6
1Ai 7
1Ai 8
17
0Es macroexpand/form
0D
23s macroexpand/fold
1Ai 9
1Ai 10
1Ai 11
17
0Es macroexpand/fold
0D
23s macroexpand*
1Ai 12
1Ai 13
1Ai 14
17
0Es macroexpand*
0D
23s macroexpand
1Ai 15
1Ai 16
1Ai 17
17
0Es macroexpand
01
}#{##[[arg] #@[source: [[when arg [when [or [not [pair? arg]] [not [symbol? [car arg]]]] [throw [list :invalid-let-form "Please fix the structure of the let form" arg]]] [quasiquote [def [unquote [car arg]] [unquote [cadr arg]]]]]]] #{##[#f #t :invalid-let-form "Please fix the structure of the let form"]
10s arg
0Bo 106
10s pair?
10s arg
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
0C
0Ao 32
0D
10s symbol?
10s arg
11
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
0C
0Ao 6
0D
1Ai 0
0Bo 26
10s throw
10s list
1Ai 2
1Ai 3
10s arg
04i 3
04i 1
09o 4
24
0D
23s def
10s arg
11
10s arg
12
11
24
14
14
14
09o 4
24
01
} [args] #@[source: [[if-not args #nil [cons [let/arg [car args]] [let/args [cdr args]]]]]] #{##[]
10s args
0Bo 29
10s let/arg
10s args
11
04i 1
10s let/args
10s args
12
04i 1
14
09o 4
24
01
} [bindings . body] #@[documentation: "Evalutes to BODY if PRED is true" source: ["Evalutes to BODY if PRED is true" [quasiquote [let* [do [unquote-splicing [let/args bindings]] [unquote-splicing body]]]]]] #{##[]
23s let*
23s do
10s append
10s let/args
10s bindings
04i 1
10s append
10s body
24
04i 2
04i 2
14
24
14
14
01
} [binding then else] #@[source: [[quasiquote [let* [def [unquote [car binding]] [unquote [cadr binding]]] [if [unquote [car binding]] [unquote then] [unquote else]]]]]] #{##[]
23s let*
23s def
10s binding
11
10s binding
12
11
24
14
14
14
23s if
10s binding
11
10s then
10s else
24
14
14
14
14
24
14
14
14
01
} [binding . body] #@[source: [[quasiquote [if-let [unquote binding] [unquote [cons 'do body]] #nil]]]] #{##[]
23s if-let
10s binding
23s do
10s body
14
24
24
14
14
14
14
01
}]
23s let/arg
1Ai 0
1Ai 1
1Ai 2
17
0Es let/arg
0D
23s let/args
1Ai 3
1Ai 4
1Ai 5
17
0Es let/args
0D
23s let
1Ai 6
1Ai 7
1Ai 8
18
0Es let
0D
23s if-let
1Ai 9
1Ai 10
1Ai 11
18
0Es if-let
0D
23s when-let
1Ai 12
1Ai 13
1Ai 14
18
0Es when-let
01
}#{##[#t #@[source: []] #{##[]
24
01
} #{##[]
24
01
} #@[documentation: "Does nothing" source: ["Does nothing" #nil]] #{##[]
24
01
} [val inc] #@[source: [[quasiquote [set! [unquote val] [+ [unquote val] [unquote inc]]]]]] #{##[]
23s set!
10s val
23s +
10s val
10s inc
24
14
14
14
24
14
14
14
01
} [l] #@[documentation: "[set! l [cdr l]]" source: ["[set! l [cdr l]]" [quasiquote [set! [unquote l] [cdr [unquote l]]]]]] #{##[]
23s set!
10s l
23s cdr
10s l
24
14
14
24
14
14
14
01
} [v] #@[documentation: "Return true if V is false" source: [:inline "Return true if V is false" [if v #f #t]] inline: #t] #{##[#f #t]
10s v
0Bo 8
1Ai 0
09o 5
1Ai 1
01
} [α] #@[documentation: "Returns its argument" source: [:inline "Returns its argument" α] inline: #t] #{##[]
10s α
01
} #@[documentation: "Return ARGUMENTS as a list" source: ["Return ARGUMENTS as a list" arguments]] #{##[]
10s arguments
01
} [p] #@[documentation: "[car [car p]]" source: [:inline "[car [car p]]" [car [car p]]] inline: #t] #{##[]
10s p
11
11
01
} [p] #@[documentation: "[car [cdr p]]" source: [:inline "[car [cdr p]]" [car [cdr p]]] inline: #t] #{##[]
10s p
12
11
01
} [p] #@[documentation: "[cdr [car p]]" source: [:inline "[cdr [car p]]" [cdr [car p]]] inline: #t] #{##[]
10s p
11
12
01
} [p] #@[documentation: "[cdr [cdr p]]" source: [:inline "[cdr [cdr p]]" [cdr [cdr p]]] inline: #t] #{##[]
10s p
12
12
01
} [p] #@[documentation: "[cdr [car p]]" source: ["[cdr [car p]]" [car [cdr [car p]]]]] #{##[]
10s p
11
12
11
01
} [p] #@[documentation: "[car [cdr [cdr p]]]" source: ["[car [cdr [cdr p]]]" [car [cdr [cdr p]]]]] #{##[]
10s p
12
12
11
01
} [p] #@[documentation: "[cdr [cdr [cdr p]]]" source: ["[cdr [cdr [cdr p]]]" [cdr [cdr [cdr p]]]]] #{##[]
10s p
12
12
12
01
} [p] #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [car [cdr [cdr [cdr p]]]]]] #{##[]
10s p
12
12
12
11
01
} [p] #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [cdr [cdr [cdr [cdr p]]]]]] #{##[]
10s p
12
12
12
12
01
} [p] #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [car [cdr [cdr [cdr [cdr p]]]]]]] #{##[]
10s p
12
12
12
12
11
01
} [p] #@[documentation: "[cdr [cdr [cdr [cdr p]]]]" source: ["[cdr [cdr [cdr [cdr p]]]]" [cdr [cdr [cdr [cdr [cdr p]]]]]]] #{##[]
10s p
12
12
12
12
12
01
} [α] #@[source: [[when-not [keyword? α] [throw [list :type-error "[keyword->string] can only be called on keywords" α [current-lambda]]]] [symbol->string [keyword->symbol α]]]] #{##[:type-error "[keyword->string] can only be called on keywords"]
10s keyword?
10s α
04i 1
0Bo 7
24
09o 29
10s throw
10s list
1Ai 0
1Ai 1
10s α
10s current-lambda
04i 0
04i 4
04i 1
0D
10s symbol->string
10s keyword->symbol
10s α
04i 1
04i 1
01
} [α] #@[source: [[when-not [string? α] [throw [list :type-error "[string->keyword] can only be called on strings" α [current-lambda]]]] [symbol->keyword [string->symbol α]]]] #{##[:type-error "[string->keyword] can only be called on strings"]
10s string?
10s α
04i 1
0Bo 7
24
09o 29
10s throw
10s list
1Ai 0
1Ai 1
10s α
10s current-lambda
04i 0
04i 4
04i 1
0D
10s symbol->keyword
10s string->symbol
10s α
04i 1
04i 1
01
} [type description value] #@[source: [[quasiquote [throw [list [unquote type] [unquote description] [unquote value] [current-lambda]]]]]] #{##[]
23s throw
23s list
10s type
10s description
10s value
23s current-lambda
24
14
24
14
14
14
14
14
24
14
14
01
}]
1Ai 0
0Es otherwise
0D
23s deftest
23s l
1Ai 1
1Ai 2
18
0Es deftest
0D
23s defqtest
23s l
1Ai 1
1Ai 3
18
0Es defqtest
0D
23s comment
23s body
1Ai 4
1Ai 5
18
0Es comment
0D
23s +=
1Ai 6
1Ai 7
1Ai 8
18
0Es +=
0D
23s cdr!
1Ai 9
1Ai 10
1Ai 11
18
0Es cdr!
0D
23s not
1Ai 12
1Ai 13
1Ai 14
17
0Es not
0D
23s identity
1Ai 15
1Ai 16
1Ai 17
17
0Es identity
0D
23s list
23s arguments
1Ai 18
1Ai 19
17
0Es list
0D
23s caar
1Ai 20
1Ai 21
1Ai 22
17
0Es caar
0D
23s cadr
1Ai 23
1Ai 24
1Ai 25
17
0Es cadr
0D
23s cdar
1Ai 26
1Ai 27
1Ai 28
17
0Es cdar
0D
23s cddr
1Ai 29
1Ai 30
1Ai 31
17
0Es cddr
0D
23s cadar
1Ai 32
1Ai 33
1Ai 34
17
0Es cadar
0D
23s caddr
1Ai 35
1Ai 36
1Ai 37
17
0Es caddr
0D
23s cdddr
1Ai 38
1Ai 39
1Ai 40
17
0Es cdddr
0D
23s cadddr
1Ai 41
1Ai 42
1Ai 43
17
0Es cadddr
0D
23s cddddr
1Ai 44
1Ai 45
1Ai 46
17
0Es cddddr
0D
23s caddddr
1Ai 47
1Ai 48
1Ai 49
17
0Es caddddr
0D
23s cdddddr
1Ai 50
1Ai 51
1Ai 52
17
0Es cdddddr
0D
23s keyword->string
1Ai 53
1Ai 54
1Ai 55
17
0Es keyword->string
0D
23s string->keyword
1Ai 56
1Ai 57
1Ai 58
17
0Es string->keyword
0D
23s exception
1Ai 59
1Ai 60
1Ai 61
18
0Es exception
01
}#{##[[pred then else] #@[source: [[quasiquote [if [unquote pred] [unquote else] [unquote then]]]]] #{##[]
23s if
10s pred
10s else
10s then
24
14
14
14
14
01
} [pred . body] #@[documentation: "Evalutes to BODY if PRED is false" source: ["Evalutes to BODY if PRED is false" [quasiquote [if [unquote pred] #nil [do [unquote-splicing body]]]]]] #{##[]
23s if
10s pred
24
23s do
10s append
10s body
24
04i 2
14
24
14
14
14
14
01
} [pred . body] #@[documentation: "Evalutes to BODY if PRED is true" source: ["Evalutes to BODY if PRED is true" [quasiquote [if [unquote pred] [do [unquote-splicing body]] #nil]]]] #{##[]
23s if
10s pred
23s do
10s append
10s body
24
04i 2
14
24
24
14
14
14
14
01
} [key-sym cases] #@[source: [[when cases [cons [list '= key-sym [car cases]] [case/clauses/multiple key-sym [cdr cases]]]]]] #{##[]
10s cases
0Bo 41
10s list
23s =
10s key-sym
10s cases
11
04i 3
10s case/clauses/multiple
10s key-sym
10s cases
12
04i 2
14
09o 4
24
01
} [key-sym clauses] #@[source: [[when clauses [if [= [caar clauses] 'otherwise] [cons 'do [cdar clauses]] [list 'if [if [pair? [caar clauses]] [if [and [= [car [caar clauses]] 'quote] [last? [cdr [caar clauses]]] [symbol? [cadr [caar clauses]]]] [list '= key-sym [caar clauses]] [cons 'or [case/clauses/multiple key-sym [caar clauses]]]] [list '= key-sym [caar clauses]]] [cons 'do [cdar clauses]] [case/clauses key-sym [cdr clauses]]]]]]] #{##[]
10s clauses
0Bo 205
10s clauses
11
11
23s otherwise
20
0Bo 17
23s do
10s clauses
11
12
14
09o 174
10s list
23s if
10s pair?
10s clauses
11
11
04i 1
0Bo 103
10s clauses
11
11
11
23s quote
20
0C
0Bo 37
0D
10s nil?
10s clauses
11
11
12
12
04i 1
0C
0Bo 18
0D
10s symbol?
10s clauses
11
11
12
11
04i 1
0Bo 26
10s list
23s =
10s key-sym
10s clauses
11
11
04i 3
09o 24
23s or
10s case/clauses/multiple
10s key-sym
10s clauses
11
11
04i 2
14
09o 23
10s list
23s =
10s key-sym
10s clauses
11
11
04i 3
23s do
10s clauses
11
12
14
10s case/clauses
10s key-sym
10s clauses
12
04i 2
04i 4
09o 4
24
01
} [key-form . clauses] #@[source: [[def key-sym [gensym]] [list 'let* [list 'def key-sym key-form] [case/clauses key-sym clauses]]]] #{##[]
10s gensym
04i 0
0Es key-sym
0D
10s list
23s let*
10s list
23s def
10s key-sym
10s key-form
04i 3
10s case/clauses
10s key-sym
10s clauses
04i 2
04i 3
01
} #@[documentation: "Contains multiple cond clauses" source: ["Contains multiple cond clauses" [when [and body [caar body]] [list 'if [caar body] [cons 'do [cdar body]] [macro-apply cond [cdr body]]]]]] #{##[]
10s body
0C
0Bo 10
0D
10s body
11
11
0Bo 48
10s list
23s if
10s body
11
11
23s do
10s body
11
12
14
10s macro-apply
10s cond
10s body
12
04i 2
04i 4
09o 4
24
01
} [binding . body] #@[documentation: "binding => [name n result-form]\nRepeatedly executes body with name bound to integers from 0 through n-1. Returns result-form or #nil." source: ["binding => [name n result-form]" "Repeatedly executes body with name bound to integers from 0 through n-1. Returns result-form or #nil." [def sym [car binding]] [typecheck/only sym :symbol] [def times [cadr binding]] [def result-form [caddr binding]] [quasiquote [let [[[unquote sym] 0]] [while [< [unquote sym] [unquote times]] [unquote-splicing body] [set! [unquote sym] [add/int 1 [unquote sym]]]] [unquote result-form]]]]] #{##[:symbol :type-error "Expected a value of type :symbol"]
10s binding
11
0Es sym
0D
10s type-of
10s sym
04i 1
1Ai 0
20
0Bo 7
24
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s sym
10s current-lambda
04i 0
04i 4
04i 1
0D
10s binding
12
11
0Es times
0D
10s caddr
10s binding
04i 1
0Es result-form
0D
23s let
10s sym
02i 0
24
14
14
24
14
23s while
23s <
10s sym
10s times
24
14
14
14
10s append
10s body
23s set!
10s sym
23s add/int
02i 1
10s sym
24
14
14
14
24
14
14
14
24
14
04i 2
14
14
10s result-form
24
14
14
14
14
01
} [for-loop . body] #@[documentation: "[doseq [l [list 1 2 3 4]] [println l]]" source: ["[doseq [l [list 1 2 3 4]] [println l]]" [def symbol-name [gensym]] [quasiquote [let [[[unquote symbol-name] [unquote [cadr for-loop]]]] [when [unquote symbol-name] [while [unquote symbol-name] [def [unquote [car for-loop]] [car [unquote symbol-name]]] [unquote-splicing body] [cdr! [unquote symbol-name]]]]]]]] #{##[]
10s gensym
04i 0
0Es symbol-name
0D
23s let
10s symbol-name
10s for-loop
12
11
24
14
14
24
14
23s when
10s symbol-name
23s while
10s symbol-name
23s def
10s for-loop
11
23s car
10s symbol-name
24
14
14
24
14
14
14
10s append
10s body
23s cdr!
10s symbol-name
24
14
14
24
14
04i 2
14
14
14
24
14
14
14
24
14
14
14
01
} [init fun] #@[source: [[if-not fun init [if [pair? [car fun]] [quasiquote [[unquote [caar fun]] [unquote [thread/-> init [cdr fun]]] [unquote-splicing [cdar fun]]]] [list [car fun] [thread/-> init [cdr fun]]]]]]] #{##[]
10s fun
0Bo 85
10s pair?
10s fun
11
04i 1
0Bo 42
10s fun
11
11
10s thread/->
10s init
10s fun
12
04i 2
10s append
10s fun
11
12
24
04i 2
14
14
09o 29
10s list
10s fun
11
10s thread/->
10s init
10s fun
12
04i 2
04i 2
09o 7
10s init
01
} [init . fun] #@[documentation: "Thread init as the first argument through every function in fun" source: ["Thread init as the first argument through every function in fun" [thread/-> init [reverse fun]]]] #{##[]
10s thread/->
10s init
10s reverse
10s fun
04i 1
04i 2
01
} [init fun] #@[source: [[if-not fun init [append [car fun] [cons [thread/->> init [cdr fun]] #nil]]]]] #{##[]
10s fun
0Bo 34
10s append
10s fun
11
10s thread/->>
10s init
10s fun
12
04i 2
24
14
04i 2
09o 7
10s init
01
} [init . fun] #@[documentation: "Thread init as the last argument through every function in fun" source: ["Thread init as the last argument through every function in fun" [thread/->> init [reverse fun]]]] #{##[]
10s thread/->>
10s init
10s reverse
10s fun
04i 1
04i 2
01
}]
23s if-not
1Ai 0
1Ai 1
1Ai 2
18
0Es if-not
0D
23s when-not
1Ai 3
1Ai 4
1Ai 5
18
0Es when-not
0D
23s when
1Ai 6
1Ai 7
1Ai 8
18
0Es when
0D
23s case/clauses/multiple
1Ai 9
1Ai 10
1Ai 11
17
0Es case/clauses/multiple
0D
23s case/clauses
1Ai 12
1Ai 13
1Ai 14
17
0Es case/clauses
0D
23s case
1Ai 15
1Ai 16
1Ai 17
18
0Es case
0D
23s cond
23s body
1Ai 18
1Ai 19
18
0Es cond
0D
23s dotimes
1Ai 20
1Ai 21
1Ai 22
18
0Es dotimes
0D
23s doseq
1Ai 23
1Ai 24
1Ai 25
18
0Es doseq
0D
23s thread/->
1Ai 26
1Ai 27
1Ai 28
17
0Es thread/->
0D
23s ->
1Ai 29
1Ai 30
1Ai 31
18
0Es ->
0D
23s thread/->>
1Ai 32
1Ai 33
1Ai 34
17
0Es thread/->>
0D
23s ->>
1Ai 35
1Ai 36
1Ai 37
18
0Es ->>
01
}#{##[[f] #@[source: [[set! module/loader [cons f module/loader]]]] #{##[]
10s f
10s module/loader
14
0Fs module/loader
01
} [] #@[source: [[tree/new :cache module/cache :loader module/loader]]] #{##[:cache :loader]
10s tree/new
1Ai 0
10s module/cache
1Ai 1
10s module/loader
04i 4
01
} [c] #@[source: [[set! module/cache [tree/ref c :cache]] [set! module/loader [tree/ref c :loader]]]] #{##[:cache :loader]
10s tree/ref
10s c
1Ai 0
04i 2
0Fs module/cache
0D
10s tree/ref
10s c
1Ai 1
04i 2
0Fs module/loader
01
} [module-name symbol] #@[source: [[string->symbol [cat [keyword->symbol module-name] "/" [string symbol]]]]] #{##["/"]
10s string->symbol
10s cat
10s keyword->symbol
10s module-name
04i 1
1Ai 0
10s string
10s symbol
04i 1
04i 3
04i 1
01
} #@[documentation: "Define a new module and return it" source: ["Define a new module and return it" [macroexpand [cons 'environment* [cons '[def exports [tree/new #nil]] body]]]]] #{##[[def exports [tree/new #nil]]]
10s macroexpand
23s environment*
1Ai 0
10s body
14
14
04i 1
01
} [name . body] #@[documentation: "Define a new named module" source: ["Define a new named module" [quasiquote [module/insert [unquote name] [unquote [cons module body]]]]]] #{##[]
23s module/insert
10s name
10s module
10s body
14
24
14
14
14
01
} [name value] #@[source: [[quasiquote [tree/set! exports '[unquote name] [unquote value]]]]] #{##[]
23s tree/set!
23s exports
23s quote
10s name
24
14
14
10s value
24
14
14
14
14
01
} [module env qualify?] #@[source: [[def mod [module/load module]] [def exports [resolve 'exports mod]] [doseq [k [tree/keys exports]] [def q [if qualify? [module/qualify-symbol module [keyword->symbol k]] [keyword->symbol k]]] [def expr [quasiquote [def [unquote q] [module/import [unquote mod] '[unquote [keyword->symbol k]]]]]] [apply env [compile* expr env]]]]] #{##[]
10s module/load
10s module
04i 1
0Es mod
0D
10s resolve
23s exports
10s mod
04i 2
0Es exports
0D
15
10s tree/keys
10s exports
04i 1
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
0Bo 155
24
1B
09o 140
0D
1C
10s ΓεnΣym-1
11
0Es k
0D
10s qualify?
0Bo 26
10s module/qualify-symbol
10s module
10s keyword->symbol
10s k
04i 1
04i 2
09o 13
10s keyword->symbol
10s k
04i 1
0Es q
0D
23s def
10s q
23s module/import
10s mod
23s quote
10s keyword->symbol
10s k
04i 1
24
14
14
24
14
14
14
24
14
14
14
0Es expr
0D
10s apply
10s env
10s compile*
10s expr
10s env
04i 2
04i 2
0D
10s ΓεnΣym-1
12
0Fs ΓεnΣym-1
10s ΓεnΣym-1
0Ao -141
09o 4
24
16
01
} [module] #@[source: [[quasiquote [require* [unquote module] [current-closure] #f]]]] #{##[#f]
23s require*
10s module
23s current-closure
24
14
1Ai 0
24
14
14
14
14
01
} [module] #@[source: [[quasiquote [require* [unquote module] [current-closure] #t]]]] #{##[#t]
23s require*
10s module
23s current-closure
24
14
1Ai 0
24
14
14
14
14
01
} [local-symbol module module-symbol] #@[source: [[quasiquote [def [unquote local-symbol] [module/import [unquote module] '[unquote module-symbol]]]]]] #{##[]
23s def
10s local-symbol
23s module/import
10s module
23s quote
10s module-symbol
24
14
14
24
14
14
14
24
14
14
14
01
} [names module] #@[source: [[when-not [list? names] [return [quasiquote [import* [unquote names] [module/load [unquote module]] [unquote names]]]]] [def ret #nil] [while names [if [= [cadr names] :as] [do [set! ret [cons [quasiquote [import* [unquote [caddr names]] [module/load [unquote module]] [unquote [car names]]]] ret]] [set! names [cddr names]]] [set! ret [cons [quasiquote [import* [unquote [car names]] [module/load [unquote module]] [unquote [car names]]]] ret]]] [cdr! names]] [cons do [nreverse ret]]]] #{##[:as]
10s list?
10s names
04i 1
0Bo 7
24
09o 32
23s import*
10s names
23s module/load
10s module
24
14
14
10s names
24
14
14
14
14
01
0D
24
0Es ret
0D
24
1B
09o 124
0D
1C
10s names
12
11
1Ai 0
20
0Bo 61
23s import*
10s caddr
10s names
04i 1
23s module/load
10s module
24
14
14
10s names
11
24
14
14
14
14
10s ret
14
0Fs ret
0D
10s names
12
12
0Fs names
09o 42
23s import*
10s names
11
23s module/load
10s module
24
14
14
10s names
11
24
14
14
14
14
10s ret
14
0Fs ret
0D
10s names
12
0Fs names
10s names
0Ao -125
0D
10s do
10s nreverse
10s ret
04i 1
14
01
} [name] #@[source: [[doseq [loader module/loader] [def mod [loader name]] [when mod [return mod]]] [return #nil]]] #{##[]
15
10s module/loader
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
0Bo 71
24
1B
09o 56
0D
1C
10s ΓεnΣym-2
11
0Es loader
0D
10s loader
10s name
04i 1
0Es mod
0D
10s mod
0Bo 11
10s mod
01
09o 4
24
0D
10s ΓεnΣym-2
12
0Fs ΓεnΣym-2
10s ΓεnΣym-2
0Ao -57
09o 4
24
16
0D
24
01
01
} [name module] #@[source: [[tree/set! module/cache name module]]] #{##[]
10s tree/set!
10s module/cache
10s name
10s module
04i 3
01
} [name] #@[source: [[case [type-of name] [:object name] [:keyword [or [tree/ref module/cache name] [do [def mod [module/load/external name]] [when mod [tree/set! module/cache name mod]] [return mod]]]]]]] #{##[:object :keyword #f]
15
10s type-of
10s name
04i 1
0Es ΓεnΣym-3
0D
10s ΓεnΣym-3
1Ai 0
20
0Bo 10
10s name
09o 93
10s ΓεnΣym-3
1Ai 1
20
0Bo 82
10s tree/ref
10s module/cache
10s name
04i 2
0C
0Ao 61
0D
10s module/load/external
10s name
04i 1
0Es mod
0D
10s mod
0Bo 24
10s tree/set!
10s module/cache
10s name
10s mod
04i 3
09o 4
24
0D
10s mod
01
0C
0Ao 6
0D
1Ai 2
09o 4
24
16
01
} [module symbol] #@[source: [[def exports [resolve 'exports module]] [typecheck/only exports :tree] [return exports]]] #{##[:tree :type-error "Expected a value of type :tree"]
10s resolve
23s exports
10s module
04i 2
0Es exports
0D
10s type-of
10s exports
04i 1
1Ai 0
20
0Bo 7
24
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s exports
10s current-lambda
04i 0
04i 4
04i 1
0D
10s exports
01
01
} [module symbol] #@[source: [[def exports [module/import-all module symbol]] [when-not [tree/has? exports symbol] [exception :import-error [if [resolves? symbol module] "That symbol was not exported" "That symbol does not exist in that module"]]] [tree/ref exports symbol]]] #{##[:import-error "That symbol was not exported" "That symbol does not exist in that module"]
10s module/import-all
10s module
10s symbol
04i 2
0Es exports
0D
10s tree/has?
10s exports
10s symbol
04i 2
0Bo 7
24
09o 48
10s throw
10s list
1Ai 0
10s resolves?
10s symbol
10s module
04i 2
0Bo 8
1Ai 1
09o 5
1Ai 2
24
10s current-lambda
04i 0
04i 4
04i 1
0D
10s tree/ref
10s exports
10s symbol
04i 2
01
}]
10s tree/new
24
04i 1
0Es module/cache
0D
24
0Es module/loader
0D
23s module/add-loader
1Ai 0
1Ai 1
1Ai 2
17
0Es module/add-loader
0D
23s module/save-state
1Ai 3
1Ai 4
1Ai 5
17
0Es module/save-state
0D
23s module/restore-state
1Ai 6
1Ai 7
1Ai 8
17
0Es module/restore-state
0D
23s module/qualify-symbol
1Ai 9
1Ai 10
1Ai 11
17
0Es module/qualify-symbol
0D
23s module
23s body
1Ai 12
1Ai 13
18
0Es module
0D
23s defmodule
1Ai 14
1Ai 15
1Ai 16
18
0Es defmodule
0D
23s export
1Ai 17
1Ai 18
1Ai 19
18
0Es export
0D
23s require*
1Ai 20
1Ai 21
1Ai 22
17
0Es require*
0D
23s use
1Ai 23
1Ai 24
1Ai 25
18
0Es use
0D
23s require
1Ai 26
1Ai 27
1Ai 28
18
0Es require
0D
23s import*
1Ai 29
1Ai 30
1Ai 31
18
0Es import*
0D
23s import
1Ai 32
1Ai 33
1Ai 34
18
0Es import
0D
23s module/load/external
1Ai 35
1Ai 36
1Ai 37
17
0Es module/load/external
0D
23s module/insert
1Ai 38
1Ai 39
1Ai 40
17
0Es module/insert
0D
23s module/load
1Ai 41
1Ai 42
1Ai 43
17
0Es module/load
0D
23s module/import-all
1Ai 44
1Ai 45
1Ai 46
17
0Es module/import-all
0D
23s module/import
1Ai 47
1Ai 48
1Ai 49
17
0Es module/import
01
}#{##[[a] #@[documentation: "Return #t if a is a number" source: ["Return #t if a is a number" [or [int? a] [float? a] [vec? a]]]] #{##[#f]
10s int?
10s a
04i 1
0C
0Ao 36
0D
10s float?
10s a
04i 1
0C
0Ao 21
0D
10s vec?
10s a
04i 1
0C
0Ao 6
0D
1Ai 0
01
} [a] #@[documentation: "Return #t if a is the last pair in a list" source: [:inline "Return #t if a is the last pair in a list" [nil? [cdr a]]] inline: #t] #{##[]
10s nil?
10s a
12
04i 1
01
} [a] #@[documentation: "Return #t if a is positive" source: [:inline "Return #t if a is positive" [>= a 0.0]] inline: #t] #{##[0.0]
10s a
1Ai 0
21
01
} [a] #@[documentation: "Return #t if a is zero or negative" source: [:inline "Return #t if a is zero or negative" [<= a 0.0]] inline: #t] #{##[0.0]
10s a
1Ai 0
1F
01
} [a] #@[documentation: "Returns #t if a is negative" source: [:inline "Returns #t if a is negative" [< a 0.0]] inline: #t] #{##[0.0]
10s a
1Ai 0
1E
01
} [a] #@[documentation: "Predicate that returns #t if a is odd" source: ["Predicate that returns #t if a is odd" [= [rem [int a] 2] 1]]] #{##[]
10s int
10s a
04i 1
02i 2
29
02i 1
20
01
} [a] #@[documentation: "Predicate that returns #t if a is even" source: ["Predicate that returns #t if a is even" [= [mod/int [int a] 2] 0]]] #{##[]
10s mod/int
10s int
10s a
04i 1
02i 2
04i 2
02i 0
20
01
} [val] #@[documentation: "#t if VAL is not zero" source: [:inline "#t if VAL is not zero" [not= 0 val]] inline: #t] #{##[]
10s not=
02i 0
10s val
04i 2
01
} [a b] #@[documentation: "High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." source: ["High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." [def cur-type [type-of a]] [if [not= cur-type [type-of b]] #f [case cur-type [:array [array/equal? a b]] [:tree [tree/equal? a b]] [:pair [list/equal? a b]] [otherwise [= a b]]]]]] #{##[#f :array :tree :pair]
10s type-of
10s a
04i 1
0Es cur-type
0D
10s not=
10s cur-type
10s type-of
10s b
04i 1
04i 2
0Bo 8
1Ai 0
09o 104
15
10s cur-type
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
1Ai 1
20
0Bo 20
10s array/equal?
10s a
10s b
04i 2
09o 66
10s ΓεnΣym-1
1Ai 2
20
0Bo 20
10s tree/equal?
10s a
10s b
04i 2
09o 39
10s ΓεnΣym-1
1Ai 3
20
0Bo 20
10s list/equal?
10s a
10s b
04i 2
09o 12
10s a
10s b
20
16
01
} [a b] #@[documentation: "High level inequality comparator" source: ["High level inequality comparator" [not [equal? a b]]]] #{##[#f #t]
10s equal?
10s a
10s b
04i 2
0Bo 8
1Ai 0
09o 5
1Ai 1
01
} [val] #@[source: [[= :int [type-of val]]]] #{##[:int]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[= :float [type-of val]]]] #{##[:float]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[= :vec [type-of val]]]] #{##[:vec]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[= :bool [type-of val]]]] #{##[:bool]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[= :pair [type-of val]]]] #{##[:pair]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[= :array [type-of val]]]] #{##[:array]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[= :string [type-of val]]]] #{##[:string]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[= :symbol [type-of val]]]] #{##[:symbol]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[= :object [type-of val]]]] #{##[:object]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[= :tree [type-of val]]]] #{##[:tree]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [v] #@[source: [[= :keyword [type-of v]]]] #{##[:keyword]
1Ai 0
10s type-of
10s v
04i 1
20
01
} [val] #@[source: [[= :macro [type-of val]]]] #{##[:macro]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[or [= :lambda [type-of val]]]]] #{##[:lambda #f]
1Ai 0
10s type-of
10s val
04i 1
20
0C
0Ao 6
0D
1Ai 1
01
} [val] #@[source: [[= :native-function [type-of val]]]] #{##[:native-function]
1Ai 0
10s type-of
10s val
04i 1
20
01
} [val] #@[source: [[or [lambda? val] [native? val]]]] #{##[#f]
10s lambda?
10s val
04i 1
0C
0Ao 21
0D
10s native?
10s val
04i 1
0C
0Ao 6
0D
1Ai 0
01
} [v] #@[source: [[= :buffer [type-of v]]]] #{##[:buffer]
1Ai 0
10s type-of
10s v
04i 1
20
01
} [v] #@[source: [[= :buffer-view [type-of v]]]] #{##[:buffer-view]
1Ai 0
10s type-of
10s v
04i 1
20
01
} [v] #@[source: [[= :bytecode-array [type-of v]]]] #{##[:bytecode-array]
1Ai 0
10s type-of
10s v
04i 1
20
01
} [v] #@[source: [[= :bytecode-op [type-of v]]]] #{##[:bytecode-op]
1Ai 0
10s type-of
10s v
04i 1
20
01
} [v min max] #@[source: [[and [>= v min] [<= v max]]]] #{##[]
10s v
10s min
21
0C
0Bo 13
0D
10s v
10s max
1F
01
}]
23s numeric?
1Ai 0
1Ai 1
1Ai 2
17
0Es numeric?
0D
23s last?
1Ai 3
1Ai 4
1Ai 5
17
0Es last?
0D
23s pos?
1Ai 6
1Ai 7
1Ai 8
17
0Es pos?
0D
23s zero-neg?
1Ai 9
1Ai 10
1Ai 11
17
0Es zero-neg?
0D
23s neg?
1Ai 12
1Ai 13
1Ai 14
17
0Es neg?
0D
23s odd?
1Ai 15
1Ai 16
1Ai 17
17
0Es odd?
0D
23s even?
1Ai 18
1Ai 19
1Ai 20
17
0Es even?
0D
23s not-zero?
1Ai 21
1Ai 22
1Ai 23
17
0Es not-zero?
0D
23s equal?
1Ai 24
1Ai 25
1Ai 26
17
0Es equal?
0D
23s inequal?
1Ai 27
1Ai 28
1Ai 29
17
0Es inequal?
0D
23s int?
1Ai 30
1Ai 31
1Ai 32
17
0Es int?
0D
23s float?
1Ai 33
1Ai 34
1Ai 35
17
0Es float?
0D
23s vec?
1Ai 36
1Ai 37
1Ai 38
17
0Es vec?
0D
23s bool?
1Ai 39
1Ai 40
1Ai 41
17
0Es bool?
0D
23s pair?
1Ai 42
1Ai 43
1Ai 44
17
0Es pair?
0D
23s array?
1Ai 45
1Ai 46
1Ai 47
17
0Es array?
0D
23s string?
1Ai 48
1Ai 49
1Ai 50
17
0Es string?
0D
23s symbol?
1Ai 51
1Ai 52
1Ai 53
17
0Es symbol?
0D
23s object?
1Ai 54
1Ai 55
1Ai 56
17
0Es object?
0D
23s tree?
1Ai 57
1Ai 58
1Ai 59
17
0Es tree?
0D
23s keyword?
1Ai 60
1Ai 61
1Ai 62
17
0Es keyword?
0D
23s macro?
1Ai 63
1Ai 64
1Ai 65
17
0Es macro?
0D
23s lambda?
1Ai 66
1Ai 67
1Ai 68
17
0Es lambda?
0D
23s native?
1Ai 69
1Ai 70
1Ai 71
17
0Es native?
0D
23s procedure?
1Ai 72
1Ai 73
1Ai 74
17
0Es procedure?
0D
23s buffer?
1Ai 75
1Ai 76
1Ai 77
17
0Es buffer?
0D
23s buffer-view?
1Ai 78
1Ai 79
1Ai 80
17
0Es buffer-view?
0D
23s bytecode-array?
1Ai 81
1Ai 82
1Ai 83
17
0Es bytecode-array?
0D
23s bytecode-op?
1Ai 84
1Ai 85
1Ai 86
17
0Es bytecode-op?
0D
23s in-range?
1Ai 87
1Ai 88
1Ai 89
17
0Es in-range?
01
}#{##[[l depth] #@[source: [[if [nil? l] #nil [if [pair? l] [if [= [caar l] 'unquote-splicing] [if [zero? depth] [list 'append [cadr [car l]] [quasiquote-real [cdr l] depth]] [list 'unquote-splicing [quasiquote-real [cadr l] [+ -1 depth]]]] [if [= [car l] 'unquote] [if [zero? depth] [cadr l] [list 'unquote [quasiquote-real [cadr l] [+ -1 depth]]]] [if [= [car l] 'quasiquote] [quasiquote-real [quasiquote-real [cadr l] [+ 1 depth]] depth] [if [zero? depth] [list 'cons [quasiquote-real [car l] depth] [quasiquote-real [cdr l] depth]] [cons [quasiquote-real [car l] depth] [quasiquote-real [cdr l] depth]]]]]] [if [and [zero? depth] [symbol? l]] [cons 'quote [cons l #nil]] l]]]]] #{##[]
10s nil?
10s l
04i 1
0Bo 7
24
09o 338
10s pair?
10s l
04i 1
0Bo 284
10s l
11
11
23s unquote-splicing
20
0Bo 78
10s depth
2A
0Bo 38
10s list
23s append
10s l
11
12
11
10s quasiquote-real
10s l
12
10s depth
04i 2
04i 3
09o 32
10s list
23s unquote-splicing
10s quasiquote-real
10s l
12
11
02i -1
10s depth
25
04i 2
04i 2
09o 192
10s l
11
23s unquote
20
0Bo 52
10s depth
2A
0Bo 12
10s l
12
11
09o 32
10s list
23s unquote
10s quasiquote-real
10s l
12
11
02i -1
10s depth
25
04i 2
04i 2
09o 130
10s l
11
23s quasiquote
20
0Bo 35
10s quasiquote-real
10s quasiquote-real
10s l
12
11
02i 1
10s depth
25
04i 2
10s depth
04i 2
09o 85
10s depth
2A
0Bo 46
10s list
23s cons
10s quasiquote-real
10s l
11
10s depth
04i 2
10s quasiquote-real
10s l
12
10s depth
04i 2
04i 3
09o 34
10s quasiquote-real
10s l
11
10s depth
04i 2
10s quasiquote-real
10s l
12
10s depth
04i 2
14
09o 44
10s depth
2A
0C
0Bo 14
0D
10s symbol?
10s l
04i 1
0Bo 17
23s quote
10s l
24
14
14
09o 7
10s l
01
} [l] #@[source: [[quasiquote-real l 0]]] #{##[]
10s quasiquote-real
10s l
02i 0
04i 2
01
} [expr] #@[source: [[throw [list :unquote-without-quasiquote "unquote should only occur inside a quasiquote, never evaluated directly"]]]] #{##[:unquote-without-quasiquote "unquote should only occur inside a quasiquote, never evaluated directly"]
10s throw
10s list
1Ai 0
1Ai 1
04i 2
04i 1
01
} [expr] #@[source: [[throw [list :unquote-splicing-without-quasiq "unquote-splicing should only occur inside a quasiquote, never evaluated directly"]]]] #{##[:unquote-splicing-without-quasiq "unquote-splicing should only occur inside a quasiquote, never evaluated directly"]
10s throw
10s list
1Ai 0
1Ai 1
04i 2
04i 1
01
}]
23s quasiquote-real
1Ai 0
1Ai 1
1Ai 2
17
0Es quasiquote-real
0D
23s quasiquote
1Ai 3
1Ai 4
1Ai 5
18
0Es quasiquote
0D
23s unquote
1Ai 6
1Ai 7
1Ai 8
17
0Es unquote
0D
23s unquote-splicing
1Ai 9
1Ai 10
1Ai 11
17
0Es unquote-splicing
01
}#{##[3.14159 [x] #@[documentation: "Return a number 1 greater than x" source: [:inline "Return a number 1 greater than x" [+ 1 x]] inline: #t] #{##[]
02i 1
10s x
25
01
} [i v] #@[documentation: "Decrement I by V (defaults to 1) and store the result in I" source: ["Decrement I by V (defaults to 1) and store the result in I" [quasiquote [set! [unquote i] [+ [unquote i] [unquote [or v 1]]]]]]] #{##[#f]
23s set!
10s i
23s +
10s i
10s v
0C
0Ao 13
0D
02i 1
0C
0Ao 6
0D
1Ai 0
24
14
14
14
24
14
14
14
01
} [x] #@[documentation: "Return a number 1 less than x" source: [:inline "Return a number 1 less than x" [+ -1 x]] inline: #t] #{##[]
02i -1
10s x
25
01
} [i v] #@[documentation: "Decrement I by V and store the result in I" source: ["Decrement I by V and store the result in I" [quasiquote [set! [unquote i] [- [unquote i] [unquote [or v 1]]]]]]] #{##[#f]
23s set!
10s i
23s -
10s i
10s v
0C
0Ao 13
0D
02i 1
0C
0Ao 6
0D
1Ai 0
24
14
14
14
24
14
14
14
01
} [α] #@[documentation: "Return a function that adds α to it's argument, useful for mapping" source: ["Return a function that adds α to it's argument, useful for mapping" [fn [β] [+ α β]]]] #{##[[β] #@[source: [[+ α β]]] #{##[]
10s α
10s β
25
01
}]
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
01
} [i] #@[documentation: "Terribly inefficient, but, useful for testing the GC" source: ["Terribly inefficient, but, useful for testing the GC" [if [< i 2] i [+ [fib [- i 2]] [fib [- i 1]]]]]] #{##[]
10s i
02i 2
1E
0Bo 10
10s i
09o 30
10s fib
10s i
02i 2
26
04i 1
10s fib
10s i
02i 1
26
04i 1
25
01
} [val min max] #@[documentation: "Constrains VAL to be within MIN and MAX, wrapping it around" source: ["Constrains VAL to be within MIN and MAX, wrapping it around" [+ min [rem [- val min] [- max min]]]]] #{##[]
10s min
10s val
10s min
26
10s max
10s min
26
29
25
01
} [v] #@[source: [[quasiquote [+ 1 [unquote v]]]]] #{##[]
23s +
02i 1
10s v
24
14
14
14
01
} [degrees] #@[documentation: "Convert a quantity in degrees to radians" source: ["Convert a quantity in degrees to radians" [/ [* π degrees] 180.0]]] #{##[180.0]
10s π
10s degrees
27
1Ai 0
28
01
}]
1Ai 0
0Es PI
0D
1Ai 0
0Es π
0D
23s inc
1Ai 1
1Ai 2
1Ai 3
17
0Es inc
0D
23s inc!
1Ai 4
1Ai 5
1Ai 6
18
0Es inc!
0D
23s dec
1Ai 7
1Ai 8
1Ai 9
17
0Es dec
0D
23s dec!
1Ai 10
1Ai 11
1Ai 12
18
0Es dec!
0D
23s +x
1Ai 13
1Ai 14
1Ai 15
17
0Es +x
0D
23s fib
1Ai 16
1Ai 17
1Ai 18
17
0Es fib
0D
23s wrap-value
1Ai 19
1Ai 20
1Ai 21
17
0Es wrap-value
0D
23s +1
1Ai 22
1Ai 23
1Ai 24
18
0Es +1
0D
23s radians
1Ai 25
1Ai 26
1Ai 27
17
0Es radians
01
}#{##[[c i] #@[source: [[when c [if [= c root-closure] [cat [ansi-blue [cat [int [or i 0]] "# <root environment>"]] "\r\n"] [do [def data [closure/data c]] [def l [length data]] [cat [ansi-blue [cat [int [or i 0]] "# " [string/write c]]] " - " [if [< l 16] [string/write data] "-+- Very big tree structure -+-"] "\r\n" [describe/closure [closure/caller c] [+ [int [or i 0]] 1]]]]]]]] #{##[#f "# <root environment>" "\r\n" "# " " - " "-+- Very big tree structure -+-"]
10s c
0Bo 223
10s c
10s root-closure
20
0Bo 52
10s cat
10s ansi-blue
10s cat
10s int
10s i
0C
0Ao 13
0D
02i 0
0C
0Ao 6
0D
1Ai 0
04i 1
1Ai 1
04i 2
04i 1
1Ai 2
04i 2
09o 159
10s closure/data
10s c
04i 1
0Es data
0D
10s length
10s data
04i 1
0Es l
0D
10s cat
10s ansi-blue
10s cat
10s int
10s i
0C
0Ao 13
0D
02i 0
0C
0Ao 6
0D
1Ai 0
04i 1
1Ai 3
10s string/write
10s c
04i 1
04i 3
04i 1
1Ai 4
10s l
02i 16
1E
0Bo 16
10s string/write
10s data
04i 1
09o 5
1Ai 5
1Ai 2
10s describe/closure
10s closure/caller
10s c
04i 1
10s int
10s i
0C
0Ao 13
0D
02i 0
0C
0Ao 6
0D
1Ai 0
04i 1
02i 1
25
04i 2
04i 5
09o 4
24
01
} [] #@[source: [[display [describe/closure [closure/caller [current-lambda]]]]]] #{##[]
10s print
10s describe/closure
10s closure/caller
10s current-lambda
04i 0
04i 1
04i 1
04i 1
01
} [i text] #@[source: [[case i [0 [ansi-red text]] [1 [string text]] [2 [ansi-yellow [string/write text]]] [3 [describe/closure text]] [otherwise text]]]] #{##[]
15
10s i
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
02i 0
20
0Bo 16
10s ansi-red
10s text
04i 1
09o 82
10s ΓεnΣym-1
02i 1
20
0Bo 16
10s string
10s text
04i 1
09o 59
10s ΓεnΣym-1
02i 2
20
0Bo 22
10s ansi-yellow
10s string/write
10s text
04i 1
04i 1
09o 30
10s ΓεnΣym-1
02i 3
20
0Bo 16
10s describe/closure
10s text
04i 1
09o 7
10s text
16
01
} [error i] #@[source: [[if error [cons [display/error/wrap i [car error]] [display/error/iter [cdr error] [+ 1 i]]] [cons "" #nil]]]] #{##[""]
10s error
0Bo 40
10s display/error/wrap
10s i
10s error
11
04i 2
10s display/error/iter
10s error
12
02i 1
10s i
25
04i 2
14
09o 7
1Ai 0
24
14
01
} [error] #@[documentation: "Display ERROR in a nice, human readable way" source: ["Display ERROR in a nice, human readable way" [display [join [display/error/iter error 0] "\r\n"]]]] #{##["\r\n"]
10s print
10s join
10s display/error/iter
10s error
02i 0
04i 2
1Ai 0
04i 2
04i 1
01
} [o] #@[source: [[meta o :documentation]]] #{##[:documentation]
10s meta
10s o
1Ai 0
04i 2
01
} [o] #@[documentation: "Describe a specific value O" source: ["Describe a specific value O" [def documentation [closure/documentation o]] [def arguments [closure/arguments o]] [fmt "{arguments:?} - {documentation}"]]] #{##[" - "]
10s closure/documentation
10s o
04i 1
0Es documentation
0D
10s closure/arguments
10s o
04i 1
0Es arguments
0D
10s cat
10s string/write
10s arguments
04i 1
1Ai 0
10s documentation
04i 3
01
} [a] #@[documentation: "Descibe whatever value string A resolves to" source: ["Descibe whatever value string A resolves to" [describe/thing [resolve [string->symbol a]]]]] #{##[]
10s describe/thing
10s resolve
10s string->symbol
10s a
04i 1
04i 1
04i 1
01
} [fun] #@[documentation: "Describe FUN, if there is documentation available" source: ["Describe FUN, if there is documentation available" [if [string? fun] [describe/string fun] [describe/thing fun]]]] #{##[]
10s string?
10s fun
04i 1
0Bo 16
10s describe/string
10s fun
04i 1
09o 13
10s describe/thing
10s fun
04i 1
01
} [off len environment] #@[documentation: "Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" source: ["Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" [when-not environment [set! environment root-closure]] [when-not off [set! off 0]] [when-not len [set! len 9999999]] [sublist [eval-in environment '[symbol-table*]] off [+ off len] #nil]]] #{##[9999999 [symbol-table*]]
10s environment
0Bo 7
24
09o 11
10s root-closure
0Fs environment
0D
10s off
0Bo 7
24
09o 9
02i 0
0Fs off
0D
10s len
0Bo 7
24
09o 9
1Ai 0
0Fs len
0D
10s sublist
10s eval-in
10s environment
1Ai 1
04i 2
10s off
10s off
10s len
25
24
04i 4
01
} [prefix] #@[source: [[inc! gensym/counter] [string->symbol [cat prefix "ΓεnΣym-" gensym/counter]]]] #{##["ΓεnΣym-"]
10s gensym/counter
02i 1
25
0Fs gensym/counter
0D
10s string->symbol
10s cat
10s prefix
1Ai 0
10s gensym/counter
04i 3
04i 1
01
}]
23s describe/closure
1Ai 0
1Ai 1
1Ai 2
17
0Es describe/closure
0D
23s stacktrace
1Ai 3
1Ai 4
1Ai 5
17
0Es stacktrace
0D
23s display/error/wrap
1Ai 6
1Ai 7
1Ai 8
17
0Es display/error/wrap
0D
23s display/error/iter
1Ai 9
1Ai 10
1Ai 11
17
0Es display/error/iter
0D
23s display/error
1Ai 12
1Ai 13
1Ai 14
17
0Es display/error
0D
23s closure/documentation
1Ai 15
1Ai 16
1Ai 17
17
0Es closure/documentation
0D
23s describe/thing
1Ai 18
1Ai 19
1Ai 20
17
0Es describe/thing
0D
23s describe/string
1Ai 21
1Ai 22
1Ai 23
17
0Es describe/string
0D
23s describe
1Ai 24
1Ai 25
1Ai 26
17
0Es describe
0D
23s symbol-table
1Ai 27
1Ai 28
1Ai 29
17
0Es symbol-table
0D
02i 0
0Es gensym/counter
0D
23s gensym
1Ai 30
1Ai 31
1Ai 32
17
0Es gensym
0D
10s current-closure
04i 0
0Es root-closure
01
}#{##[[] #@[source: [[set! random/seed [bit-xor [time] [time/milliseconds]]]]] #{##[]
10s bit-xor
10s time
04i 0
10s time/milliseconds
04i 0
04i 2
0Fs random/seed
01
} [] #@[source: [[set! random/seed [+ 12345 [* random/seed 1103515245]]] [bit-or [bit-shift-left [bit-and random/seed 65535] 16] [bit-and [bit-shift-right random/seed 16] 65535]]]] #{##[12345 1103515245 65535]
1Ai 0
10s random/seed
1Ai 1
27
25
0Fs random/seed
0D
10s bit-or
10s bit-shift-left
10s bit-and
10s random/seed
1Ai 2
04i 2
02i 16
04i 2
10s bit-and
10s bit-shift-right
10s random/seed
02i 16
04i 2
1Ai 2
04i 2
04i 2
01
} [new-seed] #@[documentation: "Set a new seed value for the RNG" source: ["Set a new seed value for the RNG" [set! seed new-seed]]] #{##[]
10s new-seed
0Fs seed
01
} [] #@[documentation: "Return the current RNG seed value" source: ["Return the current RNG seed value" seed]] #{##[]
10s seed
01
} [max] #@[documentation: "Return a value from 0 to MAX, or, if left out, a random int" source: ["Return a value from 0 to MAX, or, if left out, a random int" [if [numeric? max] [rem [abs [random/rng!]] max] [random/rng!]]]] #{##[]
10s numeric?
10s max
04i 1
0Bo 23
10s abs
10s random/rng!
04i 0
04i 1
10s max
29
09o 9
10s random/rng!
04i 0
01
}]
02i 0
0Es random/seed
0D
23s random/seed-initialize!
1Ai 0
1Ai 1
1Ai 2
17
0Es random/seed-initialize!
0D
23s random/rng!
1Ai 3
1Ai 4
1Ai 5
17
0Es random/rng!
0D
23s random/seed!
1Ai 6
1Ai 7
1Ai 8
17
0Es random/seed!
0D
23s random/seed
1Ai 9
1Ai 10
1Ai 11
17
0Es random/seed
0D
23s random
1Ai 12
1Ai 13
1Ai 14
17
0Es random
0D
10s random/seed-initialize!
04i 0
01
}#{##[#f "\e[0m" "\e[0;39m" "\e[49m" "\e[0;30m" "\e[0;31m" "\e[0;32m" "\e[0;33m" "\e[0;34m" "\e[0;35m" "\e[0;36m" "\e[0;37m" "\e[1;30m" "\e[1;31m" "\e[1;32m" "\e[1;33m" "\e[1;34m" "\e[1;35m" "\e[1;36m" "\e[1;37m" "\e[40m" "\e[41m" "\e[42m" "\e[43m" "\e[44m" "\e[45m" "\e[46m" "\e[47m" [code string] #@[documentation: "Wrap STRING in the ansi color CODE" source: ["Wrap STRING in the ansi color CODE" [cat [or ansi/disabled [array/ref ansi-fg code]] string [or ansi/disabled ansi-reset]]]] #{##[#f]
10s cat
10s ansi/disabled
0C
0Ao 25
0D
10s array/ref
10s ansi-fg
10s code
04i 2
0C
0Ao 6
0D
1Ai 0
10s string
10s ansi/disabled
0C
0Ao 15
0D
10s ansi-reset
0C
0Ao 6
0D
1Ai 0
04i 3
01
} #@[documentation: "Wrap ARGS in black" source: ["Wrap ARGS in black" [ansi-wrap 0 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 0
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in dark red" source: ["Wrap ARGS in dark red" [ansi-wrap 1 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 1
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in dark green" source: ["Wrap ARGS in dark green" [ansi-wrap 2 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 2
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in brown" source: ["Wrap ARGS in brown" [ansi-wrap 3 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 3
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in dark blue" source: ["Wrap ARGS in dark blue" [ansi-wrap 4 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 4
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in purple" source: ["Wrap ARGS in purple" [ansi-wrap 5 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 5
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in teal" source: ["Wrap ARGS in teal" [ansi-wrap 6 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 6
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in dark gray" source: ["Wrap ARGS in dark gray" [ansi-wrap 7 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 7
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in gray" source: ["Wrap ARGS in gray" [ansi-wrap 8 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 8
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in red" source: ["Wrap ARGS in red" [ansi-wrap 9 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 9
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in green" source: ["Wrap ARGS in green" [ansi-wrap 10 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 10
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in yellow" source: ["Wrap ARGS in yellow" [ansi-wrap 11 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 11
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in blue" source: ["Wrap ARGS in blue" [ansi-wrap 12 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 12
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in pink" source: ["Wrap ARGS in pink" [ansi-wrap 13 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 13
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in cyan" source: ["Wrap ARGS in cyan" [ansi-wrap 14 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 14
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in white" source: ["Wrap ARGS in white" [ansi-wrap 15 [apply cat args]]]] #{##[]
10s ansi-wrap
02i 15
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [let* [def count 0] [cat [join [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] ""] [or ansi/disabled ansi-fg-reset]]]]] #{##["" [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] #{##[#f]
10s bit-and
02i 1
10s count
25
02i 7
04i 2
0Fs count
0D
10s cat
10s ansi/disabled
0C
0Ao 41
0D
10s array/ref
10s ansi-fg
10s count
2A
0Bo 8
02i 7
09o 10
10s count
02i 8
25
04i 2
0C
0Ao 6
0D
1Ai 0
10s a
04i 2
01
} #f]
15
02i 0
0Es count
0D
10s cat
10s join
10s map
10s split
10s apply
10s cat
10s args
04i 2
1Ai 0
04i 2
23s anonymous
1Ai 1
1Ai 2
1Ai 3
17
04i 2
1Ai 0
04i 2
10s ansi/disabled
0C
0Ao 15
0D
10s ansi-fg-reset
0C
0Ao 6
0D
1Ai 4
04i 2
16
01
} #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [def count 0] [def colored-list [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [bit-xor count 7]]] [or ansi/disabled [array/ref ansi-bg count]] a]]]] [cat [join colored-list ""] [or ansi/disabled ansi-reset]]]] #{##["" [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [bit-xor count 7]]] [or ansi/disabled [array/ref ansi-bg count]] a]]] #{##[#f]
10s bit-and
02i 1
10s count
25
02i 7
04i 2
0Fs count
0D
10s cat
10s ansi/disabled
0C
0Ao 33
0D
10s array/ref
10s ansi-fg
10s bit-xor
10s count
02i 7
04i 2
04i 2
0C
0Ao 6
0D
1Ai 0
10s ansi/disabled
0C
0Ao 25
0D
10s array/ref
10s ansi-bg
10s count
04i 2
0C
0Ao 6
0D
1Ai 0
10s a
04i 3
01
} #f]
02i 0
0Es count
0D
10s map
10s split
10s apply
10s cat
10s args
04i 2
1Ai 0
04i 2
23s anonymous
1Ai 1
1Ai 2
1Ai 3
17
04i 2
0Es colored-list
0D
10s cat
10s join
10s colored-list
1Ai 0
04i 2
10s ansi/disabled
0C
0Ao 15
0D
10s ansi-reset
0C
0Ao 6
0D
1Ai 4
04i 2
01
} [text width] #@[source: [[when-not width [set! width 20]] [print "\r"] [dotimes [i width] [print " "]] [print "\r"] [print text]]] #{##["\r" " "]
10s width
0Bo 7
24
09o 9
02i 20
0Fs width
0D
10s print
1Ai 0
04i 1
0D
15
02i 0
0Es i
0D
24
1B
09o 25
0D
1C
10s print
1Ai 1
04i 1
0D
02i 1
10s i
03
0Fs i
10s i
10s width
1E
0Ao -31
0D
24
16
0D
10s print
1Ai 0
04i 1
0D
10s print
10s text
04i 1
01
}]
1Ai 0
0Es ansi/disabled
0D
1Ai 1
0Es ansi-reset
0D
1Ai 2
0Es ansi-fg-reset
0D
1Ai 3
0Es ansi-bg-reset
0D
10s array/new
1Ai 4
1Ai 5
1Ai 6
1Ai 7
1Ai 8
1Ai 9
1Ai 10
1Ai 11
1Ai 12
1Ai 13
1Ai 14
1Ai 15
1Ai 16
1Ai 17
1Ai 18
1Ai 19
04i 16
0Es ansi-fg
0D
1Ai 1
0Es ansi-reset
0D
10s array/new
1Ai 20
1Ai 21
1Ai 22
1Ai 23
1Ai 24
1Ai 25
1Ai 26
1Ai 27
04i 8
0Es ansi-bg
0D
23s ansi-wrap
1Ai 28
1Ai 29
1Ai 30
17
0Es ansi-wrap
0D
23s ansi-black
23s args
1Ai 31
1Ai 32
17
0Es ansi-black
0D
23s ansi-dark-red
23s args
1Ai 33
1Ai 34
17
0Es ansi-dark-red
0D
23s ansi-dark-green
23s args
1Ai 35
1Ai 36
17
0Es ansi-dark-green
0D
23s ansi-brown
23s args
1Ai 37
1Ai 38
17
0Es ansi-brown
0D
23s ansi-dark-blue
23s args
1Ai 39
1Ai 40
17
0Es ansi-dark-blue
0D
23s ansi-purple
23s args
1Ai 41
1Ai 42
17
0Es ansi-purple
0D
23s ansi-teal
23s args
1Ai 43
1Ai 44
17
0Es ansi-teal
0D
23s ansi-dark-gray
23s args
1Ai 45
1Ai 46
17
0Es ansi-dark-gray
0D
23s ansi-gray
23s args
1Ai 47
1Ai 48
17
0Es ansi-gray
0D
23s ansi-red
23s args
1Ai 49
1Ai 50
17
0Es ansi-red
0D
23s ansi-green
23s args
1Ai 51
1Ai 52
17
0Es ansi-green
0D
23s ansi-yellow
23s args
1Ai 53
1Ai 54
17
0Es ansi-yellow
0D
23s ansi-blue
23s args
1Ai 55
1Ai 56
17
0Es ansi-blue
0D
23s ansi-pink
23s args
1Ai 57
1Ai 58
17
0Es ansi-pink
0D
23s ansi-cyan
23s args
1Ai 59
1Ai 60
17
0Es ansi-cyan
0D
23s ansi-white
23s args
1Ai 61
1Ai 62
17
0Es ansi-white
0D
23s ansi-rainbow
23s args
1Ai 63
1Ai 64
17
0Es ansi-rainbow
0D
23s ansi-rainbow-bg
23s args
1Ai 65
1Ai 66
17
0Es ansi-rainbow-bg
0D
23s reprint-line
1Ai 67
1Ai 68
1Ai 69
17
0Es reprint-line
01
}#{##[:align :right :debug #f :base :width :padding-char " " [s i] #@[source: [[if [< i 0] -1 [do [def char [char-at s i]] [if [and [>= char 48] [<= char 57]] [fmt/find-non-digit-from-right s [- i 1]] i]]]]] #{##[]
10s i
02i 0
1E
0Bo 8
02i -1
09o 68
10s char-at
10s s
10s i
04i 2
0Es char
0D
10s char
02i 48
21
0C
0Bo 11
0D
10s char
02i 57
1F
0Bo 23
10s fmt/find-non-digit-from-right
10s s
10s i
02i 1
26
04i 2
09o 7
10s i
01
} [opts spec] #@[source: [[if [zero? [string/length spec]] opts [case [char-at spec [- [string/length spec] 1]] [[48 49 50 51 52 53 54 55 56 57] [def next-non-digit [fmt/find-non-digit-from-right spec [- [string/length spec] 1]]] [def number [string/cut spec [+ 1 next-non-digit] [string/length spec]]] [tree/set! opts :width [read/single number]] [when [= 48 [char-at number 0]] [tree/set! opts :padding-char "0"]] [fmt/parse-spec opts [string/cut spec 0 [+ 1 next-non-digit]]]] [63 [fmt/parse-spec [tree/set! opts :debug #t] [string/cut spec 0 [- [string/length spec] 1]]]] [88 [fmt/parse-spec [tree/set! opts :base :HEXADECIMAL] [string/cut spec 0 [- [string/length spec] 1]]]] [120 [fmt/parse-spec [tree/set! opts :base :hexadecimal] [string/cut spec 0 [- [string/length spec] 1]]]] [100 [fmt/parse-spec [tree/set! opts :base :decimal] [string/cut spec 0 [- [string/length spec] 1]]]] [111 [fmt/parse-spec [tree/set! opts :base :octal] [string/cut spec 0 [- [string/length spec] 1]]]] [98 [fmt/parse-spec [tree/set! opts :base :binary] [string/cut spec 0 [- [string/length spec] 1]]]] [60 [fmt/parse-spec [tree/set! opts :align :left] [string/cut spec 0 [- [string/length spec] 1]]]] [94 [fmt/parse-spec [tree/set! opts :align :center] [string/cut spec 0 [- [string/length spec] 1]]]] [62 [fmt/parse-spec [tree/set! opts :align :right] [string/cut spec 0 [- [string/length spec] 1]]]] [46 [fmt/parse-spec [tree/set! opts :precision [tree/ref opts :width]] [string/cut spec 0 [- [string/length spec] 1]]]] [otherwise [throw [list :format-error "Unknown form-spec option" spec [current-closure]]]]]]]] #{##[#f :width :padding-char "0" :debug #t :base :HEXADECIMAL :hexadecimal :decimal :octal :binary :align :left :center :right :precision :format-error "Unknown form-spec option"]
10s string/length
10s spec
04i 1
2A
0Bo 10
10s opts
09o 926
15
10s char-at
10s spec
10s string/length
10s spec
04i 1
02i 1
26
04i 2
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
02i 48
20
0C
0Ao 114
0D
10s ΓεnΣym-1
02i 49
20
0C
0Ao 102
0D
10s ΓεnΣym-1
02i 50
20
0C
0Ao 90
0D
10s ΓεnΣym-1
02i 51
20
0C
0Ao 78
0D
10s ΓεnΣym-1
02i 52
20
0C
0Ao 66
0D
10s ΓεnΣym-1
02i 53
20
0C
0Ao 54
0D
10s ΓεnΣym-1
02i 54
20
0C
0Ao 42
0D
10s ΓεnΣym-1
02i 55
20
0C
0Ao 30
0D
10s ΓεnΣym-1
02i 56
20
0C
0Ao 18
0D
10s ΓεnΣym-1
02i 57
20
0C
0Ao 6
0D
1Ai 0
0Bo 155
10s fmt/find-non-digit-from-right
10s spec
10s string/length
10s spec
04i 1
02i 1
26
04i 2
0Es next-non-digit
0D
10s string/cut
10s spec
02i 1
10s next-non-digit
25
10s string/length
10s spec
04i 1
04i 3
0Es number
0D
10s tree/set!
10s opts
1Ai 1
10s read/single
10s number
04i 1
04i 3
0D
02i 48
10s char-at
10s number
02i 0
04i 2
20
0Bo 20
10s tree/set!
10s opts
1Ai 2
1Ai 3
04i 3
09o 4
24
0D
10s fmt/parse-spec
10s opts
10s string/cut
10s spec
02i 0
02i 1
10s next-non-digit
25
04i 3
04i 2
09o 619
10s ΓεnΣym-1
02i 63
20
0Bo 51
10s fmt/parse-spec
10s tree/set!
10s opts
1Ai 4
1Ai 5
04i 3
10s string/cut
10s spec
02i 0
10s string/length
10s spec
04i 1
02i 1
26
04i 3
04i 2
09o 561
10s ΓεnΣym-1
02i 88
20
0Bo 51
10s fmt/parse-spec
10s tree/set!
10s opts
1Ai 6
1Ai 7
04i 3
10s string/cut
10s spec
02i 0
10s string/length
10s spec
04i 1
02i 1
26
04i 3
04i 2
09o 503
10s ΓεnΣym-1
02i 120
20
0Bo 51
10s fmt/parse-spec
10s tree/set!
10s opts
1Ai 6
1Ai 8
04i 3
10s string/cut
10s spec
02i 0
10s string/length
10s spec
04i 1
02i 1
26
04i 3
04i 2
09o 445
10s ΓεnΣym-1
02i 100
20
0Bo 51
10s fmt/parse-spec
10s tree/set!
10s opts
1Ai 6
1Ai 9
04i 3
10s string/cut
10s spec
02i 0
10s string/length
10s spec
04i 1
02i 1
26
04i 3
04i 2
09o 387
10s ΓεnΣym-1
02i 111
20
0Bo 51
10s fmt/parse-spec
10s tree/set!
10s opts
1Ai 6
1Ai 10
04i 3
10s string/cut
10s spec
02i 0
10s string/length
10s spec
04i 1
02i 1
26
04i 3
04i 2
09o 329
10s ΓεnΣym-1
02i 98
20
0Bo 51
10s fmt/parse-spec
10s tree/set!
10s opts
1Ai 6
1Ai 11
04i 3
10s string/cut
10s spec
02i 0
10s string/length
10s spec
04i 1
02i 1
26
04i 3
04i 2
09o 271
10s ΓεnΣym-1
02i 60
20
0Bo 51
10s fmt/parse-spec
10s tree/set!
10s opts
1Ai 12
1Ai 13
04i 3
10s string/cut
10s spec
02i 0
10s string/length
10s spec
04i 1
02i 1
26
04i 3
04i 2
09o 213
10s ΓεnΣym-1
02i 94
20
0Bo 51
10s fmt/parse-spec
10s tree/set!
10s opts
1Ai 12
1Ai 14
04i 3
10s string/cut
10s spec
02i 0
10s string/length
10s spec
04i 1
02i 1
26
04i 3
04i 2
09o 155
10s ΓεnΣym-1
02i 62
20
0Bo 51
10s fmt/parse-spec
10s tree/set!
10s opts
1Ai 12
1Ai 15
04i 3
10s string/cut
10s spec
02i 0
10s string/length
10s spec
04i 1
02i 1
26
04i 3
04i 2
09o 97
10s ΓεnΣym-1
02i 46
20
0Bo 61
10s fmt/parse-spec
10s tree/set!
10s opts
1Ai 16
10s tree/ref
10s opts
1Ai 1
04i 2
04i 3
10s string/cut
10s spec
02i 0
10s string/length
10s spec
04i 1
02i 1
26
04i 3
04i 2
09o 29
10s throw
10s list
1Ai 17
1Ai 18
10s spec
10s current-closure
04i 0
04i 4
04i 1
16
01
} [opts] #@[source: [[if-not [tree/ref opts :debug] opts [tree/set! opts :argument [list string/write [tree/ref opts :argument]]]]]] #{##[:debug :argument]
10s tree/ref
10s opts
1Ai 0
04i 2
0Bo 40
10s tree/set!
10s opts
1Ai 1
10s list
10s string/write
10s tree/ref
10s opts
1Ai 1
04i 2
04i 2
04i 3
09o 7
10s opts
01
} [opts] #@[source: [[case [tree/ref opts :base] [:binary [tree/set! opts :argument [list int->string/binary [tree/ref opts :argument]]]] [:octal [tree/set! opts :argument [list int->string/octal [tree/ref opts :argument]]]] [:decimal [tree/set! opts :argument [list int->string/decimal [tree/ref opts :argument]]]] [:hexadecimal [tree/set! opts :argument [list int->string/hex [tree/ref opts :argument]]]] [:HEXADECIMAL [tree/set! opts :argument [list int->string/HEX [tree/ref opts :argument]]]] [otherwise opts]]]] #{##[:base :binary :argument :octal :decimal :hexadecimal :HEXADECIMAL]
15
10s tree/ref
10s opts
1Ai 0
04i 2
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
1Ai 1
20
0Bo 40
10s tree/set!
10s opts
1Ai 2
10s list
10s int->string/binary
10s tree/ref
10s opts
1Ai 2
04i 2
04i 2
04i 3
09o 195
10s ΓεnΣym-2
1Ai 3
20
0Bo 40
10s tree/set!
10s opts
1Ai 2
10s list
10s int->string/octal
10s tree/ref
10s opts
1Ai 2
04i 2
04i 2
04i 3
09o 148
10s ΓεnΣym-2
1Ai 4
20
0Bo 40
10s tree/set!
10s opts
1Ai 2
10s list
10s int->string/decimal
10s tree/ref
10s opts
1Ai 2
04i 2
04i 2
04i 3
09o 101
10s ΓεnΣym-2
1Ai 5
20
0Bo 40
10s tree/set!
10s opts
1Ai 2
10s list
10s int->string/hex
10s tree/ref
10s opts
1Ai 2
04i 2
04i 2
04i 3
09o 54
10s ΓεnΣym-2
1Ai 6
20
0Bo 40
10s tree/set!
10s opts
1Ai 2
10s list
10s int->string/HEX
10s tree/ref
10s opts
1Ai 2
04i 2
04i 2
04i 3
09o 7
10s opts
16
01
} :binary "#b" :octal "#o" :decimal "#d" :hexadecimal "#x" :HEXADECIMAL [opts] #@[source: [[if [or [not [tree/ref opts :debug]] [not [tree/ref opts :base]]] opts [-> [if [member '[:binary :octal :decimal :hexadecimal :HEXADECIMAL] [tree/ref opts :base]] [tree/set! opts :argument [list cat [tree/ref fmt/number-format-prefixex [tree/ref opts :base]] [tree/ref opts :argument]]] opts] [tree/set! :debug #f]]]]] #{##[:debug #f #t :base [:binary :octal :decimal :hexadecimal :HEXADECIMAL] :argument]
10s tree/ref
10s opts
1Ai 0
04i 2
0Bo 8
1Ai 1
09o 5
1Ai 2
0C
0Ao 33
0D
10s tree/ref
10s opts
1Ai 3
04i 2
0Bo 8
1Ai 1
09o 5
1Ai 2
0C
0Ao 6
0D
1Ai 1
0Bo 10
10s opts
09o 99
10s tree/set!
10s member
1Ai 4
10s tree/ref
10s opts
1Ai 3
04i 2
04i 2
0Bo 62
10s tree/set!
10s opts
1Ai 5
10s list
10s cat
10s tree/ref
10s fmt/number-format-prefixex
10s tree/ref
10s opts
1Ai 3
04i 2
04i 2
10s tree/ref
10s opts
1Ai 5
04i 2
04i 3
04i 3
09o 7
10s opts
1Ai 0
1Ai 1
04i 3
01
} [opts] #@[source: [[if-not [tree/ref opts :width] opts [tree/set! opts :argument [list [case [tree/ref opts :align] [:right string/pad-start] [:center string/pad-middle] [:left string/pad-end]] [tree/ref opts :argument] [if [and [tree/ref opts :debug] [tree/ref opts :base]] [- [tree/ref opts :width] 2] [tree/ref opts :width]] [tree/ref opts :padding-char]]]]]] #{##[:width :argument :align :right :center :left :debug :base :padding-char]
10s tree/ref
10s opts
1Ai 0
04i 2
0Bo 181
10s tree/set!
10s opts
1Ai 1
10s list
15
10s tree/ref
10s opts
1Ai 2
04i 2
0Es ΓεnΣym-3
0D
10s ΓεnΣym-3
1Ai 3
20
0Bo 10
10s string/pad-start
09o 38
10s ΓεnΣym-3
1Ai 4
20
0Bo 10
10s string/pad-middle
09o 21
10s ΓεnΣym-3
1Ai 5
20
0Bo 10
10s string/pad-end
09o 4
24
16
10s tree/ref
10s opts
1Ai 1
04i 2
10s tree/ref
10s opts
1Ai 6
04i 2
0C
0Bo 16
0D
10s tree/ref
10s opts
1Ai 7
04i 2
0Bo 21
10s tree/ref
10s opts
1Ai 0
04i 2
02i 2
26
09o 15
10s tree/ref
10s opts
1Ai 0
04i 2
10s tree/ref
10s opts
1Ai 8
04i 2
04i 4
04i 3
09o 7
10s opts
01
} [opts] #@[source: [[if-not [tree/ref opts :precision] opts [tree/set! opts :argument [list string/round [tree/ref opts :argument] [tree/ref opts :precision]]]]]] #{##[:precision :argument]
10s tree/ref
10s opts
1Ai 0
04i 2
0Bo 52
10s tree/set!
10s opts
1Ai 1
10s list
10s string/round
10s tree/ref
10s opts
1Ai 1
04i 2
10s tree/ref
10s opts
1Ai 0
04i 2
04i 3
04i 3
09o 7
10s opts
01
} [opts] #@[source: [[if-not [tree/ref opts :width] opts [tree/set! opts :argument [list string/cut [tree/ref opts :argument] 0 [+ 1 [tree/ref opts :width]]]]]]] #{##[:width :argument]
10s tree/ref
10s opts
1Ai 0
04i 2
0Bo 57
10s tree/set!
10s opts
1Ai 1
10s list
10s string/cut
10s tree/ref
10s opts
1Ai 1
04i 2
02i 0
02i 1
10s tree/ref
10s opts
1Ai 0
04i 2
25
04i 4
04i 3
09o 7
10s opts
01
} [opts] #@[source: [[tree/ref opts :argument]]] #{##[:argument]
10s tree/ref
10s opts
1Ai 0
04i 2
01
} [spec argument] #@[source: [[-> [tree/set! [fmt/parse-spec [tree/dup fmt/format-arg/default] spec] :argument argument] fmt/number-format fmt/precision fmt/add-padding fmt/truncate fmt/number-format-prefix fmt/debug fmt/output]]] #{##[:argument]
10s fmt/output
10s fmt/debug
10s fmt/number-format-prefix
10s fmt/truncate
10s fmt/add-padding
10s fmt/precision
10s fmt/number-format
10s tree/set!
10s fmt/parse-spec
10s tree/dup
10s fmt/format-arg/default
04i 1
10s spec
04i 2
1Ai 0
10s argument
04i 3
04i 1
04i 1
04i 1
04i 1
04i 1
04i 1
04i 1
01
} [argument] #@[source: [[or [int? argument] [symbol? argument]]]] #{##[#f]
10s int?
10s argument
04i 1
0C
0Ao 21
0D
10s symbol?
10s argument
04i 1
0C
0Ao 6
0D
1Ai 0
01
} [v] #@[source: [[case [type-of v] [:int [fmt/arg-sym [cat "fmt-arg-" [string v]]]] [:symbol v] [:string [string->symbol v]] [otherwise [throw [list :type-error "Invalid fmt argument name" v [current-lambda]]]]]]] #{##[:int "fmt-arg-" :symbol :string :type-error "Invalid fmt argument name"]
15
10s type-of
10s v
04i 1
0Es ΓεnΣym-4
0D
10s ΓεnΣym-4
1Ai 0
20
0Bo 30
10s fmt/arg-sym
10s cat
1Ai 1
10s string
10s v
04i 1
04i 2
04i 1
09o 69
10s ΓεnΣym-4
1Ai 2
20
0Bo 10
10s v
09o 52
10s ΓεnΣym-4
1Ai 3
20
0Bo 16
10s string->symbol
10s v
04i 1
09o 29
10s throw
10s list
1Ai 4
1Ai 5
10s v
10s current-lambda
04i 0
04i 4
04i 1
16
01
} [expr arguments-used opts] #@[source: [[when-not [string? expr] [throw [list :format-error "fmt needs a string literal as a first argument, since it is implemented as a macro" expr [current-lambda]]]] [def split-expr [split expr ":"]] [def argument [car split-expr]] [def format-spec [or [cadr split-expr] ""]] [if [= "" argument] [do [tree/-- opts :expr-count] [array/set! arguments-used [tree/ref opts :expr-count] #t] [fmt/format-arg format-spec [fmt/arg-sym [tree/ref opts :expr-count]]]] [let [[read-vals [read argument]]] [when [cdr read-vals] [throw [list :format-error "Format argument specifier contains more than a single atom" argument [current-lambda]]]] [when-not [fmt/valid-argument? [car read-vals]] [throw [list :format-error "Format argument specifier should be either an integer or a symbol" argument [current-lambda]]]] [when [int? [car read-vals]] [when [or [< [car read-vals] 0] [>= [car read-vals] [array/length arguments-used]]] [throw [list :format-error "fmt numbered argument is out of bounds" argument [current-lambda]]]] [array/set! arguments-used [car read-vals] #t]] [fmt/format-arg format-spec [fmt/arg-sym [car read-vals]]]]]]] #{##[:format-error "fmt needs a string literal as a first argument, since it is implemented as a macro" ":" "" #f :expr-count #t "Format argument specifier contains more than a single atom" "Format argument specifier should be either an integer or a symbol" "fmt numbered argument is out of bounds"]
10s string?
10s expr
04i 1
0Bo 7
24
09o 29
10s throw
10s list
1Ai 0
1Ai 1
10s expr
10s current-lambda
04i 0
04i 4
04i 1
0D
10s split
10s expr
1Ai 2
04i 2
0Es split-expr
0D
10s split-expr
11
0Es argument
0D
10s split-expr
12
11
0C
0Ao 13
0D
1Ai 3
0C
0Ao 6
0D
1Ai 4
0Es format-spec
0D
1Ai 3
10s argument
20
0Bo 74
10s tree/+=
10s opts
1Ai 5
02i -1
04i 3
0D
10s array/set!
10s arguments-used
10s tree/ref
10s opts
1Ai 5
04i 2
1Ai 6
04i 3
0D
10s fmt/format-arg
10s format-spec
10s fmt/arg-sym
10s tree/ref
10s opts
1Ai 5
04i 2
04i 1
04i 2
09o 231
15
10s read
10s argument
04i 1
0Es read-vals
0D
10s read-vals
12
0Bo 32
10s throw
10s list
1Ai 0
1Ai 7
10s argument
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s fmt/valid-argument?
10s read-vals
11
04i 1
0Bo 7
24
09o 29
10s throw
10s list
1Ai 0
1Ai 8
10s argument
10s current-lambda
04i 0
04i 4
04i 1
0D
10s int?
10s read-vals
11
04i 1
0Bo 93
10s read-vals
11
02i 0
1E
0C
0Ao 27
0D
10s read-vals
11
10s array/length
10s arguments-used
04i 1
21
0C
0Ao 6
0D
1Ai 4
0Bo 32
10s throw
10s list
1Ai 0
1Ai 9
10s argument
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s array/set!
10s arguments-used
10s read-vals
11
1Ai 6
04i 3
09o 4
24
0D
10s fmt/format-arg
10s format-spec
10s fmt/arg-sym
10s read-vals
11
04i 1
04i 2
16
01
} [format-string . args] #@[documentation: "Return a formatted string" source: ["Return a formatted string" [when-not [string? format-string] [throw [list :type-error "fmt needs a string literal as a first argument, since it is implemented as a macro" format-string [current-lambda]]]] [def cuts #nil] [dotimes [i [string/length format-string]] [case [char-at format-string i] [123 [do [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]] [set! cuts [cons i cuts]]]] [125 [do [when-not [int? [car cuts]] [throw [list :format-error "fmt expects all brackets to be closed" format-string [current-lambda]]]] [set! cuts [cons [cons [car cuts] i] [cdr cuts]]]]]]] [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]] [def expr-list #nil] [def last-pos [string/length format-string]] [def arguments-used [-> [array/allocate [length args]] [array/fill! #f]]] [def opts [tree/new :expr-count [array/length arguments-used]]] [doseq [c cuts] [def lit [string/cut format-string [+ [cdr c] 1] last-pos]] [when-not [= "" lit] [set! expr-list [cons lit expr-list]]] [def expr [fmt/expr [string/cut format-string [+ 1 [car c]] [cdr c]] arguments-used opts]] [set! expr-list [cons expr expr-list]] [set! last-pos [car c]]] [when [> last-pos 0] [def lit [string/cut format-string 0 last-pos]] [set! expr-list [cons lit expr-list]]] [dotimes [i [array/length arguments-used]] [when-not [array/ref arguments-used i] [throw [list :format-error "fmt expects all arguments to be used" [list format-string [list/ref args i]] [current-lambda]]]]] [def expr [if [cdr expr-list] [cons 'cat expr-list] [if [string? [car expr-list]] [car expr-list] [cons 'string expr-list]]]] [def fmt/args/map-fun/count 0] [defn fmt/args/map-fun [arg] [def s [string->symbol [cat "fmt-arg-" [string fmt/args/map-fun/count]]]] [inc! fmt/args/map-fun/count] [list 'def s arg]] [if args [quasiquote [let* [unquote-splicing [map args fmt/args/map-fun]] [unquote expr]]] expr]]] #{##[:type-error "fmt needs a string literal as a first argument, since it is implemented as a macro" :format-error "fmt placeholders can't be nested" "fmt expects all brackets to be closed" #f :expr-count "" "fmt expects all arguments to be used" [arg] #@[source: [[def s [string->symbol [cat "fmt-arg-" [string fmt/args/map-fun/count]]]] [inc! fmt/args/map-fun/count] [list 'def s arg]]] #{##["fmt-arg-"]
10s string->symbol
10s cat
1Ai 0
10s string
10s fmt/args/map-fun/count
04i 1
04i 2
04i 1
0Es s
0D
10s fmt/args/map-fun/count
02i 1
25
0Fs fmt/args/map-fun/count
0D
10s list
23s def
10s s
10s arg
04i 3
01
}]
10s string?
10s format-string
04i 1
0Bo 7
24
09o 29
10s throw
10s list
1Ai 0
1Ai 1
10s format-string
10s current-lambda
04i 0
04i 4
04i 1
0D
24
0Es cuts
0D
15
02i 0
0Es i
0D
24
1B
09o 188
0D
1C
15
10s char-at
10s format-string
10s i
04i 2
0Es ΓεnΣym-5
0D
10s ΓεnΣym-5
02i 123
20
0Bo 64
10s int?
10s cuts
11
04i 1
0Bo 32
10s throw
10s list
1Ai 2
1Ai 3
10s format-string
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s i
10s cuts
14
0Fs cuts
09o 82
10s ΓεnΣym-5
02i 125
20
0Bo 71
10s int?
10s cuts
11
04i 1
0Bo 7
24
09o 29
10s throw
10s list
1Ai 2
1Ai 4
10s format-string
10s current-lambda
04i 0
04i 4
04i 1
0D
10s cuts
11
10s i
14
10s cuts
12
14
0Fs cuts
09o 4
24
16
0D
02i 1
10s i
03
0Fs i
10s i
10s string/length
10s format-string
04i 1
1E
0Ao -200
0D
24
16
0D
10s int?
10s cuts
11
04i 1
0Bo 32
10s throw
10s list
1Ai 2
1Ai 3
10s format-string
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
24
0Es expr-list
0D
10s string/length
10s format-string
04i 1
0Es last-pos
0D
10s array/fill!
10s array/allocate
10s length
10s args
04i 1
04i 1
1Ai 5
04i 2
0Es arguments-used
0D
10s tree/new
1Ai 6
10s array/length
10s arguments-used
04i 1
04i 2
0Es opts
0D
15
10s cuts
0Es ΓεnΣym-6
0D
10s ΓεnΣym-6
0Bo 160
24
1B
09o 145
0D
1C
10s ΓεnΣym-6
11
0Es c
0D
10s string/cut
10s format-string
10s c
12
02i 1
25
10s last-pos
04i 3
0Es lit
0D
1Ai 7
10s lit
20
0Bo 7
24
09o 16
10s lit
10s expr-list
14
0Fs expr-list
0D
10s fmt/expr
10s string/cut
10s format-string
02i 1
10s c
11
25
10s c
12
04i 3
10s arguments-used
10s opts
04i 3
0Es expr
0D
10s expr
10s expr-list
14
0Fs expr-list
0D
10s c
11
0Fs last-pos
0D
10s ΓεnΣym-6
12
0Fs ΓεnΣym-6
10s ΓεnΣym-6
0Ao -146
09o 4
24
16
0D
10s last-pos
02i 0
22
0Bo 40
10s string/cut
10s format-string
02i 0
10s last-pos
04i 3
0Es lit
0D
10s lit
10s expr-list
14
0Fs expr-list
09o 4
24
0D
15
02i 0
0Es i
0D
24
1B
09o 84
0D
1C
10s array/ref
10s arguments-used
10s i
04i 2
0Bo 7
24
09o 49
10s throw
10s list
1Ai 2
1Ai 8
10s list
10s format-string
10s list/ref
10s args
10s i
04i 2
04i 2
10s current-lambda
04i 0
04i 4
04i 1
0D
02i 1
10s i
03
0Fs i
10s i
10s array/length
10s arguments-used
04i 1
1E
0Ao -96
0D
24
16
0D
10s expr-list
12
0Bo 15
23s cat
10s expr-list
14
09o 34
10s string?
10s expr-list
11
04i 1
0Bo 11
10s expr-list
11
09o 12
23s string
10s expr-list
14
0Es expr
0D
02i 0
0Es fmt/args/map-fun/count
0D
23s fmt/args/map-fun
1Ai 9
1Ai 10
1Ai 11
17
0Es fmt/args/map-fun
0D
10s args
0Bo 37
23s let*
10s append
10s map
10s args
10s fmt/args/map-fun
04i 2
10s expr
24
14
04i 2
14
09o 7
10s expr
01
} [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [print [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[]
23s print
23s fmt
10s format-string
10s append
10s args
24
04i 2
14
14
24
14
14
01
} [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [error [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[]
23s error
23s fmt
10s format-string
10s append
10s args
24
04i 2
14
14
24
14
14
01
} [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [println [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[]
23s println
23s fmt
10s format-string
10s append
10s args
24
04i 2
14
14
24
14
14
01
} [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [errorln [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[]
23s errorln
23s fmt
10s format-string
10s append
10s args
24
04i 2
14
14
24
14
14
01
}]
10s tree/new
1Ai 0
1Ai 1
1Ai 2
1Ai 3
1Ai 4
1Ai 3
1Ai 5
24
1Ai 6
1Ai 7
04i 10
0Es fmt/format-arg/default
0D
23s fmt/find-non-digit-from-right
1Ai 8
1Ai 9
1Ai 10
17
0Es fmt/find-non-digit-from-right
0D
23s fmt/parse-spec
1Ai 11
1Ai 12
1Ai 13
17
0Es fmt/parse-spec
0D
23s fmt/debug
1Ai 14
1Ai 15
1Ai 16
17
0Es fmt/debug
0D
23s fmt/number-format
1Ai 17
1Ai 18
1Ai 19
17
0Es fmt/number-format
0D
10s tree/new
1Ai 20
1Ai 21
1Ai 22
1Ai 23
1Ai 24
1Ai 25
1Ai 26
1Ai 27
1Ai 28
1Ai 27
04i 10
0Es fmt/number-format-prefixex
0D
23s fmt/number-format-prefix
1Ai 29
1Ai 30
1Ai 31
17
0Es fmt/number-format-prefix
0D
23s fmt/add-padding
1Ai 32
1Ai 33
1Ai 34
17
0Es fmt/add-padding
0D
23s fmt/precision
1Ai 35
1Ai 36
1Ai 37
17
0Es fmt/precision
0D
23s fmt/truncate
1Ai 38
1Ai 39
1Ai 40
17
0Es fmt/truncate
0D
23s fmt/output
1Ai 41
1Ai 42
1Ai 43
17
0Es fmt/output
0D
23s fmt/format-arg
1Ai 44
1Ai 45
1Ai 46
17
0Es fmt/format-arg
0D
23s fmt/valid-argument?
1Ai 47
1Ai 48
1Ai 49
17
0Es fmt/valid-argument?
0D
23s fmt/arg-sym
1Ai 50
1Ai 51
1Ai 52
17
0Es fmt/arg-sym
0D
23s fmt/expr
1Ai 53
1Ai 54
1Ai 55
17
0Es fmt/expr
0D
23s fmt
1Ai 56
1Ai 57
1Ai 58
18
0Es fmt
0D
23s pfmt
1Ai 59
1Ai 60
1Ai 61
18
0Es pfmt
0D
23s efmt
1Ai 62
1Ai 63
1Ai 64
18
0Es efmt
0D
23s pfmtln
1Ai 65
1Ai 66
1Ai 67
18
0Es pfmtln
0D
23s efmtln
1Ai 68
1Ai 69
1Ai 70
18
0Es efmtln
01
}#{##[[α] #@[documentation: "Return string α as a keyword" source: [:inline "Return string α as a keyword" [symbol->keyword [string->symbol α]]] inline: #t] #{##[]
10s symbol->keyword
10s string->symbol
10s α
04i 1
04i 1
01
} [a] #@[documentation: "Turn a string into an UTF-8 encoded byte array" source: ["Turn a string into an UTF-8 encoded byte array" [def ret [array/allocate [string/length a]]] [dotimes [i [string/length a]] [array/set! ret i [char-at a i]]] ret]] #{##[]
10s array/allocate
10s string/length
10s a
04i 1
04i 1
0Es ret
0D
15
02i 0
0Es i
0D
24
1B
09o 45
0D
1C
10s array/set!
10s ret
10s i
10s char-at
10s a
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
10s i
10s string/length
10s a
04i 1
1E
0Ao -57
0D
24
16
0D
10s ret
01
} [str] #@[documentation: "Print STR on a single line" source: ["Print STR on a single line" [print [cat str "\r\n"]]]] #{##["\r\n"]
10s print
10s cat
10s str
1Ai 0
04i 2
04i 1
01
} [str] #@[documentation: "Print to stderr STR on a single line" source: ["Print to stderr STR on a single line" [error [cat str "\r\n"]]]] #{##["\r\n"]
10s error
10s cat
10s str
1Ai 0
04i 2
04i 1
01
} [value] #@[documentation: "Display VALUE" source: [:inline "Display VALUE" [print value]] inline: #t] #{##[]
10s print
10s value
04i 1
01
} [] #@[documentation: "Print a single line feed character" source: ["Print a single line feed character" [print "\r\n"]]] #{##["\r\n"]
10s print
1Ai 0
04i 1
01
} [num] #@[documentation: "Return NUM=1 linebreaks" source: ["Return NUM=1 linebreaks" [if [or [nil? num] [<= [int num] 1]] "\n" [cat "\n" [br [+ -1 num]]]]]] #{##[#f "\n"]
10s nil?
10s num
04i 1
0C
0Ao 24
0D
10s int
10s num
04i 1
02i 1
1F
0C
0Ao 6
0D
1Ai 0
0Bo 8
1Ai 1
09o 24
10s cat
1Ai 1
10s br
02i -1
10s num
25
04i 1
04i 2
01
} [ext] #@[documentation: "Return a predicate that checks if a path ends on EXT" source: ["Return a predicate that checks if a path ends on EXT" [case [type-of ext] [:string [fn [path] [= ext [lowercase [path/extension path]]]]] [:pair [fn [path] [def cext [lowercase [path/extension path]]] [reduce ext [fn [α β] [or α [= β cext]]]]]] [otherwise [throw [list :type-error "Expected a :string or :list" ext]]]]]] #{##[:string [path] #@[source: [[= ext [lowercase [path/extension path]]]]] #{##[]
10s ext
10s lowercase
10s path/extension
10s path
04i 1
04i 1
20
01
} :pair [path] #@[source: [[def cext [lowercase [path/extension path]]] [reduce ext [fn [α β] [or α [= β cext]]]]]] #{##[[α β] #@[source: [[or α [= β cext]]]] #{##[#f]
10s α
0C
0Ao 20
0D
10s β
10s cext
20
0C
0Ao 6
0D
1Ai 0
01
}]
10s lowercase
10s path/extension
10s path
04i 1
04i 1
0Es cext
0D
10s reduce
10s ext
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
04i 2
01
} :type-error "Expected a :string or :list"]
15
10s type-of
10s ext
04i 1
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
1Ai 0
20
0Bo 17
23s anonymous
1Ai 1
1Ai 2
1Ai 3
17
09o 47
10s ΓεnΣym-1
1Ai 4
20
0Bo 17
23s anonymous
1Ai 5
1Ai 6
1Ai 7
17
09o 23
10s throw
10s list
1Ai 8
1Ai 9
10s ext
04i 3
04i 1
16
01
} [path] #@[documentation: "Return the extension of PATH" source: ["Return the extension of PATH" [def last-period [last-index-of path "."]] [if [>= last-period 0] [string/cut path [+ 1 last-period] [string/length path]] path]]] #{##["."]
10s last-index-of
10s path
1Ai 0
04i 2
0Es last-period
0D
10s last-period
02i 0
21
0Bo 33
10s string/cut
10s path
02i 1
10s last-period
25
10s string/length
10s path
04i 1
04i 3
09o 7
10s path
01
} [path] #@[documentation: "Return PATH, but without the extension part" source: ["Return PATH, but without the extension part" [def last-period [last-index-of path "."]] [if [>= last-period 0] [string/cut path 0 last-period] path]]] #{##["."]
10s last-index-of
10s path
1Ai 0
04i 2
0Es last-period
0D
10s last-period
02i 0
21
0Bo 22
10s string/cut
10s path
02i 0
10s last-period
04i 3
09o 7
10s path
01
} [α] #@[documentation: "Turn α into a its **binary** string representation" source: ["Turn α into a its **binary** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [while [not-zero? α] [set! ret [cat [from-char-code [+ 48 [bit-and α 1]]] ret]] [set! α [bit-shift-right α 1]]] ret]] #{##["" "0"]
1Ai 0
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
10s α
2A
0Bo 12
1Ai 1
0Fs ret
09o 4
24
0D
24
1B
09o 57
0D
1C
10s cat
10s from-char-code
02i 48
10s bit-and
10s α
02i 1
04i 2
25
04i 1
10s ret
04i 2
0Fs ret
0D
10s bit-shift-right
10s α
02i 1
04i 2
0Fs α
10s not=
02i 0
10s α
04i 2
0Ao -66
0D
10s ret
01
} [α] #@[documentation: "Turn α into a its **octal** string representation" source: ["Turn α into a its **octal** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [while [not-zero? α] [set! ret [cat [from-char-code [+ 48 [bit-and α 7]]] ret]] [set! α [bit-shift-right α 3]]] ret]] #{##["" "0"]
1Ai 0
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
10s α
2A
0Bo 12
1Ai 1
0Fs ret
09o 4
24
0D
24
1B
09o 57
0D
1C
10s cat
10s from-char-code
02i 48
10s bit-and
10s α
02i 7
04i 2
25
04i 1
10s ret
04i 2
0Fs ret
0D
10s bit-shift-right
10s α
02i 3
04i 2
0Fs α
10s not=
02i 0
10s α
04i 2
0Ao -66
0D
10s ret
01
} "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" [α] #@[documentation: "Turn α into a its **hexadecimal** string representation" source: ["Turn α into a its **hexadecimal** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [when [< α 0] [throw [list :type-error "Can't print negative numbers in hex for now" α [current-lambda]]]] [while [not-zero? α] [set! ret [cat [array/ref int->string/hex/conversion-arr [bit-and α 15]] ret]] [set! α [bit-shift-right α 4]]] ret]] #{##["" "0" :type-error "Can't print negative numbers in hex for now"]
1Ai 0
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
10s α
2A
0Bo 12
1Ai 1
0Fs ret
09o 4
24
0D
10s α
02i 0
1E
0Bo 32
10s throw
10s list
1Ai 2
1Ai 3
10s α
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
24
1B
09o 58
0D
1C
10s cat
10s array/ref
10s int->string/hex/conversion-arr
10s bit-and
10s α
02i 15
04i 2
04i 2
10s ret
04i 2
0Fs ret
0D
10s bit-shift-right
10s α
02i 4
04i 2
0Fs α
10s not=
02i 0
10s α
04i 2
0Ao -67
0D
10s ret
01
} [α] #@[documentation: "Turn α into a its **hexadecimal** string representation" source: ["Turn α into a its **hexadecimal** string representation" [lowercase [int->string/HEX α]]]] #{##[]
10s lowercase
10s int->string/HEX
10s α
04i 1
04i 1
01
} [α] #@[documentation: "Turn α into a its **decimal** string representation" source: ["Turn α into a its **decimal** string representation" [string α]]] #{##[]
10s string
10s α
04i 1
01
} [text goal-length char] #@[documentation: "Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat char text]]] [if [> [string/length text] goal-length] [string/cut text [- [string/length text] goal-length] [string/length text]] text]]] #{##[" " :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters"]
10s char
0Bo 7
24
09o 9
1Ai 0
0Fs char
0D
10s string?
10s text
04i 1
0Bo 7
24
09o 17
10s string
10s text
04i 1
0Fs text
0D
10s string?
10s char
04i 1
0Bo 7
24
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s char
10s current-lambda
04i 0
04i 4
04i 1
0D
24
1B
09o 23
0D
1C
10s cat
10s char
10s text
04i 2
0Fs text
10s string/length
10s text
04i 1
10s goal-length
1E
0Ao -35
0D
10s string/length
10s text
04i 1
10s goal-length
22
0Bo 41
10s string/cut
10s text
10s string/length
10s text
04i 1
10s goal-length
26
10s string/length
10s text
04i 1
04i 3
09o 7
10s text
01
} [text goal-length char] #@[documentation: "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat text char]]] [if [> [string/length text] goal-length] [string/cut text 0 goal-length] text]]] #{##[" " :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters"]
10s char
0Bo 7
24
09o 9
1Ai 0
0Fs char
0D
10s string?
10s text
04i 1
0Bo 7
24
09o 17
10s string
10s text
04i 1
0Fs text
0D
10s string?
10s char
04i 1
0Bo 7
24
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s char
10s current-lambda
04i 0
04i 4
04i 1
0D
24
1B
09o 23
0D
1C
10s cat
10s text
10s char
04i 2
0Fs text
10s string/length
10s text
04i 1
10s goal-length
1E
0Ao -35
0D
10s string/length
10s text
04i 1
10s goal-length
22
0Bo 22
10s string/cut
10s text
02i 0
10s goal-length
04i 3
09o 7
10s text
01
} [text goal-length char] #@[documentation: "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-middle needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat char text char]]] [if [> [string/length text] goal-length] [let [[end-overflow [/ [- [string/length text] goal-length] 2]] [start-overflow [- [- [string/length text] goal-length] end-overflow]]] [string/cut text start-overflow [+ start-overflow goal-length]]] text]]] #{##[" " :type-error "string/pad-middle needs char as a string, so that one can pad with multiple characters"]
10s char
0Bo 7
24
09o 9
1Ai 0
0Fs char
0D
10s string?
10s text
04i 1
0Bo 7
24
09o 17
10s string
10s text
04i 1
0Fs text
0D
10s string?
10s char
04i 1
0Bo 7
24
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s char
10s current-lambda
04i 0
04i 4
04i 1
0D
24
1B
09o 27
0D
1C
10s cat
10s char
10s text
10s char
04i 3
0Fs text
10s string/length
10s text
04i 1
10s goal-length
1E
0Ao -39
0D
10s string/length
10s text
04i 1
10s goal-length
22
0Bo 79
15
10s string/length
10s text
04i 1
10s goal-length
26
02i 2
28
0Es end-overflow
0D
10s string/length
10s text
04i 1
10s goal-length
26
10s end-overflow
26
0Es start-overflow
0D
10s string/cut
10s text
10s start-overflow
10s start-overflow
10s goal-length
25
04i 3
16
09o 7
10s text
01
} [text decimal-digits] #@[documentation: "Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" source: ["Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" [def pos [last-index-of text "."]] [if [>= pos 0] [string/cut text 0 [+ pos 1 decimal-digits]] text]]] #{##["."]
10s last-index-of
10s text
1Ai 0
04i 2
0Es pos
0D
10s pos
02i 0
21
0Bo 30
10s string/cut
10s text
02i 0
10s pos
02i 1
25
10s decimal-digits
25
04i 3
09o 7
10s text
01
} [str separator] #@[source: [[def slen [string/length str]] [def start 0] [def ret #nil] [while [< start slen] [set! ret [cons [string/cut str start [+ 1 start]] ret]] [inc! start]] [reverse ret]]] #{##[]
10s string/length
10s str
04i 1
0Es slen
0D
02i 0
0Es start
0D
24
0Es ret
0D
24
1B
09o 47
0D
1C
10s string/cut
10s str
10s start
02i 1
10s start
25
04i 3
10s ret
14
0Fs ret
0D
10s start
02i 1
25
0Fs start
10s start
10s slen
1E
0Ao -53
0D
10s reverse
10s ret
04i 1
01
} [str separator start] #@[source: [[when-not start [set! start 0]] [def pos-found [index-of str separator start]] [if [>= pos-found 0] [cons [string/cut str start pos-found] [split/string str separator [+ pos-found [string/length separator]]]] [cons [string/cut str start [string/length str]] #nil]]]] #{##[]
10s start
0Bo 7
24
09o 9
02i 0
0Fs start
0D
10s index-of
10s str
10s separator
10s start
04i 3
0Es pos-found
0D
10s pos-found
02i 0
21
0Bo 54
10s string/cut
10s str
10s start
10s pos-found
04i 3
10s split/string
10s str
10s separator
10s pos-found
10s string/length
10s separator
04i 1
25
04i 3
14
09o 29
10s string/cut
10s str
10s start
10s string/length
10s str
04i 1
04i 3
24
14
01
} [str separator] #@[documentation: "Splits STR into a list at every occurunse of SEPARATOR" source: ["Splits STR into a list at every occurunse of SEPARATOR" [typecheck/only str :string] [typecheck/only separator :string] [case [string/length separator] [0 [split/empty str]] [otherwise [split/string str separator 0]]]]] #{##[:string :type-error "Expected a value of type :string"]
10s type-of
10s str
04i 1
1Ai 0
20
0Bo 7
24
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s str
10s current-lambda
04i 0
04i 4
04i 1
0D
10s type-of
10s separator
04i 1
1Ai 0
20
0Bo 7
24
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s separator
10s current-lambda
04i 0
04i 4
04i 1
0D
15
10s string/length
10s separator
04i 1
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
02i 0
20
0Bo 16
10s split/empty
10s str
04i 1
09o 19
10s split/string
10s str
10s separator
02i 0
04i 3
16
01
} [text] #@[documentation: "Uses the reader and returns the first single value read from string TEXT" source: ["Uses the reader and returns the first single value read from string TEXT" [typecheck/only text :string] [car [read text]]]] #{##[:string :type-error "Expected a value of type :string"]
10s type-of
10s text
04i 1
1Ai 0
20
0Bo 7
24
09o 29
10s throw
10s list
1Ai 1
1Ai 2
10s text
10s current-lambda
04i 0
04i 4
04i 1
0D
10s read
10s text
04i 1
11
01
} [text] #@[documentation: "Reads the first string from TEXT" source: ["Reads the first string from TEXT" [int [read/single text]]]] #{##[]
10s int
10s read/single
10s text
04i 1
04i 1
01
} [text] #@[documentation: "Reads the first float from TEXT" source: ["Reads the first float from TEXT" [float [read/single text]]]] #{##[]
10s float
10s read/single
10s text
04i 1
04i 1
01
} [chars] #@[source: [[fn [a] [= chars [string/length a]]]]] #{##[[a] #@[source: [[= chars [string/length a]]]] #{##[]
10s chars
10s string/length
10s a
04i 1
20
01
}]
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
01
} [str chars] #@[source: [[apply or [map [split chars ""] [fn [a] [>= [index-of str a] 0]]]]]] #{##["" [a] #@[source: [[>= [index-of str a] 0]]] #{##[]
10s index-of
10s str
10s a
04i 2
02i 0
21
01
}]
10s apply
10s or
10s map
10s split
10s chars
1Ai 0
04i 2
23s anonymous
1Ai 1
1Ai 2
1Ai 3
17
04i 2
04i 2
01
} [str chars] #@[source: [[apply and [map [split chars ""] [fn [a] [>= [index-of str a] 0]]]]]] #{##["" [a] #@[source: [[>= [index-of str a] 0]]] #{##[]
10s index-of
10s str
10s a
04i 2
02i 0
21
01
}]
10s apply
10s and
10s map
10s split
10s chars
1Ai 0
04i 2
23s anonymous
1Ai 1
1Ai 2
1Ai 3
17
04i 2
04i 2
01
}]
23s string->keyword
1Ai 0
1Ai 1
1Ai 2
17
0Es string->keyword
0D
23s string->byte-array
1Ai 3
1Ai 4
1Ai 5
17
0Es string->byte-array
0D
23s println
1Ai 6
1Ai 7
1Ai 8
17
0Es println
0D
23s errorln
1Ai 9
1Ai 10
1Ai 11
17
0Es errorln
0D
23s display
1Ai 12
1Ai 13
1Ai 14
17
0Es display
0D
23s newline
1Ai 15
1Ai 16
1Ai 17
17
0Es newline
0D
23s br
1Ai 18
1Ai 19
1Ai 20
17
0Es br
0D
23s path/ext?!
1Ai 21
1Ai 22
1Ai 23
17
0Es path/ext?!
0D
23s path/extension
1Ai 24
1Ai 25
1Ai 26
17
0Es path/extension
0D
23s path/without-extension
1Ai 27
1Ai 28
1Ai 29
17
0Es path/without-extension
0D
23s int->string/binary
1Ai 30
1Ai 31
1Ai 32
17
0Es int->string/binary
0D
23s int->string/octal
1Ai 33
1Ai 34
1Ai 35
17
0Es int->string/octal
0D
10s array/new
1Ai 36
1Ai 37
1Ai 38
1Ai 39
1Ai 40
1Ai 41
1Ai 42
1Ai 43
1Ai 44
1Ai 45
1Ai 46
1Ai 47
1Ai 48
1Ai 49
1Ai 50
1Ai 51
04i 16
0Es int->string/hex/conversion-arr
0D
23s int->string/HEX
1Ai 52
1Ai 53
1Ai 54
17
0Es int->string/HEX
0D
23s int->string/hex
1Ai 55
1Ai 56
1Ai 57
17
0Es int->string/hex
0D
23s int->string/decimal
1Ai 58
1Ai 59
1Ai 60
17
0Es int->string/decimal
0D
10s int->string/decimal
0Es int->string
0D
23s string/pad-start
1Ai 61
1Ai 62
1Ai 63
17
0Es string/pad-start
0D
23s string/pad-end
1Ai 64
1Ai 65
1Ai 66
17
0Es string/pad-end
0D
23s string/pad-middle
1Ai 67
1Ai 68
1Ai 69
17
0Es string/pad-middle
0D
23s string/round
1Ai 70
1Ai 71
1Ai 72
17
0Es string/round
0D
23s split/empty
1Ai 73
1Ai 74
1Ai 75
17
0Es split/empty
0D
23s split/string
1Ai 76
1Ai 77
1Ai 78
17
0Es split/string
0D
23s split
1Ai 79
1Ai 80
1Ai 81
17
0Es split
0D
23s read/single
1Ai 82
1Ai 83
1Ai 84
17
0Es read/single
0D
23s read/int
1Ai 85
1Ai 86
1Ai 87
17
0Es read/int
0D
23s read/float
1Ai 88
1Ai 89
1Ai 90
17
0Es read/float
0D
23s string/length?!
1Ai 91
1Ai 92
1Ai 93
17
0Es string/length?!
0D
23s contains-any?
1Ai 94
1Ai 95
1Ai 96
17
0Es contains-any?
0D
23s contains-all?
1Ai 97
1Ai 98
1Ai 99
17
0Es contains-all?
01
}#{##[:array/2d [width height] #@[source: [[tree/new :data [-> [array/allocate [* width height]] [array/fill! 0]] :width width :height height]]] #{##[:data :width :height]
10s tree/new
1Ai 0
10s array/fill!
10s array/allocate
10s width
10s height
27
04i 1
02i 0
04i 2
1Ai 1
10s width
1Ai 2
10s height
04i 6
01
} [data v] #@[source: [[array/fill! [tree/ref data :data] v] [return data]]] #{##[:data]
10s array/fill!
10s tree/ref
10s data
1Ai 0
04i 2
10s v
04i 2
0D
10s data
01
01
} [data x y oob-val] #@[source: [[if [or [>= x [tree/ref data :width]] [>= y [tree/ref data :height]] [< x 0] [< y 0]] oob-val [array/ref [tree/ref data :data] [+ x [* y [tree/ref data :width]]]]]]] #{##[:width :height #f :data]
10s x
10s tree/ref
10s data
1Ai 0
04i 2
21
0C
0Ao 52
0D
10s y
10s tree/ref
10s data
1Ai 1
04i 2
21
0C
0Ao 30
0D
10s x
02i 0
1E
0C
0Ao 18
0D
10s y
02i 0
1E
0C
0Ao 6
0D
1Ai 2
0Bo 10
10s oob-val
09o 43
10s array/ref
10s tree/ref
10s data
1Ai 3
04i 2
10s x
10s y
10s tree/ref
10s data
1Ai 0
04i 2
27
25
04i 2
01
} [data x y val] #@[source: [[if [or [>= x [tree/ref data :width]] [>= y [tree/ref data :height]] [< x 0] [< y 0]] [exception :out-of-bounds "Trying to set an array out of bounds" data] [array/set! [tree/ref data :data] [+ x [* y [tree/ref data :width]]] val]] [return data]]] #{##[:width :height #f :out-of-bounds "Trying to set an array out of bounds" :data]
10s x
10s tree/ref
10s data
1Ai 0
04i 2
21
0C
0Ao 52
0D
10s y
10s tree/ref
10s data
1Ai 1
04i 2
21
0C
0Ao 30
0D
10s x
02i 0
1E
0C
0Ao 18
0D
10s y
02i 0
1E
0C
0Ao 6
0D
1Ai 2
0Bo 32
10s throw
10s list
1Ai 3
1Ai 4
10s data
10s current-lambda
04i 0
04i 4
04i 1
09o 47
10s array/set!
10s tree/ref
10s data
1Ai 5
04i 2
10s x
10s y
10s tree/ref
10s data
1Ai 0
04i 2
27
25
10s val
04i 3
0D
10s data
01
01
} [data] #@[source: [[dotimes [y [tree/ref data :height]] [dotimes [x [tree/ref data :width]] [display [cat [array/2d/ref data x y] " "]]] [newline]] [return data]]] #{##[" " :width :height]
15
02i 0
0Es y
0D
24
1B
09o 106
0D
1C
15
02i 0
0Es x
0D
24
1B
09o 49
0D
1C
10s print
10s cat
10s array/2d/ref
10s data
10s x
10s y
04i 3
1Ai 0
04i 2
04i 1
0D
02i 1
10s x
03
0Fs x
10s x
10s tree/ref
10s data
1Ai 1
04i 2
1E
0Ao -63
0D
24
16
0D
10s newline
04i 0
0D
02i 1
10s y
03
0Fs y
10s y
10s tree/ref
10s data
1Ai 2
04i 2
1E
0Ao -120
0D
24
16
0D
10s data
01
01
}]
10s module/insert
1Ai 0
15
10s tree/new
24
04i 1
0Es exports
0D
1Ai 0
0Es *module*
0D
10s tree/set!
10s exports
23s allocate
23s array/2d/allocate
1Ai 1
1Ai 2
1Ai 3
17
0Es array/2d/allocate
04i 3
0D
10s tree/set!
10s exports
23s fill!
23s array/2d/fill!
1Ai 4
1Ai 5
1Ai 6
17
0Es array/2d/fill!
04i 3
0D
10s tree/set!
10s exports
23s ref
23s array/2d/ref
1Ai 7
1Ai 8
1Ai 9
17
0Es array/2d/ref
04i 3
0D
10s tree/set!
10s exports
23s set!
23s array/2d/set!
1Ai 10
1Ai 11
1Ai 12
17
0Es array/2d/set!
04i 3
0D
10s tree/set!
10s exports
23s print
23s array/2d/print
1Ai 13
1Ai 14
1Ai 15
17
0Es array/2d/print
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[:avl :e [n] #@[source: [[= :e n]]] #{##[:e]
1Ai 0
10s n
20
01
} [x y] #@[source: [[if [< x y] -1 [if [> x y] 1 0]]]] #{##[]
10s x
10s y
1E
0Bo 8
02i -1
09o 22
10s x
10s y
22
0Bo 8
02i 1
09o 5
02i 0
01
} [r k] #@[source: [[or [avl/empty? [avl/root r]] [= [type-of k] [type-of [avl/key [avl/root r]]]] [throw [list :type-error "AVL trees can only contains keys of a single type" k [current-lambda]]]]]] #{##[:type-error "AVL trees can only contains keys of a single type" #f]
10s avl/empty?
10s avl/root
10s r
04i 1
04i 1
0C
0Ao 75
0D
10s type-of
10s k
04i 1
10s type-of
10s avl/key
10s avl/root
10s r
04i 1
04i 1
04i 1
20
0C
0Ao 37
0D
10s throw
10s list
1Ai 0
1Ai 1
10s k
10s current-lambda
04i 0
04i 4
04i 1
0C
0Ao 6
0D
1Ai 2
01
} [cmp] #@[source: [[array/new avl/empty [or cmp avl/default-cmp]]]] #{##[#f]
10s array/new
10s avl/empty
10s cmp
0C
0Ao 15
0D
10s avl/default-cmp
0C
0Ao 6
0D
1Ai 0
04i 2
01
} [n] #@[source: [[if [avl/empty? n] 0 [array/ref n 0]]]] #{##[]
10s avl/empty?
10s n
04i 1
0Bo 8
02i 0
09o 15
10s array/ref
10s n
02i 0
04i 2
01
} [n] #@[source: [[array/ref n 1]]] #{##[]
10s array/ref
10s n
02i 1
04i 2
01
} [n] #@[source: [[array/ref n 2]]] #{##[]
10s array/ref
10s n
02i 2
04i 2
01
} [n] #@[source: [[array/ref n 3]]] #{##[]
10s array/ref
10s n
02i 3
04i 2
01
} [r] #@[source: [[array/ref r 0]]] #{##[]
10s array/ref
10s r
02i 0
04i 2
01
} [r] #@[source: [[array/ref r 1]]] #{##[]
10s array/ref
10s r
02i 1
04i 2
01
} [n] #@[source: [[if [avl/empty? n] avl/empty [let [[l [avl/left n]]] [if [avl/empty? l] n [avl/min-mode l]]]]]] #{##[]
10s avl/empty?
10s n
04i 1
0Bo 10
10s avl/empty
09o 50
15
10s avl/left
10s n
04i 1
0Es l
0D
10s avl/empty?
10s l
04i 1
0Bo 10
10s n
09o 13
10s avl/min-mode
10s l
04i 1
16
01
} [n l] #@[source: [[array/set! [array/dup n] 2 l]]] #{##[]
10s array/set!
10s array/dup
10s n
04i 1
02i 2
10s l
04i 3
01
} [n r] #@[source: [[array/set! [array/dup n] 3 r]]] #{##[]
10s array/set!
10s array/dup
10s n
04i 1
02i 3
10s r
04i 3
01
} [n k] #@[source: [[array/set! [array/dup n] 1 k]]] #{##[]
10s array/set!
10s array/dup
10s n
04i 1
02i 1
10s k
04i 3
01
} [t r] #@[source: [[array/set! [array/dup t] 0 r]]] #{##[]
10s array/set!
10s array/dup
10s t
04i 1
02i 0
10s r
04i 3
01
} [n] #@[source: [[array/set! [array/dup n] 0 [+ 1 [max [avl/height [avl/left n]] [avl/height [avl/right n]]]]]]] #{##[]
10s array/set!
10s array/dup
10s n
04i 1
02i 0
02i 1
10s max
10s avl/height
10s avl/left
10s n
04i 1
04i 1
10s avl/height
10s avl/right
10s n
04i 1
04i 1
04i 2
25
04i 3
01
} [y] #@[source: [[let [[x [avl/left y]]] [avl/update-height [avl/update-right x [avl/update-height [avl/update-left y [avl/right x]]]]]]]] #{##[]
15
10s avl/left
10s y
04i 1
0Es x
0D
10s avl/update-height
10s avl/update-right
10s x
10s avl/update-height
10s avl/update-left
10s y
10s avl/right
10s x
04i 1
04i 2
04i 1
04i 2
04i 1
16
01
} [x] #@[source: [[let [[y [avl/right x]]] [avl/update-height [avl/update-left y [avl/update-height [avl/update-right x [avl/left y]]]]]]]] #{##[]
15
10s avl/right
10s x
04i 1
0Es y
0D
10s avl/update-height
10s avl/update-left
10s y
10s avl/update-height
10s avl/update-right
10s x
10s avl/left
10s y
04i 1
04i 2
04i 1
04i 2
04i 1
16
01
} [n] #@[source: [[if [avl/empty? n] 0 [- [avl/height [avl/left n]] [avl/height [avl/right n]]]]]] #{##[]
10s avl/empty?
10s n
04i 1
0Bo 8
02i 0
09o 36
10s avl/height
10s avl/left
10s n
04i 1
04i 1
10s avl/height
10s avl/right
10s n
04i 1
04i 1
26
01
} [n cmp v] #@[source: [[let [[b [avl/balance n]]] [cond [[> b 1] [case [cmp v [avl/key [avl/left n]]] [-1 [avl/rotate-right n]] [1 [avl/rotate-right [avl/update-left n [avl/rotate-left [avl/left n]]]]] [0 n]]] [[< b -1] [case [cmp v [avl/key [avl/right n]]] [1 [avl/rotate-left n]] [-1 [avl/rotate-left [avl/update-right n [avl/rotate-right [avl/right n]]]]] [0 n]]] [#t n]]]]] #{##[#t]
15
10s avl/balance
10s n
04i 1
0Es b
0D
10s b
02i 1
22
0Bo 125
15
10s cmp
10s v
10s avl/key
10s avl/left
10s n
04i 1
04i 1
04i 2
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
02i -1
20
0Bo 16
10s avl/rotate-right
10s n
04i 1
09o 66
10s ΓεnΣym-1
02i 1
20
0Bo 38
10s avl/rotate-right
10s avl/update-left
10s n
10s avl/rotate-left
10s avl/left
10s n
04i 1
04i 1
04i 2
04i 1
09o 21
10s ΓεnΣym-1
02i 0
20
0Bo 10
10s n
09o 4
24
16
09o 148
10s b
02i -1
1E
0Bo 125
15
10s cmp
10s v
10s avl/key
10s avl/right
10s n
04i 1
04i 1
04i 2
0Es ΓεnΣym-2
0D
10s ΓεnΣym-2
02i 1
20
0Bo 16
10s avl/rotate-left
10s n
04i 1
09o 66
10s ΓεnΣym-2
02i -1
20
0Bo 38
10s avl/rotate-left
10s avl/update-right
10s n
10s avl/rotate-right
10s avl/right
10s n
04i 1
04i 1
04i 2
04i 1
09o 21
10s ΓεnΣym-2
02i 0
20
0Bo 10
10s n
09o 4
24
16
09o 16
1Ai 0
0Bo 10
10s n
09o 4
24
16
01
} [n cmp v] #@[source: [[if [avl/empty? n] [array/new 1 v avl/empty avl/empty] [case [cmp v [avl/key n]] [-1 [avl/insert-rebalance [avl/update-height [avl/update-left n [avl/node-insert [avl/left n] cmp v]]] cmp v]] [1 [avl/insert-rebalance [avl/update-height [avl/update-right n [avl/node-insert [avl/right n] cmp v]]] cmp v]] [0 [avl/update-key n v]]]]]] #{##[]
10s avl/empty?
10s n
04i 1
0Bo 26
10s array/new
02i 1
10s v
10s avl/empty
10s avl/empty
04i 4
09o 192
15
10s cmp
10s v
10s avl/key
10s n
04i 1
04i 2
0Es ΓεnΣym-3
0D
10s ΓεnΣym-3
02i -1
20
0Bo 60
10s avl/insert-rebalance
10s avl/update-height
10s avl/update-left
10s n
10s avl/node-insert
10s avl/left
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
04i 1
10s cmp
10s v
04i 3
09o 98
10s ΓεnΣym-3
02i 1
20
0Bo 60
10s avl/insert-rebalance
10s avl/update-height
10s avl/update-right
10s n
10s avl/node-insert
10s avl/right
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
04i 1
10s cmp
10s v
04i 3
09o 31
10s ΓεnΣym-3
02i 0
20
0Bo 20
10s avl/update-key
10s n
10s v
04i 2
09o 4
24
16
01
} [t v] #@[documentation: "Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" source: ["Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" [avl/typecheck t v] [avl/update-root t [avl/node-insert [avl/root t] [avl/cmp t] v]]]] #{##[]
10s avl/typecheck
10s t
10s v
04i 2
0D
10s avl/update-root
10s t
10s avl/node-insert
10s avl/root
10s t
04i 1
10s avl/cmp
10s t
04i 1
10s v
04i 3
04i 2
01
} [n cmp v] #@[source: [[if [avl/empty? n] #nil [case [cmp v [avl/key n]] [0 [avl/key n]] [-1 [avl/node-get [avl/left n] cmp v]] [1 [avl/node-get [avl/right n] cmp v]]]]]] #{##[]
10s avl/empty?
10s n
04i 1
0Bo 7
24
09o 128
15
10s cmp
10s v
10s avl/key
10s n
04i 1
04i 2
0Es ΓεnΣym-4
0D
10s ΓεnΣym-4
02i 0
20
0Bo 16
10s avl/key
10s n
04i 1
09o 78
10s ΓεnΣym-4
02i -1
20
0Bo 30
10s avl/node-get
10s avl/left
10s n
04i 1
10s cmp
10s v
04i 3
09o 41
10s ΓεnΣym-4
02i 1
20
0Bo 30
10s avl/node-get
10s avl/right
10s n
04i 1
10s cmp
10s v
04i 3
09o 4
24
16
01
} [t v] #@[documentation: "Retrieve the key V from tree T, or #nil if V is not in it" source: ["Retrieve the key V from tree T, or #nil if V is not in it" [if [or [avl/empty? [avl/root t]] [not= [type-of v] [type-of [avl/key [avl/root t]]]]] #nil [avl/node-get [avl/root t] [avl/cmp t] v]]]] #{##[#f]
10s avl/empty?
10s avl/root
10s t
04i 1
04i 1
0C
0Ao 49
0D
10s not=
10s type-of
10s v
04i 1
10s type-of
10s avl/key
10s avl/root
10s t
04i 1
04i 1
04i 1
04i 2
0C
0Ao 6
0D
1Ai 0
0Bo 7
24
09o 33
10s avl/node-get
10s avl/root
10s t
04i 1
10s avl/cmp
10s t
04i 1
10s v
04i 3
01
} [l cmp] #@[documentation: "Create a new avl tree using the keys in L and the comparison function CMP" source: ["Create a new avl tree using the keys in L and the comparison function CMP" [list/reduce l avl/insert [avl/tree cmp]]]] #{##[]
10s list/reduce
10s l
10s avl/insert
10s avl/tree
10s cmp
04i 1
04i 3
01
} [n] #@[source: [[if [avl/empty? n] n [let [[b [avl/balance n]] [l [avl/left n]] [r [avl/right n]]] [cond [[> b 1] [if [>= [avl/balance l] 0] [avl/rotate-right n] [avl/rotate-right [avl/update-left n [avl/rotate-left l]]]]] [[< b -1] [if [<= [avl/balance r] 0] [avl/rotate-left n] [avl/rotate-left [avl/update-right n [avl/rotate-right r]]]]] [#t n]]]]]] #{##[#t]
10s avl/empty?
10s n
04i 1
0Bo 10
10s n
09o 199
15
10s avl/balance
10s n
04i 1
0Es b
0D
10s avl/left
10s n
04i 1
0Es l
0D
10s avl/right
10s n
04i 1
0Es r
0D
10s b
02i 1
22
0Bo 61
10s avl/balance
10s l
04i 1
02i 0
21
0Bo 16
10s avl/rotate-right
10s n
04i 1
09o 29
10s avl/rotate-right
10s avl/update-left
10s n
10s avl/rotate-left
10s l
04i 1
04i 2
04i 1
09o 84
10s b
02i -1
1E
0Bo 61
10s avl/balance
10s r
04i 1
02i 0
1F
0Bo 16
10s avl/rotate-left
10s n
04i 1
09o 29
10s avl/rotate-left
10s avl/update-right
10s n
10s avl/rotate-right
10s r
04i 1
04i 2
04i 1
09o 16
1Ai 0
0Bo 10
10s n
09o 4
24
16
01
} [n cmp v] #@[source: [[if [avl/empty? n] n [let [[root [case [cmp v [avl/key n]] [-1 [avl/update-left n [avl/node-remove [avl/left n] cmp v]]] [1 [avl/update-right n [avl/node-remove [avl/right n] cmp v]]] [0 [cond [[avl/empty? [avl/left n]] [avl/right n]] [[avl/empty? [avl/right n]] [avl/left n]] [#t [let [[k [avl/key [avl/min-node [avl/right n]]]]] [avl/update-key [avl/update-right [avl/right n] [avl/node-remove [avl/right n] cmp v]] k]]]]]]]] [set! root [avl/update-height root]] [avl/remove-rebalance root]]]]] #{##[#t]
10s avl/empty?
10s n
04i 1
0Bo 10
10s n
09o 322
15
15
10s cmp
10s v
10s avl/key
10s n
04i 1
04i 2
0Es ΓεnΣym-5
0D
10s ΓεnΣym-5
02i -1
20
0Bo 40
10s avl/update-left
10s n
10s avl/node-remove
10s avl/left
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
09o 216
10s ΓεnΣym-5
02i 1
20
0Bo 40
10s avl/update-right
10s n
10s avl/node-remove
10s avl/right
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
09o 169
10s ΓεnΣym-5
02i 0
20
0Bo 158
10s avl/empty?
10s avl/left
10s n
04i 1
04i 1
0Bo 16
10s avl/right
10s n
04i 1
09o 123
10s avl/empty?
10s avl/right
10s n
04i 1
04i 1
0Bo 16
10s avl/left
10s n
04i 1
09o 91
1Ai 0
0Bo 85
15
10s avl/key
10s avl/min-node
10s avl/right
10s n
04i 1
04i 1
04i 1
0Es k
0D
10s avl/update-key
10s avl/update-right
10s avl/right
10s n
04i 1
10s avl/node-remove
10s avl/right
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
10s k
04i 2
16
09o 4
24
09o 4
24
16
0Es root
0D
10s avl/update-height
10s root
04i 1
0Fs root
0D
10s avl/remove-rebalance
10s root
04i 1
16
01
} [t v] #@[documentation: "Remove the key V from tree T if it is contained within it" source: ["Remove the key V from tree T if it is contained within it" [avl/update-root t [avl/node-remove [avl/root t] [avl/cmp t] v]]]] #{##[]
10s avl/update-root
10s t
10s avl/node-remove
10s avl/root
10s t
04i 1
10s avl/cmp
10s t
04i 1
10s v
04i 3
04i 2
01
} [a b] #@[source: [[if [avl/empty? a] [avl/empty? b] [and [equal? [avl/key a] [avl/key b]] [avl/equal-node? [avl/left a] [avl/left b]] [avl/equal-node? [avl/right a] [avl/right b]]]]]] #{##[]
10s avl/empty?
10s a
04i 1
0Bo 16
10s avl/empty?
10s b
04i 1
09o 91
10s equal?
10s avl/key
10s a
04i 1
10s avl/key
10s b
04i 1
04i 2
0C
0Bo 61
0D
10s avl/equal-node?
10s avl/left
10s a
04i 1
10s avl/left
10s b
04i 1
04i 2
0C
0Bo 30
0D
10s avl/equal-node?
10s avl/right
10s a
04i 1
10s avl/right
10s b
04i 1
04i 2
01
} [a b] #@[documentation: "Test if two avl trees are equal" source: ["Test if two avl trees are equal" [avl/equal-node? [avl/root a] [avl/root b]]]] #{##[]
10s avl/equal-node?
10s avl/root
10s a
04i 1
10s avl/root
10s b
04i 1
04i 2
01
} [node o s] #@[source: [[if [avl/empty? node] s [o [avl/key node] [avl/reduce-node [avl/right node] o [avl/reduce-node [avl/left node] o s]]]]]] #{##[]
10s avl/empty?
10s node
04i 1
0Bo 10
10s s
09o 63
10s o
10s avl/key
10s node
04i 1
10s avl/reduce-node
10s avl/right
10s node
04i 1
10s o
10s avl/reduce-node
10s avl/left
10s node
04i 1
10s o
10s s
04i 3
04i 3
04i 2
01
} [t o s] #@[documentation: "Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" source: ["Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" [avl/reduce-node [avl/root t] o s]]] #{##[]
10s avl/reduce-node
10s avl/root
10s t
04i 1
10s o
10s s
04i 3
01
} [n o s] #@[source: [[if [avl/empty? n] s [o [o [avl/key n] [avl/reduce-node-bin [avl/left n] o s]] [avl/reduce-node-bin [avl/right n] o s]]]]] #{##[]
10s avl/empty?
10s n
04i 1
0Bo 10
10s s
09o 73
10s o
10s o
10s avl/key
10s n
04i 1
10s avl/reduce-node-bin
10s avl/left
10s n
04i 1
10s o
10s s
04i 3
04i 2
10s avl/reduce-node-bin
10s avl/right
10s n
04i 1
10s o
10s s
04i 3
04i 2
01
} [t o s] #@[documentation: "Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" source: ["Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" [avl/reduce-node-bin [avl/root t] o s]]] #{##[]
10s avl/reduce-node-bin
10s avl/root
10s t
04i 1
10s o
10s s
04i 3
01
} [t f] #@[documentation: "Create a new avl tree by mapping each key in T using F, using the same comparison function as T" source: ["Create a new avl tree by mapping each key in T using F, using the same comparison function as T" [avl/reduce t [fn [x acc] [avl/insert acc [f x]]] [avl/tree [avl/cmp t]]]]] #{##[[x acc] #@[source: [[avl/insert acc [f x]]]] #{##[]
10s avl/insert
10s acc
10s f
10s x
04i 1
04i 2
01
}]
10s avl/reduce
10s t
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
10s avl/tree
10s avl/cmp
10s t
04i 1
04i 1
04i 3
01
} [t f cmp] #@[documentation: "Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" source: ["Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" [avl/reduce t [fn [x acc] [avl/insert acc [f x]]] [avl/tree cmp]]]] #{##[[x acc] #@[source: [[avl/insert acc [f x]]]] #{##[]
10s avl/insert
10s acc
10s f
10s x
04i 1
04i 2
01
}]
10s avl/reduce
10s t
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
10s avl/tree
10s cmp
04i 1
04i 3
01
} [t] #@[source: [[avl/reduce t cons #nil]]] #{##[]
10s avl/reduce
10s t
10s cons
24
04i 3
01
}]
10s module/insert
1Ai 0
15
10s tree/new
24
04i 1
0Es exports
0D
1Ai 0
0Es *module*
0D
1Ai 1
0Es avl/empty
0D
23s avl/empty?
1Ai 2
1Ai 3
1Ai 4
17
0Es avl/empty?
0D
10s tree/set!
10s exports
23s default-cmp
23s avl/default-cmp
1Ai 5
1Ai 6
1Ai 7
17
0Es avl/default-cmp
04i 3
0D
23s avl/typecheck
1Ai 8
1Ai 9
1Ai 10
17
0Es avl/typecheck
0D
10s tree/set!
10s exports
23s tree
23s avl/tree
1Ai 11
1Ai 12
1Ai 13
17
0Es avl/tree
04i 3
0D
23s avl/height
1Ai 14
1Ai 15
1Ai 16
17
0Es avl/height
0D
23s avl/key
1Ai 17
1Ai 18
1Ai 19
17
0Es avl/key
0D
23s avl/left
1Ai 20
1Ai 21
1Ai 22
17
0Es avl/left
0D
23s avl/right
1Ai 23
1Ai 24
1Ai 25
17
0Es avl/right
0D
23s avl/root
1Ai 26
1Ai 27
1Ai 28
17
0Es avl/root
0D
23s avl/cmp
1Ai 29
1Ai 30
1Ai 31
17
0Es avl/cmp
0D
23s avl/min-node
1Ai 32
1Ai 33
1Ai 34
17
0Es avl/min-node
0D
23s avl/update-left
1Ai 35
1Ai 36
1Ai 37
17
0Es avl/update-left
0D
23s avl/update-right
1Ai 38
1Ai 39
1Ai 40
17
0Es avl/update-right
0D
23s avl/update-key
1Ai 41
1Ai 42
1Ai 43
17
0Es avl/update-key
0D
23s avl/update-root
1Ai 44
1Ai 45
1Ai 46
17
0Es avl/update-root
0D
23s avl/update-height
1Ai 47
1Ai 48
1Ai 49
17
0Es avl/update-height
0D
23s avl/rotate-right
1Ai 50
1Ai 51
1Ai 52
17
0Es avl/rotate-right
0D
23s avl/rotate-left
1Ai 53
1Ai 54
1Ai 55
17
0Es avl/rotate-left
0D
23s avl/balance
1Ai 56
1Ai 57
1Ai 58
17
0Es avl/balance
0D
23s avl/insert-rebalance
1Ai 59
1Ai 60
1Ai 61
17
0Es avl/insert-rebalance
0D
23s avl/node-insert
1Ai 62
1Ai 63
1Ai 64
17
0Es avl/node-insert
0D
10s tree/set!
10s exports
23s insert
23s avl/insert
1Ai 65
1Ai 66
1Ai 67
17
0Es avl/insert
04i 3
0D
23s avl/node-get
1Ai 68
1Ai 69
1Ai 70
17
0Es avl/node-get
0D
10s tree/set!
10s exports
23s get
23s avl/get
1Ai 71
1Ai 72
1Ai 73
17
0Es avl/get
04i 3
0D
10s tree/set!
10s exports
23s from-list
23s avl/from-list
1Ai 74
1Ai 75
1Ai 76
17
0Es avl/from-list
04i 3
0D
23s avl/remove-rebalance
1Ai 77
1Ai 78
1Ai 79
17
0Es avl/remove-rebalance
0D
23s avl/node-remove
1Ai 80
1Ai 81
1Ai 82
17
0Es avl/node-remove
0D
10s tree/set!
10s exports
23s remove
23s avl/remove
1Ai 83
1Ai 84
1Ai 85
17
0Es avl/remove
04i 3
0D
23s avl/equal-node?
1Ai 86
1Ai 87
1Ai 88
17
0Es avl/equal-node?
0D
10s tree/set!
10s exports
23s equal?
23s avl/equal?
1Ai 89
1Ai 90
1Ai 91
17
0Es avl/equal?
04i 3
0D
23s avl/reduce-node
1Ai 92
1Ai 93
1Ai 94
17
0Es avl/reduce-node
0D
10s tree/set!
10s exports
23s reduce
23s avl/reduce
1Ai 95
1Ai 96
1Ai 97
17
0Es avl/reduce
04i 3
0D
23s avl/reduce-node-bin
1Ai 98
1Ai 99
1Ai 100
17
0Es avl/reduce-node-bin
0D
10s tree/set!
10s exports
23s reduce-bin
23s avl/reduce-bin
1Ai 101
1Ai 102
1Ai 103
17
0Es avl/reduce-bin
04i 3
0D
10s tree/set!
10s exports
23s map
23s avl/map
1Ai 104
1Ai 105
1Ai 106
17
0Es avl/map
04i 3
0D
10s tree/set!
10s exports
23s map-to
23s avl/map-to
1Ai 107
1Ai 108
1Ai 109
17
0Es avl/map-to
04i 3
0D
10s tree/set!
10s exports
23s to-list
23s avl/to-list
1Ai 110
1Ai 111
1Ai 112
17
0Es avl/to-list
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[:crypto/adler32 [data] #@[source: [[def a 1] [def b 0] [when [string? data] [set! data [string->buffer data]]] [when [not= [type-of data] :buffer] [exception :type-error "Can only hash buffers or strings"]] [def v [buffer/view/u8* data]] [dotimes [i [buffer/length data]] [set! a [mod/int [add/int a [buffer/view/ref v i]] 65521]] [set! b [mod/int [add/int a b] 65521]]] [bit-or a [bit-shift-left b 16]]]] #{##[:buffer :type-error "Can only hash buffers or strings" 65521]
02i 1
0Es a
0D
02i 0
0Es b
0D
10s string?
10s data
04i 1
0Bo 20
10s string->buffer
10s data
04i 1
0Fs data
09o 4
24
0D
10s not=
10s type-of
10s data
04i 1
1Ai 0
04i 2
0Bo 29
10s throw
10s list
1Ai 1
1Ai 2
24
10s current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s buffer/view/u8*
10s data
04i 1
0Es v
0D
15
02i 0
0Es i
0D
24
1B
09o 70
0D
1C
10s mod/int
10s a
10s buffer/view/ref
10s v
10s i
04i 2
03
1Ai 3
04i 2
0Fs a
0D
10s mod/int
10s a
10s b
03
1Ai 3
04i 2
0Fs b
0D
02i 1
10s i
03
0Fs i
10s i
10s buffer/length
10s data
04i 1
1E
0Ao -82
0D
24
16
0D
10s bit-or
10s a
10s bit-shift-left
10s b
02i 16
04i 2
04i 2
01
}]
10s module/insert
1Ai 0
15
10s tree/new
24
04i 1
0Es exports
0D
1Ai 0
0Es *module*
0D
10s tree/set!
10s exports
23s hash
23s hash
1Ai 1
1Ai 2
1Ai 3
17
0Es hash
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[:image [ext enc] #@[source: [[def ext [string->keyword [lowercase ext]]] [tree/set! image/encoders ext enc]]] #{##[]
10s symbol->keyword
10s string->symbol
10s lowercase
10s ext
04i 1
04i 1
04i 1
0Es ext
0D
10s tree/set!
10s image/encoders
10s ext
10s enc
04i 3
01
} [ext dec] #@[source: [[def ext [string->keyword [lowercase ext]]] [tree/set! image/decoders ext dec]]] #{##[]
10s symbol->keyword
10s string->symbol
10s lowercase
10s ext
04i 1
04i 1
04i 1
0Es ext
0D
10s tree/set!
10s image/decoders
10s ext
10s dec
04i 3
01
} [path] #@[source: [[def ext [string->keyword [lowercase [path/extension path]]]] [tree/ref image/encoders ext]]] #{##[]
10s symbol->keyword
10s string->symbol
10s lowercase
10s path/extension
10s path
04i 1
04i 1
04i 1
04i 1
0Es ext
0D
10s tree/ref
10s image/encoders
10s ext
04i 2
01
} [path] #@[source: [[def ext [string->keyword [lowercase [path/extension path]]]] [tree/ref image/decoders ext]]] #{##[]
10s symbol->keyword
10s string->symbol
10s lowercase
10s path/extension
10s path
04i 1
04i 1
04i 1
04i 1
0Es ext
0D
10s tree/ref
10s image/decoders
10s ext
04i 2
01
} [width height] #@[source: [[def buffer [buffer/allocate [* width height 4]]] [tree/new :width width :height height :buffer buffer :pixels [buffer/view/u32* buffer]]]] #{##[:width :height :buffer :pixels]
10s buffer/allocate
10s width
10s height
27
02i 4
27
04i 1
0Es buffer
0D
10s tree/new
1Ai 0
10s width
1Ai 1
10s height
1Ai 2
10s buffer
1Ai 3
10s buffer/view/u32*
10s buffer
04i 1
04i 8
01
} [img x y] #@[source: [[def i [+ [int x] [* [int y] [tree/ref img :width]]]] [buffer/view/ref [tree/ref img :pixels] i]]] #{##[:width :pixels]
10s int
10s x
04i 1
10s int
10s y
04i 1
10s tree/ref
10s img
1Ai 0
04i 2
27
25
0Es i
0D
10s buffer/view/ref
10s tree/ref
10s img
1Ai 1
04i 2
10s i
04i 2
01
} [img x y value] #@[source: [[def i [+ [int x] [* [int y] [tree/ref img :width]]]] [buffer/view/set! [tree/ref img :pixels] i value]]] #{##[:width :pixels]
10s int
10s x
04i 1
10s int
10s y
04i 1
10s tree/ref
10s img
1Ai 0
04i 2
27
25
0Es i
0D
10s buffer/view/set!
10s tree/ref
10s img
1Ai 1
04i 2
10s i
10s value
04i 3
01
} [img value] #@[source: [[def p [tree/ref img :pixels]] [dotimes [i [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! p i value]] [return img]]] #{##[:pixels :width :height]
10s tree/ref
10s img
1Ai 0
04i 2
0Es p
0D
15
02i 0
0Es i
0D
24
1B
09o 35
0D
1C
10s buffer/view/set!
10s p
10s i
10s value
04i 3
0D
02i 1
10s i
03
0Fs i
10s i
10s tree/ref
10s img
1Ai 1
04i 2
10s tree/ref
10s img
1Ai 2
04i 2
27
1E
0Ao -62
0D
24
16
0D
10s img
01
01
} [img fun] #@[source: [[def p [tree/ref img :pixels]] [dotimes [i [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! p i [fun [buffer/view/ref p i]]]] [return img]]] #{##[:pixels :width :height]
10s tree/ref
10s img
1Ai 0
04i 2
0Es p
0D
15
02i 0
0Es i
0D
24
1B
09o 51
0D
1C
10s buffer/view/set!
10s p
10s i
10s fun
10s buffer/view/ref
10s p
10s i
04i 2
04i 1
04i 3
0D
02i 1
10s i
03
0Fs i
10s i
10s tree/ref
10s img
1Ai 1
04i 2
10s tree/ref
10s img
1Ai 2
04i 2
27
1E
0Ao -78
0D
24
16
0D
10s img
01
01
} [img] #@[source: [[def ret [image/new [tree/ref img :width] [tree/ref img :height]]] [def in [tree/ref img :pixels]] [def out [tree/ref ret :pixels]] [dotimes [i [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! out i [buffer/view/ref in i]]] [return ret]]] #{##[:width :height :pixels]
10s image/new
10s tree/ref
10s img
1Ai 0
04i 2
10s tree/ref
10s img
1Ai 1
04i 2
04i 2
0Es ret
0D
10s tree/ref
10s img
1Ai 2
04i 2
0Es in
0D
10s tree/ref
10s ret
1Ai 2
04i 2
0Es out
0D
15
02i 0
0Es i
0D
24
1B
09o 45
0D
1C
10s buffer/view/set!
10s out
10s i
10s buffer/view/ref
10s in
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
10s i
10s tree/ref
10s img
1Ai 0
04i 2
10s tree/ref
10s img
1Ai 1
04i 2
27
1E
0Ao -72
0D
24
16
0D
10s ret
01
01
} [img path] #@[source: [[def enc [image/get-encoder path]] [if enc [file/write [enc img] path] [exception :missing-encoder "Currently there is no encoder loaded for that image format" path]]]] #{##[:missing-encoder "Currently there is no encoder loaded for that image format"]
10s image/get-encoder
10s path
04i 1
0Es enc
0D
10s enc
0Bo 26
10s file/write
10s enc
10s img
04i 1
10s path
04i 2
09o 29
10s throw
10s list
1Ai 0
1Ai 1
10s path
10s current-lambda
04i 0
04i 4
04i 1
01
} [img] #@[source: [[import [hash] :crypto/adler32] [hash [tree/ref img :buffer]]]] #{##[:crypto/adler32 :buffer]
10s module/import
10s module/load
1Ai 0
04i 1
23s hash
04i 2
0Es hash
0D
10s hash
10s tree/ref
10s img
1Ai 1
04i 2
04i 1
01
} [] #@[source: [[def w 256] [def h 256] [def out [image/new w h]] [dotimes [x w] [dotimes [y h] [image/set! out x y [bit-or x [bit-shift-left y 8] [bit-shift-left [bit-xor x y] 16]]]]] [return out]]] #{##[256]
1Ai 0
0Es w
0D
1Ai 0
0Es h
0D
10s image/new
10s w
10s h
04i 2
0Es out
0D
15
02i 0
0Es x
0D
24
1B
09o 127
0D
1C
15
02i 0
0Es y
0D
24
1B
09o 85
0D
1C
10s image/set!
10s out
10s x
10s y
10s bit-or
10s bit-or
10s x
10s bit-shift-left
10s y
02i 8
04i 2
04i 2
10s bit-shift-left
10s bit-xor
10s x
10s y
04i 2
02i 16
04i 2
04i 2
04i 4
0D
02i 1
10s y
03
0Fs y
10s y
10s h
1E
0Ao -91
0D
24
16
0D
02i 1
10s x
03
0Fs x
10s x
10s w
1E
0Ao -133
0D
24
16
0D
10s out
01
01
}]
10s module/insert
1Ai 0
15
10s tree/new
24
04i 1
0Es exports
0D
1Ai 0
0Es *module*
0D
10s tree/new
24
04i 1
0Es image/decoders
0D
10s tree/new
24
04i 1
0Es image/encoders
0D
10s tree/set!
10s exports
23s add-encoder!
23s image/add-encoder!
1Ai 1
1Ai 2
1Ai 3
17
0Es image/add-encoder!
04i 3
0D
10s tree/set!
10s exports
23s add-decoder!
23s image/add-decoder!
1Ai 4
1Ai 5
1Ai 6
17
0Es image/add-decoder!
04i 3
0D
23s image/get-encoder
1Ai 7
1Ai 8
1Ai 9
17
0Es image/get-encoder
0D
23s image/get-decoder
1Ai 10
1Ai 11
1Ai 12
17
0Es image/get-decoder
0D
10s tree/set!
10s exports
23s new
23s image/new
1Ai 13
1Ai 14
1Ai 15
17
0Es image/new
04i 3
0D
10s tree/set!
10s exports
23s ref
23s image/ref
1Ai 16
1Ai 17
1Ai 18
17
0Es image/ref
04i 3
0D
10s tree/set!
10s exports
23s set!
23s image/set!
1Ai 19
1Ai 20
1Ai 21
17
0Es image/set!
04i 3
0D
10s tree/set!
10s exports
23s fill!
23s image/fill!
1Ai 22
1Ai 23
1Ai 24
17
0Es image/fill!
04i 3
0D
10s tree/set!
10s exports
23s map!
23s image/map!
1Ai 25
1Ai 26
1Ai 27
17
0Es image/map!
04i 3
0D
10s tree/set!
10s exports
23s dup
23s image/dup
1Ai 28
1Ai 29
1Ai 30
17
0Es image/dup
04i 3
0D
10s tree/set!
10s exports
23s save!
23s image/save!
1Ai 31
1Ai 32
1Ai 33
17
0Es image/save!
04i 3
0D
10s tree/set!
10s exports
23s adler32
23s image/adler32
1Ai 34
1Ai 35
1Ai 36
17
0Es image/adler32
04i 3
0D
10s tree/set!
10s exports
23s test-image-xor
23s image/test-image-xor
1Ai 37
1Ai 38
1Ai 39
17
0Es image/test-image-xor
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[:image/bmp [u8v offset bytes val] #@[source: [[while [> bytes 0] [buffer/view/set! u8v [inc! offset] [bit-and 255 val]] [dec! bytes] [set! val [bit-shift-right val 8]]] offset]] #{##[255]
24
1B
09o 67
0D
1C
10s buffer/view/set!
10s u8v
10s offset
02i 1
25
0Fs offset
10s bit-and
1Ai 0
10s val
04i 2
04i 3
0D
10s bytes
02i 1
26
0Fs bytes
0D
10s bit-shift-right
10s val
02i 8
04i 2
0Fs val
10s bytes
02i 0
22
0Ao -71
0D
10s offset
01
} [width pixel-length] #@[source: [[def ret [- 4 [bit-and [* width pixel-length] 3]]] [if [= ret 4] 0 ret]]] #{##[]
02i 4
10s bit-and
10s width
10s pixel-length
27
02i 3
04i 2
26
0Es ret
0D
10s ret
02i 4
20
0Bo 8
02i 0
09o 7
10s ret
01
} [image] #@[source: [[require :image] [def image-size [* [tree/ref image :height] 3 [+ [tree/ref image :width] [image/bmp/row-padding [tree/ref image :width] 3]]]] [def header-size [+ 14 40]] [def file-size [+ image-size header-size]] [def out [buffer/allocate file-size]] [def b [buffer/view/u8* out]] [def i -1] [buffer/view/set! b [inc! i] 66] [buffer/view/set! b [inc! i] 77] [set! i [buffer/view/le/set! b i 4 file-size]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 header-size]] [set! i [buffer/view/le/set! b i 4 40]] [set! i [buffer/view/le/set! b i 4 [tree/ref image :width]]] [set! i [buffer/view/le/set! b i 4 [tree/ref image :height]]] [set! i [buffer/view/le/set! b i 2 1]] [set! i [buffer/view/le/set! b i 2 24]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 image-size]] [set! i [buffer/view/le/set! b i 4 8192]] [set! i [buffer/view/le/set! b i 4 8192]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 0]] [def row-padding [image/bmp/row-padding [tree/ref image :width] 3]] [def pixels [- header-size 1]] [let [[y [- [tree/ref image :height] 1]]] [while [>= y 0] [dotimes [x [tree/ref image :width]] [set! pixels [buffer/view/le/set! b pixels 3 [image/ref image x y]]]] [set! pixels [+ pixels row-padding]] [set! y [add/int y -1]]]] [return out]]] #{##[:image #t :height :width 8192]
10s require*
1Ai 0
10s current-closure
04i 0
1Ai 1
04i 3
0D
10s tree/ref
10s image
1Ai 2
04i 2
02i 3
27
10s tree/ref
10s image
1Ai 3
04i 2
10s image/bmp/row-padding
10s tree/ref
10s image
1Ai 3
04i 2
02i 3
04i 2
25
27
0Es image-size
0D
02i 54
0Es header-size
0D
10s image-size
10s header-size
25
0Es file-size
0D
10s buffer/allocate
10s file-size
04i 1
0Es out
0D
10s buffer/view/u8*
10s out
04i 1
0Es b
0D
02i -1
0Es i
0D
10s buffer/view/set!
10s b
10s i
02i 1
25
0Fs i
02i 66
04i 3
0D
10s buffer/view/set!
10s b
10s i
02i 1
25
0Fs i
02i 77
04i 3
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
10s file-size
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
02i 0
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
10s header-size
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
02i 40
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
10s tree/ref
10s image
1Ai 3
04i 2
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
10s tree/ref
10s image
1Ai 2
04i 2
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 2
02i 1
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 2
02i 24
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
02i 0
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
10s image-size
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
1Ai 4
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
1Ai 4
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
02i 0
04i 4
0Fs i
0D
10s buffer/view/le/set!
10s b
10s i
02i 4
02i 0
04i 4
0Fs i
0D
10s image/bmp/row-padding
10s tree/ref
10s image
1Ai 3
04i 2
02i 3
04i 2
0Es row-padding
0D
10s header-size
02i 1
26
0Es pixels
0D
15
10s tree/ref
10s image
1Ai 2
04i 2
02i 1
26
0Es y
0D
24
1B
09o 119
0D
1C
15
02i 0
0Es x
0D
24
1B
09o 55
0D
1C
10s buffer/view/le/set!
10s b
10s pixels
02i 3
10s image/ref
10s image
10s x
10s y
04i 3
04i 4
0Fs pixels
0D
02i 1
10s x
03
0Fs x
10s x
10s tree/ref
10s image
1Ai 3
04i 2
1E
0Ao -69
0D
24
16
0D
10s pixels
10s row-padding
25
0Fs pixels
0D
10s y
02i -1
03
0Fs y
10s y
02i 0
21
0Ao -123
16
0D
10s out
01
01
} [] #@[source: [[require :image] [image/add-encoder! "bmp" image/bmp/encode]]] #{##[:image #t "bmp"]
10s require*
1Ai 0
10s current-closure
04i 0
1Ai 1
04i 3
0D
10s image/add-encoder!
1Ai 2
10s image/bmp/encode
04i 2
01
}]
10s module/insert
1Ai 0
15
10s tree/new
24
04i 1
0Es exports
0D
1Ai 0
0Es *module*
0D
23s buffer/view/le/set!
1Ai 1
1Ai 2
1Ai 3
17
0Es buffer/view/le/set!
0D
23s image/bmp/row-padding
1Ai 4
1Ai 5
1Ai 6
17
0Es image/bmp/row-padding
0D
10s tree/set!
10s exports
23s encode
23s image/bmp/encode
1Ai 7
1Ai 8
1Ai 9
17
0Es image/bmp/encode
04i 3
0D
10s tree/set!
10s exports
23s init!
23s image/bmp/init!
1Ai 10
1Ai 11
1Ai 12
17
0Es image/bmp/init!
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[:io/ansi #f [v] #@[source: [[set! disabled [if [nil? v] #t v]]]] #{##[#t]
10s nil?
10s v
04i 1
0Bo 8
1Ai 0
09o 7
10s v
0Fs disabled
01
} "\e[0m" "\e[0;39m" "\e[49m" "\e[0;30m" "\e[0;31m" "\e[0;32m" "\e[0;33m" "\e[0;34m" "\e[0;35m" "\e[0;36m" "\e[0;37m" "\e[1;30m" "\e[1;31m" "\e[1;32m" "\e[1;33m" "\e[1;34m" "\e[1;35m" "\e[1;36m" "\e[1;37m" "\e[40m" "\e[41m" "\e[42m" "\e[43m" "\e[44m" "\e[45m" "\e[46m" "\e[47m" [code string] #@[documentation: "Wrap STRING in the ansi color CODE" source: ["Wrap STRING in the ansi color CODE" [cat [or disabled [array/ref ansi-fg code]] string [or disabled reset]]]] #{##[#f]
10s cat
10s disabled
0C
0Ao 25
0D
10s array/ref
10s ansi-fg
10s code
04i 2
0C
0Ao 6
0D
1Ai 0
10s string
10s disabled
0C
0Ao 15
0D
10s reset
0C
0Ao 6
0D
1Ai 0
04i 3
01
} #@[source: [[wrap 0 [apply cat args]]]] #{##[]
10s wrap
02i 0
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 1 [apply cat args]]]] #{##[]
10s wrap
02i 1
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 2 [apply cat args]]]] #{##[]
10s wrap
02i 2
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 3 [apply cat args]]]] #{##[]
10s wrap
02i 3
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 4 [apply cat args]]]] #{##[]
10s wrap
02i 4
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 5 [apply cat args]]]] #{##[]
10s wrap
02i 5
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 6 [apply cat args]]]] #{##[]
10s wrap
02i 6
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 7 [apply cat args]]]] #{##[]
10s wrap
02i 7
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 8 [apply cat args]]]] #{##[]
10s wrap
02i 8
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 9 [apply cat args]]]] #{##[]
10s wrap
02i 9
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 10 [apply cat args]]]] #{##[]
10s wrap
02i 10
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 11 [apply cat args]]]] #{##[]
10s wrap
02i 11
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 12 [apply cat args]]]] #{##[]
10s wrap
02i 12
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 13 [apply cat args]]]] #{##[]
10s wrap
02i 13
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 14 [apply cat args]]]] #{##[]
10s wrap
02i 14
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[source: [[wrap 15 [apply cat args]]]] #{##[]
10s wrap
02i 15
10s apply
10s cat
10s args
04i 2
04i 2
01
} #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [let* [def count 0] [cat [join [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] ""] [or disabled fg-reset]]]]] #{##["" [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] #{##[#f]
10s bit-and
02i 1
10s count
25
02i 7
04i 2
0Fs count
0D
10s cat
10s disabled
0C
0Ao 41
0D
10s array/ref
10s ansi-fg
10s count
2A
0Bo 8
02i 7
09o 10
10s count
02i 8
25
04i 2
0C
0Ao 6
0D
1Ai 0
10s a
04i 2
01
} #f]
15
02i 0
0Es count
0D
10s cat
10s join
10s map
10s split
10s apply
10s cat
10s args
04i 2
1Ai 0
04i 2
23s anonymous
1Ai 1
1Ai 2
1Ai 3
17
04i 2
1Ai 0
04i 2
10s disabled
0C
0Ao 15
0D
10s fg-reset
0C
0Ao 6
0D
1Ai 4
04i 2
16
01
} #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [def count 0] [def colored-list [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [bit-xor count 7]]] [or disabled [array/ref ansi-bg count]] a]]]] [cat [join colored-list ""] [or disabled reset]]]] #{##["" [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [bit-xor count 7]]] [or disabled [array/ref ansi-bg count]] a]]] #{##[#f]
10s bit-and
02i 1
10s count
25
02i 7
04i 2
0Fs count
0D
10s cat
10s disabled
0C
0Ao 33
0D
10s array/ref
10s ansi-fg
10s bit-xor
10s count
02i 7
04i 2
04i 2
0C
0Ao 6
0D
1Ai 0
10s disabled
0C
0Ao 25
0D
10s array/ref
10s ansi-bg
10s count
04i 2
0C
0Ao 6
0D
1Ai 0
10s a
04i 3
01
} #f]
02i 0
0Es count
0D
10s map
10s split
10s apply
10s cat
10s args
04i 2
1Ai 0
04i 2
23s anonymous
1Ai 1
1Ai 2
1Ai 3
17
04i 2
0Es colored-list
0D
10s cat
10s join
10s colored-list
1Ai 0
04i 2
10s disabled
0C
0Ao 15
0D
10s reset
0C
0Ao 6
0D
1Ai 4
04i 2
01
} [text width] #@[source: [[when-not width [set! width 20]] [print "\r"] [dotimes [i width] [print " "]] [print "\r"] [print text]]] #{##["\r" " "]
10s width
0Bo 7
24
09o 9
02i 20
0Fs width
0D
10s print
1Ai 0
04i 1
0D
15
02i 0
0Es i
0D
24
1B
09o 25
0D
1C
10s print
1Ai 1
04i 1
0D
02i 1
10s i
03
0Fs i
10s i
10s width
1E
0Ao -31
0D
24
16
0D
10s print
1Ai 0
04i 1
0D
10s print
10s text
04i 1
01
}]
10s module/insert
1Ai 0
15
10s tree/new
24
04i 1
0Es exports
0D
1Ai 0
0Es *module*
0D
1Ai 1
0Es disabled
0D
10s tree/set!
10s exports
23s disable!
23s disable!
1Ai 2
1Ai 3
1Ai 4
17
0Es disable!
04i 3
0D
1Ai 5
0Es reset
0D
1Ai 6
0Es fg-reset
0D
1Ai 7
0Es bg-reset
0D
10s array/new
1Ai 8
1Ai 9
1Ai 10
1Ai 11
1Ai 12
1Ai 13
1Ai 14
1Ai 15
1Ai 16
1Ai 17
1Ai 18
1Ai 19
1Ai 20
1Ai 21
1Ai 22
1Ai 23
04i 16
0Es ansi-fg
0D
10s array/new
1Ai 24
1Ai 25
1Ai 26
1Ai 27
1Ai 28
1Ai 29
1Ai 30
1Ai 31
04i 8
0Es ansi-bg
0D
10s tree/set!
10s exports
23s wrap
23s wrap
1Ai 32
1Ai 33
1Ai 34
17
0Es wrap
04i 3
0D
10s tree/set!
10s exports
23s black
23s black
23s args
1Ai 35
1Ai 36
17
0Es black
04i 3
0D
10s tree/set!
10s exports
23s dark-red
23s dark-red
23s args
1Ai 37
1Ai 38
17
0Es dark-red
04i 3
0D
10s tree/set!
10s exports
23s dark-green
23s dark-green
23s args
1Ai 39
1Ai 40
17
0Es dark-green
04i 3
0D
10s tree/set!
10s exports
23s dark-brown
23s brown
23s args
1Ai 41
1Ai 42
17
0Es brown
04i 3
0D
10s tree/set!
10s exports
23s dark-blue
23s dark-blue
23s args
1Ai 43
1Ai 44
17
0Es dark-blue
04i 3
0D
10s tree/set!
10s exports
23s purple
23s purple
23s args
1Ai 45
1Ai 46
17
0Es purple
04i 3
0D
10s tree/set!
10s exports
23s teal
23s teal
23s args
1Ai 47
1Ai 48
17
0Es teal
04i 3
0D
10s tree/set!
10s exports
23s dark-gray
23s dark-gray
23s args
1Ai 49
1Ai 50
17
0Es dark-gray
04i 3
0D
10s tree/set!
10s exports
23s gray
23s gray
23s args
1Ai 51
1Ai 52
17
0Es gray
04i 3
0D
10s tree/set!
10s exports
23s red
23s red
23s args
1Ai 53
1Ai 54
17
0Es red
04i 3
0D
10s tree/set!
10s exports
23s green
23s green
23s args
1Ai 55
1Ai 56
17
0Es green
04i 3
0D
10s tree/set!
10s exports
23s yellow
23s yellow
23s args
1Ai 57
1Ai 58
17
0Es yellow
04i 3
0D
10s tree/set!
10s exports
23s blue
23s blue
23s args
1Ai 59
1Ai 60
17
0Es blue
04i 3
0D
10s tree/set!
10s exports
23s pink
23s pink
23s args
1Ai 61
1Ai 62
17
0Es pink
04i 3
0D
10s tree/set!
10s exports
23s cyan
23s cyan
23s args
1Ai 63
1Ai 64
17
0Es cyan
04i 3
0D
10s tree/set!
10s exports
23s white
23s white
23s args
1Ai 65
1Ai 66
17
0Es white
04i 3
0D
10s tree/set!
10s exports
23s rainbow
23s rainbow
23s args
1Ai 67
1Ai 68
17
0Es rainbow
04i 3
0D
10s tree/set!
10s exports
23s rainbow-bg
23s rainbow-bg
23s args
1Ai 69
1Ai 70
17
0Es rainbow-bg
04i 3
0D
10s tree/set!
10s exports
23s reprint-line
23s reprint-line
1Ai 71
1Ai 72
1Ai 73
17
0Es reprint-line
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[:serialization/json [v] #@[documentation: "Converts a tree into a JSON encoded string, you should prefer VAL->JSON" source: ["Converts a tree into a JSON encoded string, you should prefer VAL->JSON" [cat "{" [join [map [tree/keys v] [fn [k] [cat "\"" [keyword->string k] "\": " [val->json [tree/ref v k]]]]] ",\n"] "}"]]] #{##["{" [k] #@[source: [[cat "\"" [keyword->string k] "\": " [val->json [tree/ref v k]]]]] #{##["\"" "\": "]
10s cat
1Ai 0
10s keyword->string
10s k
04i 1
1Ai 1
10s val->json
10s tree/ref
10s v
10s k
04i 2
04i 1
04i 4
01
} ",\n" "}"]
10s cat
1Ai 0
10s join
10s map
10s tree/keys
10s v
04i 1
23s anonymous
1Ai 1
1Ai 2
1Ai 3
17
04i 2
1Ai 4
04i 2
1Ai 5
04i 3
01
} [v] #@[documentation: "Return V as a JSON encoded string" source: ["Return V as a JSON encoded string" [case [type-of v] [:nil "null"] [[:int :float] [string v]] [:bool [if v "true" "false"]] [[:array :pair] [cat "[" [join [map v val->json] ","] "]"]] [:string [string/write v]] [:symbol [cat "\"" [symbol->string v] "\""]] [:keyword [cat "\"" [keyword->string v] "\""]] [:tree [tree->json v]] [otherwise [throw [list :type-error "Can't encode the value into JSON" v [current-lambda]]]]]]] #{##[:nil "null" :int :float #f :bool "true" "false" :array :pair "[" "," "]" :string :symbol "\"" :keyword :tree :type-error "Can't encode the value into JSON"]
15
10s type-of
10s v
04i 1
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
1Ai 0
20
0Bo 8
1Ai 1
09o 274
10s ΓεnΣym-1
1Ai 2
20
0C
0Ao 18
0D
10s ΓεnΣym-1
1Ai 3
20
0C
0Ao 6
0D
1Ai 4
0Bo 16
10s string
10s v
04i 1
09o 232
10s ΓεnΣym-1
1Ai 5
20
0Bo 20
10s v
0Bo 8
1Ai 6
09o 5
1Ai 7
09o 205
10s ΓεnΣym-1
1Ai 8
20
0C
0Ao 18
0D
10s ΓεnΣym-1
1Ai 9
20
0C
0Ao 6
0D
1Ai 4
0Bo 38
10s cat
1Ai 10
10s join
10s map
10s v
10s val->json
04i 2
1Ai 11
04i 2
1Ai 12
04i 3
09o 141
10s ΓεnΣym-1
1Ai 13
20
0Bo 16
10s string/write
10s v
04i 1
09o 118
10s ΓεnΣym-1
1Ai 14
20
0Bo 26
10s cat
1Ai 15
10s symbol->string
10s v
04i 1
1Ai 15
04i 3
09o 85
10s ΓεnΣym-1
1Ai 16
20
0Bo 26
10s cat
1Ai 15
10s keyword->string
10s v
04i 1
1Ai 15
04i 3
09o 52
10s ΓεnΣym-1
1Ai 17
20
0Bo 16
10s tree->json
10s v
04i 1
09o 29
10s throw
10s list
1Ai 18
1Ai 19
10s v
10s current-lambda
04i 0
04i 4
04i 1
16
01
}]
10s module/insert
1Ai 0
15
10s tree/new
24
04i 1
0Es exports
0D
1Ai 0
0Es *module*
0D
23s tree->json
1Ai 1
1Ai 2
1Ai 3
17
0Es tree->json
0D
10s tree/set!
10s exports
23s serialize
23s val->json
1Ai 4
1Ai 5
1Ai 6
17
0Es val->json
04i 3
0D
24
0D
13
16
04i 2
01
}#{##[:test #t #f [result expr] #@[source: [[set! test-list [cons [cons result expr] test-list]] [set! test-count [+ test-count 1]]]] #{##[]
10s result
10s expr
14
10s test-list
14
0Fs test-list
0D
10s test-count
02i 1
25
0Fs test-count
01
} [result . expr] #@[documentation: "Add a test where EXPR must eval to RESULT" source: ["Add a test where EXPR must eval to RESULT" [quasiquote [[unquote test/add*] [unquote result] [unquote [list 'quote [cons 'do expr]]]]]]] #{##[]
10s test/add*
10s result
10s list
23s quote
23s do
10s expr
14
04i 2
24
14
14
14
01
} [] #@[source: [[set! test-list [cons 4 '[+ 3 1]]] [set! test-count 1]]] #{##[[+ 3 1]]
02i 4
1Ai 0
14
0Fs test-list
0D
02i 1
0Fs test-count
01
} [description] #@[documentation: "Prints the result Message" source: ["Prints the result Message" [random/seed-initialize!] [efmtln "{} {} - [{} / {}] in {} ms" [if [and [zero? error-count] [> test-count 0]] [if [zero? success-count] [ansi-yellow "?"] [ansi-green "✓"]] [ansi-red "✗"]] description [if [zero? success-count] [ansi-yellow success-count] [ansi-green success-count]] [if [zero? error-count] [ansi-gray error-count] [ansi-red error-count]] [- [time/milliseconds] nujel-start]]]] #{##["?" "✓" "✗" " " " - [" " / " "] in " " ms"]
10s random/seed-initialize!
04i 0
0D
10s errorln
15
10s error-count
2A
0C
0Bo 11
0D
10s test-count
02i 0
22
0Bo 33
10s success-count
2A
0Bo 14
10s ansi-yellow
1Ai 0
04i 1
09o 11
10s ansi-green
1Ai 1
04i 1
09o 11
10s ansi-red
1Ai 2
04i 1
0Es fmt-arg-0
0D
10s description
0Es fmt-arg-1
0D
10s success-count
2A
0Bo 16
10s ansi-yellow
10s success-count
04i 1
09o 13
10s ansi-green
10s success-count
04i 1
0Es fmt-arg-2
0D
10s error-count
2A
0Bo 16
10s ansi-gray
10s error-count
04i 1
09o 13
10s ansi-red
10s error-count
04i 1
0Es fmt-arg-3
0D
10s time/milliseconds
04i 0
10s nujel-start
26
0Es fmt-arg-4
0D
10s cat
10s fmt-arg-0
1Ai 3
10s fmt-arg-1
1Ai 4
10s fmt-arg-2
1Ai 5
10s fmt-arg-3
1Ai 6
10s fmt-arg-4
1Ai 7
04i 10
16
04i 1
01
} [res-should res-is expr] #@[documentation: "Should be called after a test has finished successfully" source: ["Should be called after a test has finished successfully" [when print-passes [efmtln "{} == {}\r\n{}\r\n\r\n" [ansi-green [string/write res-is]] [ansi-green [string/write res-should]] [string/write expr]]] [set! success-count [+ 1 success-count]]]] #{##[" == " "\r\n" "\r\n\r\n"]
10s print-passes
0Bo 95
10s errorln
15
10s ansi-green
10s string/write
10s res-is
04i 1
04i 1
0Es fmt-arg-0
0D
10s ansi-green
10s string/write
10s res-should
04i 1
04i 1
0Es fmt-arg-1
0D
10s string/write
10s expr
04i 1
0Es fmt-arg-2
0D
10s cat
10s fmt-arg-0
1Ai 0
10s fmt-arg-1
1Ai 1
10s fmt-arg-2
1Ai 2
04i 6
16
04i 1
09o 4
24
0D
02i 1
10s success-count
25
0Fs success-count
01
} [res-should res-is expr] #@[documentation: "Should be called if EXPR does not equal RES" source: ["Should be called if EXPR does not equal RES" [when print-errors [pfmtln "{} != {}\r\n{}\r\n\r\n" [ansi-red [string/write res-is]] [ansi-green [string/write res-should]] [string/write expr]]] [set! error-count [+ 1 error-count]]]] #{##[" != " "\r\n" "\r\n\r\n"]
10s print-errors
0Bo 95
10s println
15
10s ansi-red
10s string/write
10s res-is
04i 1
04i 1
0Es fmt-arg-0
0D
10s ansi-green
10s string/write
10s res-should
04i 1
04i 1
0Es fmt-arg-1
0D
10s string/write
10s expr
04i 1
0Es fmt-arg-2
0D
10s cat
10s fmt-arg-0
1Ai 0
10s fmt-arg-1
1Ai 1
10s fmt-arg-2
1Ai 2
04i 6
16
04i 1
09o 4
24
0D
02i 1
10s error-count
25
0Fs error-count
01
} [result rawexpr i] #@[documentation: "Tests that RAWEXPR evaluates to RESULT" source: ["Tests that RAWEXPR evaluates to RESULT" [try [fn [err] [display/error err] [test-failure result [list :exception-caught err] rawexpr]] [def expr [eval rawexpr]] [if [equal? result expr] [test-success result expr rawexpr] [test-failure result expr rawexpr]]]]] #{##[[err] #@[source: [[display/error err] [test-failure result [list :exception-caught err] rawexpr]]] #{##[:exception-caught]
10s display/error
10s err
04i 1
0D
10s test-failure
10s result
10s list
1Ai 0
10s err
04i 2
10s rawexpr
04i 3
01
}]
23s anonymous
1Ai 0
1Ai 1
1Ai 2
17
19o 81
10s eval-in
10s current-closure
04i 0
10s rawexpr
04i 2
0Es expr
0D
10s equal?
10s result
10s expr
04i 2
0Bo 24
10s test-success
10s result
10s expr
10s rawexpr
04i 3
09o 21
10s test-failure
10s result
10s expr
10s rawexpr
04i 3
16
01
} [output-passes hide-errors] #@[documentation: "Initialize the testing framework" source: ["Initialize the testing framework" [set! print-errors [not [bool hide-errors]]] [set! print-passes [bool output-passes]] [set! nujel-start [time/milliseconds]] [set! success-count 0] [set! error-count 0]]] #{##[#f #t]
10s bool
10s hide-errors
04i 1
0Bo 8
1Ai 0
09o 5
1Ai 1
0Fs print-errors
0D
10s bool
10s output-passes
04i 1
0Fs print-passes
0D
10s time/milliseconds
04i 0
0Fs nujel-start
0D
02i 0
0Fs success-count
0D
02i 0
0Fs error-count
01
} [description] #@[source: [[display-results description] [return error-count]]] #{##[]
10s display-results
10s description
04i 1
0D
10s error-count
01
01
} [output-passes hide-errors] #@[documentation: "Run through all automated Tests" source: ["Run through all automated Tests" [init!] [doseq [cur-test test-list] [run-test! [car cur-test] [cdr cur-test]]] [finish! [fmt "{} {} [{System/OS} {System/Architecture}]" [ansi-blue ":core"] [ansi-rainbow "Nujel"]]]]] #{##[":core" "Nujel" " " " [" "]"]
10s init!
04i 0
0D
15
10s test-list
0Es ΓεnΣym-1
0D
10s ΓεnΣym-1
0Bo 56
24
1B
09o 41
0D
1C
10s ΓεnΣym-1
11
0Es cur-test
0D
10s run-test!
10s cur-test
11
10s cur-test
12
04i 2
0D
10s ΓεnΣym-1
12
0Fs ΓεnΣym-1
10s ΓεnΣym-1
0Ao -42
09o 4
24
16
0D
10s finish!
15
10s ansi-blue
1Ai 0
04i 1
0Es fmt-arg-0
0D
10s ansi-rainbow
1Ai 1
04i 1
0Es fmt-arg-1
0D
10s cat
10s fmt-arg-0
1Ai 2
10s fmt-arg-1
1Ai 3
10s System/OS
1Ai 2
10s System/Architecture
1Ai 4
04i 8
16
04i 1
01
}]
10s module/insert
1Ai 0
15
10s tree/new
24
04i 1
0Es exports
0D
1Ai 0
0Es *module*
0D
24
0Es test-list
0D
02i 0
0Es test-count
0D
02i 0
0Es nujel-start
0D
02i 0
0Es success-count
0D
02i 0
0Es error-count
0D
1Ai 1
0Es print-errors
0D
1Ai 2
0Es print-passes
0D
10s tree/set!
10s exports
23s add*
23s test/add*
1Ai 3
1Ai 4
1Ai 5
17
0Es test/add*
04i 3
0D
10s tree/set!
10s exports
23s add
23s test/add
1Ai 6
1Ai 7
1Ai 8
18
0Es test/add
04i 3
0D
10s tree/set!
10s exports
23s reset!
23s reset!
1Ai 9
1Ai 10
1Ai 11
17
0Es reset!
04i 3
0D
23s display-results
1Ai 12
1Ai 13
1Ai 14
17
0Es display-results
0D
23s test-success
1Ai 15
1Ai 16
1Ai 17
17
0Es test-success
0D
23s test-failure
1Ai 18
1Ai 19
1Ai 20
17
0Es test-failure
0D
10s tree/set!
10s exports
23s run-test!
23s run-test!
1Ai 21
1Ai 22
1Ai 23
17
0Es run-test!
04i 3
0D
10s tree/set!
10s exports
23s init!
23s init!
1Ai 24
1Ai 25
1Ai 26
17
0Es init!
04i 3
0D
10s tree/set!
10s exports
23s finish!
23s finish!
1Ai 27
1Ai 28
1Ai 29
17
0Es finish!
04i 3
0D
10s tree/set!
10s exports
23s run
23s run
1Ai 30
1Ai 31
1Ai 32
17
0Es run
04i 3
0D
10s reset!
04i 0
0D
24
0D
13
16
04i 2
01
}#{##[:time [timestamp] #@[documentation: "Return the seconds part of TIMESTAMP, defaults to current time" source: ["Return the seconds part of TIMESTAMP, defaults to current time" [rem [or timestamp [time]] 60]]] #{##[#f]
10s timestamp
0C
0Ao 17
0D
10s time
04i 0
0C
0Ao 6
0D
1Ai 0
02i 60
29
01
} [timestamp] #@[documentation: "Return the minutes part of TIMESTAMP, defaults to current time" source: ["Return the minutes part of TIMESTAMP, defaults to current time" [rem [/ [or timestamp [time]] 60] 60]]] #{##[#f]
10s timestamp
0C
0Ao 17
0D
10s time
04i 0
0C
0Ao 6
0D
1Ai 0
02i 60
28
02i 60
29
01
} [timestamp] #@[documentation: "Return the hours part of TIMESTAMP, defaults to current time" source: ["Return the hours part of TIMESTAMP, defaults to current time" [rem [/ [or timestamp [time]] 3600] 24]]] #{##[#f 3600]
10s timestamp
0C
0Ao 17
0D
10s time
04i 0
0C
0Ao 6
0D
1Ai 0
1Ai 1
28
02i 24
29
01
}]
10s module/insert
1Ai 0
15
10s tree/new
24
04i 1
0Es exports
0D
1Ai 0
0Es *module*
0D
10s tree/set!
10s exports
23s seconds
23s seconds
1Ai 1
1Ai 2
1Ai 3
17
0Es seconds
04i 3
0D
10s tree/set!
10s exports
23s minutes
23s minutes
1Ai 4
1Ai 5
1Ai 6
17
0Es minutes
04i 3
0D
10s tree/set!
10s exports
23s hours
23s hours
1Ai 7
1Ai 8
1Ai 9
17
0Es hours
04i 3
0D
24
0D
13
16
04i 2
01
}