#{##[]
23s lognand
23s l
05v #@[documentation: "Returns the Nand of its arguments" source: ["Returns the Nand of its arguments" [lognot [apply logand l]]]]
05v #{##[]
05v lognot
05v apply
10s logand
10s l
04i 2
04i 1
01
}
17
0Es lognand
0D
23s bit-set?
05v [α i]
05v #@[documentation: "Returns #t if bit I is set in Α" source: ["Returns #t if bit I is set in Α" [typecheck/only α :int] [typecheck/only i :int] [not [zero? [logand α [ash 1 i]]]]]]
05v #{##[]
05v type-of
10s α
04i 1
05v :int
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :int"
10s α
05v current-lambda
04i 0
04i 4
04i 1
0D
05v type-of
10s i
04i 1
05v :int
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :int"
10s i
05v current-lambda
04i 0
04i 4
04i 1
0D
02i 0
05v logand
10s α
05v ash
02i 1
10s i
04i 2
04i 2
20
0Bo 10
05v #f
09o 7
05v #t
01
}
17
0Es bit-set?
0D
23s bit-set?!
05v [i]
05v #@[documentation: "Returns a function that checks if bit I is set in the provided number" source: ["Returns a function that checks if bit I is set in the provided number" [typecheck/only i :int] [def mask [ash 1 i]] [fn [α] [not [zero? [logand α mask]]]]]]
05v #{##[]
05v type-of
10s i
04i 1
05v :int
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :int"
10s i
05v current-lambda
04i 0
04i 4
04i 1
0D
05v ash
02i 1
10s i
04i 2
0Es mask
0D
23s anonymous
05v [α]
05v #@[source: [[not [zero? [logand α mask]]]]]
05v #{##[]
02i 0
05v logand
10s α
10s mask
04i 2
20
0Bo 10
05v #f
09o 7
05v #t
01
}
17
01
}
17
0Es bit-set?!
0D
23s bit-clear?!
05v [i]
05v #@[documentation: "Returns a function that checks if bit I is clear in the provided number" source: ["Returns a function that checks if bit I is clear in the provided number" [typecheck/only i :int] [def mask [ash 1 i]] [fn [α] [zero? [logand α mask]]]]]
05v #{##[]
05v type-of
10s i
04i 1
05v :int
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :int"
10s i
05v current-lambda
04i 0
04i 4
04i 1
0D
05v ash
02i 1
10s i
04i 2
0Es mask
0D
23s anonymous
05v [α]
05v #@[source: [[zero? [logand α mask]]]]
05v #{##[]
02i 0
05v logand
10s α
10s mask
04i 2
20
01
}
17
01
}
17
0Es bit-clear?!
0D
23s test-function
05v [i]
05v #@[documentation: "Returns a function that checks if bit I is clear in the provided number" source: ["Returns a function that checks if bit I is clear in the provided number" [def mask [ash 1 i]] [fn [α] [zero? [logand α mask]]]]]
05v #{##[]
05v ash
02i 1
10s i
04i 2
0Es mask
0D
23s anonymous
05v [α]
05v #@[source: [[zero? [logand α mask]]]]
05v #{##[]
02i 0
05v logand
10s α
10s mask
04i 2
20
01
}
17
01
}
17
0Es test-function
01
}#{##[]
23s array/2d/allocate
05v [width height]
05v #@[source: [[tree/new :data [-> [array/allocate [* width height]] [array/fill! 0]] :width width :height height]]]
05v #{##[]
05v tree/new
05v :data
05v array/fill!
05v array/allocate
05v *
10s width
10s height
04i 2
04i 1
02i 0
04i 2
05v :width
10s width
05v :height
10s height
04i 6
01
}
17
0Es array/2d/allocate
0D
23s array/2d/fill!
05v [data v]
05v #@[source: [[array/fill! [tree/ref data :data] v] data]]
05v #{##[]
05v array/fill!
05v tree/ref
10s data
05v :data
04i 2
10s v
04i 2
0D
10s data
01
}
17
0Es array/2d/fill!
0D
23s array/2d/ref
05v [data x y oob-val]
05v #@[source: [[if [or [>= x [tree/ref data :width]] [>= y [tree/ref data :height]] [< x 0] [< y 0]] oob-val [array/ref [tree/ref data :data] [+ x [* y [tree/ref data :width]]]]]]]
05v #{##[]
10s x
05v tree/ref
10s data
05v :width
04i 2
21
0C
0Ao 56
0D
10s y
05v tree/ref
10s data
05v :height
04i 2
21
0C
0Ao 32
0D
10s x
02i 0
1E
0C
0Ao 20
0D
10s y
02i 0
1E
0C
0Ao 8
0D
05v #f
0Bo 10
10s oob-val
09o 57
05v array/ref
05v tree/ref
10s data
05v :data
04i 2
05v +
10s x
05v *
10s y
05v tree/ref
10s data
05v :width
04i 2
04i 2
04i 2
04i 2
01
}
17
0Es array/2d/ref
0D
23s array/2d/set!
05v [data x y val]
05v #@[source: [[if [or [>= x [tree/ref data :width]] [>= y [tree/ref data :height]] [< x 0] [< y 0]] [throw [list :out-of-bounds "Trying to set an array out of bounds" data [current-lambda]]] [array/set! [tree/ref data :data] [+ x [* y [tree/ref data :width]]] val]] data]]
05v #{##[]
10s x
05v tree/ref
10s data
05v :width
04i 2
21
0C
0Ao 56
0D
10s y
05v tree/ref
10s data
05v :height
04i 2
21
0C
0Ao 32
0D
10s x
02i 0
1E
0C
0Ao 20
0D
10s y
02i 0
1E
0C
0Ao 8
0D
05v #f
0Bo 36
05v throw
05v list
05v :out-of-bounds
05v "Trying to set an array out of bounds"
10s data
05v current-lambda
04i 0
04i 4
04i 1
09o 61
05v array/set!
05v tree/ref
10s data
05v :data
04i 2
05v +
10s x
05v *
10s y
05v tree/ref
10s data
05v :width
04i 2
04i 2
04i 2
10s val
04i 3
0D
10s data
01
}
17
0Es array/2d/set!
0D
23s array/2d/print
05v [data]
05v #@[source: [[for [y 0 [tree/ref data :height]] [for [x 0 [tree/ref data :width]] [display [cat [array/2d/ref data x y] " "]]] [newline]] data]]
05v #{##[]
15
02i 0
0Es y
0D
05v tree/ref
10s data
05v :height
04i 2
0Es ΓεnΣym-24
0D
02i 0
1B
1C
10s y
10s ΓεnΣym-24
1E
0Bo 120
0D
15
02i 0
0Es x
0D
05v tree/ref
10s data
05v :width
04i 2
0Es ΓεnΣym-25
0D
02i 0
1B
1C
10s x
10s ΓεnΣym-25
1E
0Bo 53
0D
05v print
05v cat
05v array/2d/ref
10s data
10s x
10s y
04i 3
05v " "
04i 2
04i 1
0D
02i 1
10s x
03
0Fs x
09o -60
16
0D
05v newline
04i 0
0D
02i 1
10s y
03
0Fs y
09o -127
16
0D
10s data
01
}
17
0Es array/2d/print
01
}#{##[]
23s array/+=
05v [a i v]
05v #@[documentation: "Add V to the value in A at position I and store the result in A returning A" source: ["Add V to the value in A at position I and store the result in A returning A" [array/set! a i [+ v [array/ref a i]]]]]
05v #{##[]
05v array/set!
10s a
10s i
05v +
10s v
05v array/ref
10s a
10s i
04i 2
04i 2
04i 3
01
}
17
0Es array/+=
0D
23s array/++
05v [a i]
05v #@[documentation: "Increment position I in A and return A" source: ["Increment position I in A and return A" [array/+= a i 1]]]
05v #{##[]
05v array/+=
10s a
10s i
02i 1
04i 3
01
}
17
0Es array/++
0D
23s array/fill!
05v [a v]
05v #@[documentation: "Fills array a with value v" source: ["Fills array a with value v" [def len [array/length a]] [for [i 0 len] [array/set! a i v]] [return a]]]
05v #{##[]
05v array/length
10s a
04i 1
0Es len
0D
15
02i 0
0Es i
0D
10s len
0Es ΓεnΣym-13
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-13
1E
0Bo 37
0D
05v array/set!
10s a
10s i
10s v
04i 3
0D
02i 1
10s i
03
0Fs i
09o -44
16
0D
10s a
01
01
}
17
0Es array/fill!
0D
23s array/append
05v [a b]
05v #@[documentation: "Append array A to array B" source: ["Append array A to array B" [when-not [and [array? a] [array? b]] [throw [list :type-error "array/append expects two arrays as its arguments" #nil [current-lambda]]]] [def ret [array/allocate [+ [array/length a] [array/length b]]]] [for [i 0 [array/length a]] [array/set! ret i [array/ref a i]]] [for [i [array/length a] [array/length ret]] [array/set! ret i [array/ref b [- i [array/length a]]]]] [return ret]]]
05v #{##[]
05v array?
10s a
04i 1
0C
0Bo 14
0D
05v array?
10s b
04i 1
0Bo 7
24
09o 30
05v throw
05v list
05v :type-error
05v "array/append expects two arrays as its arguments"
24
05v current-lambda
04i 0
04i 4
04i 1
0D
05v array/allocate
05v +
05v array/length
10s a
04i 1
05v array/length
10s b
04i 1
04i 2
04i 1
0Es ret
0D
15
02i 0
0Es i
0D
05v array/length
10s a
04i 1
0Es ΓεnΣym-14
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-14
1E
0Bo 47
0D
05v array/set!
10s ret
10s i
05v array/ref
10s a
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -54
16
0D
15
05v array/length
10s a
04i 1
0Es i
0D
05v array/length
10s ret
04i 1
0Es ΓεnΣym-15
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-15
1E
0Bo 63
0D
05v array/set!
10s ret
10s i
05v array/ref
10s b
05v -
10s i
05v array/length
10s a
04i 1
04i 2
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -70
16
0D
10s ret
01
01
}
17
0Es array/append
0D
23s array/dup
05v [a]
05v #@[documentation: "Duplicate Array A" source: ["Duplicate Array A" [def ret [array/allocate [array/length a]]] [for [i 0 [array/length a]] [array/set! ret i [array/ref a i]]] [return ret]]]
05v #{##[]
05v array/allocate
05v array/length
10s a
04i 1
04i 1
0Es ret
0D
15
02i 0
0Es i
0D
05v array/length
10s a
04i 1
0Es ΓεnΣym-16
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-16
1E
0Bo 47
0D
05v array/set!
10s ret
10s i
05v array/ref
10s a
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -54
16
0D
10s ret
01
01
}
17
0Es array/dup
0D
23s array/reduce
05v [arr fun α]
05v #@[documentation: "Reduce an array, [reduce] should be preferred" source: ["Reduce an array, [reduce] should be preferred" [def len [array/length arr]] [for [i 0 len] [set! α [fun α [array/ref arr i]]]] [return α]]]
05v #{##[]
05v array/length
10s arr
04i 1
0Es len
0D
15
02i 0
0Es i
0D
10s len
0Es ΓεnΣym-17
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-17
1E
0Bo 47
0D
10s fun
10s α
05v array/ref
10s arr
10s i
04i 2
04i 2
0Fs α
0D
02i 1
10s i
03
0Fs i
09o -54
16
0D
10s α
01
01
}
17
0Es array/reduce
0D
23s array/map
05v [arr fun]
05v #@[documentation: "Map an array, [map] should be preferred" source: ["Map an array, [map] should be preferred" [def len [array/length arr]] [for [i 0 len] [array/set! arr i [fun [array/ref arr i]]]] [return arr]]]
05v #{##[]
05v array/length
10s arr
04i 1
0Es len
0D
15
02i 0
0Es i
0D
10s len
0Es ΓεnΣym-18
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-18
1E
0Bo 53
0D
05v array/set!
10s arr
10s i
10s fun
05v array/ref
10s arr
10s i
04i 2
04i 1
04i 3
0D
02i 1
10s i
03
0Fs i
09o -60
16
0D
10s arr
01
01
}
17
0Es array/map
0D
23s array/filter
05v [arr pred]
05v #@[documentation: "Filter an array, [filter] should be preferred" source: ["Filter an array, [filter] should be preferred" [def ri 0] [def len [array/length arr]] [def ret [array/allocate len]] [for [ai 0 len] [when [pred [array/ref arr ai]] [array/set! ret ri [array/ref arr ai]] [++ ri]]] [array/length! ret ri]]]
05v #{##[]
02i 0
0Es ri
0D
05v array/length
10s arr
04i 1
0Es len
0D
05v array/allocate
10s len
04i 1
0Es ret
0D
15
02i 0
0Es ai
0D
10s len
0Es ΓεnΣym-19
0D
02i 0
1B
1C
10s ai
10s ΓεnΣym-19
1E
0Bo 91
0D
10s pred
05v array/ref
10s arr
10s ai
04i 2
04i 1
0Bo 51
05v array/set!
10s ret
10s ri
05v array/ref
10s arr
10s ai
04i 2
04i 3
0D
05v +
02i 1
10s ri
04i 2
0Fs ri
09o 4
24
0D
02i 1
10s ai
03
0Fs ai
09o -98
16
0D
05v array/length!
10s ret
10s ri
04i 2
01
}
17
0Es array/filter
0D
23s array/equal?
05v [a b]
05v #@[source: [[if [or [not [array? a]] [not [array? b]] [!= [array/length a] [array/length b]]] [return #f] [let [[ret #t]] [for [i 0 [array/length a]] [when-not [equal? [array/ref a i] [array/ref b i]] [set! ret #f] [set! i [array/length a]]]] [return ret]]]]]
05v #{##[]
05v array?
10s a
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 68
0D
05v array?
10s b
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 39
0D
05v !=
05v array/length
10s a
04i 1
05v array/length
10s b
04i 1
04i 2
0C
0Ao 8
0D
05v #f
0Bo 11
05v #f
01
09o 140
15
05v #t
0Es ret
0D
15
02i 0
0Es i
0D
05v array/length
10s a
04i 1
0Es ΓεnΣym-20
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-20
1E
0Bo 83
0D
05v equal?
05v array/ref
10s a
10s i
04i 2
05v array/ref
10s b
10s i
04i 2
04i 2
0Bo 7
24
09o 26
05v #f
0Fs ret
0D
05v array/length
10s a
04i 1
0Fs i
0D
02i 1
10s i
03
0Fs i
09o -90
16
0D
10s ret
01
16
01
}
17
0Es array/equal?
0D
23s array/push
05v [arr val]
05v #@[documentation: "Append VAL to ARR" source: ["Append VAL to ARR" [-> arr [array/length! [+ 1 [array/length arr]]] [array/set! [- [array/length arr] 1] val]]]]
05v #{##[]
05v array/set!
05v array/length!
10s arr
05v +
02i 1
05v array/length
10s arr
04i 1
04i 2
04i 2
05v -
05v array/length
10s arr
04i 1
02i 1
04i 2
10s val
04i 3
01
}
17
0Es array/push
0D
23s array/swap
05v [arr i j]
05v #@[documentation: "Swap values at I and J in ARR" source: ["Swap values at I and J in ARR" [def tmp [array/ref arr i]] [-> arr [array/set! i [array/ref arr j]] [array/set! j tmp]]]]
05v #{##[]
05v array/ref
10s arr
10s i
04i 2
0Es tmp
0D
05v array/set!
05v array/set!
10s arr
10s i
05v array/ref
10s arr
10s j
04i 2
04i 3
10s j
10s tmp
04i 3
01
}
17
0Es array/swap
0D
23s array/heapify
05v [arr n at]
05v #@[documentation: "bubble up the element from index AT to until the max-heap property is satisfied" source: ["bubble up the element from index AT to until the max-heap property is satisfied" [def top at] [def looping #t] [while looping [def l [+ [ash at 1] 1]] [def r [+ [ash at 1] 2]] [when [and [< l n] [> [array/ref arr l] [array/ref arr top]]] [set! top l]] [when [and [< r n] [> [array/ref arr r] [array/ref arr top]]] [set! top r]] [if [== top at] [set! looping #f] [do [array/swap arr at top] [set! at top]]]] [return arr]]]
05v #{##[]
10s at
0Es top
0D
05v #t
0Es looping
0D
02i 0
1B
1C
10s looping
0Bo 225
0D
05v +
05v ash
10s at
02i 1
04i 2
02i 1
04i 2
0Es l
0D
05v +
05v ash
10s at
02i 1
04i 2
02i 2
04i 2
0Es r
0D
10s l
10s n
1E
0C
0Bo 33
0D
05v array/ref
10s arr
10s l
04i 2
05v array/ref
10s arr
10s top
04i 2
22
0Bo 14
10s l
0Fs top
09o 4
24
0D
10s r
10s n
1E
0C
0Bo 33
0D
05v array/ref
10s arr
10s r
04i 2
05v array/ref
10s arr
10s top
04i 2
22
0Bo 14
10s r
0Fs top
09o 4
24
0D
10s top
10s at
20
0Bo 14
05v #f
0Fs looping
09o 30
05v array/swap
10s arr
10s at
10s top
04i 3
0D
10s top
0Fs at
09o -227
0D
10s arr
01
01
}
17
0Es array/heapify
0D
23s array/make-heap
05v [arr]
05v #@[source: [[def l [array/length arr]] [def l2 [/ l 2]] [while [>= l2 0] [array/heapify arr l l2] [-- l2]] [return arr]]]
05v #{##[]
05v array/length
10s arr
04i 1
0Es l
0D
05v /
10s l
02i 2
04i 2
0Es l2
0D
02i 0
1B
1C
10s l2
02i 0
21
0Bo 42
0D
05v array/heapify
10s arr
10s l
10s l2
04i 3
0D
05v +
02i -1
10s l2
04i 2
0Fs l2
09o -47
0D
10s arr
01
01
}
17
0Es array/make-heap
0D
23s array/heap-sort
05v [arr]
05v #@[source: [[array/make-heap arr] [def l [array/length arr]] [while [> l 0] [-- l] [array/swap arr 0 l] [array/heapify arr l 0]] [return arr]]]
05v #{##[]
05v array/make-heap
10s arr
04i 1
0D
05v array/length
10s arr
04i 1
0Es l
0D
02i 0
1B
1C
10s l
02i 0
22
0Bo 57
0D
05v +
02i -1
10s l
04i 2
0Fs l
0D
05v array/swap
10s arr
02i 0
10s l
04i 3
0D
05v array/heapify
10s arr
10s l
02i 0
04i 3
09o -62
0D
10s arr
01
01
}
17
0Es array/heap-sort
0D
10s array/heap-sort
0Es array/sort
0D
23s array/cut
05v [arr start end]
05v #@[documentation: "Return a newly allocated array with the values of ARR from START to END" source: ["Return a newly allocated array with the values of ARR from START to END" [set! start [max 0 start]] [set! end [min [array/length arr] end]] [def ret [array/allocate [max 0 [- end start]]]] [for [i start end] [array/set! ret [- i start] [array/ref arr i]]] [return ret]]]
05v #{##[]
05v max
02i 0
10s start
04i 2
0Fs start
0D
05v min
05v array/length
10s arr
04i 1
10s end
04i 2
0Fs end
0D
05v array/allocate
05v max
02i 0
05v -
10s end
10s start
04i 2
04i 2
04i 1
0Es ret
0D
15
10s start
0Es i
0D
10s end
0Es ΓεnΣym-21
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-21
1E
0Bo 57
0D
05v array/set!
10s ret
05v -
10s i
10s start
04i 2
05v array/ref
10s arr
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -64
16
0D
10s ret
01
01
}
17
0Es array/cut
01
}#{##[]
05v :e
0Es avl/empty
0D
23s avl/empty?
05v [n]
05v #@[source: [[== :e n]]]
05v #{##[]
05v :e
10s n
20
01
}
17
0Es avl/empty?
0D
23s avl/default-cmp
05v [x y]
05v #@[source: [[if [< x y] -1 [if [> x y] 1 0]]]]
05v #{##[]
10s x
10s y
1E
0Bo 8
02i -1
09o 22
10s x
10s y
22
0Bo 8
02i 1
09o 5
02i 0
01
}
17
0Es avl/default-cmp
0D
23s avl/typecheck
05v [r k]
05v #@[source: [[or [avl/empty? [avl/root r]] [== [type-of k] [type-of [avl/key [avl/root r]]]] [throw [list :type-error "AVL trees can only contains keys of a single type" k [current-lambda]]]]]]
05v #{##[]
05v avl/empty?
05v avl/root
10s r
04i 1
04i 1
0C
0Ao 81
0D
05v type-of
10s k
04i 1
05v type-of
05v avl/key
05v avl/root
10s r
04i 1
04i 1
04i 1
20
0C
0Ao 43
0D
05v throw
05v list
05v :type-error
05v "AVL trees can only contains keys of a single type"
10s k
05v current-lambda
04i 0
04i 4
04i 1
0C
0Ao 8
0D
05v #f
01
}
17
0Es avl/typecheck
0D
23s avl/tree
05v [cmp]
05v #@[source: [[array/new avl/empty [or cmp avl/default-cmp]]]]
05v #{##[]
05v array/new
10s avl/empty
10s cmp
0C
0Ao 17
0D
10s avl/default-cmp
0C
0Ao 8
0D
05v #f
04i 2
01
}
17
0Es avl/tree
0D
23s avl/height
05v [n]
05v #@[source: [[if [avl/empty? n] 0 [array/ref n 0]]]]
05v #{##[]
05v avl/empty?
10s n
04i 1
0Bo 8
02i 0
09o 15
05v array/ref
10s n
02i 0
04i 2
01
}
17
0Es avl/height
0D
23s avl/key
05v [n]
05v #@[source: [[array/ref n 1]]]
05v #{##[]
05v array/ref
10s n
02i 1
04i 2
01
}
17
0Es avl/key
0D
23s avl/left
05v [n]
05v #@[source: [[array/ref n 2]]]
05v #{##[]
05v array/ref
10s n
02i 2
04i 2
01
}
17
0Es avl/left
0D
23s avl/right
05v [n]
05v #@[source: [[array/ref n 3]]]
05v #{##[]
05v array/ref
10s n
02i 3
04i 2
01
}
17
0Es avl/right
0D
23s avl/root
05v [r]
05v #@[source: [[array/ref r 0]]]
05v #{##[]
05v array/ref
10s r
02i 0
04i 2
01
}
17
0Es avl/root
0D
23s avl/cmp
05v [r]
05v #@[source: [[array/ref r 1]]]
05v #{##[]
05v array/ref
10s r
02i 1
04i 2
01
}
17
0Es avl/cmp
0D
23s avl/min-node
05v [n]
05v #@[source: [[if [avl/empty? n] avl/empty [let [[l [avl/left n]]] [if [avl/empty? l] n [avl/min-mode l]]]]]]
05v #{##[]
05v avl/empty?
10s n
04i 1
0Bo 10
10s avl/empty
09o 50
15
05v avl/left
10s n
04i 1
0Es l
0D
05v avl/empty?
10s l
04i 1
0Bo 10
10s n
09o 13
10s avl/min-mode
10s l
04i 1
16
01
}
17
0Es avl/min-node
0D
23s avl/update-left
05v [n l]
05v #@[source: [[array/set! [array/dup n] 2 l]]]
05v #{##[]
05v array/set!
05v array/dup
10s n
04i 1
02i 2
10s l
04i 3
01
}
17
0Es avl/update-left
0D
23s avl/update-right
05v [n r]
05v #@[source: [[array/set! [array/dup n] 3 r]]]
05v #{##[]
05v array/set!
05v array/dup
10s n
04i 1
02i 3
10s r
04i 3
01
}
17
0Es avl/update-right
0D
23s avl/update-key
05v [n k]
05v #@[source: [[array/set! [array/dup n] 1 k]]]
05v #{##[]
05v array/set!
05v array/dup
10s n
04i 1
02i 1
10s k
04i 3
01
}
17
0Es avl/update-key
0D
23s avl/update-root
05v [t r]
05v #@[source: [[array/set! [array/dup t] 0 r]]]
05v #{##[]
05v array/set!
05v array/dup
10s t
04i 1
02i 0
10s r
04i 3
01
}
17
0Es avl/update-root
0D
23s avl/update-height
05v [n]
05v #@[source: [[array/set! [array/dup n] 0 [+ 1 [max [avl/height [avl/left n]] [avl/height [avl/right n]]]]]]]
05v #{##[]
05v array/set!
05v array/dup
10s n
04i 1
02i 0
05v +
02i 1
05v max
05v avl/height
05v avl/left
10s n
04i 1
04i 1
05v avl/height
05v avl/right
10s n
04i 1
04i 1
04i 2
04i 2
04i 3
01
}
17
0Es avl/update-height
0D
23s avl/rotate-right
05v [y]
05v #@[source: [[let [[x [avl/left y]]] [avl/update-height [avl/update-right x [avl/update-height [avl/update-left y [avl/right x]]]]]]]]
05v #{##[]
15
05v avl/left
10s y
04i 1
0Es x
0D
05v avl/update-height
05v avl/update-right
10s x
05v avl/update-height
05v avl/update-left
10s y
05v avl/right
10s x
04i 1
04i 2
04i 1
04i 2
04i 1
16
01
}
17
0Es avl/rotate-right
0D
23s avl/rotate-left
05v [x]
05v #@[source: [[let [[y [avl/right x]]] [avl/update-height [avl/update-left y [avl/update-height [avl/update-right x [avl/left y]]]]]]]]
05v #{##[]
15
05v avl/right
10s x
04i 1
0Es y
0D
05v avl/update-height
05v avl/update-left
10s y
05v avl/update-height
05v avl/update-right
10s x
05v avl/left
10s y
04i 1
04i 2
04i 1
04i 2
04i 1
16
01
}
17
0Es avl/rotate-left
0D
23s avl/balance
05v [n]
05v #@[source: [[if [avl/empty? n] 0 [- [avl/height [avl/left n]] [avl/height [avl/right n]]]]]]
05v #{##[]
05v avl/empty?
10s n
04i 1
0Bo 8
02i 0
09o 41
05v -
05v avl/height
05v avl/left
10s n
04i 1
04i 1
05v avl/height
05v avl/right
10s n
04i 1
04i 1
04i 2
01
}
17
0Es avl/balance
0D
23s avl/insert-rebalance
05v [n cmp v]
05v #@[source: [[let [[b [avl/balance n]]] [cond [[> b 1] [case [cmp v [avl/key [avl/left n]]] [-1 [avl/rotate-right n]] [1 [avl/rotate-right [avl/update-left n [avl/rotate-left [avl/left n]]]]] [0 n]]] [[< b -1] [case [cmp v [avl/key [avl/right n]]] [1 [avl/rotate-left n]] [-1 [avl/rotate-left [avl/update-right n [avl/rotate-right [avl/right n]]]]] [0 n]]] [#t n]]]]]
05v #{##[]
15
05v avl/balance
10s n
04i 1
0Es b
0D
10s b
02i 1
22
0Bo 125
15
10s cmp
10s v
05v avl/key
05v avl/left
10s n
04i 1
04i 1
04i 2
0Es ΓεnΣym-31
0D
10s ΓεnΣym-31
02i -1
20
0Bo 16
05v avl/rotate-right
10s n
04i 1
09o 66
10s ΓεnΣym-31
02i 1
20
0Bo 38
05v avl/rotate-right
05v avl/update-left
10s n
05v avl/rotate-left
05v avl/left
10s n
04i 1
04i 1
04i 2
04i 1
09o 21
10s ΓεnΣym-31
02i 0
20
0Bo 10
10s n
09o 4
24
16
09o 150
10s b
02i -1
1E
0Bo 125
15
10s cmp
10s v
05v avl/key
05v avl/right
10s n
04i 1
04i 1
04i 2
0Es ΓεnΣym-32
0D
10s ΓεnΣym-32
02i 1
20
0Bo 16
05v avl/rotate-left
10s n
04i 1
09o 66
10s ΓεnΣym-32
02i -1
20
0Bo 38
05v avl/rotate-left
05v avl/update-right
10s n
05v avl/rotate-right
05v avl/right
10s n
04i 1
04i 1
04i 2
04i 1
09o 21
10s ΓεnΣym-32
02i 0
20
0Bo 10
10s n
09o 4
24
16
09o 18
05v #t
0Bo 10
10s n
09o 4
24
16
01
}
17
0Es avl/insert-rebalance
0D
23s avl/node-insert
05v [n cmp v]
05v #@[source: [[if [avl/empty? n] [array/new 1 v avl/empty avl/empty] [case [cmp v [avl/key n]] [-1 [avl/insert-rebalance [avl/update-height [avl/update-left n [avl/node-insert [avl/left n] cmp v]]] cmp v]] [1 [avl/insert-rebalance [avl/update-height [avl/update-right n [avl/node-insert [avl/right n] cmp v]]] cmp v]] [0 [avl/update-key n v]]]]]]
05v #{##[]
05v avl/empty?
10s n
04i 1
0Bo 26
05v array/new
02i 1
10s v
10s avl/empty
10s avl/empty
04i 4
09o 192
15
10s cmp
10s v
05v avl/key
10s n
04i 1
04i 2
0Es ΓεnΣym-33
0D
10s ΓεnΣym-33
02i -1
20
0Bo 60
05v avl/insert-rebalance
05v avl/update-height
05v avl/update-left
10s n
05v avl/node-insert
05v avl/left
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
04i 1
10s cmp
10s v
04i 3
09o 98
10s ΓεnΣym-33
02i 1
20
0Bo 60
05v avl/insert-rebalance
05v avl/update-height
05v avl/update-right
10s n
05v avl/node-insert
05v avl/right
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
04i 1
10s cmp
10s v
04i 3
09o 31
10s ΓεnΣym-33
02i 0
20
0Bo 20
05v avl/update-key
10s n
10s v
04i 2
09o 4
24
16
01
}
17
0Es avl/node-insert
0D
23s avl/insert
05v [t v]
05v #@[documentation: "Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" source: ["Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" [avl/typecheck t v] [avl/update-root t [avl/node-insert [avl/root t] [avl/cmp t] v]]]]
05v #{##[]
05v avl/typecheck
10s t
10s v
04i 2
0D
05v avl/update-root
10s t
05v avl/node-insert
05v avl/root
10s t
04i 1
05v avl/cmp
10s t
04i 1
10s v
04i 3
04i 2
01
}
17
0Es avl/insert
0D
23s avl/node-get
05v [n cmp v]
05v #@[source: [[if [avl/empty? n] #nil [case [cmp v [avl/key n]] [0 [avl/key n]] [-1 [avl/node-get [avl/left n] cmp v]] [1 [avl/node-get [avl/right n] cmp v]]]]]]
05v #{##[]
05v avl/empty?
10s n
04i 1
0Bo 7
24
09o 128
15
10s cmp
10s v
05v avl/key
10s n
04i 1
04i 2
0Es ΓεnΣym-34
0D
10s ΓεnΣym-34
02i 0
20
0Bo 16
05v avl/key
10s n
04i 1
09o 78
10s ΓεnΣym-34
02i -1
20
0Bo 30
05v avl/node-get
05v avl/left
10s n
04i 1
10s cmp
10s v
04i 3
09o 41
10s ΓεnΣym-34
02i 1
20
0Bo 30
05v avl/node-get
05v avl/right
10s n
04i 1
10s cmp
10s v
04i 3
09o 4
24
16
01
}
17
0Es avl/node-get
0D
23s avl/get
05v [t v]
05v #@[documentation: "Retrieve the key V from tree T, or #nil if V is not in it" source: ["Retrieve the key V from tree T, or #nil if V is not in it" [if [or [avl/empty? [avl/root t]] [!= [type-of v] [type-of [avl/key [avl/root t]]]]] #nil [avl/node-get [avl/root t] [avl/cmp t] v]]]]
05v #{##[]
05v avl/empty?
05v avl/root
10s t
04i 1
04i 1
0C
0Ao 51
0D
05v !=
05v type-of
10s v
04i 1
05v type-of
05v avl/key
05v avl/root
10s t
04i 1
04i 1
04i 1
04i 2
0C
0Ao 8
0D
05v #f
0Bo 7
24
09o 33
05v avl/node-get
05v avl/root
10s t
04i 1
05v avl/cmp
10s t
04i 1
10s v
04i 3
01
}
17
0Es avl/get
0D
23s avl/from-list
05v [l cmp]
05v #@[documentation: "Create a new avl tree using the keys in L and the comparison function CMP" source: ["Create a new avl tree using the keys in L and the comparison function CMP" [list/reduce l avl/insert [avl/tree cmp]]]]
05v #{##[]
05v list/reduce
10s l
10s avl/insert
05v avl/tree
10s cmp
04i 1
04i 3
01
}
17
0Es avl/from-list
0D
23s avl/remove-rebalance
05v [n]
05v #@[source: [[if [avl/empty? n] n [let [[b [avl/balance n]] [l [avl/left n]] [r [avl/right n]]] [cond [[> b 1] [if [>= [avl/balance l] 0] [avl/rotate-right n] [avl/rotate-right [avl/update-left n [avl/rotate-left l]]]]] [[< b -1] [if [<= [avl/balance r] 0] [avl/rotate-left n] [avl/rotate-left [avl/update-right n [avl/rotate-right r]]]]] [#t n]]]]]]
05v #{##[]
05v avl/empty?
10s n
04i 1
0Bo 10
10s n
09o 201
15
05v avl/balance
10s n
04i 1
0Es b
0D
05v avl/left
10s n
04i 1
0Es l
0D
05v avl/right
10s n
04i 1
0Es r
0D
10s b
02i 1
22
0Bo 61
05v avl/balance
10s l
04i 1
02i 0
21
0Bo 16
05v avl/rotate-right
10s n
04i 1
09o 29
05v avl/rotate-right
05v avl/update-left
10s n
05v avl/rotate-left
10s l
04i 1
04i 2
04i 1
09o 86
10s b
02i -1
1E
0Bo 61
05v avl/balance
10s r
04i 1
02i 0
1F
0Bo 16
05v avl/rotate-left
10s n
04i 1
09o 29
05v avl/rotate-left
05v avl/update-right
10s n
05v avl/rotate-right
10s r
04i 1
04i 2
04i 1
09o 18
05v #t
0Bo 10
10s n
09o 4
24
16
01
}
17
0Es avl/remove-rebalance
0D
23s avl/node-remove
05v [n cmp v]
05v #@[source: [[if [avl/empty? n] n [let [[root [case [cmp v [avl/key n]] [-1 [avl/update-left n [avl/node-remove [avl/left n] cmp v]]] [1 [avl/update-right n [avl/node-remove [avl/right n] cmp v]]] [0 [cond [[avl/empty? [avl/left n]] [avl/right n]] [[avl/empty? [avl/right n]] [avl/left n]] [#t [let [[k [avl/key [avl/min-node [avl/right n]]]]] [avl/update-key [avl/update-right [avl/right n] [avl/node-remove [avl/right n] cmp v]] k]]]]]]]] [set! root [avl/update-height root]] [avl/remove-rebalance root]]]]]
05v #{##[]
05v avl/empty?
10s n
04i 1
0Bo 10
10s n
09o 324
15
15
10s cmp
10s v
05v avl/key
10s n
04i 1
04i 2
0Es ΓεnΣym-35
0D
10s ΓεnΣym-35
02i -1
20
0Bo 40
05v avl/update-left
10s n
05v avl/node-remove
05v avl/left
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
09o 218
10s ΓεnΣym-35
02i 1
20
0Bo 40
05v avl/update-right
10s n
05v avl/node-remove
05v avl/right
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
09o 171
10s ΓεnΣym-35
02i 0
20
0Bo 160
05v avl/empty?
05v avl/left
10s n
04i 1
04i 1
0Bo 16
05v avl/right
10s n
04i 1
09o 125
05v avl/empty?
05v avl/right
10s n
04i 1
04i 1
0Bo 16
05v avl/left
10s n
04i 1
09o 93
05v #t
0Bo 85
15
05v avl/key
05v avl/min-node
05v avl/right
10s n
04i 1
04i 1
04i 1
0Es k
0D
05v avl/update-key
05v avl/update-right
05v avl/right
10s n
04i 1
05v avl/node-remove
05v avl/right
10s n
04i 1
10s cmp
10s v
04i 3
04i 2
10s k
04i 2
16
09o 4
24
09o 4
24
16
0Es root
0D
05v avl/update-height
10s root
04i 1
0Fs root
0D
05v avl/remove-rebalance
10s root
04i 1
16
01
}
17
0Es avl/node-remove
0D
23s avl/remove
05v [t v]
05v #@[documentation: "Remove the key V from tree T if it is contained within it" source: ["Remove the key V from tree T if it is contained within it" [avl/update-root t [avl/node-remove [avl/root t] [avl/cmp t] v]]]]
05v #{##[]
05v avl/update-root
10s t
05v avl/node-remove
05v avl/root
10s t
04i 1
05v avl/cmp
10s t
04i 1
10s v
04i 3
04i 2
01
}
17
0Es avl/remove
0D
23s avl/equal-node?
05v [a b]
05v #@[source: [[if [avl/empty? a] [avl/empty? b] [and [equal? [avl/key a] [avl/key b]] [avl/equal-node? [avl/left a] [avl/left b]] [avl/equal-node? [avl/right a] [avl/right b]]]]]]
05v #{##[]
05v avl/empty?
10s a
04i 1
0Bo 16
05v avl/empty?
10s b
04i 1
09o 91
05v equal?
05v avl/key
10s a
04i 1
05v avl/key
10s b
04i 1
04i 2
0C
0Bo 61
0D
05v avl/equal-node?
05v avl/left
10s a
04i 1
05v avl/left
10s b
04i 1
04i 2
0C
0Bo 30
0D
05v avl/equal-node?
05v avl/right
10s a
04i 1
05v avl/right
10s b
04i 1
04i 2
01
}
17
0Es avl/equal-node?
0D
23s avl/equal?
05v [a b]
05v #@[documentation: "Test if two avl trees are equal" source: ["Test if two avl trees are equal" [avl/equal-node? [avl/root a] [avl/root b]]]]
05v #{##[]
05v avl/equal-node?
05v avl/root
10s a
04i 1
05v avl/root
10s b
04i 1
04i 2
01
}
17
0Es avl/equal?
0D
23s avl/reduce-node
05v [node o s]
05v #@[source: [[if [avl/empty? node] s [o [avl/key node] [avl/reduce-node [avl/right node] o [avl/reduce-node [avl/left node] o s]]]]]]
05v #{##[]
05v avl/empty?
10s node
04i 1
0Bo 10
10s s
09o 63
10s o
05v avl/key
10s node
04i 1
05v avl/reduce-node
05v avl/right
10s node
04i 1
10s o
05v avl/reduce-node
05v avl/left
10s node
04i 1
10s o
10s s
04i 3
04i 3
04i 2
01
}
17
0Es avl/reduce-node
0D
23s avl/reduce
05v [t o s]
05v #@[documentation: "Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" source: ["Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" [avl/reduce-node [avl/root t] o s]]]
05v #{##[]
05v avl/reduce-node
05v avl/root
10s t
04i 1
10s o
10s s
04i 3
01
}
17
0Es avl/reduce
0D
23s avl/reduce-node-bin
05v [n o s]
05v #@[source: [[if [avl/empty? n] s [o [o [avl/key n] [avl/reduce-node-bin [avl/left n] o s]] [avl/reduce-node-bin [avl/right n] o s]]]]]
05v #{##[]
05v avl/empty?
10s n
04i 1
0Bo 10
10s s
09o 73
10s o
10s o
05v avl/key
10s n
04i 1
05v avl/reduce-node-bin
05v avl/left
10s n
04i 1
10s o
10s s
04i 3
04i 2
05v avl/reduce-node-bin
05v avl/right
10s n
04i 1
10s o
10s s
04i 3
04i 2
01
}
17
0Es avl/reduce-node-bin
0D
23s avl/reduce-bin
05v [t o s]
05v #@[documentation: "Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" source: ["Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" [avl/reduce-node-bin [avl/root t] o s]]]
05v #{##[]
05v avl/reduce-node-bin
05v avl/root
10s t
04i 1
10s o
10s s
04i 3
01
}
17
0Es avl/reduce-bin
0D
23s avl/map
05v [t f]
05v #@[documentation: "Create a new avl tree by mapping each key in T using F, using the same comparison function as T" source: ["Create a new avl tree by mapping each key in T using F, using the same comparison function as T" [avl/reduce t [fn [x acc] [avl/insert acc [f x]]] [avl/tree [avl/cmp t]]]]]
05v #{##[]
05v avl/reduce
10s t
23s anonymous
05v [x acc]
05v #@[source: [[avl/insert acc [f x]]]]
05v #{##[]
05v avl/insert
10s acc
10s f
10s x
04i 1
04i 2
01
}
17
05v avl/tree
05v avl/cmp
10s t
04i 1
04i 1
04i 3
01
}
17
0Es avl/map
0D
23s avl/map-to
05v [t f cmp]
05v #@[documentation: "Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" source: ["Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" [avl/reduce t [fn [x acc] [avl/insert acc [f x]]] [avl/tree cmp]]]]
05v #{##[]
05v avl/reduce
10s t
23s anonymous
05v [x acc]
05v #@[source: [[avl/insert acc [f x]]]]
05v #{##[]
05v avl/insert
10s acc
10s f
10s x
04i 1
04i 2
01
}
17
05v avl/tree
10s cmp
04i 1
04i 3
01
}
17
0Es avl/map-to
0D
23s avl/to-list
05v [t]
05v #@[source: [[avl/reduce t cons #nil]]]
05v #{##[]
05v avl/reduce
10s t
10s cons
24
04i 3
01
}
17
0Es avl/to-list
01
}#{##[]
23s sum
05v [c]
05v #@[documentation: "Return the sum of every value in collection C" source: ["Return the sum of every value in collection C" [reduce c + 0]]]
05v #{##[]
05v reduce
10s c
10s +
02i 0
04i 3
01
}
17
0Es sum
0D
23s join
05v [l glue]
05v #@[documentation: "Join every element of α together into a string with GLUE inbetween" source: ["Join every element of α together into a string with GLUE inbetween" [when-not glue [set! glue ""]] [if-not l "" [reduce l [fn [a b] [if a [cat a glue b] b]] #nil]]]]
05v #{##[]
10s glue
0Bo 7
24
09o 11
05v ""
0Fs glue
0D
10s l
0Bo 34
05v reduce
10s l
23s anonymous
05v [a b]
05v #@[source: [[if a [cat a glue b] b]]]
05v #{##[]
10s a
0Bo 24
05v cat
10s a
10s glue
10s b
04i 3
09o 7
10s b
01
}
17
24
04i 3
09o 7
05v ""
01
}
17
0Es join
0D
23s for-each
05v [l f]
05v #@[documentation: "Runs F over every item in collection L" source: ["Runs F over every item in collection L" [reduce l [fn [a b] [f b]] #nil]]]
05v #{##[]
05v reduce
10s l
23s anonymous
05v [a b]
05v #@[source: [[f b]]]
05v #{##[]
10s f
10s b
04i 1
01
}
17
24
04i 3
01
}
17
0Es for-each
0D
23s count
05v [l p]
05v #@[documentation: "Count the number of items in L where P is true" source: ["Count the number of items in L where P is true" [if p [reduce l [fn [a b] [+ a [if [p b] 1 0]]] 0] [reduce l [fn [a b] [+ a 1]] 0]]]]
05v #{##[]
10s p
0Bo 35
05v reduce
10s l
23s anonymous
05v [a b]
05v #@[source: [[+ a [if [p b] 1 0]]]]
05v #{##[]
05v +
10s a
10s p
10s b
04i 1
0Bo 8
02i 1
09o 5
02i 0
04i 2
01
}
17
02i 0
04i 3
09o 32
05v reduce
10s l
23s anonymous
05v [a b]
05v #@[source: [[+ a 1]]]
05v #{##[]
05v +
10s a
02i 1
04i 2
01
}
17
02i 0
04i 3
01
}
17
0Es count
0D
23s min
23s l
05v #@[documentation: "Returns the minimum value of its arguments, or collection" source: ["Returns the minimum value of its arguments, or collection" [reduce [if [cdr l] l [car l]] [fn [a b] [if [< a b] a b]]]]]
05v #{##[]
05v reduce
10s l
12
0Bo 10
10s l
09o 8
10s l
11
23s anonymous
05v [a b]
05v #@[source: [[if [< a b] a b]]]
05v #{##[]
10s a
10s b
1E
0Bo 10
10s a
09o 7
10s b
01
}
17
04i 2
01
}
17
0Es min
0D
23s max
23s l
05v #@[documentation: "Returns the minimum value of its arguments, or collection" source: ["Returns the minimum value of its arguments, or collection" [reduce [if [cdr l] l [car l]] [fn [a b] [if [> a b] a b]]]]]
05v #{##[]
05v reduce
10s l
12
0Bo 10
10s l
09o 8
10s l
11
23s anonymous
05v [a b]
05v #@[source: [[if [> a b] a b]]]
05v #{##[]
10s a
10s b
22
0Bo 10
10s a
09o 7
10s b
01
}
17
04i 2
01
}
17
0Es max
0D
23s delete
05v [l e]
05v #@[documentation: "Returns a filtered list l with all elements equal to e omitted" source: ["Returns a filtered list l with all elements equal to e omitted" [filter l [fn [a] [not [== a e]]]]]]
05v #{##[]
05v filter
10s l
23s anonymous
05v [a]
05v #@[source: [[not [== a e]]]]
05v #{##[]
10s a
10s e
20
0Bo 10
05v #f
09o 7
05v #t
01
}
17
04i 2
01
}
17
0Es delete
0D
23s remove
05v [l p]
05v #@[documentation: "Returns a filtered list l with all elements where P equal true removed" source: ["Returns a filtered list l with all elements where P equal true removed" [filter l [fn [a] [not [p a]]]]]]
05v #{##[]
05v filter
10s l
23s anonymous
05v [a]
05v #@[source: [[not [p a]]]]
05v #{##[]
10s p
10s a
04i 1
0Bo 10
05v #f
09o 7
05v #t
01
}
17
04i 2
01
}
17
0Es remove
0D
23s flatten/λ
05v [a b]
05v #@[source: [[cond [[collection? b] [append [reduce b flatten/λ #nil] a]] [#t [cons b a]]]]]
05v #{##[]
05v collection?
10s b
04i 1
0Bo 31
05v append
05v reduce
10s b
10s flatten/λ
24
04i 3
10s a
04i 2
09o 23
05v #t
0Bo 15
10s b
10s a
14
09o 4
24
01
}
17
0Es flatten/λ
0D
23s flatten
05v [l]
05v #@[documentation: "Flatten a collection of collections into a simple list" source: ["Flatten a collection of collections into a simple list" [if-not [collection? l] l [nreverse [reduce l flatten/λ #nil]]]]]
05v #{##[]
05v collection?
10s l
04i 1
0Bo 27
05v nreverse
05v reduce
10s l
10s flatten/λ
24
04i 3
04i 1
09o 7
10s l
01
}
17
0Es flatten
01
}#{##[]
23s ref
05v [l i]
05v #@[documentation: "Return whatver is at position I in L" source: ["Return whatver is at position I in L" [case [type-of l] [:nil #nil] [:tree [tree/ref l i]] [:string [char-at l i]] [:array [array/ref l i]] [:pair [list/ref l i]] [otherwise [throw [list :type-error "You can only use ref with a collection" l [current-lambda]]]]]]]
05v #{##[]
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-45
0D
10s ΓεnΣym-45
05v :nil
20
0Bo 7
24
09o 149
10s ΓεnΣym-45
05v :tree
20
0Bo 20
05v tree/ref
10s l
10s i
04i 2
09o 120
10s ΓεnΣym-45
05v :string
20
0Bo 20
05v char-at
10s l
10s i
04i 2
09o 91
10s ΓεnΣym-45
05v :array
20
0Bo 20
05v array/ref
10s l
10s i
04i 2
09o 62
10s ΓεnΣym-45
05v :pair
20
0Bo 20
05v list/ref
10s l
10s i
04i 2
09o 33
05v throw
05v list
05v :type-error
05v "You can only use ref with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es ref
0D
23s filter
05v [l p]
05v #@[documentation: "Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" source: ["Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" [case [type-of l] [:nil #nil] [:tree [tree/filter l p]] [:pair [list/filter l p]] [:array [array/filter l p]] [otherwise [throw [list :type-error "You can only use filter with a collection" l [current-lambda]]]]]]]
05v #{##[]
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-46
0D
10s ΓεnΣym-46
05v :nil
20
0Bo 7
24
09o 120
10s ΓεnΣym-46
05v :tree
20
0Bo 20
05v tree/filter
10s l
10s p
04i 2
09o 91
10s ΓεnΣym-46
05v :pair
20
0Bo 20
05v list/filter
10s l
10s p
04i 2
09o 62
10s ΓεnΣym-46
05v :array
20
0Bo 20
05v array/filter
10s l
10s p
04i 2
09o 33
05v throw
05v list
05v :type-error
05v "You can only use filter with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es filter
0D
23s reduce
05v [l f α]
05v #@[documentation: "Combine all elements in collection l using operation F and starting value α" source: ["Combine all elements in collection l using operation F and starting value α" [case [type-of l] [:nil α] [:tree [tree/reduce l f α]] [:pair [list/reduce l f α]] [:array [array/reduce l f α]] [otherwise [f α l]]]]]
05v #{##[]
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-47
0D
10s ΓεnΣym-47
05v :nil
20
0Bo 10
10s α
09o 116
10s ΓεnΣym-47
05v :tree
20
0Bo 24
05v tree/reduce
10s l
10s f
10s α
04i 3
09o 83
10s ΓεnΣym-47
05v :pair
20
0Bo 24
05v list/reduce
10s l
10s f
10s α
04i 3
09o 50
10s ΓεnΣym-47
05v :array
20
0Bo 24
05v array/reduce
10s l
10s f
10s α
04i 3
09o 17
10s f
10s α
10s l
04i 2
16
01
}
17
0Es reduce
0D
23s length
05v [α]
05v #@[documentation: "Returns the length of collection α" source: ["Returns the length of collection α" [case [type-of α] [:nil 0] [:array [array/length α]] [:pair [list/length α]] [:string [string/length α]] [:tree [tree/size α]] [otherwise [throw [list :type-error "You can only use length with a collection" α [current-lambda]]]]]]]
05v #{##[]
15
05v type-of
10s α
04i 1
0Es ΓεnΣym-48
0D
10s ΓεnΣym-48
05v :nil
20
0Bo 8
02i 0
09o 133
10s ΓεnΣym-48
05v :array
20
0Bo 16
05v array/length
10s α
04i 1
09o 108
10s ΓεnΣym-48
05v :pair
20
0Bo 16
05v list/length
10s α
04i 1
09o 83
10s ΓεnΣym-48
05v :string
20
0Bo 16
05v string/length
10s α
04i 1
09o 58
10s ΓεnΣym-48
05v :tree
20
0Bo 16
05v tree/size
10s α
04i 1
09o 33
05v throw
05v list
05v :type-error
05v "You can only use length with a collection"
10s α
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es length
0D
23s map
05v [l f]
05v #@[documentation: "Runs f over every item in collection l and returns the resulting list" source: ["Runs f over every item in collection l and returns the resulting list" [case [type-of l] [:nil #nil] [:pair [list/map l f]] [:array [array/map l f]] [otherwise [throw [list :type-error "You can only use map with a collection" l [current-lambda]]]]]]]
05v #{##[]
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-49
0D
10s ΓεnΣym-49
05v :nil
20
0Bo 7
24
09o 91
10s ΓεnΣym-49
05v :pair
20
0Bo 20
05v list/map
10s l
10s f
04i 2
09o 62
10s ΓεnΣym-49
05v :array
20
0Bo 20
05v array/map
10s l
10s f
04i 2
09o 33
05v throw
05v list
05v :type-error
05v "You can only use map with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es map
0D
23s sort
05v [l]
05v #@[documentation: "Sorts the collection L" source: ["Sorts the collection L" [case [type-of l] [:nil #nil] [:pair [list/sort l]] [:array [array/sort l]] [otherwise [throw [list :type-error "You can only use sort with a collection" l [current-lambda]]]]]]]
05v #{##[]
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-50
0D
10s ΓεnΣym-50
05v :nil
20
0Bo 7
24
09o 83
10s ΓεnΣym-50
05v :pair
20
0Bo 16
05v list/sort/merge
10s l
04i 1
09o 58
10s ΓεnΣym-50
05v :array
20
0Bo 16
05v array/heap-sort
10s l
04i 1
09o 33
05v throw
05v list
05v :type-error
05v "You can only use sort with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es sort
0D
23s member
05v [l m]
05v #@[documentation: "Returns the first pair/item of collection l whose car is equal to m" source: ["Returns the first pair/item of collection l whose car is equal to m" [case [type-of l] [:pair [list/member l m]] [otherwise [throw [list :type-error "You can only use member with a collection" l [current-lambda]]]]]]]
05v #{##[]
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-51
0D
10s ΓεnΣym-51
05v :pair
20
0Bo 20
05v list/member
10s l
10s m
04i 2
09o 33
05v throw
05v list
05v :type-error
05v "You can only use member with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es member
0D
23s cut
05v [l start end]
05v #@[documentation: "Return a subcollection of L from START to END" source: ["Return a subcollection of L from START to END" [case [type-of l] [:array [array/cut l start end]] [:pair [list/cut l start end]] [:string [string/cut l start end]] [otherwise [throw [list :type-error "You can only use member with a collection" l [current-lambda]]]]]]]
05v #{##[]
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-52
0D
10s ΓεnΣym-52
05v :array
20
0Bo 24
05v array/cut
10s l
10s start
10s end
04i 3
09o 99
10s ΓεnΣym-52
05v :pair
20
0Bo 24
05v list/cut
10s l
10s start
10s end
04i 3
09o 66
10s ΓεnΣym-52
05v :string
20
0Bo 24
05v string/cut
10s l
10s start
10s end
04i 3
09o 33
05v throw
05v list
05v :type-error
05v "You can only use member with a collection"
10s l
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es cut
0D
23s collection?
05v [l]
05v #@[source: [[case [type-of l] [[:pair :array :tree] #t] [otherwise #f]]]]
05v #{##[]
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-53
0D
10s ΓεnΣym-53
05v :pair
20
0C
0Ao 36
0D
10s ΓεnΣym-53
05v :array
20
0C
0Ao 22
0D
10s ΓεnΣym-53
05v :tree
20
0C
0Ao 8
0D
05v #f
0Bo 10
05v #t
09o 7
05v #f
16
01
}
17
0Es collection?
01
}#{##[]
23s array->list
05v [arr]
05v #@[source: [[def i [- [array/length arr] 1]] [def ret #nil] [while [>= i 0] [set! ret [cons [array/ref arr i] ret]] [-- i]] [return ret]]]
05v #{##[]
05v -
05v array/length
10s arr
04i 1
02i 1
04i 2
0Es i
0D
24
0Es ret
0D
02i 0
1B
1C
10s i
02i 0
21
0Bo 47
0D
05v array/ref
10s arr
10s i
04i 2
10s ret
14
0Fs ret
0D
05v +
02i -1
10s i
04i 2
0Fs i
09o -52
0D
10s ret
01
01
}
17
0Es array->list
0D
23s except-last-pair/iter
05v [list rest]
05v #@[documentation: "Iterator for except-last-pair" source: ["Iterator for except-last-pair" [if [nil? [cdr list]] [reverse rest] [except-last-pair/iter [cdr list] [cons [car list] rest]]]]]
05v #{##[]
05v nil?
10s list
12
04i 1
0Bo 16
05v reverse
10s rest
04i 1
09o 24
05v except-last-pair/iter
10s list
12
10s list
11
10s rest
14
04i 2
01
}
17
0Es except-last-pair/iter
0D
23s except-last-pair
05v [list]
05v #@[documentation: "Return a copy of LIST without the last pair" source: ["Return a copy of LIST without the last pair" [except-last-pair/iter list #nil]]]
05v #{##[]
05v except-last-pair/iter
10s list
24
04i 2
01
}
17
0Es except-last-pair
0D
23s last-pair
05v [list]
05v #@[documentation: "Return the last pair of LIST" source: ["Return the last pair of LIST" [while [cdr list] [cdr! list]] list]]
05v #{##[]
02i 0
1B
1C
10s list
12
0Bo 16
0D
10s list
12
0Fs list
09o -19
0D
10s list
01
}
17
0Es last-pair
0D
23s make-list
05v [number value]
05v #@[documentation: "Return a list of NUMBER elements containing VALUE in every car" source: ["Return a list of NUMBER elements containing VALUE in every car" [def list #nil] [while [>= [-- number] 0] [set! list [cons value list]]] list]]
05v #{##[]
24
0Es list
0D
02i 0
1B
1C
05v +
02i -1
10s number
04i 2
0Fs number
02i 0
21
0Bo 20
0D
10s value
10s list
14
0Fs list
09o -37
0D
10s list
01
}
17
0Es make-list
0D
23s range
05v [end start step]
05v #@[documentation: "Return a list containing values from START (inclusive) to END (exclusive) by STEP" source: ["Return a list containing values from START (inclusive) to END (exclusive) by STEP" [when-not end [throw [list :arity-error "[range] needs at least a specific end"]]] [when-not start [set! start 0]] [when-not step [set! step 1]] [def pred [if [pos? step] < >]] [def ret #nil] [while [pred start end] [set! ret [cons start ret]] [set! start [+ start step]]] [nreverse ret]]]
05v #{##[]
10s end
0Bo 7
24
09o 23
05v throw
05v list
05v :arity-error
05v "[range] needs at least a specific end"
04i 2
04i 1
0D
10s start
0Bo 7
24
09o 9
02i 0
0Fs start
0D
10s step
0Bo 7
24
09o 9
02i 1
0Fs step
0D
10s step
05v 0.0
21
0Bo 10
10s <
09o 7
10s >
0Es pred
0D
24
0Es ret
0D
02i 0
1B
1C
10s pred
10s start
10s end
04i 2
0Bo 39
0D
10s start
10s ret
14
0Fs ret
0D
05v +
10s start
10s step
04i 2
0Fs start
09o -51
0D
05v nreverse
10s ret
04i 1
01
}
17
0Es range
0D
23s list/reduce
05v [l o s]
05v #@[documentation: "Combine all elements in l using operation o and starting value s" source: ["Combine all elements in l using operation o and starting value s" [for-in [e l] [set! s [o s e]]] s]]
05v #{##[]
15
10s l
0Es ΓεnΣym-60
0D
10s ΓεnΣym-60
0Bo 59
02i 0
1B
1C
10s ΓεnΣym-60
0Bo 45
0D
10s ΓεnΣym-60
11
0Es e
0D
10s o
10s s
10s e
04i 2
0Fs s
0D
10s ΓεnΣym-60
12
0Fs ΓεnΣym-60
09o -47
09o 4
24
16
0D
10s s
01
}
17
0Es list/reduce
0D
23s list/ref
05v [l i]
05v #@[documentation: "Returns the the element of list l at location i" source: ["Returns the the element of list l at location i" [while [and l [> i 0]] [-- i] [cdr! l]] [car l]]]
05v #{##[]
02i 0
1B
1C
10s l
0C
0Bo 11
0D
10s i
02i 0
22
0Bo 33
0D
05v +
02i -1
10s i
04i 2
0Fs i
0D
10s l
12
0Fs l
09o -47
0D
10s l
11
01
}
17
0Es list/ref
0D
23s reverse
05v [l]
05v #@[documentation: "Return the list l in reverse order" source: ["Return the list l in reverse order" [def ret] [for-in [e l] [set! ret [cons e ret]]] ret]]
05v #{##[]
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-61
0D
10s ΓεnΣym-61
0Bo 54
02i 0
1B
1C
10s ΓεnΣym-61
0Bo 40
0D
10s ΓεnΣym-61
11
0Es e
0D
10s e
10s ret
14
0Fs ret
0D
10s ΓεnΣym-61
12
0Fs ΓεnΣym-61
09o -42
09o 4
24
16
0D
10s ret
01
}
17
0Es reverse
0D
23s list/length
05v [l]
05v #@[documentation: "Returns the length of list l" source: ["Returns the length of list l" [def ret 0] [for-in [e l] [++ ret]] ret]]
05v #{##[]
02i 0
0Es ret
0D
15
10s l
0Es ΓεnΣym-62
0D
10s ΓεnΣym-62
0Bo 57
02i 0
1B
1C
10s ΓεnΣym-62
0Bo 43
0D
10s ΓεnΣym-62
11
0Es e
0D
05v +
02i 1
10s ret
04i 2
0Fs ret
0D
10s ΓεnΣym-62
12
0Fs ΓεnΣym-62
09o -45
09o 4
24
16
0D
10s ret
01
}
17
0Es list/length
0D
23s list/filter
05v [l p]
05v #@[documentation: "Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" source: ["Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" [def ret #nil] [for-in [e l] [when [p e] [set! ret [cons e ret]]]] [nreverse ret]]]
05v #{##[]
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-63
0D
10s ΓεnΣym-63
0Bo 71
02i 0
1B
1C
10s ΓεnΣym-63
0Bo 57
0D
10s ΓεnΣym-63
11
0Es e
0D
10s p
10s e
04i 1
0Bo 19
10s e
10s ret
14
0Fs ret
09o 4
24
0D
10s ΓεnΣym-63
12
0Fs ΓεnΣym-63
09o -59
09o 4
24
16
0D
05v nreverse
10s ret
04i 1
01
}
17
0Es list/filter
0D
23s list/map
05v [l f]
05v #@[documentation: "Runs f over every item in list l and returns the resulting list" source: ["Runs f over every item in list l and returns the resulting list" [def ret #nil] [for-in [e l] [set! ret [cons [f e] ret]]] [nreverse ret]]]
05v #{##[]
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-64
0D
10s ΓεnΣym-64
0Bo 60
02i 0
1B
1C
10s ΓεnΣym-64
0Bo 46
0D
10s ΓεnΣym-64
11
0Es e
0D
10s f
10s e
04i 1
10s ret
14
0Fs ret
0D
10s ΓεnΣym-64
12
0Fs ΓεnΣym-64
09o -48
09o 4
24
16
0D
05v nreverse
10s ret
04i 1
01
}
17
0Es list/map
0D
23s append
05v [a b]
05v #@[documentation: "Appends two lists A and B together" source: ["Appends two lists A and B together" [def ret b] [set! a [reverse a]] [for-in [t a] [set! ret [cons t ret]]] ret]]
05v #{##[]
10s b
0Es ret
0D
05v reverse
10s a
04i 1
0Fs a
0D
15
10s a
0Es ΓεnΣym-65
0D
10s ΓεnΣym-65
0Bo 54
02i 0
1B
1C
10s ΓεnΣym-65
0Bo 40
0D
10s ΓεnΣym-65
11
0Es t
0D
10s t
10s ret
14
0Fs ret
0D
10s ΓεnΣym-65
12
0Fs ΓεnΣym-65
09o -42
09o 4
24
16
0D
10s ret
01
}
17
0Es append
0D
23s sublist
05v [l start end ret]
05v #@[documentation: "Returns a new list containing all elements of l from start to end" source: ["Returns a new list containing all elements of l from start to end" [cond [[nil? l] [reverse ret]] [[neg? end] [sublist l start [+ [length l] end]]] [[zero? end] [reverse ret]] [[> start 0] [sublist [cdr l] [+ -1 start] [+ -1 end] #nil]] [[> end 0] [sublist [cdr l] 0 [+ -1 end] [cons [car l] ret]]]]]]
05v #{##[]
05v nil?
10s l
04i 1
0Bo 16
05v reverse
10s ret
04i 1
09o 173
10s end
05v 0.0
1E
0Bo 40
05v sublist
10s l
10s start
05v +
05v length
10s l
04i 1
10s end
04i 2
04i 3
09o 124
02i 0
10s end
20
0Bo 16
05v reverse
10s ret
04i 1
09o 101
10s start
02i 0
22
0Bo 42
05v sublist
10s l
12
05v +
02i -1
10s start
04i 2
05v +
02i -1
10s end
04i 2
24
04i 4
09o 52
10s end
02i 0
22
0Bo 41
05v sublist
10s l
12
02i 0
05v +
02i -1
10s end
04i 2
10s l
11
10s ret
14
04i 4
09o 4
24
01
}
17
0Es sublist
0D
23s list-head
05v [l k]
05v #@[documentation: "Returns the first k elements of list l" source: ["Returns the first k elements of list l" [sublist l 0 k]]]
05v #{##[]
05v sublist
10s l
02i 0
10s k
04i 3
01
}
17
0Es list-head
0D
23s list-tail
05v [l k]
05v #@[documentation: "Returns the sublist of l obtained by omitting the first l elements" source: ["Returns the sublist of l obtained by omitting the first l elements" [sublist l k [length l]]]]
05v #{##[]
05v sublist
10s l
10s k
05v length
10s l
04i 1
04i 3
01
}
17
0Es list-tail
0D
23s list/member
05v [l m]
05v #@[documentation: "Returns the first pair of list l whose car is equal to m" source: ["Returns the first pair of list l whose car is equal to m" [cond [[nil? l] #f] [[== [car l] m] l] [#t [list/member [cdr l] m]]]]]
05v #{##[]
05v nil?
10s l
04i 1
0Bo 10
05v #f
09o 49
10s l
11
10s m
20
0Bo 10
10s l
09o 29
05v #t
0Bo 21
05v list/member
10s l
12
10s m
04i 2
09o 4
24
01
}
17
0Es list/member
0D
23s getf
05v [l key]
05v #@[documentation: "Return the value in LIST following KEY" source: ["Return the value in LIST following KEY" [cond [[nil? l] #nil] [[== key [car l]] [cadr l]] [#t [getf [cdr l] key]]]]]
05v #{##[]
05v nil?
10s l
04i 1
0Bo 7
24
09o 51
10s key
10s l
11
20
0Bo 12
10s l
12
11
09o 29
05v #t
0Bo 21
05v getf
10s l
12
10s key
04i 2
09o 4
24
01
}
17
0Es getf
0D
23s list/sort/bubble
05v [l]
05v #@[documentation: "Terribly slow way to sort a list, though it was simple to write" source: ["Terribly slow way to sort a list, though it was simple to write" [if-not l #nil [do [def top [car l]] [def next #nil] [cdr! l] [while l [if [<= [car l] top] [do [set! next [cons top next]] [set! top [car l]]] [set! next [cons [car l] next]]] [cdr! l]] [cons top [list/sort/bubble next]]]]]]
05v #{##[]
10s l
0Bo 126
10s l
11
0Es top
0D
24
0Es next
0D
10s l
12
0Fs l
0D
02i 0
1B
1C
10s l
0Bo 70
0D
10s l
11
10s top
1F
0Bo 29
10s top
10s next
14
0Fs next
0D
10s l
11
0Fs top
09o 17
10s l
11
10s next
14
0Fs next
0D
10s l
12
0Fs l
09o -72
0D
10s top
05v list/sort/bubble
10s next
04i 1
14
09o 4
24
01
}
17
0Es list/sort/bubble
0D
23s list/merge-sorted-lists
05v [l1 l2]
05v #@[source: [[cond [[nil? l1] l2] [[nil? l2] l1] [#t [if [< [car l1] [car l2]] [cons [car l1] [list/merge-sorted-lists [cdr l1] l2]] [cons [car l2] [list/merge-sorted-lists l1 [cdr l2]]]]]]]]
05v #{##[]
05v nil?
10s l1
04i 1
0Bo 10
10s l2
09o 93
05v nil?
10s l2
04i 1
0Bo 10
10s l1
09o 73
05v #t
0Bo 65
10s l1
11
10s l2
11
1E
0Bo 27
10s l1
11
05v list/merge-sorted-lists
10s l1
12
10s l2
04i 2
14
09o 24
10s l2
11
05v list/merge-sorted-lists
10s l1
10s l2
12
04i 2
14
09o 4
24
01
}
17
0Es list/merge-sorted-lists
0D
23s list/split-half-rec
05v [l acc1 acc2]
05v #@[source: [[cond [[nil? l] [cons acc1 acc2]] [[nil? [cdr l]] [cons [cons [car l] acc1] acc2]] [#t [list/split-half-rec [cddr l] [cons [car l] acc1] [cons [cadr l] acc2]]]]]]
05v #{##[]
05v nil?
10s l
04i 1
0Bo 15
10s acc1
10s acc2
14
09o 79
05v nil?
10s l
12
04i 1
0Bo 21
10s l
11
10s acc1
14
10s acc2
14
09o 47
05v #t
0Bo 39
05v list/split-half-rec
10s l
12
12
10s l
11
10s acc1
14
10s l
12
11
10s acc2
14
04i 3
09o 4
24
01
}
17
0Es list/split-half-rec
0D
23s list/split-half
05v [l]
05v #@[source: [[list/split-half-rec l #nil #nil]]]
05v #{##[]
05v list/split-half-rec
10s l
24
24
04i 3
01
}
17
0Es list/split-half
0D
23s list/sort/merge
05v [l]
05v #@[documentation: "Sorts a list" source: ["Sorts a list" [if [nil? [cdr l]] l [do [def parts [list/split-half l]] [list/merge-sorted-lists [list/sort/merge [car parts]] [list/sort/merge [cdr parts]]]]]]]
05v #{##[]
05v nil?
10s l
12
04i 1
0Bo 10
10s l
09o 46
05v list/split-half
10s l
04i 1
0Es parts
0D
05v list/merge-sorted-lists
05v list/sort/merge
10s parts
11
04i 1
05v list/sort/merge
10s parts
12
04i 1
04i 2
01
}
17
0Es list/sort/merge
0D
10s list/sort/merge
0Es list/sort
0D
23s list?
05v [a]
05v #@[documentation: "Return #t is A is a proper list" source: ["Return #t is A is a proper list" [when-not a [return #f]] [while a [when-not [pair? a] [return #f]] [cdr! a]] [return #t]]]
05v #{##[]
10s a
0Bo 7
24
09o 8
05v #f
01
0D
02i 0
1B
1C
10s a
0Bo 39
0D
05v pair?
10s a
04i 1
0Bo 7
24
09o 8
05v #f
01
0D
10s a
12
0Fs a
09o -41
0D
05v #t
01
01
}
17
0Es list?
0D
23s list/equal?
05v [a b]
05v #@[documentation: "#t if A and B are equal" source: ["#t if A and B are equal" [if [pair? a] [and [list/equal? [car a] [car b]] [list/equal? [cdr a] [cdr b]]] [equal? a b]]]]
05v #{##[]
05v pair?
10s a
04i 1
0Bo 43
05v list/equal?
10s a
11
10s b
11
04i 2
0C
0Bo 20
0D
05v list/equal?
10s a
12
10s b
12
04i 2
09o 17
05v equal?
10s a
10s b
04i 2
01
}
17
0Es list/equal?
0D
23s list/take
05v [l count]
05v #@[documentation: "Take the first COUNT elements from list L" source: ["Take the first COUNT elements from list L" [if [<= count 0] #nil [cons [car l] [list/take [cdr l] [- count 1]]]]]]
05v #{##[]
10s count
02i 0
1F
0Bo 7
24
09o 32
10s l
11
05v list/take
10s l
12
05v -
10s count
02i 1
04i 2
04i 2
14
01
}
17
0Es list/take
0D
23s list/drop
05v [l count]
05v #@[documentation: "Drop the final COUNT elements from list L" source: ["Drop the final COUNT elements from list L" [if [<= count 0] l [list/drop [cdr l] [- count 1]]]]]
05v #{##[]
10s count
02i 0
1F
0Bo 10
10s l
09o 26
05v list/drop
10s l
12
05v -
10s count
02i 1
04i 2
04i 2
01
}
17
0Es list/drop
0D
23s list/cut
05v [l start end]
05v #@[documentation: "Return a subsequence of L from START to END" source: ["Return a subsequence of L from START to END" [list/take [list/drop l [max 0 start]] [- end [max 0 start]]]]]
05v #{##[]
05v list/take
05v list/drop
10s l
05v max
02i 0
10s start
04i 2
04i 2
05v -
10s end
05v max
02i 0
10s start
04i 2
04i 2
04i 2
01
}
17
0Es list/cut
0D
23s list/replace
05v [l search-for replace-with]
05v #@[documentation: "Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH\nUses [equal?] so we can search/replace lists/trees and other complex data structures" source: ["Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH" "" "Uses [equal?] so we can search/replace lists/trees and other complex data structures" [cond [[not l] #nil] [[equal? l search-for] replace-with] [[equal? [car l] search-for] [cons replace-with [list/replace [cdr l] search-for replace-with]]] [#t [cons [if [pair? [car l]] [list/replace [car l] search-for replace-with] [car l]] [list/replace [cdr l] search-for replace-with]]]]]]
05v #{##[]
10s l
0Bo 10
05v #f
09o 7
05v #t
0Bo 7
24
09o 144
05v equal?
10s l
10s search-for
04i 2
0Bo 10
10s replace-with
09o 120
05v equal?
10s l
11
10s search-for
04i 2
0Bo 30
10s replace-with
05v list/replace
10s l
12
10s search-for
10s replace-with
04i 3
14
09o 75
05v #t
0Bo 67
05v pair?
10s l
11
04i 1
0Bo 25
05v list/replace
10s l
11
10s search-for
10s replace-with
04i 3
09o 8
10s l
11
05v list/replace
10s l
12
10s search-for
10s replace-with
04i 3
14
09o 4
24
01
}
17
0Es list/replace
01
}#{##[]
23s tree/zip
05v [keys values]
05v #@[documentation: "Return a tree where KEYS point to VALUES" source: ["Return a tree where KEYS point to VALUES" [def ret [tree/new #nil]] [for-in [key keys] [tree/set! ret key [car values]] [cdr! values]] ret]]
05v #{##[]
05v tree/new
24
04i 1
0Es ret
0D
15
10s keys
0Es ΓεnΣym-68
0D
10s ΓεnΣym-68
0Bo 70
02i 0
1B
1C
10s ΓεnΣym-68
0Bo 56
0D
10s ΓεnΣym-68
11
0Es key
0D
05v tree/set!
10s ret
10s key
10s values
11
04i 3
0D
10s values
12
0Fs values
0D
10s ΓεnΣym-68
12
0Fs ΓεnΣym-68
09o -58
09o 4
24
16
0D
10s ret
01
}
17
0Es tree/zip
0D
23s tree/+=
05v [t k v]
05v #@[documentation: "Increment value at K in T by V" source: ["Increment value at K in T by V" [tree/set! t k [+ v [int [or [tree/ref t k] 0]]]]]]
05v #{##[]
05v tree/set!
10s t
10s k
05v +
10s v
05v int
05v tree/ref
10s t
10s k
04i 2
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
04i 1
04i 2
04i 3
01
}
17
0Es tree/+=
0D
23s tree/-=
05v [t k v]
05v #@[documentation: "Decrement value at K in T by V" source: ["Decrement value at K in T by V" [quasiquote [tree/+= [unquote t] [unquote k] [- [unquote v]]]]]]
05v #{##[]
23s tree/+=
10s t
10s k
23s -
10s v
24
14
14
24
14
14
14
14
01
}
18
0Es tree/-=
0D
23s tree/++
05v [t k]
05v #@[documentation: "Increment value at K in T by 1" source: ["Increment value at K in T by 1" [quasiquote [tree/+= [unquote t] [unquote k] 1]]]]
05v #{##[]
23s tree/+=
10s t
10s k
02i 1
24
14
14
14
14
01
}
18
0Es tree/++
0D
23s tree/--
05v [t k]
05v #@[documentation: "Increment value at K in T by 1" source: ["Increment value at K in T by 1" [quasiquote [tree/-= [unquote t] [unquote k] 1]]]]
05v #{##[]
23s tree/-=
10s t
10s k
02i 1
24
14
14
14
14
01
}
18
0Es tree/--
0D
23s tree/equal?
05v [a b]
05v #@[documentation: "Compares two trees for equality" source: ["Compares two trees for equality" [if [and [tree? a] [tree? b]] [and [== [tree/key* a] [tree/key* b]] [equal? [tree/value* a] [tree/value* b]] [tree/equal? [tree/left* a] [tree/left* b]] [tree/equal? [tree/right* a] [tree/right* b]]] [equal? a b]]]]
05v #{##[]
05v tree?
10s a
04i 1
0C
0Bo 14
0D
05v tree?
10s b
04i 1
0Bo 120
05v tree/key*
10s a
04i 1
05v tree/key*
10s b
04i 1
20
0C
0Bo 92
0D
05v equal?
05v tree/value*
10s a
04i 1
05v tree/value*
10s b
04i 1
04i 2
0C
0Bo 61
0D
05v tree/equal?
05v tree/left*
10s a
04i 1
05v tree/left*
10s b
04i 1
04i 2
0C
0Bo 30
0D
05v tree/equal?
05v tree/right*
10s a
04i 1
05v tree/right*
10s b
04i 1
04i 2
09o 17
05v equal?
10s a
10s b
04i 2
01
}
17
0Es tree/equal?
0D
23s tree/reduce
05v [l o s]
05v #@[documentation: "Combine all elements in l using operation o and starting value s" source: ["Combine all elements in l using operation o and starting value s" [list/reduce [tree/values l] o s]]]
05v #{##[]
05v list/reduce
05v tree/values
10s l
04i 1
10s o
10s s
04i 3
01
}
17
0Es tree/reduce
0D
23s tree/filter
05v [l f]
05v #@[documentation: "Return a new tree with all elements from L where F retunrs true" source: ["Return a new tree with all elements from L where F retunrs true" [def ret [tree/new #nil]] [for-in [e [tree/keys l]] [def t [tree/ref l e]] [when [f t] [tree/set! ret e t]]] ret]]
05v #{##[]
05v tree/new
24
04i 1
0Es ret
0D
15
05v tree/keys
10s l
04i 1
0Es ΓεnΣym-69
0D
10s ΓεnΣym-69
0Bo 95
02i 0
1B
1C
10s ΓεnΣym-69
0Bo 81
0D
10s ΓεnΣym-69
11
0Es e
0D
05v tree/ref
10s l
10s e
04i 2
0Es t
0D
10s f
10s t
04i 1
0Bo 24
05v tree/set!
10s ret
10s e
10s t
04i 3
09o 4
24
0D
10s ΓεnΣym-69
12
0Fs ΓεnΣym-69
09o -83
09o 4
24
16
0D
10s ret
01
}
17
0Es tree/filter
01
}#{##[]
23s $nop
05v []
05v #@[documentation: "[] -> []\nDo nothing" source: ["[] -> []" "Do nothing" :inline '[#$0]] inline: #t]
05v #{##[]
05v [#$0]
01
}
17
0Es $nop
0D
23s $ret
05v []
05v #@[documentation: "[a] -> []\nReturn top of value stack" source: ["[a] -> []" "Return top of value stack" :inline '[#$1]] inline: #t]
05v #{##[]
05v [#$1]
01
}
17
0Es $ret
0D
23s $add/int
05v []
05v #@[documentation: "[a b] -> [result]\nAdds the two topmost values and pushes the result" source: ["[a b] -> [result]" "Adds the two topmost values and pushes the result" :inline '[#$3]] inline: #t]
05v #{##[]
05v [#$3]
01
}
17
0Es $add/int
0D
23s $dup
05v []
05v #@[documentation: "[a] -> [a a]\nDuplicates the value that is on the top of the stack" source: ["[a] -> [a a]" "Duplicates the value that is on the top of the stack" :inline '[#$C]] inline: #t]
05v #{##[]
05v [#$C]
01
}
17
0Es $dup
0D
23s $drop
05v []
05v #@[documentation: "[a] -> []\nDrop whatever is on top of the stack" source: ["[a] -> []" "Drop whatever is on top of the stack" :inline '[#$D]] inline: #t]
05v #{##[]
05v [#$D]
01
}
17
0Es $drop
0D
23s $closure/push
05v []
05v #@[documentation: "[] -> [closure]\nPush the current closure as a λ on the stack" source: ["[] -> [closure]" "Push the current closure as a λ on the stack" :inline '[#$13]] inline: #t]
05v #{##[]
05v [#$13]
01
}
17
0Es $closure/push
0D
23s $let
05v []
05v #@[documentation: "[] -> []\nCreate a new let closure and switch to it" source: ["[] -> []" "Create a new let closure and switch to it" :inline '[#$15]] inline: #t]
05v #{##[]
05v [#$15]
01
}
17
0Es $let
0D
23s $closure/pop
05v []
05v #@[documentation: "[] -> []\nLeave the current closure and return to the parent one" source: ["[] -> []" "Leave the current closure and return to the parent one" :inline '[#$16]] inline: #t]
05v #{##[]
05v [#$16]
01
}
17
0Es $closure/pop
0D
23s $roots/save
05v []
05v #@[documentation: "[] -> []\nStore the current root stack pointer used for guarding allocations into the current closure" source: ["[] -> []" "Store the current root stack pointer used for guarding allocations into the current closure" :inline '[#$1B]] inline: #t]
05v #{##[]
05v [#$1B]
01
}
17
0Es $roots/save
0D
23s $roots/restore
05v []
05v #@[documentation: "[] -> []\nRestore the current root stack pointer to what is stored within the current closure" source: ["[] -> []" "Restore the current root stack pointer to what is stored within the current closure" :inline '[#$1C]] inline: #t]
05v #{##[]
05v [#$1C]
01
}
17
0Es $roots/restore
0D
23s $<
05v []
05v #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$1E]] inline: #t]
05v #{##[]
05v [#$1E]
01
}
17
0Es $<
0D
23s $<=
05v []
05v #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$1F]] inline: #t]
05v #{##[]
05v [#$1F]
01
}
17
0Es $<=
0D
23s $==
05v []
05v #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$20]] inline: #t]
05v #{##[]
05v [#$20]
01
}
17
0Es $==
0D
23s $>=
05v []
05v #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$21]] inline: #t]
05v #{##[]
05v [#$21]
01
}
17
0Es $>=
0D
23s $>
05v []
05v #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$22]] inline: #t]
05v #{##[]
05v [#$22]
01
}
17
0Es $>
0D
23s $push/nil
05v []
05v #@[documentation: "[] -> [nil]\nPush a #nil on the stack" source: ["[] -> [nil]" "Push a #nil on the stack" :inline '[#$24]] inline: #t]
05v #{##[]
05v [#$24]
01
}
17
0Es $push/nil
0D
23s $car
05v []
05v #@[documentation: "[l] -> [car]\nReplace L with its car" source: ["[l] -> [car]" "Replace L with its car" :inline '[#$11]] inline: #t]
05v #{##[]
05v [#$11]
01
}
17
0Es $car
0D
23s $cdr
05v []
05v #@[documentation: "[l] -> [cdr]\nReplace L with its cdr" source: ["[l] -> [cdr]" "Replace L with its cdr" :inline '[#$12]] inline: #t]
05v #{##[]
05v [#$12]
01
}
17
0Es $cdr
0D
23s $cons
05v []
05v #@[documentation: "[car cdr] -> [pair]\nCons CAR and CDR together and put it on the stack" source: ["[car cdr] -> [pair]" "Cons CAR and CDR together and put it on the stack" :inline '[#$14]] inline: #t]
05v #{##[]
05v [#$14]
01
}
17
0Es $cons
0D
23s $fn/dynamic
05v []
05v #@[documentation: "[name args docs body] -> [λ]\nCreate a new λ" source: ["[name args docs body] -> [λ]" "Create a new λ" :inline '[#$17]] inline: #t]
05v #{##[]
05v [#$17]
01
}
17
0Es $fn/dynamic
0D
23s $macro/dynamic
05v []
05v #@[documentation: "[name args docs body] -> [μ]\nCreate a new μ" source: ["[name args docs body] -> [μ]" "Create a new μ" :inline '[#$18]] inline: #t]
05v #{##[]
05v [#$18]
01
}
17
0Es $macro/dynamic
0D
23s $add
05v []
05v #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$25]] inline: #t]
05v #{##[]
05v [#$25]
01
}
17
0Es $add
0D
23s $sub
05v []
05v #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$26]] inline: #t]
05v #{##[]
05v [#$26]
01
}
17
0Es $sub
0D
23s $mul
05v []
05v #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$27]] inline: #t]
05v #{##[]
05v [#$27]
01
}
17
0Es $mul
0D
23s $div
05v []
05v #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$28]] inline: #t]
05v #{##[]
05v [#$28]
01
}
17
0Es $div
0D
23s $mod
05v []
05v #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$29]] inline: #t]
05v #{##[]
05v [#$29]
01
}
17
0Es $mod
01
}#{##[]
23s val->bytecode-op
05v [v]
05v #@[source: [[def i [val->index v]] [list [int->bytecode-op [logand [>> i 16] 255]] [int->bytecode-op [logand [>> i 8] 255]] [int->bytecode-op [logand i 255]]]]]
05v #{##[]
05v val->index
10s v
04i 1
0Es i
0D
05v list
05v int->bytecode-op
05v logand
05v >>
10s i
02i 16
04i 2
05v 255
04i 2
04i 1
05v int->bytecode-op
05v logand
05v >>
10s i
02i 8
04i 2
05v 255
04i 2
04i 1
05v int->bytecode-op
05v logand
10s i
05v 255
04i 2
04i 1
04i 3
01
}
17
0Es val->bytecode-op
0D
23s sym->bytecode-op
05v [v]
05v #@[source: [[def i [sym->index v]] [list [int->bytecode-op [logand [>> i 16] 255]] [int->bytecode-op [logand [>> i 8] 255]] [int->bytecode-op [logand i 255]]]]]
05v #{##[]
05v sym->index
10s v
04i 1
0Es i
0D
05v list
05v int->bytecode-op
05v logand
05v >>
10s i
02i 16
04i 2
05v 255
04i 2
04i 1
05v int->bytecode-op
05v logand
05v >>
10s i
02i 8
04i 2
05v 255
04i 2
04i 1
05v int->bytecode-op
05v logand
10s i
05v 255
04i 2
04i 1
04i 3
01
}
17
0Es sym->bytecode-op
0D
23s int-fit-in-byte?
05v [a]
05v #@[source: [[and [<= a 127] [>= a -128]]]]
05v #{##[]
10s a
02i 127
1F
0C
0Bo 11
0D
10s a
02i -128
21
01
}
17
0Es int-fit-in-byte?
0D
23s $push/int
05v [a]
05v #@[documentation: "[] -> [a]\nPush A on the stack as an :int" source: ["[] -> [a]" "Push A on the stack as an :int" [if [int-fit-in-byte? a] [$push/int/byte a] [$push/lval a]]]]
05v #{##[]
05v int-fit-in-byte?
10s a
04i 1
0Bo 16
05v $push/int/byte
10s a
04i 1
09o 13
05v $push/lval
10s a
04i 1
01
}
17
0Es $push/int
0D
23s $push/int/byte
05v [a]
05v #@[documentation: "[] -> [a]\nPush A on the stack as an :int that fits within a byte" source: ["[] -> [a]" "Push A on the stack as an :int that fits within a byte" [when-not [int-fit-in-byte? a] [throw [list :invalid-bc-op "$push/int/byte can only push a signed 8-bit value" a [current-lambda]]]] [list #$2 [int->bytecode-op a]]]]
05v #{##[]
05v int-fit-in-byte?
10s a
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :invalid-bc-op
05v "$push/int/byte can only push a signed 8-bit value"
10s a
05v current-lambda
04i 0
04i 4
04i 1
0D
05v list
05v #$2
05v int->bytecode-op
10s a
04i 1
04i 2
01
}
17
0Es $push/int/byte
0D
23s $push/lval
05v [v]
05v #@[documentation: "[] -> [v]\nPushes v onto the stack" source: ["[] -> [v]" "Pushes v onto the stack" [when [nil? v] [throw [list :invalid-bc-op "Can't push #nil as a normal lVal" v [current-lambda]]]] [list #$5 [val->bytecode-op v]]]]
05v #{##[]
05v nil?
10s v
04i 1
0Bo 36
05v throw
05v list
05v :invalid-bc-op
05v "Can't push #nil as a normal lVal"
10s v
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v list
05v #$5
05v val->bytecode-op
10s v
04i 1
04i 2
01
}
17
0Es $push/lval
0D
23s $push/symbol
05v [sym]
05v #@[documentation: "[] -> [sym]\nPushes v onto the stack" source: ["[] -> [sym]" "Pushes v onto the stack" [list #$23 [sym->bytecode-op sym]]]]
05v #{##[]
05v list
05v #$23
05v sym->bytecode-op
10s sym
04i 1
04i 2
01
}
17
0Es $push/symbol
0D
23s $def
05v [sym]
05v #@[documentation: "[val] -> [val]\nDefine a new binding for SYM and associate VAL to it" source: ["[val] -> [val]" "Define a new binding for SYM and associate VAL to it" [list #$E [sym->bytecode-op sym]]]]
05v #{##[]
05v list
05v #$E
05v sym->bytecode-op
10s sym
04i 1
04i 2
01
}
17
0Es $def
0D
23s $set
05v [sym]
05v #@[documentation: "[val] -> [val]\nUpdate the binding for SYM and associate VAL to it" source: ["[val] -> [val]" "Update the binding for SYM and associate VAL to it" [list #$F [sym->bytecode-op sym]]]]
05v #{##[]
05v list
05v #$F
05v sym->bytecode-op
10s sym
04i 1
04i 2
01
}
17
0Es $set
0D
23s $get
05v [sym]
05v #@[documentation: "[] -> [val]\nPush whatever value is associated to SYM on the stack" source: ["[] -> [val]" "Push whatever value is associated to SYM on the stack" [list #$10 [sym->bytecode-op sym]]]]
05v #{##[]
05v list
05v #$10
05v sym->bytecode-op
10s sym
04i 1
04i 2
01
}
17
0Es $get
0D
23s $apply/optimize?
05v [fun arg-count]
05v #@[source: [[case fun [[+ - * / %] [== arg-count 2]] [[car cdr add/int cons < <= == >= >] #t]]]]
05v #{##[]
15
10s fun
0Es ΓεnΣym-77
0D
10s ΓεnΣym-77
10s +
20
0C
0Ao 64
0D
10s ΓεnΣym-77
10s -
20
0C
0Ao 50
0D
10s ΓεnΣym-77
10s *
20
0C
0Ao 36
0D
10s ΓεnΣym-77
10s /
20
0C
0Ao 22
0D
10s ΓεnΣym-77
10s %
20
0C
0Ao 8
0D
05v #f
0Bo 13
10s arg-count
02i 2
20
09o 144
10s ΓεnΣym-77
10s car
20
0C
0Ao 120
0D
10s ΓεnΣym-77
10s cdr
20
0C
0Ao 106
0D
10s ΓεnΣym-77
10s add/int
20
0C
0Ao 92
0D
10s ΓεnΣym-77
10s cons
20
0C
0Ao 78
0D
10s ΓεnΣym-77
10s <
20
0C
0Ao 64
0D
10s ΓεnΣym-77
10s <=
20
0C
0Ao 50
0D
10s ΓεnΣym-77
10s ==
20
0C
0Ao 36
0D
10s ΓεnΣym-77
10s >=
20
0C
0Ao 22
0D
10s ΓεnΣym-77
10s >
20
0C
0Ao 8
0D
05v #f
0Bo 10
05v #t
09o 4
24
16
01
}
17
0Es $apply/optimize?
0D
23s $apply
05v [arg-count fun]
05v #@[documentation: "arguments -> [result]\nRead arg-count arguments from the stack, apply the to fun and push the result on the stack" source: ["arguments -> [result]" "Read arg-count arguments from the stack, apply the to fun and push the result on the stack" [case arg-count [1 [case fun [car [$car]] [cdr [$cdr]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]] [2 [case fun [add/int [$add/int]] [+ [$add]] [- [$sub]] [* [$mul]] [/ [$div]] [% [$mod]] [cons [$cons]] [< [$<]] [<= [$<=]] [== [$==]] [>= [$>=]] [> [$>]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]]]
05v #{##[]
15
10s arg-count
0Es ΓεnΣym-78
0D
10s ΓεnΣym-78
02i 1
20
0Bo 85
15
10s fun
0Es ΓεnΣym-79
0D
10s ΓεnΣym-79
10s car
20
0Bo 10
05v [#$11]
09o 52
10s ΓεnΣym-79
10s cdr
20
0Bo 10
05v [#$12]
09o 33
05v throw
05v list
05v :arity-error
05v "Wrong number of arguments for that function"
10s fun
05v current-lambda
04i 0
04i 4
04i 1
16
09o 315
10s ΓεnΣym-78
02i 2
20
0Bo 275
15
10s fun
0Es ΓεnΣym-80
0D
10s ΓεnΣym-80
10s add/int
20
0Bo 10
05v [#$3]
09o 242
10s ΓεnΣym-80
10s +
20
0Bo 10
05v [#$25]
09o 223
10s ΓεnΣym-80
10s -
20
0Bo 10
05v [#$26]
09o 204
10s ΓεnΣym-80
10s *
20
0Bo 10
05v [#$27]
09o 185
10s ΓεnΣym-80
10s /
20
0Bo 10
05v [#$28]
09o 166
10s ΓεnΣym-80
10s %
20
0Bo 10
05v [#$29]
09o 147
10s ΓεnΣym-80
10s cons
20
0Bo 10
05v [#$14]
09o 128
10s ΓεnΣym-80
10s <
20
0Bo 10
05v [#$1E]
09o 109
10s ΓεnΣym-80
10s <=
20
0Bo 10
05v [#$1F]
09o 90
10s ΓεnΣym-80
10s ==
20
0Bo 10
05v [#$20]
09o 71
10s ΓεnΣym-80
10s >=
20
0Bo 10
05v [#$21]
09o 52
10s ΓεnΣym-80
10s >
20
0Bo 10
05v [#$22]
09o 33
05v throw
05v list
05v :arity-error
05v "Wrong number of arguments for that function"
10s fun
05v current-lambda
04i 0
04i 4
04i 1
16
09o 33
05v throw
05v list
05v :arity-error
05v "Wrong number of arguments for that function"
10s fun
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es $apply
0D
23s $apply/dynamic
05v [arg-count fun]
05v #@[source: [[list #$4 [int->bytecode-op arg-count]]]]
05v #{##[]
05v list
05v #$4
05v int->bytecode-op
10s arg-count
04i 1
04i 2
01
}
17
0Es $apply/dynamic
0D
23s $try
05v [target]
05v #@[documentation: "[] -> []\nTry something, jumping to target if an exception occurs" source: ["[] -> []" "Try something, jumping to target if an exception occurs" [list #$19 [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]]
05v #{##[]
05v list
05v #$19
05v list
05v :relocate
10s target
02i 8
02i 0
05v int->bytecode-op
02i 0
04i 1
04i 5
05v list
05v :relocate
10s target
02i 0
02i 1
05v int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
}
17
0Es $try
0D
23s $jmp
05v [target]
05v #@[source: [[list #$9 [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]]
05v #{##[]
05v list
05v #$9
05v list
05v :relocate
10s target
02i 8
02i 0
05v int->bytecode-op
02i 0
04i 1
04i 5
05v list
05v :relocate
10s target
02i 0
02i 1
05v int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
}
17
0Es $jmp
0D
23s $push/val
05v [v]
05v #@[documentation: "[] -> [v]\nPushes v onto the stack" source: ["[] -> [v]" "Pushes v onto the stack" [when [nil? v] [throw [list :invalid-bc-op "Can't push #nil as a normal lVal" v [current-lambda]]]] [list #$1A [list :literal v]]]]
05v #{##[]
05v nil?
10s v
04i 1
0Bo 36
05v throw
05v list
05v :invalid-bc-op
05v "Can't push #nil as a normal lVal"
10s v
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v list
05v #$1A
05v list
05v :literal
10s v
04i 2
04i 2
01
}
17
0Es $push/val
0D
23s $jt
05v [target]
05v #@[source: [[list #$A [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]]
05v #{##[]
05v list
05v #$A
05v list
05v :relocate
10s target
02i 8
02i 0
05v int->bytecode-op
02i 0
04i 1
04i 5
05v list
05v :relocate
10s target
02i 0
02i 1
05v int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
}
17
0Es $jt
0D
23s $jf
05v [target]
05v #@[source: [[list #$B [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]]
05v #{##[]
05v list
05v #$B
05v list
05v :relocate
10s target
02i 8
02i 0
05v int->bytecode-op
02i 0
04i 1
04i 5
05v list
05v :relocate
10s target
02i 0
02i 1
05v int->bytecode-op
02i 0
04i 1
04i 5
04i 3
01
}
17
0Es $jf
0D
23s $fn
05v [name args docs body]
05v #@[source: [[list #$25 [val->bytecode-op name] [val->bytecode-op args] [val->bytecode-op docs] [val->bytecode-op body]]]]
05v #{##[]
05v list
05v #$25
05v val->bytecode-op
10s name
04i 1
05v val->bytecode-op
10s args
04i 1
05v val->bytecode-op
10s docs
04i 1
05v val->bytecode-op
10s body
04i 1
04i 5
01
}
17
0Es $fn
0D
23s $macro*
05v [name args docs body]
05v #@[source: [[list #$26 [val->bytecode-op name] [val->bytecode-op args] [val->bytecode-op docs] [val->bytecode-op body]]]]
05v #{##[]
05v list
05v #$26
05v val->bytecode-op
10s name
04i 1
05v val->bytecode-op
10s args
04i 1
05v val->bytecode-op
10s docs
04i 1
05v val->bytecode-op
10s body
04i 1
04i 5
01
}
17
0Es $macro*
0D
23s assemble/build-sym-map
05v [code sym-map pos]
05v #@[source: [[while code [case [type-of [car code]] [:bytecode-op [tree/set! sym-map :last-op [++ pos]]] [[:symbol :keyword] [and [== [car code] :label] [tree/set! sym-map [cadr code] pos]]] [:pair [set! pos [assemble/build-sym-map [car code] sym-map pos]]]] [cdr! code]] [when [zero? 123] 123] [return pos]]]
05v #{##[]
02i 0
1B
1C
10s code
0Bo 192
0D
15
05v type-of
10s code
11
04i 1
0Es ΓεnΣym-81
0D
10s ΓεnΣym-81
05v :bytecode-op
20
0Bo 36
05v tree/set!
10s sym-map
05v :last-op
05v +
02i 1
10s pos
04i 2
0Fs pos
04i 3
09o 115
10s ΓεnΣym-81
05v :symbol
20
0C
0Ao 22
0D
10s ΓεnΣym-81
05v :keyword
20
0C
0Ao 8
0D
05v #f
0Bo 41
10s code
11
05v :label
20
0C
0Bo 24
0D
05v tree/set!
10s sym-map
10s code
12
11
10s pos
04i 3
09o 42
10s ΓεnΣym-81
05v :pair
20
0Bo 29
05v assemble/build-sym-map
10s code
11
10s sym-map
10s pos
04i 3
0Fs pos
09o 4
24
16
0D
10s code
12
0Fs code
09o -194
0D
02i 0
02i 123
20
0Bo 8
02i 123
09o 4
24
0D
10s pos
01
01
}
17
0Es assemble/build-sym-map
0D
23s assemble/relocate-op
05v [code sym-map pos out]
05v #@[source: [[def target [tree/ref sym-map [cadr code]]] [def off [- [+ target [cadddr code]] pos]] [array/set! out [++ pos] [int->bytecode-op [logand [>> off [caddr code]] 255]]] [return pos]]]
05v #{##[]
05v tree/ref
10s sym-map
10s code
12
11
04i 2
0Es target
0D
05v -
05v +
10s target
05v cadddr
10s code
04i 1
04i 2
10s pos
04i 2
0Es off
0D
05v array/set!
10s out
05v +
02i 1
10s pos
04i 2
0Fs pos
05v int->bytecode-op
05v logand
05v >>
10s off
05v caddr
10s code
04i 1
04i 2
05v 255
04i 2
04i 1
04i 3
0D
10s pos
01
01
}
17
0Es assemble/relocate-op
0D
23s assemble/emit-relocated-ops
05v [code sym-map pos out]
05v #@[source: [[if [== [car code] :relocate] [set! pos [assemble/relocate-op code sym-map pos out]] [for-in [op code] [case [type-of op] [:bytecode-op [array/set! out [++ pos] op]] [:pair [set! pos [assemble/emit-relocated-ops op sym-map pos out]]]]]] [return pos]]]
05v #{##[]
10s code
11
05v :relocate
20
0Bo 32
05v assemble/relocate-op
10s code
10s sym-map
10s pos
10s out
04i 4
0Fs pos
09o 164
15
10s code
0Es ΓεnΣym-82
0D
10s ΓεnΣym-82
0Bo 145
02i 0
1B
1C
10s ΓεnΣym-82
0Bo 131
0D
10s ΓεnΣym-82
11
0Es op
0D
15
05v type-of
10s op
04i 1
0Es ΓεnΣym-83
0D
10s ΓεnΣym-83
05v :bytecode-op
20
0Bo 36
05v array/set!
10s out
05v +
02i 1
10s pos
04i 2
0Fs pos
10s op
04i 3
09o 45
10s ΓεnΣym-83
05v :pair
20
0Bo 32
05v assemble/emit-relocated-ops
10s op
10s sym-map
10s pos
10s out
04i 4
0Fs pos
09o 4
24
16
0D
10s ΓεnΣym-82
12
0Fs ΓεnΣym-82
09o -133
09o 4
24
16
0D
10s pos
01
01
}
17
0Es assemble/emit-relocated-ops
0D
23s assemble/add-literal
05v [code lit-arr]
05v #@[source: [[when [>= [array/length lit-arr] 255] [exception :out-of-bounds "Can only store up to 255 literals per bytecode-arr" code]] [array/length! lit-arr [+ 1 [array/length lit-arr]]] [array/set! lit-arr [- [array/length lit-arr] 1] [cadr code]] [int->bytecode-op [- [array/length lit-arr] 1]]]]
05v #{##[]
05v array/length
10s lit-arr
04i 1
05v 255
21
0Bo 36
05v throw
05v list
05v :out-of-bounds
05v "Can only store up to 255 literals per bytecode-arr"
10s code
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v array/length!
10s lit-arr
05v +
02i 1
05v array/length
10s lit-arr
04i 1
04i 2
04i 2
0D
05v array/set!
10s lit-arr
05v -
05v array/length
10s lit-arr
04i 1
02i 1
04i 2
10s code
12
11
04i 3
0D
05v int->bytecode-op
05v -
05v array/length
10s lit-arr
04i 1
02i 1
04i 2
04i 1
01
}
17
0Es assemble/add-literal
0D
23s assemble/build-lit-arr
05v [code lit-arr]
05v #@[source: [[when-not code [return #nil]] [cons [cond [[pair? [car code]] [assemble/build-lit-arr [car code] lit-arr]] [[== :literal [car code]] [assemble/add-literal code lit-arr]] [#t [car code]]] [assemble/build-lit-arr [cdr code] lit-arr]]]]
05v #{##[]
10s code
0Bo 7
24
09o 5
24
01
0D
05v pair?
10s code
11
04i 1
0Bo 21
05v assemble/build-lit-arr
10s code
11
10s lit-arr
04i 2
09o 49
05v :literal
10s code
11
20
0Bo 20
05v assemble/add-literal
10s code
10s lit-arr
04i 2
09o 19
05v #t
0Bo 11
10s code
11
09o 4
24
05v assemble/build-lit-arr
10s code
12
10s lit-arr
04i 2
14
01
}
17
0Es assemble/build-lit-arr
0D
23s assemble*
05v [code]
05v #@[documentation: "Assemble all arguments into a single :bytecode-array" source: ["Assemble all arguments into a single :bytecode-array" [def sym-map [tree/new #nil]] [def lit-arr [array/new #nil]] [def tmp [assemble/build-lit-arr code lit-arr]] [assemble/build-sym-map tmp sym-map 0] [def out [array/allocate [tree/ref sym-map :last-op]]] [assemble/emit-relocated-ops tmp sym-map -1 out] [arr->bytecode-arr out lit-arr]]]
05v #{##[]
05v tree/new
24
04i 1
0Es sym-map
0D
05v array/new
24
04i 1
0Es lit-arr
0D
05v assemble/build-lit-arr
10s code
10s lit-arr
04i 2
0Es tmp
0D
05v assemble/build-sym-map
10s tmp
10s sym-map
02i 0
04i 3
0D
05v array/allocate
05v tree/ref
10s sym-map
05v :last-op
04i 2
04i 1
0Es out
0D
05v assemble/emit-relocated-ops
10s tmp
10s sym-map
02i -1
10s out
04i 4
0D
05v arr->bytecode-arr
10s out
10s lit-arr
04i 2
01
}
17
0Es assemble*
0D
23s assemble
23s l
05v #@[documentation: "Assemble all arguments into a single :bytecode-array" source: ["Assemble all arguments into a single :bytecode-array" [assemble* l]]]
05v #{##[]
05v assemble*
10s l
04i 1
01
}
17
0Es assemble
0D
23s asmrun
23s ops
05v #@[documentation: "Assemble and evaluate all bytecode arguments" source: ["Assemble and evaluate all bytecode arguments" [quasiquote [apply [current-closure] [assemble [unquote-splicing ops]]]]]]
05v #{##[]
23s apply
23s current-closure
24
14
23s assemble
05v append
10s ops
24
04i 2
14
24
14
14
14
01
}
18
0Es asmrun
0D
23s bytecode-eval
05v [bc env]
05v #@[source: [[apply [or env [current-closure]] bc]]]
05v #{##[]
05v apply
10s env
0C
0Ao 19
0D
05v current-closure
04i 0
0C
0Ao 8
0D
05v #f
10s bc
04i 2
01
}
17
0Es bytecode-eval
01
}#{##[]
02i 0
0Es bytecompile/gen-label/counter
0D
23s bytecompile/gen-label
05v [prefix]
05v #@[source: [[++ bytecompile/gen-label/counter] [string->symbol [cat prefix "label-" bytecompile/gen-label/counter]]]]
05v #{##[]
05v +
02i 1
10s bytecompile/gen-label/counter
04i 2
0Fs bytecompile/gen-label/counter
0D
05v string->symbol
05v cat
10s prefix
05v "label-"
10s bytecompile/gen-label/counter
04i 3
04i 1
01
}
17
0Es bytecompile/gen-label
0D
05v #f
0Es *bytecompile-push*
0D
23s $push/v
05v [v]
05v #@[source: [[if *bytecompile-push* [$push/val v] [$push/lval v]]]]
05v #{##[]
10s *bytecompile-push*
0Bo 16
05v $push/val
10s v
04i 1
09o 13
05v $push/lval
10s v
04i 1
01
}
17
0Es $push/v
0D
23s bytecompile/literal
05v [source]
05v #@[source: [[case [type-of source] [[:symbol :keyword] [if [keyword? source] [$push/v source] [$get source]]] [:int [$push/int source]] [:nil [$push/nil]] [otherwise [$push/v source]]]]]
05v #{##[]
15
05v type-of
10s source
04i 1
0Es ΓεnΣym-89
0D
10s ΓεnΣym-89
05v :symbol
20
0C
0Ao 22
0D
10s ΓεnΣym-89
05v :keyword
20
0C
0Ao 8
0D
05v #f
0Bo 42
05v keyword?
10s source
04i 1
0Bo 16
05v $push/v
10s source
04i 1
09o 13
05v $get
10s source
04i 1
09o 57
10s ΓεnΣym-89
05v :int
20
0Bo 16
05v $push/int
10s source
04i 1
09o 32
10s ΓεnΣym-89
05v :nil
20
0Bo 10
05v [#$24]
09o 13
05v $push/v
10s source
04i 1
16
01
}
17
0Es bytecompile/literal
0D
23s bytecompile/quote
05v [source]
05v #@[source: [[case [type-of source] [:int [$push/int source]] [:symbol [$push/symbol source]] [otherwise [$push/v source]]]]]
05v #{##[]
15
05v type-of
10s source
04i 1
0Es ΓεnΣym-90
0D
10s ΓεnΣym-90
05v :int
20
0Bo 16
05v $push/int
10s source
04i 1
09o 38
10s ΓεnΣym-90
05v :symbol
20
0Bo 16
05v $push/symbol
10s source
04i 1
09o 13
05v $push/v
10s source
04i 1
16
01
}
17
0Es bytecompile/quote
0D
23s bytecompile/do/form
05v [source env]
05v #@[source: [[when source [cons [cons [bytecompile* [car source] env] [if [last? source] #nil [cons [$drop] #nil]]] [bytecompile/do/form [cdr source] env]]]]]
05v #{##[]
10s source
0Bo 62
05v bytecompile*
10s source
11
10s env
04i 2
05v nil?
10s source
12
04i 1
0Bo 7
24
09o 9
05v [#$D]
24
14
14
05v bytecompile/do/form
10s source
12
10s env
04i 2
14
09o 4
24
01
}
17
0Es bytecompile/do/form
0D
23s bytecompile/do
05v [source env]
05v #@[source: [[list [bytecompile/do/form [cdr source] env]]]]
05v #{##[]
05v list
05v bytecompile/do/form
10s source
12
10s env
04i 2
04i 1
01
}
17
0Es bytecompile/do
0D
23s bytecompile/def
05v [source env]
05v #@[source: [[when [or [not [symbol? [cadr source]]] [not [cddr source]]] [throw [list :type-error "[def] needs a symbol name and a value as arguments" #nil env]]] [list [bytecompile* [caddr source] env] [$def [cadr source]]]]]
05v #{##[]
05v symbol?
10s source
12
11
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 33
0D
10s source
12
12
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 8
0D
05v #f
0Bo 31
05v throw
05v list
05v :type-error
05v "[def] needs a symbol name and a value as arguments"
24
10s env
04i 4
04i 1
09o 4
24
0D
05v list
05v bytecompile*
05v caddr
10s source
04i 1
10s env
04i 2
05v $def
10s source
12
11
04i 1
04i 2
01
}
17
0Es bytecompile/def
0D
23s bytecompile/set!
05v [source env]
05v #@[source: [[when [or [not [symbol? [cadr source]]] [not [cddr source]]] [throw [list :type-error "[set!] needs a symbol name and a value as arguments" #nil env]]] [list [bytecompile* [caddr source] env] [$set [cadr source]]]]]
05v #{##[]
05v symbol?
10s source
12
11
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 33
0D
10s source
12
12
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 8
0D
05v #f
0Bo 31
05v throw
05v list
05v :type-error
05v "[set!] needs a symbol name and a value as arguments"
24
10s env
04i 4
04i 1
09o 4
24
0D
05v list
05v bytecompile*
05v caddr
10s source
04i 1
10s env
04i 2
05v $set
10s source
12
11
04i 1
04i 2
01
}
17
0Es bytecompile/set!
0D
23s bytecompile/if
05v [source env]
05v #@[source: [[let [[sym-else [bytecompile/gen-label]] [sym-after [bytecompile/gen-label]]] [list [bytecompile* [cadr source] env] [$jf sym-else] [bytecompile* [caddr source] env] [$jmp sym-after] [list :label sym-else] [bytecompile* [cadddr source] env] [list :label sym-after]]]]]
05v #{##[]
15
05v bytecompile/gen-label
04i 0
0Es sym-else
0D
05v bytecompile/gen-label
04i 0
0Es sym-after
0D
05v list
05v bytecompile*
10s source
12
11
10s env
04i 2
05v $jf
10s sym-else
04i 1
05v bytecompile*
05v caddr
10s source
04i 1
10s env
04i 2
05v $jmp
10s sym-after
04i 1
05v list
05v :label
10s sym-else
04i 2
05v bytecompile*
05v cadddr
10s source
04i 1
10s env
04i 2
05v list
05v :label
10s sym-after
04i 2
04i 7
16
01
}
17
0Es bytecompile/if
0D
23s bytecompile/while
05v [source env]
05v #@[source: [[def sym-start [bytecompile/gen-label]] [def sym-end [bytecompile/gen-label]] [list [$push/int 0] [$roots/save] [list :label sym-start] [$roots/restore] [bytecompile* [cadr source] env] [$jf sym-end] [$drop] [bytecompile/do/form [cddr source] env] [$jmp sym-start] [list :label sym-end]]]]
05v #{##[]
05v bytecompile/gen-label
04i 0
0Es sym-start
0D
05v bytecompile/gen-label
04i 0
0Es sym-end
0D
05v list
05v $push/int
02i 0
04i 1
05v [#$1B]
05v list
05v :label
10s sym-start
04i 2
05v [#$1C]
05v bytecompile*
10s source
12
11
10s env
04i 2
05v $jf
10s sym-end
04i 1
05v [#$D]
05v bytecompile/do/form
10s source
12
12
10s env
04i 2
05v $jmp
10s sym-start
04i 1
05v list
05v :label
10s sym-end
04i 2
04i 10
01
}
17
0Es bytecompile/while
0D
23s bytecompile/procedure/arg
05v [source env]
05v #@[source: [[if [last? source] [bytecompile* [car source] env] [cons [bytecompile* [car source] env] [bytecompile/procedure/arg [cdr source] env]]]]]
05v #{##[]
05v nil?
10s source
12
04i 1
0Bo 21
05v bytecompile*
10s source
11
10s env
04i 2
09o 34
05v bytecompile*
10s source
11
10s env
04i 2
05v bytecompile/procedure/arg
10s source
12
10s env
04i 2
14
01
}
17
0Es bytecompile/procedure/arg
0D
23s bytecompile/procedure/inline?
05v [op]
05v #@[source: [[case [type-of op] [:lambda [meta op :inline]] [#t #f]]]]
05v #{##[]
15
05v type-of
10s op
04i 1
0Es ΓεnΣym-91
0D
10s ΓεnΣym-91
05v :lambda
20
0Bo 20
05v meta
10s op
05v :inline
04i 2
09o 23
10s ΓεnΣym-91
05v #t
20
0Bo 10
05v #f
09o 4
24
16
01
}
17
0Es bytecompile/procedure/inline?
0D
23s bytecompile/procedure/inline
05v [op args env]
05v #@[source: [[def arg-count [length args]] [when [> arg-count 1] [throw [list :compiler-error "For now only monadic functions can be inlined" op [current-lambda]]]] [def form [macroexpand/do [meta op :source] env]] [def arg-name [car [closure/arguments op]]] [if args [bytecompile* [list/replace form arg-name [car args]] env] [bytecompile* form env]]]]
05v #{##[]
05v length
10s args
04i 1
0Es arg-count
0D
10s arg-count
02i 1
22
0Bo 36
05v throw
05v list
05v :compiler-error
05v "For now only monadic functions can be inlined"
10s op
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v macroexpand/do
05v meta
10s op
05v :source
04i 2
10s env
04i 2
0Es form
0D
05v closure/arguments
10s op
04i 1
11
0Es arg-name
0D
10s args
0Bo 35
05v bytecompile*
05v list/replace
10s form
10s arg-name
10s args
11
04i 3
10s env
04i 2
09o 17
05v bytecompile*
10s form
10s env
04i 2
01
}
17
0Es bytecompile/procedure/inline
0D
23s bytecompile/procedure
05v [op args env]
05v #@[source: [[if [bytecompile/procedure/inline? op] [bytecompile/procedure/inline op args env] [bytecompile/procedure/default op args env]]]]
05v #{##[]
05v bytecompile/procedure/inline?
10s op
04i 1
0Bo 24
05v bytecompile/procedure/inline
10s op
10s args
10s env
04i 3
09o 21
05v bytecompile/procedure/default
10s op
10s args
10s env
04i 3
01
}
17
0Es bytecompile/procedure
0D
23s bytecompile/procedure/default
05v [op args env]
05v #@[source: [[def arg-count [length args]] [if [$apply/optimize? op arg-count] [list [when args [bytecompile/procedure/arg args]] [$apply arg-count op]] [list [bytecompile* op env] [when args [bytecompile/procedure/arg args]] [$apply/dynamic arg-count]]]]]
05v #{##[]
05v length
10s args
04i 1
0Es arg-count
0D
05v $apply/optimize?
10s op
10s arg-count
04i 2
0Bo 47
05v list
10s args
0Bo 16
05v bytecompile/procedure/arg
10s args
04i 1
09o 4
24
05v $apply
10s arg-count
10s op
04i 2
04i 2
09o 54
05v list
05v bytecompile*
10s op
10s env
04i 2
10s args
0Bo 16
05v bytecompile/procedure/arg
10s args
04i 1
09o 4
24
05v $apply/dynamic
10s arg-count
04i 1
04i 3
01
}
17
0Es bytecompile/procedure/default
0D
23s bytecompile/and/rec
05v [source env label-end]
05v #@[source: [[list [bytecompile* [car source] env] [when [cdr source] [list [$dup] [$jf label-end] [$drop] [bytecompile/and/rec [cdr source] env label-end]]]]]]
05v #{##[]
05v list
05v bytecompile*
10s source
11
10s env
04i 2
10s source
12
0Bo 49
05v list
05v [#$C]
05v $jf
10s label-end
04i 1
05v [#$D]
05v bytecompile/and/rec
10s source
12
10s env
10s label-end
04i 3
04i 4
09o 4
24
04i 2
01
}
17
0Es bytecompile/and/rec
0D
23s bytecompile/and
05v [source env]
05v #@[source: [[def label-end [bytecompile/gen-label]] [list [bytecompile/and/rec [cdr source] env label-end] [list :label label-end]]]]
05v #{##[]
05v bytecompile/gen-label
04i 0
0Es label-end
0D
05v list
05v bytecompile/and/rec
10s source
12
10s env
10s label-end
04i 3
05v list
05v :label
10s label-end
04i 2
04i 2
01
}
17
0Es bytecompile/and
0D
23s bytecompile/or/rec
05v [source env label-end]
05v #@[source: [[when source [list [bytecompile* [car source] env] [$dup] [$jt label-end] [$drop] [bytecompile/or/rec [cdr source] env label-end]]]]]
05v #{##[]
10s source
0Bo 64
05v list
05v bytecompile*
10s source
11
10s env
04i 2
05v [#$C]
05v $jt
10s label-end
04i 1
05v [#$D]
05v bytecompile/or/rec
10s source
12
10s env
10s label-end
04i 3
04i 5
09o 4
24
01
}
17
0Es bytecompile/or/rec
0D
23s bytecompile/or
05v [source env]
05v #@[source: [[def label-end [bytecompile/gen-label]] [list [bytecompile/or/rec [cdr source] env label-end] [$push/lval #f] [list :label label-end]]]]
05v #{##[]
05v bytecompile/gen-label
04i 0
0Es label-end
0D
05v list
05v bytecompile/or/rec
10s source
12
10s env
10s label-end
04i 3
05v $push/lval
05v #f
04i 1
05v list
05v :label
10s label-end
04i 2
04i 3
01
}
17
0Es bytecompile/or
0D
23s bytecompile/string
05v [source env]
05v #@[source: [[bytecompile/procedure cat source env]]]
05v #{##[]
05v bytecompile/procedure
10s cat
10s source
10s env
04i 3
01
}
17
0Es bytecompile/string
0D
23s bytecompile/array
05v [source env]
05v #@[source: [[bytecompile/procedure array/ref source env]]]
05v #{##[]
05v bytecompile/procedure
10s array/ref
10s source
10s env
04i 3
01
}
17
0Es bytecompile/array
0D
23s bytecompile/tree
05v [source env]
05v #@[source: [[bytecompile/procedure tree/ref source env]]]
05v #{##[]
05v bytecompile/procedure
10s tree/ref
10s source
10s env
04i 3
01
}
17
0Es bytecompile/tree
0D
23s bytecompile/fn*
05v [source env]
05v #@[source: [[def arg-count [length [cdr source]]] [when [!= arg-count 5] [exception :arity-error "[fn*] needs exactly 4 arguments" source]] [cdr! source] [list [bytecompile* [car source] env] [bytecompile* [cadr source] env] [bytecompile* [caddr source] env] [bytecompile* [cadddr source] env] [$fn/dynamic]]]]
05v #{##[]
05v length
10s source
12
04i 1
0Es arg-count
0D
05v !=
10s arg-count
02i 5
04i 2
0Bo 36
05v throw
05v list
05v :arity-error
05v "[fn*] needs exactly 4 arguments"
10s source
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s source
12
0Fs source
0D
05v list
05v bytecompile*
10s source
11
10s env
04i 2
05v bytecompile*
10s source
12
11
10s env
04i 2
05v bytecompile*
05v caddr
10s source
04i 1
10s env
04i 2
05v bytecompile*
05v cadddr
10s source
04i 1
10s env
04i 2
05v [#$17]
04i 5
01
}
17
0Es bytecompile/fn*
0D
23s bytecompile/macro*
05v [source env]
05v #@[source: [[def arg-count [length [cdr source]]] [when [!= arg-count 5] [exception :arity-error "[macro*] needs exactly 4 arguments" source]] [cdr! source] [list [bytecompile* [car source] env] [bytecompile* [cadr source] env] [bytecompile* [caddr source] env] [bytecompile* [cadddr source] env] [$macro/dynamic]]]]
05v #{##[]
05v length
10s source
12
04i 1
0Es arg-count
0D
05v !=
10s arg-count
02i 5
04i 2
0Bo 36
05v throw
05v list
05v :arity-error
05v "[macro*] needs exactly 4 arguments"
10s source
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s source
12
0Fs source
0D
05v list
05v bytecompile*
10s source
11
10s env
04i 2
05v bytecompile*
10s source
12
11
10s env
04i 2
05v bytecompile*
05v caddr
10s source
04i 1
10s env
04i 2
05v bytecompile*
05v cadddr
10s source
04i 1
10s env
04i 2
05v [#$18]
04i 5
01
}
17
0Es bytecompile/macro*
0D
23s bytecompile/ω*
05v [source env]
05v #@[source: [[list [$let] [bytecompile/do/form [cdr source] env] [$drop] [$closure/push] [$closure/pop]]]]
05v #{##[]
05v list
05v [#$15]
05v bytecompile/do/form
10s source
12
10s env
04i 2
05v [#$D]
05v [#$13]
05v [#$16]
04i 5
01
}
17
0Es bytecompile/ω*
0D
23s bytecompile/let*
05v [source env]
05v #@[source: [[list [$let] [bytecompile/do [cadr source] env] [$closure/pop]]]]
05v #{##[]
05v list
05v [#$15]
05v bytecompile/do
10s source
12
11
10s env
04i 2
05v [#$16]
04i 3
01
}
17
0Es bytecompile/let*
0D
23s bytecompile/return
05v [source env]
05v #@[source: [[list [bytecompile* [cadr source] env] [$ret]]]]
05v #{##[]
05v list
05v bytecompile*
10s source
12
11
10s env
04i 2
05v [#$1]
04i 2
01
}
17
0Es bytecompile/return
0D
23s bytecompile/try
05v [source env]
05v #@[source: [[def end-sym [bytecompile/gen-label]] [list [bytecompile* [cadr source] env] [$try end-sym] [bytecompile/do/form [cddr source] env] [$closure/pop] [list :label end-sym]]]]
05v #{##[]
05v bytecompile/gen-label
04i 0
0Es end-sym
0D
05v list
05v bytecompile*
10s source
12
11
10s env
04i 2
05v $try
10s end-sym
04i 1
05v bytecompile/do/form
10s source
12
12
10s env
04i 2
05v [#$16]
05v list
05v :label
10s end-sym
04i 2
04i 5
01
}
17
0Es bytecompile/try
0D
23s bytecompile*
05v [source env]
05v #@[documentation: "Compile the forms in source" source: ["Compile the forms in source" [def op [if [resolves? [car source] env] [resolve [car source] env] [car source]]] [case [type-of op] [[:lambda :native-function] [case op [do [bytecompile/do source env]] [let* [bytecompile/let* source env]] [def [bytecompile/def source env]] [set! [bytecompile/set! source env]] [if [bytecompile/if source env]] [while [bytecompile/while source env]] [and [bytecompile/and source env]] [or [bytecompile/or source env]] [fn* [bytecompile/fn* source env]] [macro* [bytecompile/macro* source env]] [ω* [bytecompile/ω* source env]] [try [bytecompile/try source env]] [return [bytecompile/return source env]] '[bytecompile/quote [cadr source]] [otherwise [bytecompile/procedure op [cdr source] env]]]] [[:pair :symbol] [bytecompile/procedure op [cdr source] env]] [:string [bytecompile/string source env]] [:array [bytecompile/array source env]] [:tree [bytecompile/tree source env]] [otherwise [bytecompile/literal source]]]]]
05v #{##[]
05v resolves?
10s source
11
10s env
04i 2
0Bo 21
05v resolve
10s source
11
10s env
04i 2
09o 8
10s source
11
0Es op
0D
15
05v type-of
10s op
04i 1
0Es ΓεnΣym-92
0D
10s ΓεnΣym-92
05v :lambda
20
0C
0Ao 22
0D
10s ΓεnΣym-92
05v :native-function
20
0C
0Ao 8
0D
05v #f
0Bo 440
15
10s op
0Es ΓεnΣym-93
0D
10s ΓεnΣym-93
10s do
20
0Bo 20
05v bytecompile/do
10s source
10s env
04i 2
09o 397
10s ΓεnΣym-93
10s let*
20
0Bo 20
05v bytecompile/let*
10s source
10s env
04i 2
09o 368
10s ΓεnΣym-93
10s def
20
0Bo 20
05v bytecompile/def
10s source
10s env
04i 2
09o 339
10s ΓεnΣym-93
10s set!
20
0Bo 20
05v bytecompile/set!
10s source
10s env
04i 2
09o 310
10s ΓεnΣym-93
10s if
20
0Bo 20
05v bytecompile/if
10s source
10s env
04i 2
09o 281
10s ΓεnΣym-93
10s while
20
0Bo 20
05v bytecompile/while
10s source
10s env
04i 2
09o 252
10s ΓεnΣym-93
10s and
20
0Bo 20
05v bytecompile/and
10s source
10s env
04i 2
09o 223
10s ΓεnΣym-93
10s or
20
0Bo 20
05v bytecompile/or
10s source
10s env
04i 2
09o 194
10s ΓεnΣym-93
10s fn*
20
0Bo 20
05v bytecompile/fn*
10s source
10s env
04i 2
09o 165
10s ΓεnΣym-93
10s macro*
20
0Bo 20
05v bytecompile/macro*
10s source
10s env
04i 2
09o 136
10s ΓεnΣym-93
10s ω*
20
0Bo 20
05v bytecompile/ω*
10s source
10s env
04i 2
09o 107
10s ΓεnΣym-93
10s try
20
0Bo 20
05v bytecompile/try
10s source
10s env
04i 2
09o 78
10s ΓεnΣym-93
10s return
20
0Bo 20
05v bytecompile/return
10s source
10s env
04i 2
09o 49
10s ΓεnΣym-93
10s quote
20
0Bo 18
05v bytecompile/quote
10s source
12
11
04i 1
09o 22
05v bytecompile/procedure
10s op
10s source
12
10s env
04i 3
16
09o 157
10s ΓεnΣym-92
05v :pair
20
0C
0Ao 22
0D
10s ΓεnΣym-92
05v :symbol
20
0C
0Ao 8
0D
05v #f
0Bo 25
05v bytecompile/procedure
10s op
10s source
12
10s env
04i 3
09o 100
10s ΓεnΣym-92
05v :string
20
0Bo 20
05v bytecompile/string
10s source
10s env
04i 2
09o 71
10s ΓεnΣym-92
05v :array
20
0Bo 20
05v bytecompile/array
10s source
10s env
04i 2
09o 42
10s ΓεnΣym-92
05v :tree
20
0Bo 20
05v bytecompile/tree
10s source
10s env
04i 2
09o 13
05v bytecompile/literal
10s source
04i 1
16
01
}
17
0Es bytecompile*
0D
23s bytecompile
05v [form environment]
05v #@[source: [[list [bytecompile* form environment] [$ret]]]]
05v #{##[]
05v list
05v bytecompile*
10s form
10s environment
04i 2
05v [#$1]
04i 2
01
}
17
0Es bytecompile
01
}#{##[]
23s load/forms
05v [source environment]
05v #@[documentation: "Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" source: ["Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" [for-in [form source] [apply environment [-> [macroexpand form environment] bytecompile assemble*]]]]]
05v #{##[]
15
10s source
0Es ΓεnΣym-97
0D
10s ΓεnΣym-97
0Bo 77
02i 0
1B
1C
10s ΓεnΣym-97
0Bo 63
0D
10s ΓεnΣym-97
11
0Es form
0D
05v apply
10s environment
05v assemble*
05v bytecompile
05v macroexpand
10s form
10s environment
04i 2
04i 1
04i 1
04i 2
0D
10s ΓεnΣym-97
12
0Fs ΓεnΣym-97
09o -65
09o 4
24
16
01
}
17
0Es load/forms
0D
23s macroexpand/forms
05v [source-raw environment]
05v #@[documentation: "Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined." source: ["Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined." [when-not environment [set! environment [ω]]] [load/forms source-raw environment] [macroexpand source-raw environment]]]
05v #{##[]
10s environment
0Bo 7
24
09o 12
15
24
0D
13
16
0Fs environment
0D
05v load/forms
10s source-raw
10s environment
04i 2
0D
05v macroexpand
10s source-raw
10s environment
04i 2
01
}
17
0Es macroexpand/forms
0D
23s compile/debug
05v [expr]
05v #@[source: [[-> [macroexpand expr] bytecompile assemble* disassemble]]]
05v #{##[]
05v disassemble
05v assemble*
05v bytecompile
05v macroexpand
10s expr
04i 1
04i 1
04i 1
04i 1
01
}
17
0Es compile/debug
0D
23s compile*
05v [source environment]
05v #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [-> [macroexpand source environment] bytecompile assemble*]]]
05v #{##[]
05v assemble*
05v bytecompile
05v macroexpand
10s source
10s environment
04i 2
04i 1
04i 1
01
}
17
0Es compile*
0D
23s compile/do*
05v [source environment]
05v #@[source: [[compile* [cons do source] environment]]]
05v #{##[]
05v compile*
10s do
10s source
14
10s environment
04i 2
01
}
17
0Es compile/do*
0D
23s compile
05v [source]
05v #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [quasiquote [compile* [unquote source] [current-closure]]]]]
05v #{##[]
23s compile*
10s source
23s current-closure
24
14
24
14
14
14
01
}
18
0Es compile
0D
23s compile/do
05v [source]
05v #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [quasiquote [compile* [cons do [unquote source]] [current-closure]]]]]
05v #{##[]
23s compile*
23s cons
23s do
10s source
24
14
14
14
23s current-closure
24
14
24
14
14
14
01
}
18
0Es compile/do
0D
23s meta/parse/body
05v [type args body]
05v #@[source: [[def meta [tree/new #nil]] [for-in [v body] [case [type-of v] [:pair [return meta]] [:string [tree/set! meta :documentation [trim [cat [string [tree/ref meta :documentation]] "\n" v]]]] [:keyword [tree/set! meta v #t]]]] [return meta]]]
05v #{##[]
05v tree/new
24
04i 1
0Es meta
0D
15
10s body
0Es ΓεnΣym-98
0D
10s ΓεnΣym-98
0Bo 181
02i 0
1B
1C
10s ΓεnΣym-98
0Bo 167
0D
10s ΓεnΣym-98
11
0Es v
0D
15
05v type-of
10s v
04i 1
0Es ΓεnΣym-99
0D
10s ΓεnΣym-99
05v :pair
20
0Bo 11
10s meta
01
09o 106
10s ΓεnΣym-99
05v :string
20
0Bo 60
05v tree/set!
10s meta
05v :documentation
05v trim
05v cat
05v string
05v tree/ref
10s meta
05v :documentation
04i 2
04i 1
05v "\n"
10s v
04i 3
04i 1
04i 3
09o 37
10s ΓεnΣym-99
05v :keyword
20
0Bo 24
05v tree/set!
10s meta
10s v
05v #t
04i 3
09o 4
24
16
0D
10s ΓεnΣym-98
12
0Fs ΓεnΣym-98
09o -169
09o 4
24
16
0D
10s meta
01
01
}
17
0Es meta/parse/body
0D
23s defmacro
05v [name args . body]
05v #@[documentation: "Define a new macro" source: ["Define a new macro" [quasiquote [def [unquote name] [macro* '[unquote name] '[unquote args] [unquote [tree/set! [meta/parse/body :macro args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]]]
05v #{##[]
23s def
10s name
23s macro*
23s quote
10s name
24
14
14
23s quote
10s args
24
14
14
05v tree/set!
05v meta/parse/body
05v :macro
10s args
10s body
04i 3
05v :source
10s body
04i 3
23s quote
05v compile/do*
10s body
05v current-closure
04i 0
04i 2
24
14
14
24
14
14
14
14
14
24
14
14
14
01
}
18
0Es defmacro
0D
23s fn
05v [args . body]
05v #@[documentation: "Define an anonymous function" source: ["Define an anonymous function" [quasiquote [fn* 'anonymous '[unquote args] [unquote [tree/set! [meta/parse/body :lambda args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]]
05v #{##[]
23s fn*
23s quote
23s anonymous
24
14
14
23s quote
10s args
24
14
14
05v tree/set!
05v meta/parse/body
05v :lambda
10s args
10s body
04i 3
05v :source
10s body
04i 3
23s quote
05v compile/do*
10s body
05v current-closure
04i 0
04i 2
24
14
14
24
14
14
14
14
14
01
}
18
0Es fn
0D
23s defn
05v [name args . body]
05v #@[documentation: "Define a new function" source: ["Define a new function" [quasiquote [def [unquote name] [fn* '[unquote name] '[unquote args] [unquote [tree/set! [meta/parse/body :lambda args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]]]
05v #{##[]
23s def
10s name
23s fn*
23s quote
10s name
24
14
14
23s quote
10s args
24
14
14
05v tree/set!
05v meta/parse/body
05v :lambda
10s args
10s body
04i 3
05v :source
10s body
04i 3
23s quote
05v compile/do*
10s body
05v current-closure
04i 0
04i 2
24
14
14
24
14
14
14
14
14
24
14
14
14
01
}
18
0Es defn
0D
23s ω
23s body
05v #@[documentation: "Defines and returns new object after evaluating body within" source: ["Defines and returns new object after evaluating body within" [macroexpand [cons 'ω* body]]]]
05v #{##[]
05v macroexpand
23s ω*
10s body
14
04i 1
01
}
18
0Es ω
0D
10s ω
0Es defobj
0D
23s eval-in
05v [closure expr]
05v #@[documentation: "Compile and the immediatly evaluate the result\nMostly used by lRun()" source: ["Compile and the immediatly evaluate the result" "" "Mostly used by lRun()" [try display/error [apply closure [compile* expr closure]]]]]
05v #{##[]
10s display/error
19o 28
05v apply
10s closure
05v compile*
10s expr
10s closure
04i 2
04i 2
16
01
}
17
0Es eval-in
0D
23s eval
05v [expr]
05v #@[documentation: "Compile, Evaluate and then return the result of EXPR" source: ["Compile, Evaluate and then return the result of EXPR" [quasiquote [eval-in [current-closure] [unquote expr]]]]]
05v #{##[]
23s eval-in
23s current-closure
24
14
10s expr
24
14
14
14
01
}
18
0Es eval
0D
23s typecheck/only
05v [v t]
05v #@[source: [[quasiquote [when-not [== [type-of [unquote v]] [unquote t]] [throw [list :type-error [unquote [fmt "Expected a value of type {t}"]] [unquote v] [current-lambda]]]]]]]
05v #{##[]
23s when-not
23s ==
23s type-of
10s v
24
14
14
10s t
24
14
14
14
23s throw
23s list
05v :type-error
05v cat
05v "Expected a value of type "
10s t
04i 2
10s v
23s current-lambda
24
14
24
14
14
14
14
14
24
14
14
24
14
14
14
01
}
18
0Es typecheck/only
0D
23s typecheck/numeric/single
05v [v]
05v #@[source: [[quasiquote [when-not [numeric? [unquote v]] [throw [list :type-error [unquote [fmt "Expected numeric value"]] [unquote v] [current-lambda]]]]]]]
05v #{##[]
23s when-not
23s numeric?
10s v
24
14
14
23s throw
23s list
05v :type-error
05v "Expected numeric value"
10s v
23s current-lambda
24
14
24
14
14
14
14
14
24
14
14
24
14
14
14
01
}
17
0Es typecheck/numeric/single
0D
23s typecheck/numeric
23s v
05v #@[source: [[map v typecheck/numeric/single]]]
05v #{##[]
05v map
10s v
10s typecheck/numeric/single
04i 2
01
}
18
0Es typecheck/numeric
01
}#{##[]
23s disassemble/length
05v [op]
05v #@[documentation: "Return the length in bytes of a bytecode operation and all its arguments" source: ["Return the length in bytes of a bytecode operation and all its arguments" [case op [[#$0 #$1 #$3 #$C #$D #$11 #$12 #$13 #$14 #$15 #$16 #$1B #$1C #$1E #$1F #$20 #$21 #$22 #$24 #$25 #$26 #$27 #$28 #$29] 1] [[#$2 #$4 #$7 #$1A] 2] [[#$9 #$A #$B #$18 #$19] 3] [[#$5 #$E #$F #$10 #$23] 4] [otherwise [throw [list :unknown-op "This op needs its length specified for disassembly to work" op [current-lambda]]]]]]]
05v #{##[]
15
10s op
0Es ΓεnΣym-104
0D
10s ΓεnΣym-104
05v #$0
20
0C
0Ao 330
0D
10s ΓεnΣym-104
05v #$1
20
0C
0Ao 316
0D
10s ΓεnΣym-104
05v #$3
20
0C
0Ao 302
0D
10s ΓεnΣym-104
05v #$C
20
0C
0Ao 288
0D
10s ΓεnΣym-104
05v #$D
20
0C
0Ao 274
0D
10s ΓεnΣym-104
05v #$11
20
0C
0Ao 260
0D
10s ΓεnΣym-104
05v #$12
20
0C
0Ao 246
0D
10s ΓεnΣym-104
05v #$13
20
0C
0Ao 232
0D
10s ΓεnΣym-104
05v #$14
20
0C
0Ao 218
0D
10s ΓεnΣym-104
05v #$15
20
0C
0Ao 204
0D
10s ΓεnΣym-104
05v #$16
20
0C
0Ao 190
0D
10s ΓεnΣym-104
05v #$1B
20
0C
0Ao 176
0D
10s ΓεnΣym-104
05v #$1C
20
0C
0Ao 162
0D
10s ΓεnΣym-104
05v #$1E
20
0C
0Ao 148
0D
10s ΓεnΣym-104
05v #$1F
20
0C
0Ao 134
0D
10s ΓεnΣym-104
05v #$20
20
0C
0Ao 120
0D
10s ΓεnΣym-104
05v #$21
20
0C
0Ao 106
0D
10s ΓεnΣym-104
05v #$22
20
0C
0Ao 92
0D
10s ΓεnΣym-104
05v #$24
20
0C
0Ao 78
0D
10s ΓεnΣym-104
05v #$25
20
0C
0Ao 64
0D
10s ΓεnΣym-104
05v #$26
20
0C
0Ao 50
0D
10s ΓεnΣym-104
05v #$27
20
0C
0Ao 36
0D
10s ΓεnΣym-104
05v #$28
20
0C
0Ao 22
0D
10s ΓεnΣym-104
05v #$29
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 1
09o 265
10s ΓεnΣym-104
05v #$2
20
0C
0Ao 50
0D
10s ΓεnΣym-104
05v #$4
20
0C
0Ao 36
0D
10s ΓεnΣym-104
05v #$7
20
0C
0Ao 22
0D
10s ΓεnΣym-104
05v #$1A
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 2
09o 197
10s ΓεnΣym-104
05v #$9
20
0C
0Ao 64
0D
10s ΓεnΣym-104
05v #$A
20
0C
0Ao 50
0D
10s ΓεnΣym-104
05v #$B
20
0C
0Ao 36
0D
10s ΓεnΣym-104
05v #$18
20
0C
0Ao 22
0D
10s ΓεnΣym-104
05v #$19
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 3
09o 115
10s ΓεnΣym-104
05v #$5
20
0C
0Ao 64
0D
10s ΓεnΣym-104
05v #$E
20
0C
0Ao 50
0D
10s ΓεnΣym-104
05v #$F
20
0C
0Ao 36
0D
10s ΓεnΣym-104
05v #$10
20
0C
0Ao 22
0D
10s ΓεnΣym-104
05v #$23
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 4
09o 33
05v throw
05v list
05v :unknown-op
05v "This op needs its length specified for disassembly to work"
10s op
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es disassemble/length
0D
23s bytecode/nil-catcher
05v [error]
05v #@[source: [[if [== [car error] :type-error] #nil [throw error]]]]
05v #{##[]
10s error
11
05v :type-error
20
0Bo 7
24
09o 13
05v throw
10s error
04i 1
01
}
17
0Es bytecode/nil-catcher
0D
23s bytecode-op->val
05v [a b c]
05v #@[documentation: "Turn three bytecode ops representing an encoded value into an actual value" source: ["Turn three bytecode ops representing an encoded value into an actual value" [index->val [logior [ash [bytecode-op->int a] 16] [ash [bytecode-op->int b] 8] [bytecode-op->int c]]]]]
05v #{##[]
05v index->val
05v logior
05v logior
05v ash
05v bytecode-op->int
10s a
04i 1
02i 16
04i 2
05v ash
05v bytecode-op->int
10s b
04i 1
02i 8
04i 2
04i 2
05v bytecode-op->int
10s c
04i 1
04i 2
04i 1
01
}
17
0Es bytecode-op->val
0D
23s bytecode-arr->val
05v [a i]
05v #@[documentation: "Read a bytecode encoded value in A at I and return it" source: ["Read a bytecode encoded value in A at I and return it" [try bytecode/nil-catcher [bytecode-op->val [ref a i] [ref a [+ 1 i]] [ref a [+ 2 i]]]]]]
05v #{##[]
10s bytecode/nil-catcher
19o 68
05v bytecode-op->val
05v ref
10s a
10s i
04i 2
05v ref
10s a
05v +
02i 1
10s i
04i 2
04i 2
05v ref
10s a
05v +
02i 2
10s i
04i 2
04i 2
04i 3
16
01
}
17
0Es bytecode-arr->val
0D
23s bytecode-op->sym
05v [a b c]
05v #@[documentation: "Turn three bytecode ops representing an encoded symbol into an actual symbol" source: ["Turn three bytecode ops representing an encoded symbol into an actual symbol" [index->sym [logior [ash [bytecode-op->int a] 16] [ash [bytecode-op->int b] 8] [bytecode-op->int c]]]]]
05v #{##[]
05v index->sym
05v logior
05v logior
05v ash
05v bytecode-op->int
10s a
04i 1
02i 16
04i 2
05v ash
05v bytecode-op->int
10s b
04i 1
02i 8
04i 2
04i 2
05v bytecode-op->int
10s c
04i 1
04i 2
04i 1
01
}
17
0Es bytecode-op->sym
0D
23s bytecode-arr->sym
05v [a i]
05v #@[documentation: "Read a bytecode encoded symbol in A at I and return it" source: ["Read a bytecode encoded symbol in A at I and return it" [try bytecode/nil-catcher [bytecode-op->sym [ref a i] [ref a [+ 1 i]] [ref a [+ 2 i]]]]]]
05v #{##[]
10s bytecode/nil-catcher
19o 68
05v bytecode-op->sym
05v ref
10s a
10s i
04i 2
05v ref
10s a
05v +
02i 1
10s i
04i 2
04i 2
05v ref
10s a
05v +
02i 2
10s i
04i 2
04i 2
04i 3
16
01
}
17
0Es bytecode-arr->sym
0D
23s bytecode-op->offset
05v [a b]
05v #@[documentation: "Turn two bytecode ops encoding an offset into the integer representation" source: ["Turn two bytecode ops encoding an offset into the integer representation" [def t [logior [ash [bytecode-op->int a] 8] [bytecode-op->int b]]] [if-not [> t 32768] t [- [- 65536 t]]]]]
05v #{##[]
05v logior
05v ash
05v bytecode-op->int
10s a
04i 1
02i 8
04i 2
05v bytecode-op->int
10s b
04i 1
04i 2
0Es t
0D
10s t
05v 32768
22
0Bo 26
05v -
05v -
05v 65536
10s t
04i 2
04i 1
09o 7
10s t
01
}
17
0Es bytecode-op->offset
0D
23s bytecode-arr->offset
05v [a i]
05v #@[documentation: "Read a bytecode encoded offset in A at I and return it as a signed integer" source: ["Read a bytecode encoded offset in A at I and return it as a signed integer" [bytecode-op->offset [ref a i] [ref a [+ 1 i]]]]]
05v #{##[]
05v bytecode-op->offset
05v ref
10s a
10s i
04i 2
05v ref
10s a
05v +
02i 1
10s i
04i 2
04i 2
04i 2
01
}
17
0Es bytecode-arr->offset
0D
23s disassemble/op
05v [a i literals]
05v #@[documentation: "Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" source: ["Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" [case [ref a i] [#$0 '[$nop]] [#$1 '[$ret]] [#$2 [quasiquote [$push/int/byte [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$3 '[$add/int]] [#$4 [quasiquote [$apply/dynamic [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$5 [quasiquote [$push/lval [unquote [bytecode-arr->val a [+ i 1]]]]]] [#$7 [quasiquote [$apply/dynamic/new [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$9 [quasiquote [$jmp* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$A [quasiquote [$jt* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$B [quasiquote [$jf* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$C '[$dup]] [#$D '[$drop]] [#$E [quasiquote [$def [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$F [quasiquote [$set [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$10 [quasiquote [$get [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$11 '[$car]] [#$12 '[$cdr]] [#$13 '[$closure/push]] [#$14 '[$cons]] [#$15 '[$let]] [#$16 '[$closure/pop]] [#$18 [quasiquote [$try/old [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$19 [quasiquote [$try [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$1A [quasiquote [$push/val [unquote [ref literals [bytecode-op->int [ref a [+ i 1]]]]]]]] [#$1B [quasiquote [$roots/push]]] [#$1C [quasiquote [$roots/pop]]] [#$1E [quasiquote [$<]]] [#$1F [quasiquote [$<=]]] [#$20 [quasiquote [$==]]] [#$21 [quasiquote [$>=]]] [#$22 [quasiquote [$>]]] [#$23 [quasiquote [$push/symbol [unquote [bytecode-arr->sym a [+ i 1]]]]]] [#$24 [quasiquote [$push/nil]]] [#$25 '[$add]] [#$26 '[$sub]] [#$27 '[$mul]] [#$28 '[$div]] [#$29 '[$mod]] [otherwise :unknown-op]]]]
05v #{##[]
15
05v ref
10s a
10s i
04i 2
0Es ΓεnΣym-105
0D
10s ΓεnΣym-105
05v #$0
20
0Bo 10
05v [$nop]
09o 1110
10s ΓεnΣym-105
05v #$1
20
0Bo 10
05v [$ret]
09o 1091
10s ΓεnΣym-105
05v #$2
20
0Bo 41
23s $push/int/byte
05v bytecode-op->int
05v ref
10s a
05v +
10s i
02i 1
04i 2
04i 2
04i 1
24
14
14
09o 1041
10s ΓεnΣym-105
05v #$3
20
0Bo 10
05v [$add/int]
09o 1022
10s ΓεnΣym-105
05v #$4
20
0Bo 41
23s $apply/dynamic
05v bytecode-op->int
05v ref
10s a
05v +
10s i
02i 1
04i 2
04i 2
04i 1
24
14
14
09o 972
10s ΓεnΣym-105
05v #$5
20
0Bo 35
23s $push/lval
05v bytecode-arr->val
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 928
10s ΓεnΣym-105
05v #$7
20
0Bo 41
23s $apply/dynamic/new
05v bytecode-op->int
05v ref
10s a
05v +
10s i
02i 1
04i 2
04i 2
04i 1
24
14
14
09o 878
10s ΓεnΣym-105
05v #$9
20
0Bo 35
23s $jmp*
05v bytecode-arr->offset
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 834
10s ΓεnΣym-105
05v #$A
20
0Bo 35
23s $jt*
05v bytecode-arr->offset
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 790
10s ΓεnΣym-105
05v #$B
20
0Bo 35
23s $jf*
05v bytecode-arr->offset
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 746
10s ΓεnΣym-105
05v #$C
20
0Bo 10
05v [$dup]
09o 727
10s ΓεnΣym-105
05v #$D
20
0Bo 10
05v [$drop]
09o 708
10s ΓεnΣym-105
05v #$E
20
0Bo 35
23s $def
05v bytecode-arr->sym
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 664
10s ΓεnΣym-105
05v #$F
20
0Bo 35
23s $set
05v bytecode-arr->sym
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 620
10s ΓεnΣym-105
05v #$10
20
0Bo 35
23s $get
05v bytecode-arr->sym
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 576
10s ΓεnΣym-105
05v #$11
20
0Bo 10
05v [$car]
09o 557
10s ΓεnΣym-105
05v #$12
20
0Bo 10
05v [$cdr]
09o 538
10s ΓεnΣym-105
05v #$13
20
0Bo 10
05v [$closure/push]
09o 519
10s ΓεnΣym-105
05v #$14
20
0Bo 10
05v [$cons]
09o 500
10s ΓεnΣym-105
05v #$15
20
0Bo 10
05v [$let]
09o 481
10s ΓεnΣym-105
05v #$16
20
0Bo 10
05v [$closure/pop]
09o 462
10s ΓεnΣym-105
05v #$18
20
0Bo 35
23s $try/old
05v bytecode-arr->offset
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 418
10s ΓεnΣym-105
05v #$19
20
0Bo 35
23s $try
05v bytecode-arr->offset
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 374
10s ΓεnΣym-105
05v #$1A
20
0Bo 51
23s $push/val
05v ref
10s literals
05v bytecode-op->int
05v ref
10s a
05v +
10s i
02i 1
04i 2
04i 2
04i 1
04i 2
24
14
14
09o 314
10s ΓεnΣym-105
05v #$1B
20
0Bo 12
23s $roots/push
24
14
09o 293
10s ΓεnΣym-105
05v #$1C
20
0Bo 12
23s $roots/pop
24
14
09o 272
10s ΓεnΣym-105
05v #$1E
20
0Bo 12
23s $<
24
14
09o 251
10s ΓεnΣym-105
05v #$1F
20
0Bo 12
23s $<=
24
14
09o 230
10s ΓεnΣym-105
05v #$20
20
0Bo 12
23s $==
24
14
09o 209
10s ΓεnΣym-105
05v #$21
20
0Bo 12
23s $>=
24
14
09o 188
10s ΓεnΣym-105
05v #$22
20
0Bo 12
23s $>
24
14
09o 167
10s ΓεnΣym-105
05v #$23
20
0Bo 35
23s $push/symbol
05v bytecode-arr->sym
10s a
05v +
10s i
02i 1
04i 2
04i 2
24
14
14
09o 123
10s ΓεnΣym-105
05v #$24
20
0Bo 12
23s $push/nil
24
14
09o 102
10s ΓεnΣym-105
05v #$25
20
0Bo 10
05v [$add]
09o 83
10s ΓεnΣym-105
05v #$26
20
0Bo 10
05v [$sub]
09o 64
10s ΓεnΣym-105
05v #$27
20
0Bo 10
05v [$mul]
09o 45
10s ΓεnΣym-105
05v #$28
20
0Bo 10
05v [$div]
09o 26
10s ΓεnΣym-105
05v #$29
20
0Bo 10
05v [$mod]
09o 7
05v :unknown-op
16
01
}
17
0Es disassemble/op
0D
23s disassemble/array
05v [a i literals]
05v #@[documentation: "Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" source: ["Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" [def ret #nil] [while [< i [array/length a]] [set! ret [cons [cons i [disassemble/op a i literals]] ret]] [set! i [+ i [disassemble/length [ref a i]]]]] [nreverse ret]]]
05v #{##[]
24
0Es ret
0D
02i 0
1B
1C
10s i
05v array/length
10s a
04i 1
1E
0Bo 74
0D
10s i
05v disassemble/op
10s a
10s i
10s literals
04i 3
14
10s ret
14
0Fs ret
0D
05v +
10s i
05v disassemble/length
05v ref
10s a
10s i
04i 2
04i 1
04i 2
0Fs i
09o -87
0D
05v nreverse
10s ret
04i 1
01
}
17
0Es disassemble/array
0D
23s disassemble/bytecode-array
05v [code]
05v #@[documentation: "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," source: ["Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," [disassemble/array [bytecode-arr->arr code] 0 [bytecode-literals code]]]]
05v #{##[]
05v disassemble/array
05v bytecode-arr->arr
10s code
04i 1
02i 0
05v bytecode-literals
10s code
04i 1
04i 3
01
}
17
0Es disassemble/bytecode-array
0D
23s disassemble/print
05v [bc]
05v #@[source: [[for-in [a [disassemble/bytecode-array bc]] [println [cat [ansi-blue [string/pad-start [string [car a]] 6]] " - " [cdr a]]]]]]
05v #{##[]
15
05v disassemble/bytecode-array
10s bc
04i 1
0Es ΓεnΣym-106
0D
10s ΓεnΣym-106
0Bo 87
02i 0
1B
1C
10s ΓεnΣym-106
0Bo 73
0D
10s ΓεnΣym-106
11
0Es a
0D
05v println
05v cat
05v ansi-blue
05v string/pad-start
05v string
10s a
11
04i 1
02i 6
04i 2
04i 1
05v " - "
10s a
12
04i 3
04i 1
0D
10s ΓεnΣym-106
12
0Fs ΓεnΣym-106
09o -75
09o 4
24
16
01
}
17
0Es disassemble/print
0D
23s disassemble
05v [bc]
05v #@[documentation: "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," source: ["Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," [case [type-of bc] [[:lambda :macro] [disassemble/print [closure/code bc]]] [:bytecode-array [disassemble/print bc]] [otherwise [throw [list :type-error "Can't disassemble that" bc [current-lambda]]]]]]]
05v #{##[]
15
05v type-of
10s bc
04i 1
0Es ΓεnΣym-107
0D
10s ΓεnΣym-107
05v :lambda
20
0C
0Ao 22
0D
10s ΓεnΣym-107
05v :macro
20
0C
0Ao 8
0D
05v #f
0Bo 22
05v disassemble/print
05v closure/code
10s bc
04i 1
04i 1
09o 58
10s ΓεnΣym-107
05v :bytecode-array
20
0Bo 16
05v disassemble/print
10s bc
04i 1
09o 33
05v throw
05v list
05v :type-error
05v "Can't disassemble that"
10s bc
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es disassemble
01
}#{##[]
23s macroexpand/do/args
05v [args env]
05v #@[source: [[if [last? args] [cons [macroexpand* [car args] env] #nil] [if [pair? [car args]] [let* [def ocar [macroexpand* [car args] env]] [if [pair? ocar] [cons ocar [macroexpand/do/args [cdr args] env]] [macroexpand/do/args [cdr args] env]]] [macroexpand/do/args [cdr args] env]]]]]
05v #{##[]
05v nil?
10s args
12
04i 1
0Bo 23
05v macroexpand*
10s args
11
10s env
04i 2
24
14
09o 108
05v pair?
10s args
11
04i 1
0Bo 79
15
05v macroexpand*
10s args
11
10s env
04i 2
0Es ocar
0D
05v pair?
10s ocar
04i 1
0Bo 26
10s ocar
05v macroexpand/do/args
10s args
12
10s env
04i 2
14
09o 18
05v macroexpand/do/args
10s args
12
10s env
04i 2
16
09o 18
05v macroexpand/do/args
10s args
12
10s env
04i 2
01
}
17
0Es macroexpand/do/args
0D
23s macroexpand/do
05v [source env]
05v #@[source: [[def args [macroexpand/do/args source env]] [if [last? args] [car args] [cons 'do args]]]]
05v #{##[]
05v macroexpand/do/args
10s source
10s env
04i 2
0Es args
0D
05v nil?
10s args
12
04i 1
0Bo 11
10s args
11
09o 12
23s do
10s args
14
01
}
17
0Es macroexpand/do
0D
23s macroexpand/form
05v [source env op arity implicit-do? no-expand-bitmap]
05v #@[source: [[def ret [cons op #nil]] [def l [cdr source]] [for [i 0 arity] [set! ret [cons [if [bit-set? no-expand-bitmap i] [car l] [macroexpand* [car l] env]] ret]] [cdr! l]] [if implicit-do? [set! ret [cons [macroexpand/do l env] ret]] [when l [throw [list :arity-error [cat "form contains more than " arity " arguments"] source [current-lambda]]]]] [return [nreverse ret]]]]
05v #{##[]
10s op
24
14
0Es ret
0D
10s source
12
0Es l
0D
15
02i 0
0Es i
0D
10s arity
0Es ΓεnΣym-111
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-111
1E
0Bo 78
0D
05v bit-set?
10s no-expand-bitmap
10s i
04i 2
0Bo 11
10s l
11
09o 18
05v macroexpand*
10s l
11
10s env
04i 2
10s ret
14
0Fs ret
0D
10s l
12
0Fs l
0D
02i 1
10s i
03
0Fs i
09o -85
16
0D
10s implicit-do?
0Bo 29
05v macroexpand/do
10s l
10s env
04i 2
10s ret
14
0Fs ret
09o 58
10s l
0Bo 50
05v throw
05v list
05v :arity-error
05v cat
05v "form contains more than "
10s arity
05v " arguments"
04i 3
10s source
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v nreverse
10s ret
04i 1
01
01
}
17
0Es macroexpand/form
0D
23s macroexpand/fold
05v [op source env]
05v #@[source: [[if [cdr source] [if [cddr source] [list op [macroexpand/fold op [except-last-pair source] env] [macroexpand* [car [last-pair source]] env]] [list op [macroexpand* [car source] env] [macroexpand* [cadr source] env]]] [list op [macroexpand* [car source] env]]]]]
05v #{##[]
10s source
12
0Bo 114
10s source
12
12
0Bo 61
05v list
10s op
05v macroexpand/fold
10s op
05v except-last-pair
10s source
04i 1
10s env
04i 3
05v macroexpand*
05v last-pair
10s source
04i 1
11
10s env
04i 2
04i 3
09o 44
05v list
10s op
05v macroexpand*
10s source
11
10s env
04i 2
05v macroexpand*
10s source
12
11
10s env
04i 2
04i 3
09o 28
05v list
10s op
05v macroexpand*
10s source
11
10s env
04i 2
04i 2
01
}
17
0Es macroexpand/fold
0D
23s macroexpand*
05v [source env]
05v #@[documentation: "Expand all macros within source" source: ["Expand all macros within source" [def op [if [resolves? [car source] env] [resolve [car source] env] [car source]]] [case [type-of op] [:nil source] [:native-function [case op [[+ - * / % logand logior logxor] [macroexpand/fold op [cdr source]]] [do [macroexpand/do source env]] [return [macroexpand/form source env op 1 #f 0]] [[try while] [macroexpand/form source env op 1 #t 0]] [[def set!] [macroexpand/form source env op 2 #f 1]] [if [macroexpand/form source env op 3 #f 0]] [[fn* macro*] [macroexpand/form source env op 4 #t 7]] [[let* environment*] [list op [macroexpand/do [cdr source] env]]] 'source [otherwise [map source [fn [α] [macroexpand* α env]]]]]] [:macro [macroexpand* [macro-apply op [cdr source]] env]] [otherwise [map source [fn [α] [macroexpand* α env]]]]]]]
05v #{##[]
05v resolves?
10s source
11
10s env
04i 2
0Bo 21
05v resolve
10s source
11
10s env
04i 2
09o 8
10s source
11
0Es op
0D
15
05v type-of
10s op
04i 1
0Es ΓεnΣym-112
0D
10s ΓεnΣym-112
05v :nil
20
0Bo 10
10s source
09o 645
10s ΓεnΣym-112
05v :native-function
20
0Bo 566
15
10s op
0Es ΓεnΣym-113
0D
10s ΓεnΣym-113
10s +
20
0C
0Ao 106
0D
10s ΓεnΣym-113
10s -
20
0C
0Ao 92
0D
10s ΓεnΣym-113
10s *
20
0C
0Ao 78
0D
10s ΓεnΣym-113
10s /
20
0C
0Ao 64
0D
10s ΓεnΣym-113
10s %
20
0C
0Ao 50
0D
10s ΓεnΣym-113
10s logand
20
0C
0Ao 36
0D
10s ΓεnΣym-113
10s logior
20
0C
0Ao 22
0D
10s ΓεnΣym-113
10s logxor
20
0C
0Ao 8
0D
05v #f
0Bo 21
05v macroexpand/fold
10s op
10s source
12
04i 2
09o 415
10s ΓεnΣym-113
10s do
20
0Bo 20
05v macroexpand/do
10s source
10s env
04i 2
09o 386
10s ΓεnΣym-113
10s return
20
0Bo 32
05v macroexpand/form
10s source
10s env
10s op
02i 1
05v #f
02i 0
04i 6
09o 345
10s ΓεnΣym-113
10s try
20
0C
0Ao 22
0D
10s ΓεnΣym-113
10s while
20
0C
0Ao 8
0D
05v #f
0Bo 32
05v macroexpand/form
10s source
10s env
10s op
02i 1
05v #t
02i 0
04i 6
09o 281
10s ΓεnΣym-113
10s def
20
0C
0Ao 22
0D
10s ΓεnΣym-113
10s set!
20
0C
0Ao 8
0D
05v #f
0Bo 32
05v macroexpand/form
10s source
10s env
10s op
02i 2
05v #f
02i 1
04i 6
09o 217
10s ΓεnΣym-113
10s if
20
0Bo 32
05v macroexpand/form
10s source
10s env
10s op
02i 3
05v #f
02i 0
04i 6
09o 176
10s ΓεnΣym-113
10s fn*
20
0C
0Ao 22
0D
10s ΓεnΣym-113
10s macro*
20
0C
0Ao 8
0D
05v #f
0Bo 32
05v macroexpand/form
10s source
10s env
10s op
02i 4
05v #t
02i 7
04i 6
09o 112
10s ΓεnΣym-113
10s let*
20
0C
0Ao 22
0D
10s ΓεnΣym-113
10s environment*
20
0C
0Ao 8
0D
05v #f
0Bo 31
05v list
10s op
05v macroexpand/do
10s source
12
10s env
04i 2
04i 2
09o 49
10s ΓεnΣym-113
10s quote
20
0Bo 10
10s source
09o 30
05v map
10s source
23s anonymous
05v [α]
05v #@[source: [[macroexpand* α env]]]
05v #{##[]
05v macroexpand*
10s α
10s env
04i 2
01
}
17
04i 2
16
09o 70
10s ΓεnΣym-112
05v :macro
20
0Bo 31
05v macroexpand*
05v macro-apply
10s op
10s source
12
04i 2
10s env
04i 2
09o 30
05v map
10s source
23s anonymous
05v [α]
05v #@[source: [[macroexpand* α env]]]
05v #{##[]
05v macroexpand*
10s α
10s env
04i 2
01
}
17
04i 2
16
01
}
17
0Es macroexpand*
0D
23s macroexpand
05v [source env]
05v #@[documentation: "Macroexpand the forms in source" source: ["Macroexpand the forms in source" [macroexpand* source [or env [current-closure]]]]]
05v #{##[]
05v macroexpand*
10s source
10s env
0C
0Ao 19
0D
05v current-closure
04i 0
0C
0Ao 8
0D
05v #f
04i 2
01
}
17
0Es macroexpand
01
}#{##[]
24
0Es yield-queue
0D
23s yield
05v [pred fun]
05v #@[documentation: "Evaluates FUN once PRED is true" source: ["Evaluates FUN once PRED is true" [set! yield-queue [cons [cons pred fun] yield-queue]] #t]]
05v #{##[]
10s pred
10s fun
14
10s yield-queue
14
0Fs yield-queue
0D
05v #t
01
}
17
0Es yield
0D
23s yield-run
05v []
05v #@[documentation: "Executes pending coroutines if their predicate evaluates to #t" source: ["Executes pending coroutines if their predicate evaluates to #t" [def old yield-queue] [set! yield-queue #nil] [for-in [cur old] [if [[car cur]] [[cdr cur]] [set! yield-queue [cons cur yield-queue]]]]]]
05v #{##[]
10s yield-queue
0Es old
0D
24
0Fs yield-queue
0D
15
10s old
0Es ΓεnΣym-116
0D
10s ΓεnΣym-116
0Bo 74
02i 0
1B
1C
10s ΓεnΣym-116
0Bo 60
0D
10s ΓεnΣym-116
11
0Es cur
0D
10s cur
11
04i 0
0Bo 13
10s cur
12
04i 0
09o 16
10s cur
10s yield-queue
14
0Fs yield-queue
0D
10s ΓεnΣym-116
12
0Fs ΓεnΣym-116
09o -62
09o 4
24
16
01
}
17
0Es yield-run
0D
23s timeout
05v [milliseconds]
05v #@[documentation: "Returns a function that evaluates to true once MILLISECONDS have passed" source: ["Returns a function that evaluates to true once MILLISECONDS have passed" [def goal [+ [time/milliseconds] milliseconds]] [fn [] [> [time/milliseconds] goal]]]]
05v #{##[]
05v +
05v time/milliseconds
04i 0
10s milliseconds
04i 2
0Es goal
0D
23s anonymous
05v []
05v #@[source: [[> [time/milliseconds] goal]]]
05v #{##[]
05v time/milliseconds
04i 0
10s goal
22
01
}
17
01
}
17
0Es timeout
0D
23s event-bind
05v [event id handler]
05v #@[documentation: "Bind handler to be evaluated when event-name fires, overwriting whichever handler has been associated with id before." source: ["Bind handler to be evaluated when event-name fires, overwriting whichever handler has been associated with id before." [tree/set! event id handler]]]
05v #{##[]
05v tree/set!
10s event
10s id
10s handler
04i 3
01
}
17
0Es event-bind
0D
23s event-clear
05v [event]
05v #@[documentation: "Clears all event handlers for event-name" source: ["Clears all event handlers for event-name" [quasiquote [set! [unquote event] [tree/new #nil]]]]]
05v #{##[]
23s set!
10s event
23s tree/new
24
24
14
14
24
14
14
14
01
}
18
0Es event-clear
0D
23s event-fire
05v [event val]
05v #@[documentation: "Applies ...val to all event handlers associated with event-name" source: ["Applies ...val to all event handlers associated with event-name" [for-in [h [tree/values event]] [h val]]]]
05v #{##[]
15
05v tree/values
10s event
04i 1
0Es ΓεnΣym-117
0D
10s ΓεnΣym-117
0Bo 51
02i 0
1B
1C
10s ΓεnΣym-117
0Bo 37
0D
10s ΓεnΣym-117
11
0Es h
0D
10s h
10s val
04i 1
0D
10s ΓεnΣym-117
12
0Fs ΓεnΣym-117
09o -39
09o 4
24
16
01
}
17
0Es event-fire
01
}#{##[]
23s let/arg
05v [arg]
05v #@[source: [[when arg [when [or [not [pair? arg]] [not [symbol? [car arg]]]] [throw [list :invalid-let-form "Please fix the structure of the let form" arg]]] [quasiquote [def [unquote [car arg]] [unquote [cadr arg]]]]]]]
05v #{##[]
10s arg
0Bo 120
05v pair?
10s arg
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 38
0D
05v symbol?
10s arg
11
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 8
0D
05v #f
0Bo 30
05v throw
05v list
05v :invalid-let-form
05v "Please fix the structure of the let form"
10s arg
04i 3
04i 1
09o 4
24
0D
23s def
10s arg
11
10s arg
12
11
24
14
14
14
09o 4
24
01
}
17
0Es let/arg
0D
23s let/args
05v [args]
05v #@[source: [[if-not args #nil [cons [let/arg [car args]] [let/args [cdr args]]]]]]
05v #{##[]
10s args
0Bo 29
05v let/arg
10s args
11
04i 1
05v let/args
10s args
12
04i 1
14
09o 4
24
01
}
17
0Es let/args
0D
23s let
05v [bindings . body]
05v #@[documentation: "Evalutes to BODY if PRED is true" source: ["Evalutes to BODY if PRED is true" [quasiquote [let* [do [unquote-splicing [let/args bindings]] [unquote-splicing body]]]]]]
05v #{##[]
23s let*
23s do
05v append
05v let/args
10s bindings
04i 1
05v append
10s body
24
04i 2
04i 2
14
24
14
14
01
}
18
0Es let
0D
23s if-let
05v [binding then else]
05v #@[source: [[quasiquote [let* [def [unquote [car binding]] [unquote [cadr binding]]] [if [unquote [car binding]] [unquote then] [unquote else]]]]]]
05v #{##[]
23s let*
23s def
10s binding
11
10s binding
12
11
24
14
14
14
23s if
10s binding
11
10s then
10s else
24
14
14
14
14
24
14
14
14
01
}
18
0Es if-let
0D
23s when-let
05v [binding . body]
05v #@[source: [[quasiquote [if-let [unquote binding] [unquote [cons 'do body]] #nil]]]]
05v #{##[]
23s if-let
10s binding
23s do
10s body
14
24
24
14
14
14
14
01
}
18
0Es when-let
01
}#{##[]
05v #t
0Es otherwise
0D
23s comment
23s body
05v #@[documentation: "Does nothing" source: ["Does nothing" #nil]]
05v #{##[]
24
01
}
18
0Es comment
0D
23s +=
05v [val inc]
05v #@[source: [[quasiquote [set! [unquote val] [+ [unquote val] [unquote inc]]]]]]
05v #{##[]
23s set!
10s val
23s +
10s val
10s inc
24
14
14
14
24
14
14
14
01
}
18
0Es +=
0D
23s cdr!
05v [l]
05v #@[documentation: "[set! l [cdr l]]" source: ["[set! l [cdr l]]" [quasiquote [set! [unquote l] [cdr [unquote l]]]]]]
05v #{##[]
23s set!
10s l
23s cdr
10s l
24
14
14
24
14
14
14
01
}
18
0Es cdr!
0D
23s not
05v [v]
05v #@[documentation: "Return true if V is false" source: [:inline "Return true if V is false" [if v #f #t]] inline: #t]
05v #{##[]
10s v
0Bo 10
05v #f
09o 7
05v #t
01
}
17
0Es not
0D
23s identity
05v [α]
05v #@[documentation: "Returns its argument" source: [:inline "Returns its argument" α] inline: #t]
05v #{##[]
10s α
01
}
17
0Es identity
0D
23s list
23s arguments
05v #@[documentation: "Return ARGUMENTS as a list" source: ["Return ARGUMENTS as a list" arguments]]
05v #{##[]
10s arguments
01
}
17
0Es list
0D
23s default
05v [arg default-value]
05v #@[documentation: "Returns ARG or DEFAULT-VALUE if ARG is #nil" source: ["Returns ARG or DEFAULT-VALUE if ARG is #nil" [if arg arg default-value]]]
05v #{##[]
10s arg
0Bo 10
10s arg
09o 7
10s default-value
01
}
17
0Es default
0D
23s caar
05v [p]
05v #@[documentation: "[car [car p]]" source: [:inline "[car [car p]]" [car [car p]]] inline: #t]
05v #{##[]
10s p
11
11
01
}
17
0Es caar
0D
23s cadr
05v [p]
05v #@[documentation: "[car [cdr p]]" source: [:inline "[car [cdr p]]" [car [cdr p]]] inline: #t]
05v #{##[]
10s p
12
11
01
}
17
0Es cadr
0D
23s cdar
05v [p]
05v #@[documentation: "[cdr [car p]]" source: [:inline "[cdr [car p]]" [cdr [car p]]] inline: #t]
05v #{##[]
10s p
11
12
01
}
17
0Es cdar
0D
23s cddr
05v [p]
05v #@[documentation: "[cdr [cdr p]]" source: [:inline "[cdr [cdr p]]" [cdr [cdr p]]] inline: #t]
05v #{##[]
10s p
12
12
01
}
17
0Es cddr
0D
23s cadar
05v [p]
05v #@[documentation: "[cdr [car p]]" source: ["[cdr [car p]]" [car [cdr [car p]]]]]
05v #{##[]
10s p
11
12
11
01
}
17
0Es cadar
0D
23s caddr
05v [p]
05v #@[documentation: "[car [cdr [cdr p]]]" source: ["[car [cdr [cdr p]]]" [car [cdr [cdr p]]]]]
05v #{##[]
10s p
12
12
11
01
}
17
0Es caddr
0D
23s cdddr
05v [p]
05v #@[documentation: "[cdr [cdr [cdr p]]]" source: ["[cdr [cdr [cdr p]]]" [cdr [cdr [cdr p]]]]]
05v #{##[]
10s p
12
12
12
01
}
17
0Es cdddr
0D
23s cadddr
05v [p]
05v #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [car [cdr [cdr [cdr p]]]]]]
05v #{##[]
10s p
12
12
12
11
01
}
17
0Es cadddr
0D
23s cddddr
05v [p]
05v #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [cdr [cdr [cdr [cdr p]]]]]]
05v #{##[]
10s p
12
12
12
12
01
}
17
0Es cddddr
0D
23s caddddr
05v [p]
05v #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [car [cdr [cdr [cdr [cdr p]]]]]]]
05v #{##[]
10s p
12
12
12
12
11
01
}
17
0Es caddddr
0D
23s cdddddr
05v [p]
05v #@[documentation: "[cdr [cdr [cdr [cdr p]]]]" source: ["[cdr [cdr [cdr [cdr p]]]]" [cdr [cdr [cdr [cdr [cdr p]]]]]]]
05v #{##[]
10s p
12
12
12
12
12
01
}
17
0Es cdddddr
0D
23s keyword->string
05v [α]
05v #@[source: [[when-not [keyword? α] [throw [list :type-error "[keyword->string] can only be called on keywords" α [current-lambda]]]] [symbol->string [keyword->symbol α]]]]
05v #{##[]
05v keyword?
10s α
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "[keyword->string] can only be called on keywords"
10s α
05v current-lambda
04i 0
04i 4
04i 1
0D
05v symbol->string
05v keyword->symbol
10s α
04i 1
04i 1
01
}
17
0Es keyword->string
0D
23s string->keyword
05v [α]
05v #@[source: [[when-not [string? α] [throw [list :type-error "[string->keyword] can only be called on strings" α [current-lambda]]]] [symbol->keyword [string->symbol α]]]]
05v #{##[]
05v string?
10s α
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "[string->keyword] can only be called on strings"
10s α
05v current-lambda
04i 0
04i 4
04i 1
0D
05v symbol->keyword
05v string->symbol
10s α
04i 1
04i 1
01
}
17
0Es string->keyword
0D
23s exception
05v [type description value]
05v #@[source: [[quasiquote [throw [list [unquote type] [unquote description] [unquote value] [current-lambda]]]]]]
05v #{##[]
23s throw
23s list
10s type
10s description
10s value
23s current-lambda
24
14
24
14
14
14
14
14
24
14
14
01
}
18
0Es exception
01
}#{##[]
23s if-not
05v [pred then else]
05v #@[source: [[quasiquote [if [unquote pred] [unquote else] [unquote then]]]]]
05v #{##[]
23s if
10s pred
10s else
10s then
24
14
14
14
14
01
}
18
0Es if-not
0D
23s when-not
05v [pred . body]
05v #@[documentation: "Evalutes to BODY if PRED is false" source: ["Evalutes to BODY if PRED is false" [quasiquote [if [unquote pred] #nil [do [unquote-splicing body]]]]]]
05v #{##[]
23s if
10s pred
24
23s do
05v append
10s body
24
04i 2
14
24
14
14
14
14
01
}
18
0Es when-not
0D
23s when
05v [pred . body]
05v #@[documentation: "Evalutes to BODY if PRED is true" source: ["Evalutes to BODY if PRED is true" [quasiquote [if [unquote pred] [do [unquote-splicing body]] #nil]]]]
05v #{##[]
23s if
10s pred
23s do
05v append
10s body
24
04i 2
14
24
24
14
14
14
14
01
}
18
0Es when
0D
23s case/clauses/multiple
05v [key-sym cases]
05v #@[source: [[when cases [cons [list '== key-sym [car cases]] [case/clauses/multiple key-sym [cdr cases]]]]]]
05v #{##[]
10s cases
0Bo 41
05v list
23s ==
10s key-sym
10s cases
11
04i 3
05v case/clauses/multiple
10s key-sym
10s cases
12
04i 2
14
09o 4
24
01
}
17
0Es case/clauses/multiple
0D
23s case/clauses
05v [key-sym clauses]
05v #@[source: [[when clauses [if [== [caar clauses] 'otherwise] [cons 'do [cdar clauses]] [list 'if [if [pair? [caar clauses]] [if [and [== [car [caar clauses]] 'quote] [last? [cdr [caar clauses]]] [symbol? [cadr [caar clauses]]]] [list '== key-sym [caar clauses]] [cons 'or [case/clauses/multiple key-sym [caar clauses]]]] [list '== key-sym [caar clauses]]] [cons 'do [cdar clauses]] [case/clauses key-sym [cdr clauses]]]]]]]
05v #{##[]
10s clauses
0Bo 205
10s clauses
11
11
23s otherwise
20
0Bo 17
23s do
10s clauses
11
12
14
09o 174
05v list
23s if
05v pair?
10s clauses
11
11
04i 1
0Bo 103
10s clauses
11
11
11
23s quote
20
0C
0Bo 37
0D
05v nil?
10s clauses
11
11
12
12
04i 1
0C
0Bo 18
0D
05v symbol?
10s clauses
11
11
12
11
04i 1
0Bo 26
05v list
23s ==
10s key-sym
10s clauses
11
11
04i 3
09o 24
23s or
05v case/clauses/multiple
10s key-sym
10s clauses
11
11
04i 2
14
09o 23
05v list
23s ==
10s key-sym
10s clauses
11
11
04i 3
23s do
10s clauses
11
12
14
05v case/clauses
10s key-sym
10s clauses
12
04i 2
04i 4
09o 4
24
01
}
17
0Es case/clauses
0D
23s case
05v [key-form . clauses]
05v #@[source: [[def key-sym [gensym]] [list 'let* [list 'def key-sym key-form] [case/clauses key-sym clauses]]]]
05v #{##[]
05v gensym
04i 0
0Es key-sym
0D
05v list
23s let*
05v list
23s def
10s key-sym
10s key-form
04i 3
05v case/clauses
10s key-sym
10s clauses
04i 2
04i 3
01
}
18
0Es case
0D
23s cond
23s body
05v #@[documentation: "Contains multiple cond clauses" source: ["Contains multiple cond clauses" [when [and body [caar body]] [list 'if [caar body] [cons 'do [cdar body]] [macro-apply cond [cdr body]]]]]]
05v #{##[]
10s body
0C
0Bo 10
0D
10s body
11
11
0Bo 48
05v list
23s if
10s body
11
11
23s do
10s body
11
12
14
05v macro-apply
10s cond
10s body
12
04i 2
04i 4
09o 4
24
01
}
18
0Es cond
0D
23s for
05v [for-loop . body]
05v #@[documentation: "For loops, [for [name start stop] body]" source: ["For loops, [for [name start stop] body]" [def symbol-name [car for-loop]] [def loop-start [cadr for-loop]] [def loop-stop [caddr for-loop]] [def stop-var [gensym]] [def dir 1] [when [cadddr for-loop] [set! dir [cadddr for-loop]]] [when-not [symbol? symbol-name] [throw [list :invalid-for "Expected a symbol name within the for loop" symbol-name]]] [when-not loop-start [throw [list :invalid-for "Expected a start value at the second position" for-loop]]] [when-not loop-stop [throw [list :invalid-for "Expected a stop value at the third position" for-loop]]] [def pred [if [> dir 0] < >]] [quasiquote [let [[[unquote symbol-name] [unquote loop-start]] [[unquote stop-var] [unquote loop-stop]]] [while [[unquote pred] [unquote symbol-name] [unquote stop-var]] [unquote-splicing body] [set! [unquote symbol-name] [add/int [unquote dir] [unquote symbol-name]]]]]]]]
05v #{##[]
10s for-loop
11
0Es symbol-name
0D
10s for-loop
12
11
0Es loop-start
0D
05v caddr
10s for-loop
04i 1
0Es loop-stop
0D
05v gensym
04i 0
0Es stop-var
0D
02i 1
0Es dir
0D
05v cadddr
10s for-loop
04i 1
0Bo 20
05v cadddr
10s for-loop
04i 1
0Fs dir
09o 4
24
0D
05v symbol?
10s symbol-name
04i 1
0Bo 7
24
09o 27
05v throw
05v list
05v :invalid-for
05v "Expected a symbol name within the for loop"
10s symbol-name
04i 3
04i 1
0D
10s loop-start
0Bo 7
24
09o 27
05v throw
05v list
05v :invalid-for
05v "Expected a start value at the second position"
10s for-loop
04i 3
04i 1
0D
10s loop-stop
0Bo 7
24
09o 27
05v throw
05v list
05v :invalid-for
05v "Expected a stop value at the third position"
10s for-loop
04i 3
04i 1
0D
10s dir
02i 0
22
0Bo 10
10s <
09o 7
10s >
0Es pred
0D
23s let
10s symbol-name
10s loop-start
24
14
14
10s stop-var
10s loop-stop
24
14
14
24
14
14
23s while
10s pred
10s symbol-name
10s stop-var
24
14
14
14
05v append
10s body
23s set!
10s symbol-name
23s add/int
10s dir
10s symbol-name
24
14
14
14
24
14
14
14
24
14
04i 2
14
14
24
14
14
14
01
}
18
0Es for
0D
23s for-in
05v [for-loop . body]
05v #@[documentation: "[for-in [l [list 1 2 3 4]] [println l]]" source: ["[for-in [l [list 1 2 3 4]] [println l]]" [def symbol-name [gensym]] [quasiquote [let [[[unquote symbol-name] [unquote [cadr for-loop]]]] [when [unquote symbol-name] [while [unquote symbol-name] [def [unquote [car for-loop]] [car [unquote symbol-name]]] [unquote-splicing body] [cdr! [unquote symbol-name]]]]]]]]
05v #{##[]
05v gensym
04i 0
0Es symbol-name
0D
23s let
10s symbol-name
10s for-loop
12
11
24
14
14
24
14
23s when
10s symbol-name
23s while
10s symbol-name
23s def
10s for-loop
11
23s car
10s symbol-name
24
14
14
24
14
14
14
05v append
10s body
23s cdr!
10s symbol-name
24
14
14
24
14
04i 2
14
14
14
24
14
14
14
24
14
14
14
01
}
18
0Es for-in
0D
23s thread/->
05v [init fun]
05v #@[source: [[if-not fun init [if [pair? [car fun]] [quasiquote [[unquote [caar fun]] [unquote [thread/-> init [cdr fun]]] [unquote-splicing [cdar fun]]]] [list [car fun] [thread/-> init [cdr fun]]]]]]]
05v #{##[]
10s fun
0Bo 85
05v pair?
10s fun
11
04i 1
0Bo 42
10s fun
11
11
05v thread/->
10s init
10s fun
12
04i 2
05v append
10s fun
11
12
24
04i 2
14
14
09o 29
05v list
10s fun
11
05v thread/->
10s init
10s fun
12
04i 2
04i 2
09o 7
10s init
01
}
17
0Es thread/->
0D
23s ->
05v [init . fun]
05v #@[documentation: "Thread init as the first argument through every function in fun" source: ["Thread init as the first argument through every function in fun" [thread/-> init [reverse fun]]]]
05v #{##[]
05v thread/->
10s init
05v reverse
10s fun
04i 1
04i 2
01
}
18
0Es ->
0D
23s thread/->>
05v [init fun]
05v #@[source: [[if-not fun init [append [car fun] [cons [thread/->> init [cdr fun]] #nil]]]]]
05v #{##[]
10s fun
0Bo 34
05v append
10s fun
11
05v thread/->>
10s init
10s fun
12
04i 2
24
14
04i 2
09o 7
10s init
01
}
17
0Es thread/->>
0D
23s ->>
05v [init . fun]
05v #@[documentation: "Thread init as the last argument through every function in fun" source: ["Thread init as the last argument through every function in fun" [thread/->> init [reverse fun]]]]
05v #{##[]
05v thread/->>
10s init
05v reverse
10s fun
04i 1
04i 2
01
}
18
0Es ->>
01
}#{##[]
05v tree/new
24
04i 1
0Es module/cache
0D
24
0Es module/loader
0D
23s module/add-loader
05v [f]
05v #@[source: [[set! module/loader [cons f module/loader]]]]
05v #{##[]
10s f
10s module/loader
14
0Fs module/loader
01
}
17
0Es module/add-loader
0D
23s module/save-state
05v []
05v #@[source: [[tree/new :cache module/cache :loader module/loader]]]
05v #{##[]
05v tree/new
05v :cache
10s module/cache
05v :loader
10s module/loader
04i 4
01
}
17
0Es module/save-state
0D
23s module/restore-state
05v [c]
05v #@[source: [[set! module/cache [tree/ref c :cache]] [set! module/loader [tree/ref c :loader]]]]
05v #{##[]
05v tree/ref
10s c
05v :cache
04i 2
0Fs module/cache
0D
05v tree/ref
10s c
05v :loader
04i 2
0Fs module/loader
01
}
17
0Es module/restore-state
0D
23s module/qualify-symbol
05v [module-name symbol]
05v #@[source: [[string->symbol [cat [keyword->symbol module-name] "/" [string symbol]]]]]
05v #{##[]
05v string->symbol
05v cat
05v keyword->symbol
10s module-name
04i 1
05v "/"
05v string
10s symbol
04i 1
04i 3
04i 1
01
}
17
0Es module/qualify-symbol
0D
23s module
23s body
05v #@[documentation: "Define a new module and return it" source: ["Define a new module and return it" [macroexpand [cons 'ω* [cons '[def exports [tree/new #nil]] body]]]]]
05v #{##[]
05v macroexpand
23s ω*
05v [def exports [tree/new #nil]]
10s body
14
14
04i 1
01
}
18
0Es module
0D
23s defmodule
05v [name . body]
05v #@[documentation: "Define a new named module" source: ["Define a new named module" [quasiquote [module/insert [unquote name] [unquote [cons module body]]]]]]
05v #{##[]
23s module/insert
10s name
10s module
10s body
14
24
14
14
14
01
}
18
0Es defmodule
0D
23s export
05v [name value]
05v #@[source: [[quasiquote [tree/set! exports '[unquote name] [unquote value]]]]]
05v #{##[]
23s tree/set!
23s exports
23s quote
10s name
24
14
14
10s value
24
14
14
14
14
01
}
18
0Es export
0D
23s import*
05v [local-symbol module module-symbol]
05v #@[source: [[quasiquote [def [unquote local-symbol] [module/import [unquote module] '[unquote module-symbol]]]]]]
05v #{##[]
23s def
10s local-symbol
23s module/import
10s module
23s quote
10s module-symbol
24
14
14
24
14
14
14
24
14
14
14
01
}
18
0Es import*
0D
23s import
05v [names module]
05v #@[source: [[when-not [list? names] [return [quasiquote [import* [unquote [module/qualify-symbol module names]] [module/load [unquote module]] [unquote names]]]]] [def ret #nil] [while names [if [== [cadr names] :as] [do [set! ret [cons [quasiquote [import* [unquote [module/qualify-symbol module [caddr names]]] [module/load [unquote module]] [unquote [car names]]]] ret]] [set! names [cddr names]]] [set! ret [cons [quasiquote [import* [unquote [module/qualify-symbol module [car names]]] [module/load [unquote module]] [unquote [car names]]]] ret]]] [cdr! names]] [cons do [nreverse ret]]]]
05v #{##[]
05v list?
10s names
04i 1
0Bo 7
24
09o 42
23s import*
05v module/qualify-symbol
10s module
10s names
04i 2
23s module/load
10s module
24
14
14
10s names
24
14
14
14
14
01
0D
24
0Es ret
0D
02i 0
1B
1C
10s names
0Bo 148
0D
10s names
12
11
05v :as
20
0Bo 71
23s import*
05v module/qualify-symbol
10s module
05v caddr
10s names
04i 1
04i 2
23s module/load
10s module
24
14
14
10s names
11
24
14
14
14
14
10s ret
14
0Fs ret
0D
10s names
12
12
0Fs names
09o 52
23s import*
05v module/qualify-symbol
10s module
10s names
11
04i 2
23s module/load
10s module
24
14
14
10s names
11
24
14
14
14
14
10s ret
14
0Fs ret
0D
10s names
12
0Fs names
09o -150
0D
10s do
05v nreverse
10s ret
04i 1
14
01
}
18
0Es import
0D
23s module/load/external
05v [name]
05v #@[source: [[for-in [loader module/loader] [def mod [loader name]] [when mod [return mod]]] [return #nil]]]
05v #{##[]
15
10s module/loader
0Es ΓεnΣym-120
0D
10s ΓεnΣym-120
0Bo 72
02i 0
1B
1C
10s ΓεnΣym-120
0Bo 58
0D
10s ΓεnΣym-120
11
0Es loader
0D
10s loader
10s name
04i 1
0Es mod
0D
10s mod
0Bo 11
10s mod
01
09o 4
24
0D
10s ΓεnΣym-120
12
0Fs ΓεnΣym-120
09o -60
09o 4
24
16
0D
24
01
01
}
17
0Es module/load/external
0D
23s module/insert
05v [name module]
05v #@[source: [[tree/set! module/cache name module]]]
05v #{##[]
05v tree/set!
10s module/cache
10s name
10s module
04i 3
01
}
17
0Es module/insert
0D
23s module/load
05v [name]
05v #@[source: [[case [type-of name] [:object name] [:keyword [or [tree/ref module/cache name] [do [def mod [module/load/external name]] [when mod [tree/set! module/cache name mod]] [return mod]]]]]]]
05v #{##[]
15
05v type-of
10s name
04i 1
0Es ΓεnΣym-121
0D
10s ΓεnΣym-121
05v :object
20
0Bo 10
10s name
09o 97
10s ΓεnΣym-121
05v :keyword
20
0Bo 84
05v tree/ref
10s module/cache
10s name
04i 2
0C
0Ao 63
0D
05v module/load/external
10s name
04i 1
0Es mod
0D
10s mod
0Bo 24
05v tree/set!
10s module/cache
10s name
10s mod
04i 3
09o 4
24
0D
10s mod
01
0C
0Ao 8
0D
05v #f
09o 4
24
16
01
}
17
0Es module/load
0D
23s module/import-all
05v [module symbol]
05v #@[source: [[def exports [resolve 'exports module]] [typecheck/only exports :tree] [return exports]]]
05v #{##[]
05v resolve
23s exports
10s module
04i 2
0Es exports
0D
05v type-of
10s exports
04i 1
05v :tree
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :tree"
10s exports
05v current-lambda
04i 0
04i 4
04i 1
0D
10s exports
01
01
}
17
0Es module/import-all
0D
23s module/import
05v [module symbol]
05v #@[source: [[def exports [module/import-all module symbol]] [when-not [tree/has? exports symbol] [exception :import-error [if [resolves? symbol module] "That symbol was not exported" "That symbol does not exist in that module"]]] [tree/ref exports symbol]]]
05v #{##[]
05v module/import-all
10s module
10s symbol
04i 2
0Es exports
0D
05v tree/has?
10s exports
10s symbol
04i 2
0Bo 7
24
09o 54
05v throw
05v list
05v :import-error
05v resolves?
10s symbol
10s module
04i 2
0Bo 10
05v "That symbol was not exported"
09o 7
05v "That symbol does not exist in that module"
24
05v current-lambda
04i 0
04i 4
04i 1
0D
05v tree/ref
10s exports
10s symbol
04i 2
01
}
17
0Es module/import
01
}#{##[]
23s numeric?
05v [a]
05v #@[documentation: "Return #t if a is a number" source: ["Return #t if a is a number" [or [int? a] [float? a] [vec? a]]]]
05v #{##[]
05v int?
10s a
04i 1
0C
0Ao 38
0D
05v float?
10s a
04i 1
0C
0Ao 23
0D
05v vec?
10s a
04i 1
0C
0Ao 8
0D
05v #f
01
}
17
0Es numeric?
0D
23s last?
05v [a]
05v #@[documentation: "Return #t if a is the last pair in a list" source: [:inline "Return #t if a is the last pair in a list" [nil? [cdr a]]] inline: #t]
05v #{##[]
05v nil?
10s a
12
04i 1
01
}
17
0Es last?
0D
23s pos?
05v [a]
05v #@[documentation: "Return #t if a is positive" source: [:inline "Return #t if a is positive" [>= a 0.0]] inline: #t]
05v #{##[]
10s a
05v 0.0
21
01
}
17
0Es pos?
0D
23s zero-neg?
05v [a]
05v #@[documentation: "Return #t if a is zero or negative" source: [:inline "Return #t if a is zero or negative" [<= a 0.0]] inline: #t]
05v #{##[]
10s a
05v 0.0
1F
01
}
17
0Es zero-neg?
0D
23s neg?
05v [a]
05v #@[documentation: "Returns #t if a is negative" source: [:inline "Returns #t if a is negative" [< a 0.0]] inline: #t]
05v #{##[]
10s a
05v 0.0
1E
01
}
17
0Es neg?
0D
23s odd?
05v [a]
05v #@[documentation: "Predicate that returns #t if a is odd" source: ["Predicate that returns #t if a is odd" [== [% [int a] 2] 1]]]
05v #{##[]
05v %
05v int
10s a
04i 1
02i 2
04i 2
02i 1
20
01
}
17
0Es odd?
0D
23s even?
05v [a]
05v #@[documentation: "Predicate that returns #t if a is even" source: ["Predicate that returns #t if a is even" [== [mod/int [int a] 2] 0]]]
05v #{##[]
05v mod/int
05v int
10s a
04i 1
02i 2
04i 2
02i 0
20
01
}
17
0Es even?
0D
23s zero?
05v [val]
05v #@[documentation: "#t if VAL is zero" source: [:inline "#t if VAL is zero" [== 0 val]] inline: #t]
05v #{##[]
02i 0
10s val
20
01
}
17
0Es zero?
0D
23s not-zero?
05v [val]
05v #@[documentation: "#t if VAL is not zero" source: [:inline "#t if VAL is not zero" [!= 0 val]] inline: #t]
05v #{##[]
05v !=
02i 0
10s val
04i 2
01
}
17
0Es not-zero?
0D
23s equal?
05v [a b]
05v #@[documentation: "High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." source: ["High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." [def cur-type [type-of a]] [if [!= cur-type [type-of b]] #f [case cur-type [:array [array/equal? a b]] [:tree [tree/equal? a b]] [:pair [list/equal? a b]] [otherwise [== a b]]]]]]
05v #{##[]
05v type-of
10s a
04i 1
0Es cur-type
0D
05v !=
10s cur-type
05v type-of
10s b
04i 1
04i 2
0Bo 10
05v #f
09o 110
15
10s cur-type
0Es ΓεnΣym-123
0D
10s ΓεnΣym-123
05v :array
20
0Bo 20
05v array/equal?
10s a
10s b
04i 2
09o 70
10s ΓεnΣym-123
05v :tree
20
0Bo 20
05v tree/equal?
10s a
10s b
04i 2
09o 41
10s ΓεnΣym-123
05v :pair
20
0Bo 20
05v list/equal?
10s a
10s b
04i 2
09o 12
10s a
10s b
20
16
01
}
17
0Es equal?
0D
23s inequal?
05v [a b]
05v #@[documentation: "High level inequality comparator" source: ["High level inequality comparator" [not [equal? a b]]]]
05v #{##[]
05v equal?
10s a
10s b
04i 2
0Bo 10
05v #f
09o 7
05v #t
01
}
17
0Es inequal?
0D
23s int?
05v [val]
05v #@[source: [[== :int [type-of val]]]]
05v #{##[]
05v :int
05v type-of
10s val
04i 1
20
01
}
17
0Es int?
0D
23s float?
05v [val]
05v #@[source: [[== :float [type-of val]]]]
05v #{##[]
05v :float
05v type-of
10s val
04i 1
20
01
}
17
0Es float?
0D
23s vec?
05v [val]
05v #@[source: [[== :vec [type-of val]]]]
05v #{##[]
05v :vec
05v type-of
10s val
04i 1
20
01
}
17
0Es vec?
0D
23s bool?
05v [val]
05v #@[source: [[== :bool [type-of val]]]]
05v #{##[]
05v :bool
05v type-of
10s val
04i 1
20
01
}
17
0Es bool?
0D
23s pair?
05v [val]
05v #@[source: [[== :pair [type-of val]]]]
05v #{##[]
05v :pair
05v type-of
10s val
04i 1
20
01
}
17
0Es pair?
0D
23s array?
05v [val]
05v #@[source: [[== :array [type-of val]]]]
05v #{##[]
05v :array
05v type-of
10s val
04i 1
20
01
}
17
0Es array?
0D
23s string?
05v [val]
05v #@[source: [[== :string [type-of val]]]]
05v #{##[]
05v :string
05v type-of
10s val
04i 1
20
01
}
17
0Es string?
0D
23s symbol?
05v [val]
05v #@[source: [[== :symbol [type-of val]]]]
05v #{##[]
05v :symbol
05v type-of
10s val
04i 1
20
01
}
17
0Es symbol?
0D
23s object?
05v [val]
05v #@[source: [[== :object [type-of val]]]]
05v #{##[]
05v :object
05v type-of
10s val
04i 1
20
01
}
17
0Es object?
0D
23s tree?
05v [val]
05v #@[source: [[== :tree [type-of val]]]]
05v #{##[]
05v :tree
05v type-of
10s val
04i 1
20
01
}
17
0Es tree?
0D
23s keyword?
05v [v]
05v #@[source: [[== :keyword [type-of v]]]]
05v #{##[]
05v :keyword
05v type-of
10s v
04i 1
20
01
}
17
0Es keyword?
0D
23s macro?
05v [val]
05v #@[source: [[== :macro [type-of val]]]]
05v #{##[]
05v :macro
05v type-of
10s val
04i 1
20
01
}
17
0Es macro?
0D
23s lambda?
05v [val]
05v #@[source: [[or [== :lambda [type-of val]]]]]
05v #{##[]
05v :lambda
05v type-of
10s val
04i 1
20
0C
0Ao 8
0D
05v #f
01
}
17
0Es lambda?
0D
23s native?
05v [val]
05v #@[source: [[== :native-function [type-of val]]]]
05v #{##[]
05v :native-function
05v type-of
10s val
04i 1
20
01
}
17
0Es native?
0D
23s procedure?
05v [val]
05v #@[source: [[or [lambda? val] [native? val]]]]
05v #{##[]
05v lambda?
10s val
04i 1
0C
0Ao 23
0D
05v native?
10s val
04i 1
0C
0Ao 8
0D
05v #f
01
}
17
0Es procedure?
0D
23s buffer?
05v [v]
05v #@[source: [[== :buffer [type-of v]]]]
05v #{##[]
05v :buffer
05v type-of
10s v
04i 1
20
01
}
17
0Es buffer?
0D
23s buffer-view?
05v [v]
05v #@[source: [[== :buffer-view [type-of v]]]]
05v #{##[]
05v :buffer-view
05v type-of
10s v
04i 1
20
01
}
17
0Es buffer-view?
0D
23s bytecode-array?
05v [v]
05v #@[source: [[== :bytecode-array [type-of v]]]]
05v #{##[]
05v :bytecode-array
05v type-of
10s v
04i 1
20
01
}
17
0Es bytecode-array?
0D
23s bytecode-op?
05v [v]
05v #@[source: [[== :bytecode-op [type-of v]]]]
05v #{##[]
05v :bytecode-op
05v type-of
10s v
04i 1
20
01
}
17
0Es bytecode-op?
0D
23s in-range?
05v [v min max]
05v #@[source: [[and [>= v min] [<= v max]]]]
05v #{##[]
10s v
10s min
21
0C
0Bo 13
0D
10s v
10s max
1F
01
}
17
0Es in-range?
01
}#{##[]
23s quasiquote-real
05v [l depth]
05v #@[source: [[if [nil? l] #nil [if [pair? l] [if [== [caar l] 'unquote-splicing] [if [zero? depth] [list 'append [cadr [car l]] [quasiquote-real [cdr l] depth]] [list 'unquote-splicing [quasiquote-real [cadr l] [+ -1 depth]]]] [if [== [car l] 'unquote] [if [zero? depth] [cadr l] [list 'unquote [quasiquote-real [cadr l] [+ -1 depth]]]] [if [== [car l] 'quasiquote] [quasiquote-real [quasiquote-real [cadr l] [+ 1 depth]] depth] [if [zero? depth] [list 'cons [quasiquote-real [car l] depth] [quasiquote-real [cdr l] depth]] [cons [quasiquote-real [car l] depth] [quasiquote-real [cdr l] depth]]]]]] [if [and [zero? depth] [symbol? l]] [cons 'quote [cons l #nil]] l]]]]]
05v #{##[]
05v nil?
10s l
04i 1
0Bo 7
24
09o 361
05v pair?
10s l
04i 1
0Bo 305
10s l
11
11
23s unquote-splicing
20
0Bo 85
02i 0
10s depth
20
0Bo 38
05v list
23s append
10s l
11
12
11
05v quasiquote-real
10s l
12
10s depth
04i 2
04i 3
09o 37
05v list
23s unquote-splicing
05v quasiquote-real
10s l
12
11
05v +
02i -1
10s depth
04i 2
04i 2
04i 2
09o 206
10s l
11
23s unquote
20
0Bo 59
02i 0
10s depth
20
0Bo 12
10s l
12
11
09o 37
05v list
23s unquote
05v quasiquote-real
10s l
12
11
05v +
02i -1
10s depth
04i 2
04i 2
04i 2
09o 137
10s l
11
23s quasiquote
20
0Bo 40
05v quasiquote-real
05v quasiquote-real
10s l
12
11
05v +
02i 1
10s depth
04i 2
04i 2
10s depth
04i 2
09o 87
02i 0
10s depth
20
0Bo 46
05v list
23s cons
05v quasiquote-real
10s l
11
10s depth
04i 2
05v quasiquote-real
10s l
12
10s depth
04i 2
04i 3
09o 34
05v quasiquote-real
10s l
11
10s depth
04i 2
05v quasiquote-real
10s l
12
10s depth
04i 2
14
09o 46
02i 0
10s depth
20
0C
0Bo 14
0D
05v symbol?
10s l
04i 1
0Bo 17
23s quote
10s l
24
14
14
09o 7
10s l
01
}
17
0Es quasiquote-real
0D
23s quasiquote
05v [l]
05v #@[source: [[quasiquote-real l 0]]]
05v #{##[]
05v quasiquote-real
10s l
02i 0
04i 2
01
}
18
0Es quasiquote
0D
23s unquote
05v [expr]
05v #@[source: [[throw [list :unquote-without-quasiquote "unquote should only occur inside a quasiquote, never evaluated directly"]]]]
05v #{##[]
05v throw
05v list
05v :unquote-without-quasiquote
05v "unquote should only occur inside a quasiquote, never evaluated directly"
04i 2
04i 1
01
}
17
0Es unquote
0D
23s unquote-splicing
05v [expr]
05v #@[source: [[throw [list :unquote-splicing-without-quasiq "unquote-splicing should only occur inside a quasiquote, never evaluated directly"]]]]
05v #{##[]
05v throw
05v list
05v :unquote-splicing-without-quasiq
05v "unquote-splicing should only occur inside a quasiquote, never evaluated directly"
04i 2
04i 1
01
}
17
0Es unquote-splicing
01
}#{##[]
23s describe/closure
05v [c i]
05v #@[source: [[when c [if [== c root-closure] [cat [ansi-blue [cat [int [or i 0]] "# <root environment>"]] "\r\n"] [do [def data [closure/data c]] [def l [length data]] [cat [ansi-blue [cat [int [or i 0]] "# " [string/write c]]] " - " [if [< l 16] [string/write data] "-+- Very big tree structure -+-"] "\r\n" [describe/closure [closure/caller c] [+ [int [or i 0]] 1]]]]]]]]
05v #{##[]
10s c
0Bo 246
10s c
10s root-closure
20
0Bo 58
05v cat
05v ansi-blue
05v cat
05v int
10s i
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
04i 1
05v "# <root environment>"
04i 2
04i 1
05v "\r\n"
04i 2
09o 176
05v closure/data
10s c
04i 1
0Es data
0D
05v length
10s data
04i 1
0Es l
0D
05v cat
05v ansi-blue
05v cat
05v int
10s i
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
04i 1
05v "# "
05v string/write
10s c
04i 1
04i 3
04i 1
05v " - "
10s l
02i 16
1E
0Bo 16
05v string/write
10s data
04i 1
09o 7
05v "-+- Very big tree structure -+-"
05v "\r\n"
05v describe/closure
05v closure/caller
10s c
04i 1
05v +
05v int
10s i
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
04i 1
02i 1
04i 2
04i 2
04i 5
09o 4
24
01
}
17
0Es describe/closure
0D
23s stacktrace
05v []
05v #@[source: [[display [describe/closure [closure/caller [current-lambda]]]]]]
05v #{##[]
05v print
05v describe/closure
05v closure/caller
05v current-lambda
04i 0
04i 1
04i 1
04i 1
01
}
17
0Es stacktrace
01
}#{##[]
23s time/seconds
05v [timestamp]
05v #@[documentation: "Return the seconds part of TIMESTAMP, defaults to current time" source: ["Return the seconds part of TIMESTAMP, defaults to current time" [% [default timestamp [time]] 60]]]
05v #{##[]
05v %
05v default
10s timestamp
05v time
04i 0
04i 2
02i 60
04i 2
01
}
17
0Es time/seconds
0D
23s time/minutes
05v [timestamp]
05v #@[documentation: "Return the minutes part of TIMESTAMP, defaults to current time" source: ["Return the minutes part of TIMESTAMP, defaults to current time" [% [/ [default timestamp [time]] 60] 60]]]
05v #{##[]
05v %
05v /
05v default
10s timestamp
05v time
04i 0
04i 2
02i 60
04i 2
02i 60
04i 2
01
}
17
0Es time/minutes
0D
23s time/hours
05v [timestamp]
05v #@[documentation: "Return the hours part of TIMESTAMP, defaults to current time" source: ["Return the hours part of TIMESTAMP, defaults to current time" [% [/ [default timestamp [time]] 3600] 24]]]
05v #{##[]
05v %
05v /
05v default
10s timestamp
05v time
04i 0
04i 2
05v 3600
04i 2
02i 24
04i 2
01
}
17
0Es time/hours
0D
23s profile-form
05v [raw]
05v #@[source: [[def start-time [time/milliseconds]] [def val [eval raw]] [def end-time [time/milliseconds]] [display [cat "Evaluating " [ansi-yellow [string/write raw]] " to " [ansi-green [string/write val]] " took " [ansi-red [cat [- end-time start-time] "ms"] "\n"]]]]]
05v #{##[]
05v time/milliseconds
04i 0
0Es start-time
0D
05v eval-in
05v current-closure
04i 0
10s raw
04i 2
0Es val
0D
05v time/milliseconds
04i 0
0Es end-time
0D
05v print
05v cat
05v "Evaluating "
05v ansi-yellow
05v string/write
10s raw
04i 1
04i 1
05v " to "
05v ansi-green
05v string/write
10s val
04i 1
04i 1
05v " took "
05v ansi-red
05v cat
05v -
10s end-time
10s start-time
04i 2
05v "ms"
04i 2
05v "\n"
04i 2
04i 6
04i 1
01
}
17
0Es profile-form
0D
23s profile
23s body
05v #@[documentation: "Measure and display how much time and ressources it takes for BODY to be evaluated" source: ["Measure and display how much time and ressources it takes for BODY to be evaluated" [quasiquote [profile-form '[unquote [if [last? body] [car body] [cons 'do body]]]]]]]
05v #{##[]
23s profile-form
23s quote
05v nil?
10s body
12
04i 1
0Bo 11
10s body
11
09o 12
23s do
10s body
14
24
14
14
24
14
14
01
}
18
0Es profile
01
}#{##[]
23s hash/adler32
05v [data]
05v #@[source: [[def a 1] [def b 0] [for [i 0 [string/length data]] [set! a [mod/int [add/int a [char-at data i]] 65521]] [set! b [mod/int [add/int a b] 65521]]] [logior a [ash b 16]]]]
05v #{##[]
02i 1
0Es a
0D
02i 0
0Es b
0D
15
02i 0
0Es i
0D
05v string/length
10s data
04i 1
0Es ΓεnΣym-125
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-125
1E
0Bo 76
0D
05v mod/int
10s a
05v char-at
10s data
10s i
04i 2
03
05v 65521
04i 2
0Fs a
0D
05v mod/int
10s a
10s b
03
05v 65521
04i 2
0Fs b
0D
02i 1
10s i
03
0Fs i
09o -83
16
0D
05v logior
10s a
05v ash
10s b
02i 16
04i 2
04i 2
01
}
17
0Es hash/adler32
01
}#{##[]
05v tree/new
24
04i 1
0Es image/decoders
0D
05v tree/new
24
04i 1
0Es image/encoders
0D
23s image/add-encoder!
05v [ext enc]
05v #@[source: [[def ext [string->keyword [lowercase ext]]] [tree/set! image/encoders ext enc]]]
05v #{##[]
05v symbol->keyword
05v string->symbol
05v lowercase
10s ext
04i 1
04i 1
04i 1
0Es ext
0D
05v tree/set!
10s image/encoders
10s ext
10s enc
04i 3
01
}
17
0Es image/add-encoder!
0D
23s image/add-decoder!
05v [ext dec]
05v #@[source: [[def ext [string->keyword [lowercase ext]]] [tree/set! image/decoders ext dec]]]
05v #{##[]
05v symbol->keyword
05v string->symbol
05v lowercase
10s ext
04i 1
04i 1
04i 1
0Es ext
0D
05v tree/set!
10s image/decoders
10s ext
10s dec
04i 3
01
}
17
0Es image/add-decoder!
0D
23s image/get-encoder
05v [path]
05v #@[source: [[def ext [string->keyword [lowercase [path/extension path]]]] [tree/ref image/encoders ext]]]
05v #{##[]
05v symbol->keyword
05v string->symbol
05v lowercase
05v path/extension
10s path
04i 1
04i 1
04i 1
04i 1
0Es ext
0D
05v tree/ref
10s image/encoders
10s ext
04i 2
01
}
17
0Es image/get-encoder
0D
23s image/get-decoder
05v [path]
05v #@[source: [[def ext [string->keyword [lowercase [path/extension path]]]] [tree/ref image/decoders ext]]]
05v #{##[]
05v symbol->keyword
05v string->symbol
05v lowercase
05v path/extension
10s path
04i 1
04i 1
04i 1
04i 1
0Es ext
0D
05v tree/ref
10s image/decoders
10s ext
04i 2
01
}
17
0Es image/get-decoder
0D
23s image/new
05v [width height]
05v #@[source: [[def buffer [buffer/allocate [* width height 4]]] [tree/new :width width :height height :pixel-buffer buffer :pixels [buffer/view/u32* buffer]]]]
05v #{##[]
05v buffer/allocate
05v *
05v *
10s width
10s height
04i 2
02i 4
04i 2
04i 1
0Es buffer
0D
05v tree/new
05v :width
10s width
05v :height
10s height
05v :pixel-buffer
10s buffer
05v :pixels
05v buffer/view/u32*
10s buffer
04i 1
04i 8
01
}
17
0Es image/new
0D
23s image/ref
05v [img x y]
05v #@[source: [[def i [+ [int x] [* [int y] [tree/ref img :width]]]] [buffer/view/ref [tree/ref img :pixels] i]]]
05v #{##[]
05v +
05v int
10s x
04i 1
05v *
05v int
10s y
04i 1
05v tree/ref
10s img
05v :width
04i 2
04i 2
04i 2
0Es i
0D
05v buffer/view/ref
05v tree/ref
10s img
05v :pixels
04i 2
10s i
04i 2
01
}
17
0Es image/ref
0D
23s image/set!
05v [img x y value]
05v #@[source: [[def i [+ [int x] [* [int y] [tree/ref img :width]]]] [buffer/view/set! [tree/ref img :pixels] i value]]]
05v #{##[]
05v +
05v int
10s x
04i 1
05v *
05v int
10s y
04i 1
05v tree/ref
10s img
05v :width
04i 2
04i 2
04i 2
0Es i
0D
05v buffer/view/set!
05v tree/ref
10s img
05v :pixels
04i 2
10s i
10s value
04i 3
01
}
17
0Es image/set!
0D
23s image/fill!
05v [img value]
05v #@[source: [[def p [tree/ref img :pixels]] [for [i 0 [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! p i value]] [return img]]]
05v #{##[]
05v tree/ref
10s img
05v :pixels
04i 2
0Es p
0D
15
02i 0
0Es i
0D
05v *
05v tree/ref
10s img
05v :width
04i 2
05v tree/ref
10s img
05v :height
04i 2
04i 2
0Es ΓεnΣym-131
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-131
1E
0Bo 37
0D
05v buffer/view/set!
10s p
10s i
10s value
04i 3
0D
02i 1
10s i
03
0Fs i
09o -44
16
0D
10s img
01
01
}
17
0Es image/fill!
0D
23s image/map!
05v [img fun]
05v #@[source: [[def p [tree/ref img :pixels]] [for [i 0 [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! p i [fun [buffer/view/ref p i]]]] [return img]]]
05v #{##[]
05v tree/ref
10s img
05v :pixels
04i 2
0Es p
0D
15
02i 0
0Es i
0D
05v *
05v tree/ref
10s img
05v :width
04i 2
05v tree/ref
10s img
05v :height
04i 2
04i 2
0Es ΓεnΣym-132
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-132
1E
0Bo 53
0D
05v buffer/view/set!
10s p
10s i
10s fun
05v buffer/view/ref
10s p
10s i
04i 2
04i 1
04i 3
0D
02i 1
10s i
03
0Fs i
09o -60
16
0D
10s img
01
01
}
17
0Es image/map!
0D
23s image/dup
05v [img]
05v #@[source: [[def ret [image/new [tree/ref img :width] [tree/ref img :height]]] [def in [tree/ref img :pixels]] [def out [tree/ref ret :pixels]] [for [i 0 [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! out i [buffer/view/ref in i]]] [return ret]]]
05v #{##[]
05v image/new
05v tree/ref
10s img
05v :width
04i 2
05v tree/ref
10s img
05v :height
04i 2
04i 2
0Es ret
0D
05v tree/ref
10s img
05v :pixels
04i 2
0Es in
0D
05v tree/ref
10s ret
05v :pixels
04i 2
0Es out
0D
15
02i 0
0Es i
0D
05v *
05v tree/ref
10s img
05v :width
04i 2
05v tree/ref
10s img
05v :height
04i 2
04i 2
0Es ΓεnΣym-133
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-133
1E
0Bo 47
0D
05v buffer/view/set!
10s out
10s i
05v buffer/view/ref
10s in
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -54
16
0D
10s ret
01
01
}
17
0Es image/dup
0D
23s image/save!
05v [img path]
05v #@[source: [[def enc [image/get-encoder path]] [if enc [file/write [enc img] path] [exception :missing-encoder "Currently there is no encoder loaded for that image format" path]]]]
05v #{##[]
05v image/get-encoder
10s path
04i 1
0Es enc
0D
10s enc
0Bo 26
05v file/write
10s enc
10s img
04i 1
10s path
04i 2
09o 33
05v throw
05v list
05v :missing-encoder
05v "Currently there is no encoder loaded for that image format"
10s path
05v current-lambda
04i 0
04i 4
04i 1
01
}
17
0Es image/save!
0D
23s image/test
05v []
05v #@[source: [[def w 256] [def h 256] [def out [image/new w h]] [for [x 0 w] [for [y 0 h] [image/set! out x y [logior x [ash y 8] [ash [logxor x y] 16]]]]] [return out]]]
05v #{##[]
05v 256
0Es w
0D
05v 256
0Es h
0D
05v image/new
10s w
10s h
04i 2
0Es out
0D
15
02i 0
0Es x
0D
10s w
0Es ΓεnΣym-134
0D
02i 0
1B
1C
10s x
10s ΓεnΣym-134
1E
0Bo 137
0D
15
02i 0
0Es y
0D
10s h
0Es ΓεnΣym-135
0D
02i 0
1B
1C
10s y
10s ΓεnΣym-135
1E
0Bo 87
0D
05v image/set!
10s out
10s x
10s y
05v logior
05v logior
10s x
05v ash
10s y
02i 8
04i 2
04i 2
05v ash
05v logxor
10s x
10s y
04i 2
02i 16
04i 2
04i 2
04i 4
0D
02i 1
10s y
03
0Fs y
09o -94
16
0D
02i 1
10s x
03
0Fs x
09o -144
16
0D
10s out
01
01
}
17
0Es image/test
01
}#{##[]
23s buffer/view/le/set!
05v [u8v offset bytes val]
05v #@[source: [[while [> bytes 0] [buffer/view/set! u8v [++ offset] [logand 255 val]] [-- bytes] [set! val [ash val -8]]] offset]]
05v #{##[]
02i 0
1B
1C
10s bytes
02i 0
22
0Bo 81
0D
05v buffer/view/set!
10s u8v
05v +
02i 1
10s offset
04i 2
0Fs offset
05v logand
05v 255
10s val
04i 2
04i 3
0D
05v +
02i -1
10s bytes
04i 2
0Fs bytes
0D
05v ash
10s val
02i -8
04i 2
0Fs val
09o -86
0D
10s offset
01
}
17
0Es buffer/view/le/set!
0D
23s image/bmp/row-padding
05v [width pixel-length]
05v #@[source: [[def ret [- 4 [logand [* width pixel-length] 3]]] [if [== ret 4] 0 ret]]]
05v #{##[]
05v -
02i 4
05v logand
05v *
10s width
10s pixel-length
04i 2
02i 3
04i 2
04i 2
0Es ret
0D
10s ret
02i 4
20
0Bo 8
02i 0
09o 7
10s ret
01
}
17
0Es image/bmp/row-padding
0D
23s image/bmp/encode
05v [image]
05v #@[source: [[def image-size [* [tree/ref image :height] 3 [+ [tree/ref image :width] [image/bmp/row-padding [tree/ref image :width] 3]]]] [def header-size [+ 14 40]] [def file-size [+ image-size header-size]] [def out [buffer/allocate file-size]] [def b [buffer/view/u8* out]] [def i -1] [buffer/view/set! b [++ i] 66] [buffer/view/set! b [++ i] 77] [set! i [buffer/view/le/set! b i 4 file-size]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 header-size]] [set! i [buffer/view/le/set! b i 4 40]] [set! i [buffer/view/le/set! b i 4 [tree/ref image :width]]] [set! i [buffer/view/le/set! b i 4 [tree/ref image :height]]] [set! i [buffer/view/le/set! b i 2 1]] [set! i [buffer/view/le/set! b i 2 24]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 image-size]] [set! i [buffer/view/le/set! b i 4 8192]] [set! i [buffer/view/le/set! b i 4 8192]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 0]] [def row-padding [image/bmp/row-padding [tree/ref image :width] 3]] [def pixels [- header-size 1]] [for [y [- [tree/ref image :height] 1] -1 -1] [for [x 0 [tree/ref image :width]] [set! pixels [buffer/view/le/set! b pixels 3 [image/ref image x y]]]] [set! pixels [+ pixels row-padding]]] out]]
05v #{##[]
05v *
05v *
05v tree/ref
10s image
05v :height
04i 2
02i 3
04i 2
05v +
05v tree/ref
10s image
05v :width
04i 2
05v image/bmp/row-padding
05v tree/ref
10s image
05v :width
04i 2
02i 3
04i 2
04i 2
04i 2
0Es image-size
0D
05v +
02i 14
02i 40
04i 2
0Es header-size
0D
05v +
10s image-size
10s header-size
04i 2
0Es file-size
0D
05v buffer/allocate
10s file-size
04i 1
0Es out
0D
05v buffer/view/u8*
10s out
04i 1
0Es b
0D
02i -1
0Es i
0D
05v buffer/view/set!
10s b
05v +
02i 1
10s i
04i 2
0Fs i
02i 66
04i 3
0D
05v buffer/view/set!
10s b
05v +
02i 1
10s i
04i 2
0Fs i
02i 77
04i 3
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
10s file-size
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
02i 0
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
10s header-size
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
02i 40
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
05v tree/ref
10s image
05v :width
04i 2
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
05v tree/ref
10s image
05v :height
04i 2
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 2
02i 1
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 2
02i 24
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
02i 0
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
10s image-size
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
05v 8192
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
05v 8192
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
02i 0
04i 4
0Fs i
0D
05v buffer/view/le/set!
10s b
10s i
02i 4
02i 0
04i 4
0Fs i
0D
05v image/bmp/row-padding
05v tree/ref
10s image
05v :width
04i 2
02i 3
04i 2
0Es row-padding
0D
05v -
10s header-size
02i 1
04i 2
0Es pixels
0D
15
05v -
05v tree/ref
10s image
05v :height
04i 2
02i 1
04i 2
0Es y
0D
02i -1
0Es ΓεnΣym-138
0D
02i 0
1B
1C
10s y
10s ΓεnΣym-138
22
0Bo 136
0D
15
02i 0
0Es x
0D
05v tree/ref
10s image
05v :width
04i 2
0Es ΓεnΣym-139
0D
02i 0
1B
1C
10s x
10s ΓεnΣym-139
1E
0Bo 57
0D
05v buffer/view/le/set!
10s b
10s pixels
02i 3
05v image/ref
10s image
10s x
10s y
04i 3
04i 4
0Fs pixels
0D
02i 1
10s x
03
0Fs x
09o -64
16
0D
05v +
10s pixels
10s row-padding
04i 2
0Fs pixels
0D
02i -1
10s y
03
0Fs y
09o -143
16
0D
10s out
01
}
17
0Es image/bmp/encode
0D
05v image/add-encoder!
05v "bmp"
10s image/bmp/encode
04i 2
01
}#{##[]
05v 3.14159
0Es PI
0D
05v 3.14159
0Es π
0D
23s ++
05v [i]
05v #@[documentation: "Increment I by 1 and store the result in I" source: ["Increment I by 1 and store the result in I" [quasiquote [set! [unquote i] [+ 1 [unquote i]]]]]]
05v #{##[]
23s set!
10s i
23s +
02i 1
10s i
24
14
14
14
24
14
14
14
01
}
18
0Es ++
0D
23s --
05v [i]
05v #@[documentation: "Decrement I by 1 and store the result in I" source: ["Decrement I by 1 and store the result in I" [quasiquote [set! [unquote i] [+ -1 [unquote i]]]]]]
05v #{##[]
23s set!
10s i
23s +
02i -1
10s i
24
14
14
14
24
14
14
14
01
}
18
0Es --
0D
23s +x
05v [α]
05v #@[documentation: "Return a function that adds α to it's argument, useful for mapping" source: ["Return a function that adds α to it's argument, useful for mapping" [fn [β] [+ α β]]]]
05v #{##[]
23s anonymous
05v [β]
05v #@[source: [[+ α β]]]
05v #{##[]
05v +
10s α
10s β
04i 2
01
}
17
01
}
17
0Es +x
0D
23s >>
05v [val amount]
05v #@[documentation: "Shifts VAL by AMOUNT bits to the right" source: ["Shifts VAL by AMOUNT bits to the right" [ash val [- amount]]]]
05v #{##[]
05v ash
10s val
05v -
10s amount
04i 1
04i 2
01
}
17
0Es >>
0D
23s fib
05v [i]
05v #@[documentation: "Terribly inefficient, but, useful for testing the GC" source: ["Terribly inefficient, but, useful for testing the GC" [if [< i 2] i [+ [fib [- i 2]] [fib [- i 1]]]]]]
05v #{##[]
10s i
02i 2
1E
0Bo 10
10s i
09o 45
05v +
05v fib
05v -
10s i
02i 2
04i 2
04i 1
05v fib
05v -
10s i
02i 1
04i 2
04i 1
04i 2
01
}
17
0Es fib
0D
23s wrap-value
05v [val min max]
05v #@[documentation: "Constrains VAL to be within MIN and MAX, wrapping it around" source: ["Constrains VAL to be within MIN and MAX, wrapping it around" [+ min [% [- val min] [- max min]]]]]
05v #{##[]
05v +
10s min
05v %
05v -
10s val
10s min
04i 2
05v -
10s max
10s min
04i 2
04i 2
04i 2
01
}
17
0Es wrap-value
0D
23s +1
05v [v]
05v #@[source: [[quasiquote [+ 1 [unquote v]]]]]
05v #{##[]
23s +
02i 1
10s v
24
14
14
14
01
}
18
0Es +1
0D
23s radians
05v [degrees]
05v #@[documentation: "Convert a quantity in degrees to radians" source: ["Convert a quantity in degrees to radians" [/ [* π degrees] 180.0]]]
05v #{##[]
05v /
05v *
10s π
10s degrees
04i 2
05v 180.0
04i 2
01
}
17
0Es radians
01
}#{##[]
23s display/error/wrap
05v [i text]
05v #@[source: [[case i [0 [ansi-red text]] [1 [string text]] [2 [ansi-yellow [string/write text]]] [3 [describe/closure text]] [otherwise text]]]]
05v #{##[]
15
10s i
0Es ΓεnΣym-141
0D
10s ΓεnΣym-141
02i 0
20
0Bo 16
05v ansi-red
10s text
04i 1
09o 82
10s ΓεnΣym-141
02i 1
20
0Bo 16
05v string
10s text
04i 1
09o 59
10s ΓεnΣym-141
02i 2
20
0Bo 22
05v ansi-yellow
05v string/write
10s text
04i 1
04i 1
09o 30
10s ΓεnΣym-141
02i 3
20
0Bo 16
05v describe/closure
10s text
04i 1
09o 7
10s text
16
01
}
17
0Es display/error/wrap
0D
23s display/error/iter
05v [error i]
05v #@[source: [[if error [cons [display/error/wrap i [car error]] [display/error/iter [cdr error] [+ 1 i]]] [cons "" #nil]]]]
05v #{##[]
10s error
0Bo 45
05v display/error/wrap
10s i
10s error
11
04i 2
05v display/error/iter
10s error
12
05v +
02i 1
10s i
04i 2
04i 2
14
09o 9
05v ""
24
14
01
}
17
0Es display/error/iter
0D
23s display/error
05v [error]
05v #@[documentation: "Display ERROR in a nice, human readable way" source: ["Display ERROR in a nice, human readable way" [display [join [display/error/iter error 0] "\r\n"]]]]
05v #{##[]
05v print
05v join
05v display/error/iter
10s error
02i 0
04i 2
05v "\r\n"
04i 2
04i 1
01
}
17
0Es display/error
0D
23s closure/documentation
05v [o]
05v #@[source: [[meta o :documentation]]]
05v #{##[]
05v meta
10s o
05v :documentation
04i 2
01
}
17
0Es closure/documentation
0D
23s describe/thing
05v [o]
05v #@[documentation: "Describe a specific value O" source: ["Describe a specific value O" [def documentation [closure/documentation o]] [def arguments [closure/arguments o]] [fmt "{arguments:?} - {documentation}"]]]
05v #{##[]
05v closure/documentation
10s o
04i 1
0Es documentation
0D
05v closure/arguments
10s o
04i 1
0Es arguments
0D
05v cat
05v string/write
10s arguments
04i 1
05v " - "
10s documentation
04i 3
01
}
17
0Es describe/thing
0D
23s describe/string
05v [a]
05v #@[documentation: "Descibe whatever value string A resolves to" source: ["Descibe whatever value string A resolves to" [describe/thing [resolve [string->symbol a]]]]]
05v #{##[]
05v describe/thing
05v resolve
05v string->symbol
10s a
04i 1
04i 1
04i 1
01
}
17
0Es describe/string
0D
23s describe
05v [fun]
05v #@[documentation: "Describe FUN, if there is documentation available" source: ["Describe FUN, if there is documentation available" [if [string? fun] [describe/string fun] [describe/thing fun]]]]
05v #{##[]
05v string?
10s fun
04i 1
0Bo 16
05v describe/string
10s fun
04i 1
09o 13
05v describe/thing
10s fun
04i 1
01
}
17
0Es describe
0D
23s symbol-table
05v [off len environment]
05v #@[documentation: "Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" source: ["Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" [when-not environment [set! environment root-closure]] [when-not off [set! off 0]] [when-not len [set! len 9999999]] [sublist [eval-in environment '[symbol-table*]] off [+ off len] #nil]]]
05v #{##[]
10s environment
0Bo 7
24
09o 11
10s root-closure
0Fs environment
0D
10s off
0Bo 7
24
09o 9
02i 0
0Fs off
0D
10s len
0Bo 7
24
09o 11
05v 9999999
0Fs len
0D
05v sublist
05v eval-in
10s environment
05v [symbol-table*]
04i 2
10s off
05v +
10s off
10s len
04i 2
24
04i 4
01
}
17
0Es symbol-table
0D
02i 0
0Es gensym/counter
0D
23s gensym
05v [prefix]
05v #@[source: [[++ gensym/counter] [string->symbol [cat prefix "ΓεnΣym-" gensym/counter]]]]
05v #{##[]
05v +
02i 1
10s gensym/counter
04i 2
0Fs gensym/counter
0D
05v string->symbol
05v cat
10s prefix
05v "ΓεnΣym-"
10s gensym/counter
04i 3
04i 1
01
}
17
0Es gensym
0D
05v current-closure
04i 0
0Es root-closure
01
}#{##[]
02i 0
0Es random/seed
0D
23s random/seed-initialize!
05v []
05v #@[source: [[set! random/seed [logxor [time] [time/milliseconds]]]]]
05v #{##[]
05v logxor
05v time
04i 0
05v time/milliseconds
04i 0
04i 2
0Fs random/seed
01
}
17
0Es random/seed-initialize!
0D
23s random/rng!
05v []
05v #@[source: [[set! random/seed [+ 12345 [* random/seed 1103515245]]] [logior [ash [logand random/seed 65535] 16] [logand [ash random/seed -16] 65535]]]]
05v #{##[]
05v +
05v 12345
05v *
10s random/seed
05v 1103515245
04i 2
04i 2
0Fs random/seed
0D
05v logior
05v ash
05v logand
10s random/seed
05v 65535
04i 2
02i 16
04i 2
05v logand
05v ash
10s random/seed
02i -16
04i 2
05v 65535
04i 2
04i 2
01
}
17
0Es random/rng!
0D
23s random/seed!
05v [new-seed]
05v #@[documentation: "Set a new seed value for the RNG" source: ["Set a new seed value for the RNG" [set! seed new-seed]]]
05v #{##[]
10s new-seed
0Fs seed
01
}
17
0Es random/seed!
0D
23s random/seed
05v []
05v #@[documentation: "Return the current RNG seed value" source: ["Return the current RNG seed value" seed]]
05v #{##[]
10s seed
01
}
17
0Es random/seed
0D
23s random
05v [max]
05v #@[documentation: "Return a value from 0 to MAX, or, if left out, a random int" source: ["Return a value from 0 to MAX, or, if left out, a random int" [if [numeric? max] [% [abs [random/rng!]] max] [random/rng!]]]]
05v #{##[]
05v numeric?
10s max
04i 1
0Bo 28
05v %
05v abs
05v random/rng!
04i 0
04i 1
10s max
04i 2
09o 9
05v random/rng!
04i 0
01
}
17
0Es random
0D
05v random/seed-initialize!
04i 0
01
}#{##[]
23s tree->json
05v [v]
05v #@[documentation: "Converts a tree into a JSON encoded string, you should prefer VAL->JSON" source: ["Converts a tree into a JSON encoded string, you should prefer VAL->JSON" [cat "{" [join [map [tree/keys v] [fn [k] [cat "\"" [keyword->string k] "\": " [val->json [tree/ref v k]]]]] ",\n"] "}"]]]
05v #{##[]
05v cat
05v "{"
05v join
05v map
05v tree/keys
10s v
04i 1
23s anonymous
05v [k]
05v #@[source: [[cat "\"" [keyword->string k] "\": " [val->json [tree/ref v k]]]]]
05v #{##[]
05v cat
05v "\""
05v keyword->string
10s k
04i 1
05v "\": "
05v val->json
05v tree/ref
10s v
10s k
04i 2
04i 1
04i 4
01
}
17
04i 2
05v ",\n"
04i 2
05v "}"
04i 3
01
}
17
0Es tree->json
0D
23s val->json
05v [v]
05v #@[documentation: "Return V as a JSON encoded string" source: ["Return V as a JSON encoded string" [case [type-of v] [:nil "null"] [[:int :float] [string v]] [:bool [if v "true" "false"]] [[:array :pair] [cat "[" [join [map v val->json] ","] "]"]] [:string [string/write v]] [:symbol [cat "\"" [symbol->string v] "\""]] [:keyword [cat "\"" [keyword->string v] "\""]] [:tree [tree->json v]] [otherwise [throw [list :type-error "Can't encode the value into JSON" v [current-lambda]]]]]]]
05v #{##[]
15
05v type-of
10s v
04i 1
0Es ΓεnΣym-143
0D
10s ΓεnΣym-143
05v :nil
20
0Bo 10
05v "null"
09o 318
10s ΓεnΣym-143
05v :int
20
0C
0Ao 22
0D
10s ΓεnΣym-143
05v :float
20
0C
0Ao 8
0D
05v #f
0Bo 16
05v string
10s v
04i 1
09o 270
10s ΓεnΣym-143
05v :bool
20
0Bo 24
10s v
0Bo 10
05v "true"
09o 7
05v "false"
09o 237
10s ΓεnΣym-143
05v :array
20
0C
0Ao 22
0D
10s ΓεnΣym-143
05v :pair
20
0C
0Ao 8
0D
05v #f
0Bo 44
05v cat
05v "["
05v join
05v map
10s v
10s val->json
04i 2
05v ","
04i 2
05v "]"
04i 3
09o 161
10s ΓεnΣym-143
05v :string
20
0Bo 16
05v string/write
10s v
04i 1
09o 136
10s ΓεnΣym-143
05v :symbol
20
0Bo 30
05v cat
05v "\""
05v symbol->string
10s v
04i 1
05v "\""
04i 3
09o 97
10s ΓεnΣym-143
05v :keyword
20
0Bo 30
05v cat
05v "\""
05v keyword->string
10s v
04i 1
05v "\""
04i 3
09o 58
10s ΓεnΣym-143
05v :tree
20
0Bo 16
05v tree->json
10s v
04i 1
09o 33
05v throw
05v list
05v :type-error
05v "Can't encode the value into JSON"
10s v
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es val->json
01
}#{##[]
05v #f
0Es ansi/disabled
0D
05v "\e[0m"
0Es ansi-reset
0D
05v "\e[0;39m"
0Es ansi-fg-reset
0D
05v "\e[49m"
0Es ansi-bg-reset
0D
05v array/new
05v "\e[0;30m"
05v "\e[0;31m"
05v "\e[0;32m"
05v "\e[0;33m"
05v "\e[0;34m"
05v "\e[0;35m"
05v "\e[0;36m"
05v "\e[0;37m"
05v "\e[1;30m"
05v "\e[1;31m"
05v "\e[1;32m"
05v "\e[1;33m"
05v "\e[1;34m"
05v "\e[1;35m"
05v "\e[1;36m"
05v "\e[1;37m"
04i 16
0Es ansi-fg
0D
05v "\e[0m"
0Es ansi-reset
0D
05v array/new
05v "\e[40m"
05v "\e[41m"
05v "\e[42m"
05v "\e[43m"
05v "\e[44m"
05v "\e[45m"
05v "\e[46m"
05v "\e[47m"
04i 8
0Es ansi-bg
0D
23s ansi-wrap
05v [code string]
05v #@[documentation: "Wrap STRING in the ansi color CODE" source: ["Wrap STRING in the ansi color CODE" [cat [or ansi/disabled [array/ref ansi-fg code]] string [or ansi/disabled ansi-reset]]]]
05v #{##[]
05v cat
10s ansi/disabled
0C
0Ao 27
0D
05v array/ref
10s ansi-fg
10s code
04i 2
0C
0Ao 8
0D
05v #f
10s string
10s ansi/disabled
0C
0Ao 17
0D
10s ansi-reset
0C
0Ao 8
0D
05v #f
04i 3
01
}
17
0Es ansi-wrap
0D
23s ansi-black
23s args
05v #@[documentation: "Wrap ARGS in black" source: ["Wrap ARGS in black" [ansi-wrap 0 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 0
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-black
0D
23s ansi-dark-red
23s args
05v #@[documentation: "Wrap ARGS in dark red" source: ["Wrap ARGS in dark red" [ansi-wrap 1 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 1
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-dark-red
0D
23s ansi-dark-green
23s args
05v #@[documentation: "Wrap ARGS in dark green" source: ["Wrap ARGS in dark green" [ansi-wrap 2 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 2
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-dark-green
0D
23s ansi-brown
23s args
05v #@[documentation: "Wrap ARGS in brown" source: ["Wrap ARGS in brown" [ansi-wrap 3 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 3
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-brown
0D
23s ansi-dark-blue
23s args
05v #@[documentation: "Wrap ARGS in dark blue" source: ["Wrap ARGS in dark blue" [ansi-wrap 4 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 4
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-dark-blue
0D
23s ansi-purple
23s args
05v #@[documentation: "Wrap ARGS in purple" source: ["Wrap ARGS in purple" [ansi-wrap 5 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 5
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-purple
0D
23s ansi-teal
23s args
05v #@[documentation: "Wrap ARGS in teal" source: ["Wrap ARGS in teal" [ansi-wrap 6 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 6
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-teal
0D
23s ansi-dark-gray
23s args
05v #@[documentation: "Wrap ARGS in dark gray" source: ["Wrap ARGS in dark gray" [ansi-wrap 7 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 7
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-dark-gray
0D
23s ansi-gray
23s args
05v #@[documentation: "Wrap ARGS in gray" source: ["Wrap ARGS in gray" [ansi-wrap 8 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 8
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-gray
0D
23s ansi-red
23s args
05v #@[documentation: "Wrap ARGS in red" source: ["Wrap ARGS in red" [ansi-wrap 9 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 9
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-red
0D
23s ansi-green
23s args
05v #@[documentation: "Wrap ARGS in green" source: ["Wrap ARGS in green" [ansi-wrap 10 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 10
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-green
0D
23s ansi-yellow
23s args
05v #@[documentation: "Wrap ARGS in yellow" source: ["Wrap ARGS in yellow" [ansi-wrap 11 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 11
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-yellow
0D
23s ansi-blue
23s args
05v #@[documentation: "Wrap ARGS in blue" source: ["Wrap ARGS in blue" [ansi-wrap 12 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 12
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-blue
0D
23s ansi-pink
23s args
05v #@[documentation: "Wrap ARGS in pink" source: ["Wrap ARGS in pink" [ansi-wrap 13 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 13
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-pink
0D
23s ansi-cyan
23s args
05v #@[documentation: "Wrap ARGS in cyan" source: ["Wrap ARGS in cyan" [ansi-wrap 14 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 14
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-cyan
0D
23s ansi-white
23s args
05v #@[documentation: "Wrap ARGS in white" source: ["Wrap ARGS in white" [ansi-wrap 15 [apply cat args]]]]
05v #{##[]
05v ansi-wrap
02i 15
05v apply
10s cat
10s args
04i 2
04i 2
01
}
17
0Es ansi-white
0D
23s ansi-rainbow
23s args
05v #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [let* [def count 0] [cat [join [map [split [apply cat args] ""] [fn [a] [set! count [logand [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] ""] [or ansi/disabled ansi-fg-reset]]]]]
05v #{##[]
15
02i 0
0Es count
0D
05v cat
05v join
05v map
05v split
05v apply
10s cat
10s args
04i 2
05v ""
04i 2
23s anonymous
05v [a]
05v #@[source: [[set! count [logand [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]]
05v #{##[]
05v logand
05v +
02i 1
10s count
04i 2
02i 7
04i 2
0Fs count
0D
05v cat
10s ansi/disabled
0C
0Ao 50
0D
05v array/ref
10s ansi-fg
02i 0
10s count
20
0Bo 8
02i 7
09o 15
05v +
10s count
02i 8
04i 2
04i 2
0C
0Ao 8
0D
05v #f
10s a
04i 2
01
}
17
04i 2
05v ""
04i 2
10s ansi/disabled
0C
0Ao 17
0D
10s ansi-fg-reset
0C
0Ao 8
0D
05v #f
04i 2
16
01
}
17
0Es ansi-rainbow
0D
23s ansi-rainbow-bg
23s args
05v #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [def count 0] [def colored-list [map [split [apply cat args] ""] [fn [a] [set! count [logand [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [logxor count 7]]] [or ansi/disabled [array/ref ansi-bg count]] a]]]] [cat [join colored-list ""] [or ansi/disabled ansi-reset]]]]
05v #{##[]
02i 0
0Es count
0D
05v map
05v split
05v apply
10s cat
10s args
04i 2
05v ""
04i 2
23s anonymous
05v [a]
05v #@[source: [[set! count [logand [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [logxor count 7]]] [or ansi/disabled [array/ref ansi-bg count]] a]]]
05v #{##[]
05v logand
05v +
02i 1
10s count
04i 2
02i 7
04i 2
0Fs count
0D
05v cat
10s ansi/disabled
0C
0Ao 35
0D
05v array/ref
10s ansi-fg
05v logxor
10s count
02i 7
04i 2
04i 2
0C
0Ao 8
0D
05v #f
10s ansi/disabled
0C
0Ao 27
0D
05v array/ref
10s ansi-bg
10s count
04i 2
0C
0Ao 8
0D
05v #f
10s a
04i 3
01
}
17
04i 2
0Es colored-list
0D
05v cat
05v join
10s colored-list
05v ""
04i 2
10s ansi/disabled
0C
0Ao 17
0D
10s ansi-reset
0C
0Ao 8
0D
05v #f
04i 2
01
}
17
0Es ansi-rainbow-bg
0D
23s reprint-line
05v [text width]
05v #@[source: [[when-not width [set! width 20]] [print "\r"] [for [i 0 width] [print " "]] [print "\r"] [print text]]]
05v #{##[]
10s width
0Bo 7
24
09o 9
02i 20
0Fs width
0D
05v print
05v "\r"
04i 1
0D
15
02i 0
0Es i
0D
10s width
0Es ΓεnΣym-145
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-145
1E
0Bo 29
0D
05v print
05v " "
04i 1
0D
02i 1
10s i
03
0Fs i
09o -36
16
0D
05v print
05v "\r"
04i 1
0D
05v print
10s text
04i 1
01
}
17
0Es reprint-line
01
}#{##[]
05v tree/new
05v :align
05v :right
05v :debug
05v #f
05v :base
05v #f
05v :width
24
05v :padding-char
05v " "
04i 10
0Es fmt/format-arg/default
0D
23s fmt/find-non-digit-from-right
05v [s i]
05v #@[source: [[if [< i 0] -1 [do [def char [char-at s i]] [if [and [>= char 48] [<= char 57]] [fmt/find-non-digit-from-right s [- i 1]] i]]]]]
05v #{##[]
10s i
02i 0
1E
0Bo 8
02i -1
09o 73
05v char-at
10s s
10s i
04i 2
0Es char
0D
10s char
02i 48
21
0C
0Bo 11
0D
10s char
02i 57
1F
0Bo 28
05v fmt/find-non-digit-from-right
10s s
05v -
10s i
02i 1
04i 2
04i 2
09o 7
10s i
01
}
17
0Es fmt/find-non-digit-from-right
0D
23s fmt/parse-spec
05v [opts spec]
05v #@[source: [[if [zero? [string/length spec]] opts [case [char-at spec [- [string/length spec] 1]] [[48 49 50 51 52 53 54 55 56 57] [def next-non-digit [fmt/find-non-digit-from-right spec [- [string/length spec] 1]]] [def number [string/cut spec [+ 1 next-non-digit] [string/length spec]]] [tree/set! opts :width [read/single number]] [when [== 48 [char-at number 0]] [tree/set! opts :padding-char "0"]] [fmt/parse-spec opts [string/cut spec 0 [+ 1 next-non-digit]]]] [63 [fmt/parse-spec [tree/set! opts :debug #t] [string/cut spec 0 [- [string/length spec] 1]]]] [88 [fmt/parse-spec [tree/set! opts :base :HEXADECIMAL] [string/cut spec 0 [- [string/length spec] 1]]]] [120 [fmt/parse-spec [tree/set! opts :base :hexadecimal] [string/cut spec 0 [- [string/length spec] 1]]]] [100 [fmt/parse-spec [tree/set! opts :base :decimal] [string/cut spec 0 [- [string/length spec] 1]]]] [111 [fmt/parse-spec [tree/set! opts :base :octal] [string/cut spec 0 [- [string/length spec] 1]]]] [98 [fmt/parse-spec [tree/set! opts :base :binary] [string/cut spec 0 [- [string/length spec] 1]]]] [60 [fmt/parse-spec [tree/set! opts :align :left] [string/cut spec 0 [- [string/length spec] 1]]]] [94 [fmt/parse-spec [tree/set! opts :align :center] [string/cut spec 0 [- [string/length spec] 1]]]] [62 [fmt/parse-spec [tree/set! opts :align :right] [string/cut spec 0 [- [string/length spec] 1]]]] [46 [fmt/parse-spec [tree/set! opts :precision [tree/ref opts :width]] [string/cut spec 0 [- [string/length spec] 1]]]] [otherwise [throw [list :format-error "Unknown form-spec option" spec [current-closure]]]]]]]]
05v #{##[]
02i 0
05v string/length
10s spec
04i 1
20
0Bo 10
10s opts
09o 1048
15
05v char-at
10s spec
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 2
0Es ΓεnΣym-154
0D
10s ΓεnΣym-154
02i 48
20
0C
0Ao 116
0D
10s ΓεnΣym-154
02i 49
20
0C
0Ao 104
0D
10s ΓεnΣym-154
02i 50
20
0C
0Ao 92
0D
10s ΓεnΣym-154
02i 51
20
0C
0Ao 80
0D
10s ΓεnΣym-154
02i 52
20
0C
0Ao 68
0D
10s ΓεnΣym-154
02i 53
20
0C
0Ao 56
0D
10s ΓεnΣym-154
02i 54
20
0C
0Ao 44
0D
10s ΓεnΣym-154
02i 55
20
0C
0Ao 32
0D
10s ΓεnΣym-154
02i 56
20
0C
0Ao 20
0D
10s ΓεnΣym-154
02i 57
20
0C
0Ao 8
0D
05v #f
0Bo 176
05v fmt/find-non-digit-from-right
10s spec
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 2
0Es next-non-digit
0D
05v string/cut
10s spec
05v +
02i 1
10s next-non-digit
04i 2
05v string/length
10s spec
04i 1
04i 3
0Es number
0D
05v tree/set!
10s opts
05v :width
05v read/single
10s number
04i 1
04i 3
0D
02i 48
05v char-at
10s number
02i 0
04i 2
20
0Bo 24
05v tree/set!
10s opts
05v :padding-char
05v "0"
04i 3
09o 4
24
0D
05v fmt/parse-spec
10s opts
05v string/cut
10s spec
02i 0
05v +
02i 1
10s next-non-digit
04i 2
04i 3
04i 2
09o 713
10s ΓεnΣym-154
02i 63
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :debug
05v #t
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 646
10s ΓεnΣym-154
02i 88
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :base
05v :HEXADECIMAL
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 579
10s ΓεnΣym-154
02i 120
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :base
05v :hexadecimal
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 512
10s ΓεnΣym-154
02i 100
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :base
05v :decimal
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 445
10s ΓεnΣym-154
02i 111
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :base
05v :octal
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 378
10s ΓεnΣym-154
02i 98
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :base
05v :binary
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 311
10s ΓεnΣym-154
02i 60
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :align
05v :left
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 244
10s ΓεnΣym-154
02i 94
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :align
05v :center
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 177
10s ΓεnΣym-154
02i 62
20
0Bo 60
05v fmt/parse-spec
05v tree/set!
10s opts
05v :align
05v :right
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 110
10s ΓεnΣym-154
02i 46
20
0Bo 70
05v fmt/parse-spec
05v tree/set!
10s opts
05v :precision
05v tree/ref
10s opts
05v :width
04i 2
04i 3
05v string/cut
10s spec
02i 0
05v -
05v string/length
10s spec
04i 1
02i 1
04i 2
04i 3
04i 2
09o 33
05v throw
05v list
05v :format-error
05v "Unknown form-spec option"
10s spec
05v current-closure
04i 0
04i 4
04i 1
16
01
}
17
0Es fmt/parse-spec
0D
23s fmt/debug
05v [opts]
05v #@[source: [[if-not [tree/ref opts :debug] opts [tree/set! opts :argument [list string/write [tree/ref opts :argument]]]]]]
05v #{##[]
05v tree/ref
10s opts
05v :debug
04i 2
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s string/write
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 7
10s opts
01
}
17
0Es fmt/debug
0D
23s fmt/number-format
05v [opts]
05v #@[source: [[case [tree/ref opts :base] [:binary [tree/set! opts :argument [list int->string/binary [tree/ref opts :argument]]]] [:octal [tree/set! opts :argument [list int->string/octal [tree/ref opts :argument]]]] [:decimal [tree/set! opts :argument [list int->string/decimal [tree/ref opts :argument]]]] [:hexadecimal [tree/set! opts :argument [list int->string/hex [tree/ref opts :argument]]]] [:HEXADECIMAL [tree/set! opts :argument [list int->string/HEX [tree/ref opts :argument]]]] [otherwise opts]]]]
05v #{##[]
15
05v tree/ref
10s opts
05v :base
04i 2
0Es ΓεnΣym-155
0D
10s ΓεnΣym-155
05v :binary
20
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s int->string/binary
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 219
10s ΓεnΣym-155
05v :octal
20
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s int->string/octal
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 166
10s ΓεnΣym-155
05v :decimal
20
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s int->string/decimal
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 113
10s ΓεnΣym-155
05v :hexadecimal
20
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s int->string/hex
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 60
10s ΓεnΣym-155
05v :HEXADECIMAL
20
0Bo 44
05v tree/set!
10s opts
05v :argument
05v list
10s int->string/HEX
05v tree/ref
10s opts
05v :argument
04i 2
04i 2
04i 3
09o 7
10s opts
16
01
}
17
0Es fmt/number-format
0D
05v tree/new
05v :binary
05v "#b"
05v :octal
05v "#o"
05v :decimal
05v "#d"
05v :hexadecimal
05v "#x"
05v :HEXADECIMAL
05v "#x"
04i 10
0Es fmt/number-format-prefixex
0D
23s fmt/number-format-prefix
05v [opts]
05v #@[source: [[if [or [not [tree/ref opts :debug]] [not [tree/ref opts :base]]] opts [-> [if [member '[:binary :octal :decimal :hexadecimal :HEXADECIMAL] [tree/ref opts :base]] [tree/set! opts :argument [list cat [tree/ref fmt/number-format-prefixex [tree/ref opts :base]] [tree/ref opts :argument]]] opts] [tree/set! :debug #f]]]]]
05v #{##[]
05v tree/ref
10s opts
05v :debug
04i 2
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 41
0D
05v tree/ref
10s opts
05v :base
04i 2
0Bo 10
05v #f
09o 7
05v #t
0C
0Ao 8
0D
05v #f
0Bo 10
10s opts
09o 113
05v tree/set!
05v member
05v [:binary :octal :decimal :hexadecimal :HEXADECIMAL]
05v tree/ref
10s opts
05v :base
04i 2
04i 2
0Bo 68
05v tree/set!
10s opts
05v :argument
05v list
10s cat
05v tree/ref
10s fmt/number-format-prefixex
05v tree/ref
10s opts
05v :base
04i 2
04i 2
05v tree/ref
10s opts
05v :argument
04i 2
04i 3
04i 3
09o 7
10s opts
05v :debug
05v #f
04i 3
01
}
17
0Es fmt/number-format-prefix
0D
23s fmt/add-padding
05v [opts]
05v #@[source: [[if-not [tree/ref opts :width] opts [tree/set! opts :argument [list [case [tree/ref opts :align] [:right string/pad-start] [:center string/pad-middle] [:left string/pad-end]] [tree/ref opts :argument] [if [and [tree/ref opts :debug] [tree/ref opts :base]] [- [tree/ref opts :width] 2] [tree/ref opts :width]] [tree/ref opts :padding-char]]]]]]
05v #{##[]
05v tree/ref
10s opts
05v :width
04i 2
0Bo 208
05v tree/set!
10s opts
05v :argument
05v list
15
05v tree/ref
10s opts
05v :align
04i 2
0Es ΓεnΣym-156
0D
10s ΓεnΣym-156
05v :right
20
0Bo 10
10s string/pad-start
09o 42
10s ΓεnΣym-156
05v :center
20
0Bo 10
10s string/pad-middle
09o 23
10s ΓεnΣym-156
05v :left
20
0Bo 10
10s string/pad-end
09o 4
24
16
05v tree/ref
10s opts
05v :argument
04i 2
05v tree/ref
10s opts
05v :debug
04i 2
0C
0Bo 18
0D
05v tree/ref
10s opts
05v :base
04i 2
0Bo 28
05v -
05v tree/ref
10s opts
05v :width
04i 2
02i 2
04i 2
09o 17
05v tree/ref
10s opts
05v :width
04i 2
05v tree/ref
10s opts
05v :padding-char
04i 2
04i 4
04i 3
09o 7
10s opts
01
}
17
0Es fmt/add-padding
0D
23s fmt/precision
05v [opts]
05v #@[source: [[if-not [tree/ref opts :precision] opts [tree/set! opts :argument [list string/round [tree/ref opts :argument] [tree/ref opts :precision]]]]]]
05v #{##[]
05v tree/ref
10s opts
05v :precision
04i 2
0Bo 58
05v tree/set!
10s opts
05v :argument
05v list
10s string/round
05v tree/ref
10s opts
05v :argument
04i 2
05v tree/ref
10s opts
05v :precision
04i 2
04i 3
04i 3
09o 7
10s opts
01
}
17
0Es fmt/precision
0D
23s fmt/truncate
05v [opts]
05v #@[source: [[if-not [tree/ref opts :width] opts [tree/set! opts :argument [list string/cut [tree/ref opts :argument] 0 [+ 1 [tree/ref opts :width]]]]]]]
05v #{##[]
05v tree/ref
10s opts
05v :width
04i 2
0Bo 68
05v tree/set!
10s opts
05v :argument
05v list
10s string/cut
05v tree/ref
10s opts
05v :argument
04i 2
02i 0
05v +
02i 1
05v tree/ref
10s opts
05v :width
04i 2
04i 2
04i 4
04i 3
09o 7
10s opts
01
}
17
0Es fmt/truncate
0D
23s fmt/output
05v [opts]
05v #@[source: [[tree/ref opts :argument]]]
05v #{##[]
05v tree/ref
10s opts
05v :argument
04i 2
01
}
17
0Es fmt/output
0D
23s fmt/format-arg
05v [spec argument]
05v #@[source: [[-> [tree/set! [fmt/parse-spec [tree/dup fmt/format-arg/default] spec] :argument argument] fmt/number-format fmt/precision fmt/add-padding fmt/truncate fmt/number-format-prefix fmt/debug fmt/output]]]
05v #{##[]
05v fmt/output
05v fmt/debug
05v fmt/number-format-prefix
05v fmt/truncate
05v fmt/add-padding
05v fmt/precision
05v fmt/number-format
05v tree/set!
05v fmt/parse-spec
05v tree/dup
10s fmt/format-arg/default
04i 1
10s spec
04i 2
05v :argument
10s argument
04i 3
04i 1
04i 1
04i 1
04i 1
04i 1
04i 1
04i 1
01
}
17
0Es fmt/format-arg
0D
23s fmt/valid-argument?
05v [argument]
05v #@[source: [[or [int? argument] [symbol? argument]]]]
05v #{##[]
05v int?
10s argument
04i 1
0C
0Ao 23
0D
05v symbol?
10s argument
04i 1
0C
0Ao 8
0D
05v #f
01
}
17
0Es fmt/valid-argument?
0D
23s fmt/arg-sym
05v [v]
05v #@[source: [[case [type-of v] [:int [fmt/arg-sym [cat "fmt-arg-" [string v]]]] [:symbol v] [:string [string->symbol v]] [otherwise [throw [list :type-error "Invalid fmt argument name" v [current-lambda]]]]]]]
05v #{##[]
15
05v type-of
10s v
04i 1
0Es ΓεnΣym-157
0D
10s ΓεnΣym-157
05v :int
20
0Bo 32
05v fmt/arg-sym
05v cat
05v "fmt-arg-"
05v string
10s v
04i 1
04i 2
04i 1
09o 77
10s ΓεnΣym-157
05v :symbol
20
0Bo 10
10s v
09o 58
10s ΓεnΣym-157
05v :string
20
0Bo 16
05v string->symbol
10s v
04i 1
09o 33
05v throw
05v list
05v :type-error
05v "Invalid fmt argument name"
10s v
05v current-lambda
04i 0
04i 4
04i 1
16
01
}
17
0Es fmt/arg-sym
0D
23s fmt/expr
05v [expr arguments-used opts]
05v #@[source: [[when-not [string? expr] [throw [list :format-error "fmt needs a string literal as a first argument, since it is implemented as a macro" expr [current-lambda]]]] [def split-expr [split expr ":"]] [def argument [car split-expr]] [def format-spec [or [cadr split-expr] ""]] [if [== "" argument] [do [tree/-- opts :expr-count] [array/set! arguments-used [tree/ref opts :expr-count] #t] [fmt/format-arg format-spec [fmt/arg-sym [tree/ref opts :expr-count]]]] [let [[read-vals [read argument]]] [when [cdr read-vals] [throw [list :format-error "Format argument specifier contains more than a single atom" argument [current-lambda]]]] [when-not [fmt/valid-argument? [car read-vals]] [throw [list :format-error "Format argument specifier should be either an integer or a symbol" argument [current-lambda]]]] [when [int? [car read-vals]] [when [or [< [car read-vals] 0] [>= [car read-vals] [array/length arguments-used]]] [throw [list :format-error "fmt numbered argument is out of bounds" argument [current-lambda]]]] [array/set! arguments-used [car read-vals] #t]] [fmt/format-arg format-spec [fmt/arg-sym [car read-vals]]]]]]]
05v #{##[]
05v string?
10s expr
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :format-error
05v "fmt needs a string literal as a first argument, since it is implemented as a macro"
10s expr
05v current-lambda
04i 0
04i 4
04i 1
0D
05v split
10s expr
05v ":"
04i 2
0Es split-expr
0D
10s split-expr
11
0Es argument
0D
10s split-expr
12
11
0C
0Ao 17
0D
05v ""
0C
0Ao 8
0D
05v #f
0Es format-spec
0D
05v ""
10s argument
20
0Bo 88
05v tree/+=
10s opts
05v :expr-count
05v -
02i 1
04i 1
04i 3
0D
05v array/set!
10s arguments-used
05v tree/ref
10s opts
05v :expr-count
04i 2
05v #t
04i 3
0D
05v fmt/format-arg
10s format-spec
05v fmt/arg-sym
05v tree/ref
10s opts
05v :expr-count
04i 2
04i 1
04i 2
09o 247
15
05v read
10s argument
04i 1
0Es read-vals
0D
10s read-vals
12
0Bo 36
05v throw
05v list
05v :format-error
05v "Format argument specifier contains more than a single atom"
10s argument
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v fmt/valid-argument?
10s read-vals
11
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :format-error
05v "Format argument specifier should be either an integer or a symbol"
10s argument
05v current-lambda
04i 0
04i 4
04i 1
0D
05v int?
10s read-vals
11
04i 1
0Bo 101
10s read-vals
11
02i 0
1E
0C
0Ao 29
0D
10s read-vals
11
05v array/length
10s arguments-used
04i 1
21
0C
0Ao 8
0D
05v #f
0Bo 36
05v throw
05v list
05v :format-error
05v "fmt numbered argument is out of bounds"
10s argument
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v array/set!
10s arguments-used
10s read-vals
11
05v #t
04i 3
09o 4
24
0D
05v fmt/format-arg
10s format-spec
05v fmt/arg-sym
10s read-vals
11
04i 1
04i 2
16
01
}
17
0Es fmt/expr
0D
23s fmt
05v [format-string . args]
05v #@[documentation: "Return a formatted string" source: ["Return a formatted string" [when-not [string? format-string] [throw [list :type-error "fmt needs a string literal as a first argument, since it is implemented as a macro" format-string [current-lambda]]]] [def cuts #nil] [for [i 0 [string/length format-string]] [case [char-at format-string i] [123 [do [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]] [set! cuts [cons i cuts]]]] [125 [do [when-not [int? [car cuts]] [throw [list :format-error "fmt expects all brackets to be closed" format-string [current-lambda]]]] [set! cuts [cons [cons [car cuts] i] [cdr cuts]]]]]]] [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]] [def expr-list #nil] [def last-pos [string/length format-string]] [def arguments-used [-> [array/allocate [length args]] [array/fill! #f]]] [def opts [tree/new :expr-count [array/length arguments-used]]] [for-in [c cuts] [def lit [string/cut format-string [+ [cdr c] 1] last-pos]] [when-not [== "" lit] [set! expr-list [cons lit expr-list]]] [def expr [fmt/expr [string/cut format-string [+ 1 [car c]] [cdr c]] arguments-used opts]] [set! expr-list [cons expr expr-list]] [set! last-pos [car c]]] [when [> last-pos 0] [def lit [string/cut format-string 0 last-pos]] [set! expr-list [cons lit expr-list]]] [for [i 0 [array/length arguments-used]] [when-not [array/ref arguments-used i] [throw [list :format-error "fmt expects all arguments to be used" [list format-string [list/ref args i]] [current-lambda]]]]] [def expr [if [cdr expr-list] [cons 'cat expr-list] [if [string? [car expr-list]] [car expr-list] [cons 'string expr-list]]]] [def fmt/args/map-fun/count 0] [defn fmt/args/map-fun [arg] [def s [string->symbol [cat "fmt-arg-" [string fmt/args/map-fun/count]]]] [++ fmt/args/map-fun/count] [list 'def s arg]] [if args [quasiquote [let* [unquote-splicing [map args fmt/args/map-fun]] [unquote expr]]] expr]]]
05v #{##[]
05v string?
10s format-string
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "fmt needs a string literal as a first argument, since it is implemented as a macro"
10s format-string
05v current-lambda
04i 0
04i 4
04i 1
0D
24
0Es cuts
0D
15
02i 0
0Es i
0D
05v string/length
10s format-string
04i 1
0Es ΓεnΣym-158
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-158
1E
0Bo 198
0D
15
05v char-at
10s format-string
10s i
04i 2
0Es ΓεnΣym-159
0D
10s ΓεnΣym-159
02i 123
20
0Bo 68
05v int?
10s cuts
11
04i 1
0Bo 36
05v throw
05v list
05v :format-error
05v "fmt placeholders can't be nested"
10s format-string
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
10s i
10s cuts
14
0Fs cuts
09o 86
10s ΓεnΣym-159
02i 125
20
0Bo 75
05v int?
10s cuts
11
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :format-error
05v "fmt expects all brackets to be closed"
10s format-string
05v current-lambda
04i 0
04i 4
04i 1
0D
10s cuts
11
10s i
14
10s cuts
12
14
0Fs cuts
09o 4
24
16
0D
02i 1
10s i
03
0Fs i
09o -205
16
0D
05v int?
10s cuts
11
04i 1
0Bo 36
05v throw
05v list
05v :format-error
05v "fmt placeholders can't be nested"
10s format-string
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
24
0Es expr-list
0D
05v string/length
10s format-string
04i 1
0Es last-pos
0D
05v array/fill!
05v array/allocate
05v length
10s args
04i 1
04i 1
05v #f
04i 2
0Es arguments-used
0D
05v tree/new
05v :expr-count
05v array/length
10s arguments-used
04i 1
04i 2
0Es opts
0D
15
10s cuts
0Es ΓεnΣym-160
0D
10s ΓεnΣym-160
0Bo 173
02i 0
1B
1C
10s ΓεnΣym-160
0Bo 159
0D
10s ΓεnΣym-160
11
0Es c
0D
05v string/cut
10s format-string
05v +
10s c
12
02i 1
04i 2
10s last-pos
04i 3
0Es lit
0D
05v ""
10s lit
20
0Bo 7
24
09o 16
10s lit
10s expr-list
14
0Fs expr-list
0D
05v fmt/expr
05v string/cut
10s format-string
05v +
02i 1
10s c
11
04i 2
10s c
12
04i 3
10s arguments-used
10s opts
04i 3
0Es expr
0D
10s expr
10s expr-list
14
0Fs expr-list
0D
10s c
11
0Fs last-pos
0D
10s ΓεnΣym-160
12
0Fs ΓεnΣym-160
09o -161
09o 4
24
16
0D
10s last-pos
02i 0
22
0Bo 40
05v string/cut
10s format-string
02i 0
10s last-pos
04i 3
0Es lit
0D
10s lit
10s expr-list
14
0Fs expr-list
09o 4
24
0D
15
02i 0
0Es i
0D
05v array/length
10s arguments-used
04i 1
0Es ΓεnΣym-161
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-161
1E
0Bo 90
0D
05v array/ref
10s arguments-used
10s i
04i 2
0Bo 7
24
09o 53
05v throw
05v list
05v :format-error
05v "fmt expects all arguments to be used"
05v list
10s format-string
05v list/ref
10s args
10s i
04i 2
04i 2
05v current-lambda
04i 0
04i 4
04i 1
0D
02i 1
10s i
03
0Fs i
09o -97
16
0D
10s expr-list
12
0Bo 15
23s cat
10s expr-list
14
09o 34
05v string?
10s expr-list
11
04i 1
0Bo 11
10s expr-list
11
09o 12
23s string
10s expr-list
14
0Es expr
0D
02i 0
0Es fmt/args/map-fun/count
0D
23s fmt/args/map-fun
05v [arg]
05v #@[source: [[def s [string->symbol [cat "fmt-arg-" [string fmt/args/map-fun/count]]]] [++ fmt/args/map-fun/count] [list 'def s arg]]]
05v #{##[]
05v string->symbol
05v cat
05v "fmt-arg-"
05v string
10s fmt/args/map-fun/count
04i 1
04i 2
04i 1
0Es s
0D
05v +
02i 1
10s fmt/args/map-fun/count
04i 2
0Fs fmt/args/map-fun/count
0D
05v list
23s def
10s s
10s arg
04i 3
01
}
17
0Es fmt/args/map-fun
0D
10s args
0Bo 37
23s let*
05v append
05v map
10s args
10s fmt/args/map-fun
04i 2
10s expr
24
14
04i 2
14
09o 7
10s expr
01
}
18
0Es fmt
0D
23s pfmt
05v [format-string . args]
05v #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [print [fmt [unquote format-string] [unquote-splicing args]]]]]]
05v #{##[]
23s print
23s fmt
10s format-string
05v append
10s args
24
04i 2
14
14
24
14
14
01
}
18
0Es pfmt
0D
23s efmt
05v [format-string . args]
05v #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [error [fmt [unquote format-string] [unquote-splicing args]]]]]]
05v #{##[]
23s error
23s fmt
10s format-string
05v append
10s args
24
04i 2
14
14
24
14
14
01
}
18
0Es efmt
0D
23s pfmtln
05v [format-string . args]
05v #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [println [fmt [unquote format-string] [unquote-splicing args]]]]]]
05v #{##[]
23s println
23s fmt
10s format-string
05v append
10s args
24
04i 2
14
14
24
14
14
01
}
18
0Es pfmtln
0D
23s efmtln
05v [format-string . args]
05v #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [errorln [fmt [unquote format-string] [unquote-splicing args]]]]]]
05v #{##[]
23s errorln
23s fmt
10s format-string
05v append
10s args
24
04i 2
14
14
24
14
14
01
}
18
0Es efmtln
01
}#{##[]
23s string->keyword
05v [α]
05v #@[documentation: "Return string α as a keyword" source: [:inline "Return string α as a keyword" [symbol->keyword [string->symbol α]]] inline: #t]
05v #{##[]
05v symbol->keyword
05v string->symbol
10s α
04i 1
04i 1
01
}
17
0Es string->keyword
0D
23s string->byte-array
05v [a]
05v #@[documentation: "Turn a string into an UTF-8 encoded byte array" source: ["Turn a string into an UTF-8 encoded byte array" [def ret [array/allocate [string/length a]]] [for [i 0 [string/length a]] [array/set! ret i [char-at a i]]] ret]]
05v #{##[]
05v array/allocate
05v string/length
10s a
04i 1
04i 1
0Es ret
0D
15
02i 0
0Es i
0D
05v string/length
10s a
04i 1
0Es ΓεnΣym-165
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-165
1E
0Bo 47
0D
05v array/set!
10s ret
10s i
05v char-at
10s a
10s i
04i 2
04i 3
0D
02i 1
10s i
03
0Fs i
09o -54
16
0D
10s ret
01
}
17
0Es string->byte-array
0D
23s println
05v [str]
05v #@[documentation: "Print STR on a single line" source: ["Print STR on a single line" [print [cat str "\r\n"]]]]
05v #{##[]
05v print
05v cat
10s str
05v "\r\n"
04i 2
04i 1
01
}
17
0Es println
0D
23s errorln
05v [str]
05v #@[documentation: "Print to stderr STR on a single line" source: ["Print to stderr STR on a single line" [error [cat str "\r\n"]]]]
05v #{##[]
05v error
05v cat
10s str
05v "\r\n"
04i 2
04i 1
01
}
17
0Es errorln
0D
23s display
05v [value]
05v #@[documentation: "Display VALUE" source: [:inline "Display VALUE" [print value]] inline: #t]
05v #{##[]
05v print
10s value
04i 1
01
}
17
0Es display
0D
23s newline
05v []
05v #@[documentation: "Print a single line feed character" source: ["Print a single line feed character" [display "\r\n"]]]
05v #{##[]
05v print
05v "\r\n"
04i 1
01
}
17
0Es newline
0D
23s br
05v [num]
05v #@[documentation: "Return NUM=1 linebreaks" source: ["Return NUM=1 linebreaks" [if [or [nil? num] [<= [int num] 1]] "\n" [cat "\n" [br [+ -1 num]]]]]]
05v #{##[]
05v nil?
10s num
04i 1
0C
0Ao 26
0D
05v int
10s num
04i 1
02i 1
1F
0C
0Ao 8
0D
05v #f
0Bo 10
05v "\n"
09o 31
05v cat
05v "\n"
05v br
05v +
02i -1
10s num
04i 2
04i 1
04i 2
01
}
17
0Es br
0D
23s path/ext?!
05v [ext]
05v #@[documentation: "Return a predicate that checks if a path ends on EXT" source: ["Return a predicate that checks if a path ends on EXT" [case [type-of ext] [:string [fn [path] [== ext [lowercase [path/extension path]]]]] [:pair [fn [path] [def cext [lowercase [path/extension path]]] [reduce ext [fn [α β] [or α [== β cext]]]]]] [otherwise [throw [list :type-error "Expected a :string or :list" ext]]]]]]
05v #{##[]
15
05v type-of
10s ext
04i 1
0Es ΓεnΣym-166
0D
10s ΓεnΣym-166
05v :string
20
0Bo 23
23s anonymous
05v [path]
05v #@[source: [[== ext [lowercase [path/extension path]]]]]
05v #{##[]
10s ext
05v lowercase
05v path/extension
10s path
04i 1
04i 1
20
01
}
17
09o 59
10s ΓεnΣym-166
05v :pair
20
0Bo 23
23s anonymous
05v [path]
05v #@[source: [[def cext [lowercase [path/extension path]]] [reduce ext [fn [α β] [or α [== β cext]]]]]]
05v #{##[]
05v lowercase
05v path/extension
10s path
04i 1
04i 1
0Es cext
0D
05v reduce
10s ext
23s anonymous
05v [α β]
05v #@[source: [[or α [== β cext]]]]
05v #{##[]
10s α
0C
0Ao 22
0D
10s β
10s cext
20
0C
0Ao 8
0D
05v #f
01
}
17
04i 2
01
}
17
09o 27
05v throw
05v list
05v :type-error
05v "Expected a :string or :list"
10s ext
04i 3
04i 1
16
01
}
17
0Es path/ext?!
0D
23s path/extension
05v [path]
05v #@[documentation: "Return the extension of PATH" source: ["Return the extension of PATH" [def last-period [last-index-of path "."]] [if [>= last-period 0] [string/cut path [+ 1 last-period] [string/length path]] path]]]
05v #{##[]
05v last-index-of
10s path
05v "."
04i 2
0Es last-period
0D
10s last-period
02i 0
21
0Bo 38
05v string/cut
10s path
05v +
02i 1
10s last-period
04i 2
05v string/length
10s path
04i 1
04i 3
09o 7
10s path
01
}
17
0Es path/extension
0D
23s path/without-extension
05v [path]
05v #@[documentation: "Return PATH, but without the extension part" source: ["Return PATH, but without the extension part" [def last-period [last-index-of path "."]] [if [>= last-period 0] [string/cut path 0 last-period] path]]]
05v #{##[]
05v last-index-of
10s path
05v "."
04i 2
0Es last-period
0D
10s last-period
02i 0
21
0Bo 22
05v string/cut
10s path
02i 0
10s last-period
04i 3
09o 7
10s path
01
}
17
0Es path/without-extension
0D
23s int->string/binary
05v [α]
05v #@[documentation: "Turn α into a its **binary** string representation" source: ["Turn α into a its **binary** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [while [not-zero? α] [set! ret [cat [from-char-code [+ 48 [logand α 1]]] ret]] [set! α [ash α -1]]] ret]]
05v #{##[]
05v ""
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
02i 0
10s α
20
0Bo 14
05v "0"
0Fs ret
09o 4
24
0D
02i 0
1B
1C
05v !=
02i 0
10s α
04i 2
0Bo 64
0D
05v cat
05v from-char-code
05v +
02i 48
05v logand
10s α
02i 1
04i 2
04i 2
04i 1
10s ret
04i 2
0Fs ret
0D
05v ash
10s α
02i -1
04i 2
0Fs α
09o -74
0D
10s ret
01
}
17
0Es int->string/binary
0D
23s int->string/octal
05v [α]
05v #@[documentation: "Turn α into a its **octal** string representation" source: ["Turn α into a its **octal** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [while [not-zero? α] [set! ret [cat [from-char-code [+ 48 [logand α 7]]] ret]] [set! α [ash α -3]]] ret]]
05v #{##[]
05v ""
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
02i 0
10s α
20
0Bo 14
05v "0"
0Fs ret
09o 4
24
0D
02i 0
1B
1C
05v !=
02i 0
10s α
04i 2
0Bo 64
0D
05v cat
05v from-char-code
05v +
02i 48
05v logand
10s α
02i 7
04i 2
04i 2
04i 1
10s ret
04i 2
0Fs ret
0D
05v ash
10s α
02i -3
04i 2
0Fs α
09o -74
0D
10s ret
01
}
17
0Es int->string/octal
0D
05v array/new
05v "0"
05v "1"
05v "2"
05v "3"
05v "4"
05v "5"
05v "6"
05v "7"
05v "8"
05v "9"
05v "A"
05v "B"
05v "C"
05v "D"
05v "E"
05v "F"
04i 16
0Es int->string/hex/conversion-arr
0D
23s int->string/HEX
05v [α]
05v #@[documentation: "Turn α into a its **hexadecimal** string representation" source: ["Turn α into a its **hexadecimal** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [when [< α 0] [throw [list :type-error "Can't print negative numbers in hex for now" α [current-lambda]]]] [while [not-zero? α] [set! ret [cat [array/ref int->string/hex/conversion-arr [logand α 15]] ret]] [set! α [ash α -4]]] ret]]
05v #{##[]
05v ""
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
02i 0
10s α
20
0Bo 14
05v "0"
0Fs ret
09o 4
24
0D
10s α
02i 0
1E
0Bo 36
05v throw
05v list
05v :type-error
05v "Can't print negative numbers in hex for now"
10s α
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
02i 0
1B
1C
05v !=
02i 0
10s α
04i 2
0Bo 60
0D
05v cat
05v array/ref
10s int->string/hex/conversion-arr
05v logand
10s α
02i 15
04i 2
04i 2
10s ret
04i 2
0Fs ret
0D
05v ash
10s α
02i -4
04i 2
0Fs α
09o -70
0D
10s ret
01
}
17
0Es int->string/HEX
0D
23s int->string/hex
05v [α]
05v #@[documentation: "Turn α into a its **hexadecimal** string representation" source: ["Turn α into a its **hexadecimal** string representation" [lowercase [int->string/HEX α]]]]
05v #{##[]
05v lowercase
05v int->string/HEX
10s α
04i 1
04i 1
01
}
17
0Es int->string/hex
0D
23s int->string/decimal
05v [α]
05v #@[documentation: "Turn α into a its **decimal** string representation" source: ["Turn α into a its **decimal** string representation" [string α]]]
05v #{##[]
05v string
10s α
04i 1
01
}
17
0Es int->string/decimal
0D
10s int->string/decimal
0Es int->string
0D
23s string/pad-start
05v [text goal-length char]
05v #@[documentation: "Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat char text]]] [if [> [string/length text] goal-length] [string/cut text [- [string/length text] goal-length] [string/length text]] text]]]
05v #{##[]
10s char
0Bo 7
24
09o 11
05v " "
0Fs char
0D
05v string?
10s text
04i 1
0Bo 7
24
09o 17
05v string
10s text
04i 1
0Fs text
0D
05v string?
10s char
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "string/pad-start needs char as a string, so that one can pad with multiple characters"
10s char
05v current-lambda
04i 0
04i 4
04i 1
0D
02i 0
1B
1C
05v string/length
10s text
04i 1
10s goal-length
1E
0Bo 25
0D
05v cat
10s char
10s text
04i 2
0Fs text
09o -38
0D
05v string/length
10s text
04i 1
10s goal-length
22
0Bo 46
05v string/cut
10s text
05v -
05v string/length
10s text
04i 1
10s goal-length
04i 2
05v string/length
10s text
04i 1
04i 3
09o 7
10s text
01
}
17
0Es string/pad-start
0D
23s string/pad-end
05v [text goal-length char]
05v #@[documentation: "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat text char]]] [if [> [string/length text] goal-length] [string/cut text 0 goal-length] text]]]
05v #{##[]
10s char
0Bo 7
24
09o 11
05v " "
0Fs char
0D
05v string?
10s text
04i 1
0Bo 7
24
09o 17
05v string
10s text
04i 1
0Fs text
0D
05v string?
10s char
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "string/pad-start needs char as a string, so that one can pad with multiple characters"
10s char
05v current-lambda
04i 0
04i 4
04i 1
0D
02i 0
1B
1C
05v string/length
10s text
04i 1
10s goal-length
1E
0Bo 25
0D
05v cat
10s text
10s char
04i 2
0Fs text
09o -38
0D
05v string/length
10s text
04i 1
10s goal-length
22
0Bo 22
05v string/cut
10s text
02i 0
10s goal-length
04i 3
09o 7
10s text
01
}
17
0Es string/pad-end
0D
23s string/pad-middle
05v [text goal-length char]
05v #@[documentation: "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-middle needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat char text char]]] [if [> [string/length text] goal-length] [let [[end-overflow [/ [- [string/length text] goal-length] 2]] [start-overflow [- [- [string/length text] goal-length] end-overflow]]] [string/cut text start-overflow [+ start-overflow goal-length]]] text]]]
05v #{##[]
10s char
0Bo 7
24
09o 11
05v " "
0Fs char
0D
05v string?
10s text
04i 1
0Bo 7
24
09o 17
05v string
10s text
04i 1
0Fs text
0D
05v string?
10s char
04i 1
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "string/pad-middle needs char as a string, so that one can pad with multiple characters"
10s char
05v current-lambda
04i 0
04i 4
04i 1
0D
02i 0
1B
1C
05v string/length
10s text
04i 1
10s goal-length
1E
0Bo 29
0D
05v cat
10s char
10s text
10s char
04i 3
0Fs text
09o -42
0D
05v string/length
10s text
04i 1
10s goal-length
22
0Bo 104
15
05v /
05v -
05v string/length
10s text
04i 1
10s goal-length
04i 2
02i 2
04i 2
0Es end-overflow
0D
05v -
05v -
05v string/length
10s text
04i 1
10s goal-length
04i 2
10s end-overflow
04i 2
0Es start-overflow
0D
05v string/cut
10s text
10s start-overflow
05v +
10s start-overflow
10s goal-length
04i 2
04i 3
16
09o 7
10s text
01
}
17
0Es string/pad-middle
0D
23s string/round
05v [text decimal-digits]
05v #@[documentation: "Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" source: ["Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" [def pos [last-index-of text "."]] [if [>= pos 0] [string/cut text 0 [+ pos 1 decimal-digits]] text]]]
05v #{##[]
05v last-index-of
10s text
05v "."
04i 2
0Es pos
0D
10s pos
02i 0
21
0Bo 40
05v string/cut
10s text
02i 0
05v +
05v +
10s pos
02i 1
04i 2
10s decimal-digits
04i 2
04i 3
09o 7
10s text
01
}
17
0Es string/round
0D
23s split/empty
05v [str separator]
05v #@[source: [[def slen [string/length str]] [def start 0] [def ret #nil] [while [< start slen] [set! ret [cons [string/cut str start [+ 1 start]] ret]] [++ start]] [reverse ret]]]
05v #{##[]
05v string/length
10s str
04i 1
0Es slen
0D
02i 0
0Es start
0D
24
0Es ret
0D
02i 0
1B
1C
10s start
10s slen
1E
0Bo 59
0D
05v string/cut
10s str
10s start
05v +
02i 1
10s start
04i 2
04i 3
10s ret
14
0Fs ret
0D
05v +
02i 1
10s start
04i 2
0Fs start
09o -66
0D
05v reverse
10s ret
04i 1
01
}
17
0Es split/empty
0D
23s split/string
05v [str separator start]
05v #@[source: [[when-not start [set! start 0]] [def pos-found [index-of str separator start]] [if [>= pos-found 0] [cons [string/cut str start pos-found] [split/string str separator [+ pos-found [string/length separator]]]] [cons [string/cut str start [string/length str]] #nil]]]]
05v #{##[]
10s start
0Bo 7
24
09o 9
02i 0
0Fs start
0D
05v index-of
10s str
10s separator
10s start
04i 3
0Es pos-found
0D
10s pos-found
02i 0
21
0Bo 59
05v string/cut
10s str
10s start
10s pos-found
04i 3
05v split/string
10s str
10s separator
05v +
10s pos-found
05v string/length
10s separator
04i 1
04i 2
04i 3
14
09o 29
05v string/cut
10s str
10s start
05v string/length
10s str
04i 1
04i 3
24
14
01
}
17
0Es split/string
0D
23s split
05v [str separator]
05v #@[documentation: "Splits STR into a list at every occurunse of SEPARATOR" source: ["Splits STR into a list at every occurunse of SEPARATOR" [typecheck/only str :string] [typecheck/only separator :string] [case [string/length separator] [0 [split/empty str]] [otherwise [split/string str separator 0]]]]]
05v #{##[]
05v type-of
10s str
04i 1
05v :string
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :string"
10s str
05v current-lambda
04i 0
04i 4
04i 1
0D
05v type-of
10s separator
04i 1
05v :string
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :string"
10s separator
05v current-lambda
04i 0
04i 4
04i 1
0D
15
05v string/length
10s separator
04i 1
0Es ΓεnΣym-167
0D
10s ΓεnΣym-167
02i 0
20
0Bo 16
05v split/empty
10s str
04i 1
09o 19
05v split/string
10s str
10s separator
02i 0
04i 3
16
01
}
17
0Es split
0D
23s read/single
05v [text]
05v #@[documentation: "Uses the reader and returns the first single value read from string TEXT" source: ["Uses the reader and returns the first single value read from string TEXT" [typecheck/only text :string] [car [read text]]]]
05v #{##[]
05v type-of
10s text
04i 1
05v :string
20
0Bo 7
24
09o 33
05v throw
05v list
05v :type-error
05v "Expected a value of type :string"
10s text
05v current-lambda
04i 0
04i 4
04i 1
0D
05v read
10s text
04i 1
11
01
}
17
0Es read/single
0D
23s read/int
05v [text]
05v #@[documentation: "Reads the first string from TEXT" source: ["Reads the first string from TEXT" [int [read/single text]]]]
05v #{##[]
05v int
05v read/single
10s text
04i 1
04i 1
01
}
17
0Es read/int
0D
23s read/float
05v [text]
05v #@[documentation: "Reads the first float from TEXT" source: ["Reads the first float from TEXT" [float [read/single text]]]]
05v #{##[]
05v float
05v read/single
10s text
04i 1
04i 1
01
}
17
0Es read/float
0D
23s string/length?!
05v [chars]
05v #@[source: [[fn [a] [== chars [string/length a]]]]]
05v #{##[]
23s anonymous
05v [a]
05v #@[source: [[== chars [string/length a]]]]
05v #{##[]
10s chars
05v string/length
10s a
04i 1
20
01
}
17
01
}
17
0Es string/length?!
0D
23s contains-any?
05v [str chars]
05v #@[source: [[apply or [map [split chars ""] [fn [a] [>= [index-of str a] 0]]]]]]
05v #{##[]
05v apply
10s or
05v map
05v split
10s chars
05v ""
04i 2
23s anonymous
05v [a]
05v #@[source: [[>= [index-of str a] 0]]]
05v #{##[]
05v index-of
10s str
10s a
04i 2
02i 0
21
01
}
17
04i 2
04i 2
01
}
17
0Es contains-any?
0D
23s contains-all?
05v [str chars]
05v #@[source: [[apply and [map [split chars ""] [fn [a] [>= [index-of str a] 0]]]]]]
05v #{##[]
05v apply
10s and
05v map
05v split
10s chars
05v ""
04i 2
23s anonymous
05v [a]
05v #@[source: [[>= [index-of str a] 0]]]
05v #{##[]
05v index-of
10s str
10s a
04i 2
02i 0
21
01
}
17
04i 2
04i 2
01
}
17
0Es contains-all?
01
}#{##[]
05v "Nujel"
0Es test-context
0D
23s test/reset
05v []
05v #@[source: [[set! test-list #nil] [set! test-count 0] [test/add 4 [+ 3 1]]]]
05v #{##[]
24
0Fs test-list
0D
02i 0
0Fs test-count
0D
05v test/add*
02i 4
05v [do [+ 3 1]]
04i 2
01
}
17
0Es test/reset
0D
24
0Es test-list
0D
02i 0
0Es test-count
0D
02i 0
0Es nujel-start
0D
02i 0
0Es success-count
0D
02i 0
0Es error-count
0D
05v #t
0Es print-errors
0D
05v #f
0Es print-passes
0D
23s test/add*
05v [result expr]
05v #@[source: [[set! test-list [cons [cons result expr] test-list]] [set! test-count [+ test-count 1]]]]
05v #{##[]
10s result
10s expr
14
10s test-list
14
0Fs test-list
0D
05v +
10s test-count
02i 1
04i 2
0Fs test-count
01
}
17
0Es test/add*
0D
23s test/add
05v [result . expr]
05v #@[documentation: "Add a test where EXPR must eval to RESULT" source: ["Add a test where EXPR must eval to RESULT" [quasiquote [test/add* [unquote result] [unquote [list 'quote [cons 'do expr]]]]]]]
05v #{##[]
23s test/add*
10s result
05v list
23s quote
23s do
10s expr
14
04i 2
24
14
14
14
01
}
18
0Es test/add
0D
23s display-results
05v []
05v #@[documentation: "Prints the result Message" source: ["Prints the result Message" [random/seed-initialize!] [efmtln "{test-context} [{System/OS} {System/Architecture}] - {} - [{} / {}] in {} ms - {}" [if [and [zero? error-count] [> test-count 0]] "Success" "Failed!"] [ansi-green success-count] [ansi-red error-count] [- [time/milliseconds] nujel-start] [if [and [zero? error-count] [> test-count 0]] [ansi-rainbow "Everything is working, very nice!"] [ansi-red "Better fix those!"]]]]]
05v #{##[]
05v random/seed-initialize!
04i 0
0D
05v errorln
15
02i 0
10s error-count
20
0C
0Bo 11
0D
10s test-count
02i 0
22
0Bo 10
05v "Success"
09o 7
05v "Failed!"
0Es fmt-arg-0
0D
05v ansi-green
10s success-count
04i 1
0Es fmt-arg-1
0D
05v ansi-red
10s error-count
04i 1
0Es fmt-arg-2
0D
05v -
05v time/milliseconds
04i 0
10s nujel-start
04i 2
0Es fmt-arg-3
0D
02i 0
10s error-count
20
0C
0Bo 11
0D
10s test-count
02i 0
22
0Bo 16
05v ansi-rainbow
05v "Everything is working, very nice!"
04i 1
09o 13
05v ansi-red
05v "Better fix those!"
04i 1
0Es fmt-arg-4
0D
05v cat
10s test-context
05v " ["
10s System/OS
05v " "
10s System/Architecture
05v "] - "
10s fmt-arg-0
05v " - ["
10s fmt-arg-1
05v " / "
10s fmt-arg-2
05v "] in "
10s fmt-arg-3
05v " ms - "
10s fmt-arg-4
04i 15
16
04i 1
01
}
17
0Es display-results
0D
23s test-success
05v [res-should res-is expr i]
05v #@[documentation: "Should be called after a test has finished successfully" source: ["Should be called after a test has finished successfully" [when print-passes [efmtln "{} == {}\r\n{}\r\n\r\n" [ansi-green [string/write res-is]] [ansi-green [string/write res-should]] [string/write expr]]] [set! success-count [+ 1 success-count]]]]
05v #{##[]
10s print-passes
0Bo 101
05v errorln
15
05v ansi-green
05v string/write
10s res-is
04i 1
04i 1
0Es fmt-arg-0
0D
05v ansi-green
05v string/write
10s res-should
04i 1
04i 1
0Es fmt-arg-1
0D
05v string/write
10s expr
04i 1
0Es fmt-arg-2
0D
05v cat
10s fmt-arg-0
05v " == "
10s fmt-arg-1
05v "\r\n"
10s fmt-arg-2
05v "\r\n\r\n"
04i 6
16
04i 1
09o 4
24
0D
05v +
02i 1
10s success-count
04i 2
0Fs success-count
01
}
17
0Es test-success
0D
23s test-failure
05v [res-should res-is expr i]
05v #@[documentation: "Should be called if EXPR does not equal RES" source: ["Should be called if EXPR does not equal RES" [when print-errors [pfmtln "{} != {}\r\n{}\r\n\r\n" [ansi-red [string/write res-is]] [ansi-green [string/write res-should]] [string/write expr]]] [set! error-count [+ 1 error-count]]]]
05v #{##[]
10s print-errors
0Bo 101
05v println
15
05v ansi-red
05v string/write
10s res-is
04i 1
04i 1
0Es fmt-arg-0
0D
05v ansi-green
05v string/write
10s res-should
04i 1
04i 1
0Es fmt-arg-1
0D
05v string/write
10s expr
04i 1
0Es fmt-arg-2
0D
05v cat
10s fmt-arg-0
05v " != "
10s fmt-arg-1
05v "\r\n"
10s fmt-arg-2
05v "\r\n\r\n"
04i 6
16
04i 1
09o 4
24
0D
05v +
02i 1
10s error-count
04i 2
0Fs error-count
01
}
17
0Es test-failure
0D
23s test/run
05v [result rawexpr i]
05v #@[documentation: "Tests that RAWEXPR evaluates to RESULT" source: ["Tests that RAWEXPR evaluates to RESULT" [try [fn [err] [display/error err] [test-failure result [list :exception-caught err] rawexpr i]] [def expr [eval rawexpr]] [if [equal? result expr] [test-success result expr rawexpr i] [test-failure result expr rawexpr i]]]]]
05v #{##[]
23s anonymous
05v [err]
05v #@[source: [[display/error err] [test-failure result [list :exception-caught err] rawexpr i]]]
05v #{##[]
05v display/error
10s err
04i 1
0D
05v test-failure
10s result
05v list
05v :exception-caught
10s err
04i 2
10s rawexpr
10s i
04i 4
01
}
17
19o 89
05v eval-in
05v current-closure
04i 0
10s rawexpr
04i 2
0Es expr
0D
05v equal?
10s result
10s expr
04i 2
0Bo 28
05v test-success
10s result
10s expr
10s rawexpr
10s i
04i 4
09o 25
05v test-failure
10s result
10s expr
10s rawexpr
10s i
04i 4
16
01
}
17
0Es test/run
0D
23s test-run
05v [output-passes hide-errors]
05v #@[documentation: "Run through all automated Tests" source: ["Run through all automated Tests" [set! print-errors [not [bool hide-errors]]] [set! print-passes [bool output-passes]] [set! nujel-start [time/milliseconds]] [set! success-count 0] [set! error-count 0] [def i [+ test-count 1]] [for-in [cur-test test-list] [test/run [car cur-test] [cdr cur-test] [-- i]]] [display-results] [return error-count]]]
05v #{##[]
05v bool
10s hide-errors
04i 1
0Bo 10
05v #f
09o 7
05v #t
0Fs print-errors
0D
05v bool
10s output-passes
04i 1
0Fs print-passes
0D
05v time/milliseconds
04i 0
0Fs nujel-start
0D
02i 0
0Fs success-count
0D
02i 0
0Fs error-count
0D
05v +
10s test-count
02i 1
04i 2
0Es i
0D
15
10s test-list
0Es ΓεnΣym-169
0D
10s ΓεnΣym-169
0Bo 73
02i 0
1B
1C
10s ΓεnΣym-169
0Bo 59
0D
10s ΓεnΣym-169
11
0Es cur-test
0D
05v test/run
10s cur-test
11
10s cur-test
12
05v +
02i -1
10s i
04i 2
0Fs i
04i 3
0D
10s ΓεnΣym-169
12
0Fs ΓεnΣym-169
09o -61
09o 4
24
16
0D
05v display-results
04i 0
0D
10s error-count
01
01
}
17
0Es test-run
0D
05v test/reset
04i 0
01
}#{##[]
23s dup
05v [l]
05v #@[source: [[case [type-of l] [:tree [tree/dup l]] [:array [array/dup l]] [otherwise l]]]]
05v #{##[]
15
05v type-of
10s l
04i 1
0Es ΓεnΣym-172
0D
10s ΓεnΣym-172
05v :tree
20
0Bo 16
05v tree/dup
10s l
04i 1
09o 32
10s ΓεnΣym-172
05v :array
20
0Bo 16
05v array/dup
10s l
04i 1
09o 7
10s l
16
01
}
17
0Es dup
0D
23s make-instance
05v [parent]
05v #@[source: [[when [and [not [nil? parent]] [!= [type-of parent] :tree]] [throw [list :type-error "Parents can only be trees or nil" parent [current-lambda]]]] [def ret [tree/new #nil]] [for-in [k [tree/keys parent]] [when [!= k :parent] [def pv [tree/get parent k]] [when-not [== [type-of pv] :lambda] [tree/set! ret k [dup pv]]]]] [tree/set! ret :parent parent]]]
05v #{##[]
05v nil?
10s parent
04i 1
0Bo 10
05v #f
09o 7
05v #t
0C
0Bo 24
0D
05v !=
05v type-of
10s parent
04i 1
05v :tree
04i 2
0Bo 36
05v throw
05v list
05v :type-error
05v "Parents can only be trees or nil"
10s parent
05v current-lambda
04i 0
04i 4
04i 1
09o 4
24
0D
05v tree/new
24
04i 1
0Es ret
0D
15
05v tree/keys
10s parent
04i 1
0Es ΓεnΣym-173
0D
10s ΓεnΣym-173
0Bo 127
02i 0
1B
1C
10s ΓεnΣym-173
0Bo 113
0D
10s ΓεnΣym-173
11
0Es k
0D
05v !=
10s k
05v :parent
04i 2
0Bo 71
10s tree/get
10s parent
10s k
04i 2
0Es pv
0D
05v type-of
10s pv
04i 1
05v :lambda
20
0Bo 7
24
09o 27
05v tree/set!
10s ret
10s k
05v dup
10s pv
04i 1
04i 3
09o 4
24
0D
10s ΓεnΣym-173
12
0Fs ΓεnΣym-173
09o -115
09o 4
24
16
0D
05v tree/set!
10s ret
05v :parent
10s parent
04i 3
01
}
17
0Es make-instance
0D
23s nos/funcall*
05v [o method-name args]
05v #@[source: [[if o [do [def v [tree/get o method-name]] [if v [apply v args] [nos/funcall* [tree/get o :parent] method-name args]]] [throw [list :missing-method "Can't find that method" o [current-lambda]]]]]]
05v #{##[]
10s o
0Bo 77
10s tree/get
10s o
10s method-name
04i 2
0Es v
0D
10s v
0Bo 20
05v apply
10s v
10s args
04i 2
09o 31
05v nos/funcall*
10s tree/get
10s o
05v :parent
04i 2
10s method-name
10s args
04i 3
09o 33
05v throw
05v list
05v :missing-method
05v "Can't find that method"
10s o
05v current-lambda
04i 0
04i 4
04i 1
01
}
17
0Es nos/funcall*
0D
23s nos/funcall
05v [o method-name . args]
05v #@[source: [[nos/funcall* o method-name [cons o args]]]]
05v #{##[]
05v nos/funcall*
10s o
10s method-name
10s o
10s args
14
04i 3
01
}
17
0Es nos/funcall
0D
23s nos/funcall*/try
05v [o method-name args]
05v #@[source: [[when o [def v [tree/get o method-name]] [if v [apply v args] [nos/funcall* [tree/get o :parent] method-name args]]]]]
05v #{##[]
10s o
0Bo 77
10s tree/get
10s o
10s method-name
04i 2
0Es v
0D
10s v
0Bo 20
05v apply
10s v
10s args
04i 2
09o 31
05v nos/funcall*
10s tree/get
10s o
05v :parent
04i 2
10s method-name
10s args
04i 3
09o 4
24
01
}
17
0Es nos/funcall*/try
0D
23s nos/funcall/try
05v [o method-name . args]
05v #@[source: [[nos/funcall*/try o method-name [cons o args]]]]
05v #{##[]
05v nos/funcall*/try
10s o
10s method-name
10s o
10s args
14
04i 3
01
}
17
0Es nos/funcall/try
0D
23s defobject
05v [parent]
05v #@[source: [[quasiquote [make-instance [unquote parent]]]]]
05v #{##[]
23s make-instance
10s parent
24
14
14
01
}
18
0Es defobject
0D
23s defproperty
05v [o name val]
05v #@[source: [[quasiquote [tree/set! [unquote o] [unquote name] [unquote val]]]]]
05v #{##[]
23s tree/set!
10s o
10s name
10s val
24
14
14
14
14
01
}
18
0Es defproperty
0D
23s defmethod
05v [o name args . body]
05v #@[source: [[quasiquote [tree/set! [unquote o] [unquote name] [fn [unquote [cons 'this args]] [unquote-splicing body]]]]]]
05v #{##[]
23s tree/set!
10s o
10s name
23s fn
23s this
10s args
14
05v append
10s body
24
04i 2
14
14
24
14
14
14
14
01
}
18
0Es defmethod
0D
23s _
05v [o name . args]
05v #@[source: [[quasiquote [nos/funcall [unquote o] [unquote name] [unquote-splicing args]]]]]
05v #{##[]
23s nos/funcall
10s o
10s name
05v append
10s args
24
04i 2
14
14
14
01
}
18
0Es _
01
}