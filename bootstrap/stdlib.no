#{
25v lognand v l v "Returns the Nand of its arguments" v #{
10s logand
10s l
08i 2 v apply
08i 1 v lognot
01
}
0Es lognand
0D
25v bit-set?! v [i] v "Returns a function that checks if bit I is set in the provided number" v #{
02i 1
10s i
08i 2 v ash
0Es mask
0D
25v anonymous v [α] v "" v #{
10s α
10s mask
08i 2 v logand
08i 1 v zero?
08i 1 v not
01
}
01
}
0Es bit-set?!
0D
25v bit-clear?! v [i] v "Returns a function that checks if bit I is clear in the provided number" v #{
02i 1
10s i
08i 2 v ash
0Es mask
0D
25v anonymous v [α] v "" v #{
10s α
10s mask
08i 2 v logand
08i 1 v zero?
01
}
01
}
0Es bit-clear?!
01
}#{
25v array/+= v [a i v] v "Add V to the value in A at position I and store the result in A returning A" v #{
10s a
10s i
10s v
10s a
10s i
08i 2 v array/ref
08i 2 v +
08i 3 v array/set!
01
}
0Es array/+=
0D
25v array/++ v [a i] v "Increment position I in A and return A" v #{
10s a
10s i
02i 1
08i 3 v array/+=
01
}
0Es array/++
0D
25v array/fill! v [a v] v "Fills array a with value v" v #{
10s a
08i 1 v array/length
0Es len
0D
15
02i 0
0Es i
0D
10s len
0Es ΓεnΣym-11
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-11
1E
0Bo 36
0D
10s a
10s i
10s v
08i 3 v array/set!
0D
02i 1
10s i
03
0Fs i
09o -43
16
0D
10s a
01
}
0Es array/fill!
0D
25v array/append v [a b] v "Append array A to array B" v #{
10s a
08i 1 v array?
0C
0Bo 13
0D
10s b
08i 1 v array?
0Bo 7
24
09o 27
05v :type-error
05v "array/append expects two arrays as its arguments"
24
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
10s a
08i 1 v array/length
10s b
08i 1 v array/length
08i 2 v +
08i 1 v array/allocate
0Es ret
0D
15
02i 0
0Es i
0D
10s a
08i 1 v array/length
0Es ΓεnΣym-12
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-12
1E
0Bo 45
0D
10s ret
10s i
10s a
10s i
08i 2 v array/ref
08i 3 v array/set!
0D
02i 1
10s i
03
0Fs i
09o -52
16
0D
15
10s a
08i 1 v array/length
0Es i
0D
10s ret
08i 1 v array/length
0Es ΓεnΣym-13
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-13
1E
0Bo 59
0D
10s ret
10s i
10s b
10s i
10s a
08i 1 v array/length
08i 2 v -
08i 2 v array/ref
08i 3 v array/set!
0D
02i 1
10s i
03
0Fs i
09o -66
16
0D
10s ret
01
}
0Es array/append
0D
25v array/dup v [a] v "Duplicate Array A" v #{
10s a
08i 1 v array/length
08i 1 v array/allocate
0Es ret
0D
15
02i 0
0Es i
0D
10s a
08i 1 v array/length
0Es ΓεnΣym-14
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-14
1E
0Bo 45
0D
10s ret
10s i
10s a
10s i
08i 2 v array/ref
08i 3 v array/set!
0D
02i 1
10s i
03
0Fs i
09o -52
16
0D
10s ret
01
}
0Es array/dup
0D
25v array/reduce v [arr fun α] v "Reduce an array, [reduce] should be preferred" v #{
10s arr
08i 1 v array/length
0Es len
0D
15
02i 0
0Es i
0D
10s len
0Es ΓεnΣym-15
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-15
1E
0Bo 46
0D
10s fun
10s α
10s arr
10s i
08i 2 v array/ref
1Ai 2
0Fs α
0D
02i 1
10s i
03
0Fs i
09o -53
16
0D
10s α
01
}
0Es array/reduce
0D
25v array/map v [arr fun] v "Map an array, [map] should be preferred" v #{
10s arr
08i 1 v array/length
0Es len
0D
15
02i 0
0Es i
0D
10s len
0Es ΓεnΣym-16
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-16
1E
0Bo 51
0D
10s arr
10s i
10s fun
10s arr
10s i
08i 2 v array/ref
1Ai 1
08i 3 v array/set!
0D
02i 1
10s i
03
0Fs i
09o -58
16
0D
10s arr
01
}
0Es array/map
0D
25v array/filter v [arr pred] v "Filter an array, [filter] should be preferred" v #{
02i 0
0Es ri
0D
10s arr
08i 1 v array/length
0Es len
0D
10s len
08i 1 v array/allocate
0Es ret
0D
15
02i 0
0Es ai
0D
10s len
0Es ΓεnΣym-17
0D
02i 0
1B
1C
10s ai
10s ΓεnΣym-17
1E
0Bo 87
0D
10s pred
10s arr
10s ai
08i 2 v array/ref
1Ai 1
0Bo 48
10s ret
10s ri
10s arr
10s ai
08i 2 v array/ref
08i 3 v array/set!
0D
02i 1
10s ri
08i 2 v +
0Fs ri
09o 4
24
0D
02i 1
10s ai
03
0Fs ai
09o -94
16
0D
10s ret
10s ri
08i 2 v array/length!
01
}
0Es array/filter
0D
25v array/equal? v [a b] v "" v #{
10s a
08i 1 v array?
08i 1 v not
0C
0Ao 55
0D
10s b
08i 1 v array?
08i 1 v not
0C
0Ao 36
0D
10s a
08i 1 v array/length
10s b
08i 1 v array/length
08i 2 v !=
0C
0Ao 8
0D
05v #f
0Bo 10
05v #f
09o 134
15
05v #t
0Es ret
0D
15
02i 0
0Es i
0D
10s a
08i 1 v array/length
0Es ΓεnΣym-18
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-18
1E
0Bo 79
0D
10s a
10s i
08i 2 v array/ref
10s b
10s i
08i 2 v array/ref
08i 2 v equal?
0Bo 7
24
09o 25
05v #f
0Fs ret
0D
10s a
08i 1 v array/length
0Fs i
0D
02i 1
10s i
03
0Fs i
09o -86
16
0D
10s ret
16
01
}
0Es array/equal?
0D
25v array/push v [arr val] v "Append VAL to ARR" v #{
10s arr
02i 1
10s arr
08i 1 v array/length
08i 2 v +
08i 2 v array/length!
10s arr
08i 1 v array/length
02i 1
08i 2 v -
10s val
08i 3 v array/set!
01
}
0Es array/push
0D
25v array/swap v [arr i j] v "Swap values at I and J in ARR" v #{
10s arr
10s i
08i 2 v array/ref
0Es tmp
0D
10s arr
10s i
10s arr
10s j
08i 2 v array/ref
08i 3 v array/set!
10s j
10s tmp
08i 3 v array/set!
01
}
0Es array/swap
0D
25v array/heapify v [arr n at] v "bubble up the element from index AT to until the max-heap property is satisfied" v #{
10s at
0Es top
0D
05v #t
0Es looping
0D
02i 0
1B
1C
10s looping
0Bo 216
0D
10s at
02i 1
08i 2 v ash
02i 1
08i 2 v +
0Es l
0D
10s at
02i 1
08i 2 v ash
02i 2
08i 2 v +
0Es r
0D
10s l
10s n
1E
0C
0Bo 31
0D
10s arr
10s l
08i 2 v array/ref
10s arr
10s top
08i 2 v array/ref
22
0Bo 14
10s l
0Fs top
09o 4
24
0D
10s r
10s n
1E
0C
0Bo 31
0D
10s arr
10s r
08i 2 v array/ref
10s arr
10s top
08i 2 v array/ref
22
0Bo 14
10s r
0Fs top
09o 4
24
0D
10s top
10s at
20
0Bo 14
05v #f
0Fs looping
09o 29
10s arr
10s at
10s top
08i 3 v array/swap
0D
10s top
0Fs at
09o -218
0D
10s arr
01
}
0Es array/heapify
0D
25v array/make-heap v [arr] v "" v #{
10s arr
08i 1 v array/length
0Es l
0D
10s l
02i 2
08i 2 v /
0Es l2
0D
02i 0
1B
1C
10s l2
02i 0
21
0Bo 40
0D
10s arr
10s l
10s l2
08i 3 v array/heapify
0D
02i -1
10s l2
08i 2 v +
0Fs l2
09o -45
0D
10s arr
01
}
0Es array/make-heap
0D
25v array/heap-sort v [arr] v "" v #{
10s arr
08i 1 v array/make-heap
0D
10s arr
08i 1 v array/length
0Es l
0D
02i 0
1B
1C
10s l
02i 0
22
0Bo 54
0D
02i -1
10s l
08i 2 v +
0Fs l
0D
10s arr
02i 0
10s l
08i 3 v array/swap
0D
10s arr
10s l
02i 0
08i 3 v array/heapify
09o -59
0D
10s arr
01
}
0Es array/heap-sort
0D
10s array/heap-sort
0Es array/sort
0D
25v array/cut v [arr start end] v "Return a newly allocated array with the values of ARR from START to END" v #{
02i 0
10s start
08i 2 v max
0Fs start
0D
10s arr
08i 1 v array/length
10s end
08i 2 v min
0Fs end
0D
02i 0
10s end
10s start
08i 2 v -
08i 2 v max
08i 1 v array/allocate
0Es ret
0D
15
10s start
0Es i
0D
10s end
0Es ΓεnΣym-19
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-19
1E
0Bo 54
0D
10s ret
10s i
10s start
08i 2 v -
10s arr
10s i
08i 2 v array/ref
08i 3 v array/set!
0D
02i 1
10s i
03
0Fs i
09o -61
16
0D
10s ret
01
}
0Es array/cut
01
}#{
25v array/2d/allocate v [width height] v "" v #{
05v :data
10s width
10s height
08i 2 v *
08i 1 v array/allocate
02i 0
08i 2 v array/fill!
05v :width
10s width
05v :height
10s height
08i 6 v tree/new
01
}
0Es array/2d/allocate
0D
25v array/2d/fill! v [data v] v "" v #{
10s data
05v :data
08i 2 v tree/ref
10s v
08i 2 v array/fill!
0D
10s data
01
}
0Es array/2d/fill!
0D
25v array/2d/ref v [data x y oob-val] v "" v #{
10s x
10s data
05v :width
08i 2 v tree/ref
21
0C
0Ao 55
0D
10s y
10s data
05v :height
08i 2 v tree/ref
21
0C
0Ao 32
0D
10s x
02i 0
1E
0C
0Ao 20
0D
10s y
02i 0
1E
0C
0Ao 8
0D
05v #f
0Bo 10
10s oob-val
09o 52
10s data
05v :data
08i 2 v tree/ref
10s x
10s y
10s data
05v :width
08i 2 v tree/ref
08i 2 v *
08i 2 v +
08i 2 v array/ref
01
}
0Es array/2d/ref
0D
25v array/2d/set! v [data x y val] v "" v #{
10s x
10s data
05v :width
08i 2 v tree/ref
21
0C
0Ao 55
0D
10s y
10s data
05v :height
08i 2 v tree/ref
21
0C
0Ao 32
0D
10s x
02i 0
1E
0C
0Ao 20
0D
10s y
02i 0
1E
0C
0Ao 8
0D
05v #f
0Bo 33
05v :out-of-bounds
05v "Trying to set an array out of bounds"
10s data
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 56
10s data
05v :data
08i 2 v tree/ref
10s x
10s y
10s data
05v :width
08i 2 v tree/ref
08i 2 v *
08i 2 v +
10s val
08i 3 v array/set!
0D
10s data
01
}
0Es array/2d/set!
0D
25v array/2d/print v [data] v "" v #{
15
02i 0
0Es y
0D
10s data
05v :height
08i 2 v tree/ref
0Es ΓεnΣym-22
0D
02i 0
1B
1C
10s y
10s ΓεnΣym-22
1E
0Bo 115
0D
15
02i 0
0Es x
0D
10s data
05v :width
08i 2 v tree/ref
0Es ΓεnΣym-23
0D
02i 0
1B
1C
10s x
10s ΓεnΣym-23
1E
0Bo 50
0D
10s data
10s x
10s y
08i 3 v array/2d/ref
05v " "
08i 2 v cat
08i 1 v display
0D
02i 1
10s x
03
0Fs x
09o -57
16
0D
08i 0 v newline
0D
02i 1
10s y
03
0Fs y
09o -122
16
0D
10s data
01
}
0Es array/2d/print
01
}#{
05v :e
0Es avl/empty
0D
25v avl/empty? v [n] v "" v #{
05v :e
10s n
20
01
}
0Es avl/empty?
0D
25v avl/default-cmp v [x y] v "" v #{
10s x
10s y
1E
0Bo 8
02i -1
09o 22
10s x
10s y
22
0Bo 8
02i 1
09o 5
02i 0
01
}
0Es avl/default-cmp
0D
25v avl/typecheck v [r k] v "" v #{
10s r
08i 1 v avl/root
08i 1 v avl/empty?
0C
0Ao 74
0D
10s k
08i 1 v type-of
10s r
08i 1 v avl/root
08i 1 v avl/key
08i 1 v type-of
20
0C
0Ao 40
0D
05v :type-error
05v "AVL trees can only contains keys of a single type"
10s k
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0C
0Ao 8
0D
05v #f
01
}
0Es avl/typecheck
0D
25v avl/tree v [cmp] v "" v #{
10s avl/empty
10s cmp
0C
0Ao 17
0D
10s avl/default-cmp
0C
0Ao 8
0D
05v #f
08i 2 v array/new
01
}
0Es avl/tree
0D
25v avl/height v [n] v "" v #{
10s n
08i 1 v avl/empty?
0Bo 8
02i 0
09o 14
10s n
02i 0
08i 2 v array/ref
01
}
0Es avl/height
0D
25v avl/key v [n] v "" v #{
10s n
02i 1
08i 2 v array/ref
01
}
0Es avl/key
0D
25v avl/left v [n] v "" v #{
10s n
02i 2
08i 2 v array/ref
01
}
0Es avl/left
0D
25v avl/right v [n] v "" v #{
10s n
02i 3
08i 2 v array/ref
01
}
0Es avl/right
0D
25v avl/root v [r] v "" v #{
10s r
02i 0
08i 2 v array/ref
01
}
0Es avl/root
0D
25v avl/cmp v [r] v "" v #{
10s r
02i 1
08i 2 v array/ref
01
}
0Es avl/cmp
0D
25v avl/min-node v [n] v "" v #{
10s n
08i 1 v avl/empty?
0Bo 10
10s avl/empty
09o 48
15
10s n
08i 1 v avl/left
0Es l
0D
10s l
08i 1 v avl/empty?
0Bo 10
10s n
09o 13
10s avl/min-mode
10s l
1Ai 1
16
01
}
0Es avl/min-node
0D
25v avl/update-left v [n l] v "" v #{
10s n
08i 1 v array/dup
02i 2
10s l
08i 3 v array/set!
01
}
0Es avl/update-left
0D
25v avl/update-right v [n r] v "" v #{
10s n
08i 1 v array/dup
02i 3
10s r
08i 3 v array/set!
01
}
0Es avl/update-right
0D
25v avl/update-key v [n k] v "" v #{
10s n
08i 1 v array/dup
02i 1
10s k
08i 3 v array/set!
01
}
0Es avl/update-key
0D
25v avl/update-root v [t r] v "" v #{
10s t
08i 1 v array/dup
02i 0
10s r
08i 3 v array/set!
01
}
0Es avl/update-root
0D
25v avl/update-height v [n] v "" v #{
10s n
08i 1 v array/dup
02i 0
02i 1
10s n
08i 1 v avl/left
08i 1 v avl/height
10s n
08i 1 v avl/right
08i 1 v avl/height
08i 2 v max
08i 2 v +
08i 3 v array/set!
01
}
0Es avl/update-height
0D
25v avl/rotate-right v [y] v "" v #{
15
10s y
08i 1 v avl/left
0Es x
0D
10s x
10s y
10s x
08i 1 v avl/right
08i 2 v avl/update-left
08i 1 v avl/update-height
08i 2 v avl/update-right
08i 1 v avl/update-height
16
01
}
0Es avl/rotate-right
0D
25v avl/rotate-left v [x] v "" v #{
15
10s x
08i 1 v avl/right
0Es y
0D
10s y
10s x
10s y
08i 1 v avl/left
08i 2 v avl/update-right
08i 1 v avl/update-height
08i 2 v avl/update-left
08i 1 v avl/update-height
16
01
}
0Es avl/rotate-left
0D
25v avl/balance v [n] v "" v #{
10s n
08i 1 v avl/empty?
0Bo 8
02i 0
09o 36
10s n
08i 1 v avl/left
08i 1 v avl/height
10s n
08i 1 v avl/right
08i 1 v avl/height
08i 2 v -
01
}
0Es avl/balance
0D
25v avl/insert-rebalance v [n cmp v] v "" v #{
15
10s n
08i 1 v avl/balance
0Es b
0D
10s b
02i 1
22
0Bo 118
15
10s cmp
10s v
10s n
08i 1 v avl/left
08i 1 v avl/key
1Ai 2
0Es ΓεnΣym-29
0D
10s ΓεnΣym-29
02i -1
20
0Bo 15
10s n
08i 1 v avl/rotate-right
09o 62
10s ΓεnΣym-29
02i 1
20
0Bo 34
10s n
10s n
08i 1 v avl/left
08i 1 v avl/rotate-left
08i 2 v avl/update-left
08i 1 v avl/rotate-right
09o 21
10s ΓεnΣym-29
02i 0
20
0Bo 10
10s n
09o 4
24
16
09o 143
10s b
02i -1
1E
0Bo 118
15
10s cmp
10s v
10s n
08i 1 v avl/right
08i 1 v avl/key
1Ai 2
0Es ΓεnΣym-30
0D
10s ΓεnΣym-30
02i 1
20
0Bo 15
10s n
08i 1 v avl/rotate-left
09o 62
10s ΓεnΣym-30
02i -1
20
0Bo 34
10s n
10s n
08i 1 v avl/right
08i 1 v avl/rotate-right
08i 2 v avl/update-right
08i 1 v avl/rotate-left
09o 21
10s ΓεnΣym-30
02i 0
20
0Bo 10
10s n
09o 4
24
16
09o 18
05v #t
0Bo 10
10s n
09o 4
24
16
01
}
0Es avl/insert-rebalance
0D
25v avl/node-insert v [n cmp v] v "" v #{
10s n
08i 1 v avl/empty?
0Bo 25
02i 1
10s v
10s avl/empty
10s avl/empty
08i 4 v array/new
09o 180
15
10s cmp
10s v
10s n
08i 1 v avl/key
1Ai 2
0Es ΓεnΣym-31
0D
10s ΓεnΣym-31
02i -1
20
0Bo 55
10s n
10s n
08i 1 v avl/left
10s cmp
10s v
08i 3 v avl/node-insert
08i 2 v avl/update-left
08i 1 v avl/update-height
10s cmp
10s v
08i 3 v avl/insert-rebalance
09o 92
10s ΓεnΣym-31
02i 1
20
0Bo 55
10s n
10s n
08i 1 v avl/right
10s cmp
10s v
08i 3 v avl/node-insert
08i 2 v avl/update-right
08i 1 v avl/update-height
10s cmp
10s v
08i 3 v avl/insert-rebalance
09o 30
10s ΓεnΣym-31
02i 0
20
0Bo 19
10s n
10s v
08i 2 v avl/update-key
09o 4
24
16
01
}
0Es avl/node-insert
0D
25v avl/insert v [t v] v "Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" v #{
10s t
10s v
08i 2 v avl/typecheck
0D
10s t
10s t
08i 1 v avl/root
10s t
08i 1 v avl/cmp
10s v
08i 3 v avl/node-insert
08i 2 v avl/update-root
01
}
0Es avl/insert
0D
25v avl/node-get v [n cmp v] v "" v #{
10s n
08i 1 v avl/empty?
0Bo 7
24
09o 122
15
10s cmp
10s v
10s n
08i 1 v avl/key
1Ai 2
0Es ΓεnΣym-32
0D
10s ΓεnΣym-32
02i 0
20
0Bo 15
10s n
08i 1 v avl/key
09o 74
10s ΓεnΣym-32
02i -1
20
0Bo 28
10s n
08i 1 v avl/left
10s cmp
10s v
08i 3 v avl/node-get
09o 39
10s ΓεnΣym-32
02i 1
20
0Bo 28
10s n
08i 1 v avl/right
10s cmp
10s v
08i 3 v avl/node-get
09o 4
24
16
01
}
0Es avl/node-get
0D
25v avl/get v [t v] v "Retrieve the key V from tree T, or #nil if V is not in it" v #{
10s t
08i 1 v avl/root
08i 1 v avl/empty?
0C
0Ao 46
0D
10s v
08i 1 v type-of
10s t
08i 1 v avl/root
08i 1 v avl/key
08i 1 v type-of
08i 2 v !=
0C
0Ao 8
0D
05v #f
0Bo 7
24
09o 30
10s t
08i 1 v avl/root
10s t
08i 1 v avl/cmp
10s v
08i 3 v avl/node-get
01
}
0Es avl/get
0D
25v avl/from-list v [l cmp] v "Create a new avl tree using the keys in L and the comparison function CMP" v #{
10s l
10s avl/insert
10s cmp
08i 1 v avl/tree
08i 3 v list/reduce
01
}
0Es avl/from-list
0D
25v avl/remove-rebalance v [n] v "" v #{
10s n
08i 1 v avl/empty?
0Bo 10
10s n
09o 188
15
10s n
08i 1 v avl/balance
0Es b
0D
10s n
08i 1 v avl/left
0Es l
0D
10s n
08i 1 v avl/right
0Es r
0D
10s b
02i 1
22
0Bo 56
10s l
08i 1 v avl/balance
02i 0
21
0Bo 15
10s n
08i 1 v avl/rotate-right
09o 26
10s n
10s l
08i 1 v avl/rotate-left
08i 2 v avl/update-left
08i 1 v avl/rotate-right
09o 81
10s b
02i -1
1E
0Bo 56
10s r
08i 1 v avl/balance
02i 0
1F
0Bo 15
10s n
08i 1 v avl/rotate-left
09o 26
10s n
10s r
08i 1 v avl/rotate-right
08i 2 v avl/update-right
08i 1 v avl/rotate-left
09o 18
05v #t
0Bo 10
10s n
09o 4
24
16
01
}
0Es avl/remove-rebalance
0D
25v avl/node-remove v [n cmp v] v "" v #{
10s n
08i 1 v avl/empty?
0Bo 10
10s n
09o 301
15
15
10s cmp
10s v
10s n
08i 1 v avl/key
1Ai 2
0Es ΓεnΣym-33
0D
10s ΓεnΣym-33
02i -1
20
0Bo 37
10s n
10s n
08i 1 v avl/left
10s cmp
10s v
08i 3 v avl/node-remove
08i 2 v avl/update-left
09o 201
10s ΓεnΣym-33
02i 1
20
0Bo 37
10s n
10s n
08i 1 v avl/right
10s cmp
10s v
08i 3 v avl/node-remove
08i 2 v avl/update-right
09o 157
10s ΓεnΣym-33
02i 0
20
0Bo 146
10s n
08i 1 v avl/left
08i 1 v avl/empty?
0Bo 15
10s n
08i 1 v avl/right
09o 114
10s n
08i 1 v avl/right
08i 1 v avl/empty?
0Bo 15
10s n
08i 1 v avl/left
09o 85
05v #t
0Bo 77
15
10s n
08i 1 v avl/right
08i 1 v avl/min-node
08i 1 v avl/key
0Es k
0D
10s n
08i 1 v avl/right
10s n
08i 1 v avl/right
10s cmp
10s v
08i 3 v avl/node-remove
08i 2 v avl/update-right
10s k
08i 2 v avl/update-key
16
09o 4
24
09o 4
24
16
0Es root
0D
10s root
08i 1 v avl/update-height
0Fs root
0D
10s root
08i 1 v avl/remove-rebalance
16
01
}
0Es avl/node-remove
0D
25v avl/remove v [t v] v "Remove the key V from tree T if it is contained within it" v #{
10s t
10s t
08i 1 v avl/root
10s t
08i 1 v avl/cmp
10s v
08i 3 v avl/node-remove
08i 2 v avl/update-root
01
}
0Es avl/remove
0D
25v avl/equal-node? v [a b] v "" v #{
10s a
08i 1 v avl/empty?
0Bo 15
10s b
08i 1 v avl/empty?
09o 82
10s a
08i 1 v avl/key
10s b
08i 1 v avl/key
08i 2 v equal?
0C
0Bo 55
0D
10s a
08i 1 v avl/left
10s b
08i 1 v avl/left
08i 2 v avl/equal-node?
0C
0Bo 27
0D
10s a
08i 1 v avl/right
10s b
08i 1 v avl/right
08i 2 v avl/equal-node?
01
}
0Es avl/equal-node?
0D
25v avl/equal? v [a b] v "Test if two avl trees are equal" v #{
10s a
08i 1 v avl/root
10s b
08i 1 v avl/root
08i 2 v avl/equal-node?
01
}
0Es avl/equal?
0D
25v avl/reduce-node v [node o s] v "" v #{
10s node
08i 1 v avl/empty?
0Bo 10
10s s
09o 58
10s o
10s node
08i 1 v avl/key
10s node
08i 1 v avl/right
10s o
10s node
08i 1 v avl/left
10s o
10s s
08i 3 v avl/reduce-node
08i 3 v avl/reduce-node
1Ai 2
01
}
0Es avl/reduce-node
0D
25v avl/reduce v [t o s] v "Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" v #{
10s t
08i 1 v avl/root
10s o
10s s
08i 3 v avl/reduce-node
01
}
0Es avl/reduce
0D
25v avl/reduce-node-bin v [n o s] v "" v #{
10s n
08i 1 v avl/empty?
0Bo 10
10s s
09o 68
10s o
10s o
10s n
08i 1 v avl/key
10s n
08i 1 v avl/left
10s o
10s s
08i 3 v avl/reduce-node-bin
1Ai 2
10s n
08i 1 v avl/right
10s o
10s s
08i 3 v avl/reduce-node-bin
1Ai 2
01
}
0Es avl/reduce-node-bin
0D
25v avl/reduce-bin v [t o s] v "Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" v #{
10s t
08i 1 v avl/root
10s o
10s s
08i 3 v avl/reduce-node-bin
01
}
0Es avl/reduce-bin
0D
25v avl/map v [t f] v "Create a new avl tree by mapping each key in T using F, using the same comparison function as T" v #{
10s t
25v anonymous v [x acc] v "" v #{
10s acc
10s f
10s x
1Ai 1
08i 2 v avl/insert
01
}
10s t
08i 1 v avl/cmp
08i 1 v avl/tree
08i 3 v avl/reduce
01
}
0Es avl/map
0D
25v avl/map-to v [t f cmp] v "Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" v #{
10s t
25v anonymous v [x acc] v "" v #{
10s acc
10s f
10s x
1Ai 1
08i 2 v avl/insert
01
}
10s cmp
08i 1 v avl/tree
08i 3 v avl/reduce
01
}
0Es avl/map-to
0D
25v avl/to-list v [t] v "" v #{
10s t
10s cons
24
08i 3 v avl/reduce
01
}
0Es avl/to-list
01
}#{
25v sum v [c] v "Return the sum of every value in collection C" v #{
10s c
10s +
02i 0
08i 3 v reduce
01
}
0Es sum
0D
25v join v [l glue] v "Join every element of α together into a string with GLUE inbetween" v #{
10s glue
0Bo 7
24
09o 11
05v ""
0Fs glue
0D
10s l
0Bo 29
10s l
25v anonymous v [a b] v "" v #{
10s a
0Bo 23
10s a
10s glue
10s b
08i 3 v cat
09o 7
10s b
01
}
24
08i 3 v reduce
09o 7
05v ""
01
}
0Es join
0D
25v for-each v [l f] v "Runs F over every item in collection L" v #{
10s l
25v anonymous v [a b] v "" v #{
10s f
10s b
1Ai 1
01
}
24
08i 3 v reduce
01
}
0Es for-each
0D
25v count v [l p] v "Count the number of items in L where P is true" v #{
10s p
0Bo 30
10s l
25v anonymous v [a b] v "" v #{
10s a
10s p
10s b
1Ai 1
0Bo 8
02i 1
09o 5
02i 0
08i 2 v +
01
}
02i 0
08i 3 v reduce
09o 27
10s l
25v anonymous v [a b] v "" v #{
10s a
02i 1
08i 2 v +
01
}
02i 0
08i 3 v reduce
01
}
0Es count
0D
25v min v l v "Returns the minimum value of its arguments, or collection" v #{
10s l
12
0Bo 10
10s l
09o 8
10s l
11
25v anonymous v [a b] v "" v #{
10s a
10s b
1E
0Bo 10
10s a
09o 7
10s b
01
}
08i 2 v reduce
01
}
0Es min
0D
25v max v l v "Returns the minimum value of its arguments, or collection" v #{
10s l
12
0Bo 10
10s l
09o 8
10s l
11
25v anonymous v [a b] v "" v #{
10s a
10s b
22
0Bo 10
10s a
09o 7
10s b
01
}
08i 2 v reduce
01
}
0Es max
0D
25v delete v [l e] v "Returns a filtered list l with all elements equal to e omitted" v #{
10s l
25v anonymous v [a] v "" v #{
10s a
10s e
20
08i 1 v not
01
}
08i 2 v filter
01
}
0Es delete
0D
25v remove v [l p] v "Returns a filtered list l with all elements where P equal true removed" v #{
10s l
25v anonymous v [a] v "" v #{
10s p
10s a
1Ai 1
08i 1 v not
01
}
08i 2 v filter
01
}
0Es remove
0D
25v flatten/λ v [a b] v "" v #{
10s b
08i 1 v collection?
0Bo 29
10s b
10s flatten/λ
24
08i 3 v reduce
10s a
08i 2 v append
09o 23
05v #t
0Bo 15
10s b
10s a
14
09o 4
24
01
}
0Es flatten/λ
0D
25v flatten v [l] v "Flatten a collection of collections into a simple list" v #{
10s l
08i 1 v collection?
0Bo 25
10s l
10s flatten/λ
24
08i 3 v reduce
08i 1 v nreverse
09o 7
10s l
01
}
0Es flatten
01
}#{
25v ref v [l i] v "Return whatver is at position I in L" v #{
15
10s l
08i 1 v type-of
0Es ΓεnΣym-43
0D
10s ΓεnΣym-43
05v :nil
20
0Bo 7
24
09o 142
10s ΓεnΣym-43
05v :tree
20
0Bo 19
10s l
10s i
08i 2 v tree/ref
09o 114
10s ΓεnΣym-43
05v :string
20
0Bo 19
10s l
10s i
08i 2 v char-at
09o 86
10s ΓεnΣym-43
05v :array
20
0Bo 19
10s l
10s i
08i 2 v array/ref
09o 58
10s ΓεnΣym-43
05v :pair
20
0Bo 19
10s l
10s i
08i 2 v list/ref
09o 30
05v :type-error
05v "You can only use ref with a collection"
10s l
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es ref
0D
25v filter v [l p] v "Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" v #{
15
10s l
08i 1 v type-of
0Es ΓεnΣym-44
0D
10s ΓεnΣym-44
05v :nil
20
0Bo 7
24
09o 114
10s ΓεnΣym-44
05v :tree
20
0Bo 19
10s l
10s p
08i 2 v tree/filter
09o 86
10s ΓεnΣym-44
05v :pair
20
0Bo 19
10s l
10s p
08i 2 v list/filter
09o 58
10s ΓεnΣym-44
05v :array
20
0Bo 19
10s l
10s p
08i 2 v array/filter
09o 30
05v :type-error
05v "You can only use filter with a collection"
10s l
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es filter
0D
25v reduce v [l f α] v "Combine all elements in collection l using operation F and starting value α" v #{
15
10s l
08i 1 v type-of
0Es ΓεnΣym-45
0D
10s ΓεnΣym-45
05v :nil
20
0Bo 10
10s α
09o 113
10s ΓεnΣym-45
05v :tree
20
0Bo 23
10s l
10s f
10s α
08i 3 v tree/reduce
09o 81
10s ΓεnΣym-45
05v :pair
20
0Bo 23
10s l
10s f
10s α
08i 3 v list/reduce
09o 49
10s ΓεnΣym-45
05v :array
20
0Bo 23
10s l
10s f
10s α
08i 3 v array/reduce
09o 17
10s f
10s α
10s l
1Ai 2
16
01
}
0Es reduce
0D
25v length v [α] v "Returns the length of collection α" v #{
15
10s α
08i 1 v type-of
0Es ΓεnΣym-46
0D
10s ΓεnΣym-46
05v :nil
20
0Bo 8
02i 0
09o 126
10s ΓεnΣym-46
05v :array
20
0Bo 15
10s α
08i 1 v array/length
09o 102
10s ΓεnΣym-46
05v :pair
20
0Bo 15
10s α
08i 1 v list/length
09o 78
10s ΓεnΣym-46
05v :string
20
0Bo 15
10s α
08i 1 v string/length
09o 54
10s ΓεnΣym-46
05v :tree
20
0Bo 15
10s α
08i 1 v tree/size
09o 30
05v :type-error
05v "You can only use length with a collection"
10s α
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es length
0D
25v map v [l f] v "Runs f over every item in collection l and returns the resulting list" v #{
15
10s l
08i 1 v type-of
0Es ΓεnΣym-47
0D
10s ΓεnΣym-47
05v :nil
20
0Bo 7
24
09o 86
10s ΓεnΣym-47
05v :pair
20
0Bo 19
10s l
10s f
08i 2 v list/map
09o 58
10s ΓεnΣym-47
05v :array
20
0Bo 19
10s l
10s f
08i 2 v array/map
09o 30
05v :type-error
05v "You can only use map with a collection"
10s l
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es map
0D
25v sort v [l] v "Sorts the collection L" v #{
15
10s l
08i 1 v type-of
0Es ΓεnΣym-48
0D
10s ΓεnΣym-48
05v :nil
20
0Bo 7
24
09o 78
10s ΓεnΣym-48
05v :pair
20
0Bo 15
10s l
08i 1 v list/sort/merge
09o 54
10s ΓεnΣym-48
05v :array
20
0Bo 15
10s l
08i 1 v array/heap-sort
09o 30
05v :type-error
05v "You can only use sort with a collection"
10s l
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es sort
0D
25v member v [l m] v "Returns the first pair/item of collection l whose car is equal to m" v #{
15
10s l
08i 1 v type-of
0Es ΓεnΣym-49
0D
10s ΓεnΣym-49
05v :pair
20
0Bo 19
10s l
10s m
08i 2 v list/member
09o 30
05v :type-error
05v "You can only use member with a collection"
10s l
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es member
0D
25v cut v [l start end] v "Return a subcollection of L from START to END" v #{
15
10s l
08i 1 v type-of
0Es ΓεnΣym-50
0D
10s ΓεnΣym-50
05v :array
20
0Bo 23
10s l
10s start
10s end
08i 3 v array/cut
09o 94
10s ΓεnΣym-50
05v :pair
20
0Bo 23
10s l
10s start
10s end
08i 3 v list/cut
09o 62
10s ΓεnΣym-50
05v :string
20
0Bo 23
10s l
10s start
10s end
08i 3 v string/cut
09o 30
05v :type-error
05v "You can only use member with a collection"
10s l
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es cut
0D
25v collection? v [l] v "" v #{
15
10s l
08i 1 v type-of
0Es ΓεnΣym-51
0D
10s ΓεnΣym-51
05v :pair
20
0C
0Ao 36
0D
10s ΓεnΣym-51
05v :array
20
0C
0Ao 22
0D
10s ΓεnΣym-51
05v :tree
20
0C
0Ao 8
0D
05v #f
0Bo 10
05v #t
09o 7
05v #f
16
01
}
0Es collection?
01
}#{
25v array->list v [arr] v "" v #{
10s arr
08i 1 v array/length
02i 1
08i 2 v -
0Es i
0D
24
0Es ret
0D
02i 0
1B
1C
10s i
02i 0
21
0Bo 45
0D
10s arr
10s i
08i 2 v array/ref
10s ret
14
0Fs ret
0D
02i -1
10s i
08i 2 v +
0Fs i
09o -50
0D
10s ret
01
01
}
0Es array->list
0D
25v except-last-pair/iter v [list rest] v "Iterator for except-last-pair" v #{
10s list
12
08i 1 v nil?
0Bo 15
10s rest
08i 1 v reverse
09o 23
10s list
12
10s list
11
10s rest
14
08i 2 v except-last-pair/iter
01
}
0Es except-last-pair/iter
0D
25v except-last-pair v [list] v "Return a copy of LIST without the last pair" v #{
10s list
24
08i 2 v except-last-pair/iter
01
}
0Es except-last-pair
0D
25v last-pair v [list] v "Return the last pair of LIST" v #{
02i 0
1B
1C
10s list
12
0Bo 16
0D
10s list
12
0Fs list
09o -19
0D
10s list
01
}
0Es last-pair
0D
25v make-list v [number value] v "Return a list of NUMBER elements containing VALUE in every car" v #{
24
0Es list
0D
02i 0
1B
1C
02i -1
10s number
08i 2 v +
0Fs number
02i 0
21
0Bo 20
0D
10s value
10s list
14
0Fs list
09o -36
0D
10s list
01
}
0Es make-list
0D
25v range v [end start step] v "Return a list containing values from START (inclusive) to END (exclusive) by STEP" v #{
10s end
0Bo 7
24
09o 21
05v :arity-error
05v "[range] needs at least a specific end"
08i 2 v list
08i 1 v throw
0D
10s start
0Bo 7
24
09o 9
02i 0
0Fs start
0D
10s step
0Bo 7
24
09o 9
02i 1
0Fs step
0D
10s step
08i 1 v pos?
0Bo 10
10s <
09o 7
10s >
0Es pred
0D
24
0Es ret
0D
02i 0
1B
1C
10s pred
10s start
10s end
1Ai 2
0Bo 38
0D
10s start
10s ret
14
0Fs ret
0D
10s start
10s step
08i 2 v +
0Fs start
09o -50
0D
10s ret
08i 1 v nreverse
01
}
0Es range
0D
25v list/reduce v [l o s] v "Combine all elements in l using operation o and starting value s" v #{
15
10s l
0Es ΓεnΣym-58
0D
10s ΓεnΣym-58
0Bo 59
02i 0
1B
1C
10s ΓεnΣym-58
0Bo 45
0D
10s ΓεnΣym-58
11
0Es e
0D
10s o
10s s
10s e
1Ai 2
0Fs s
0D
10s ΓεnΣym-58
12
0Fs ΓεnΣym-58
09o -47
09o 4
24
16
0D
10s s
01
}
0Es list/reduce
0D
25v list/ref v [l i] v "Returns the the element of list l at location i" v #{
02i 0
1B
1C
10s l
0C
0Bo 11
0D
10s i
02i 0
22
0Bo 32
0D
02i -1
10s i
08i 2 v +
0Fs i
0D
10s l
12
0Fs l
09o -46
0D
10s l
11
01
}
0Es list/ref
0D
25v reverse v [l] v "Return the list l in reverse order" v #{
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-59
0D
10s ΓεnΣym-59
0Bo 54
02i 0
1B
1C
10s ΓεnΣym-59
0Bo 40
0D
10s ΓεnΣym-59
11
0Es e
0D
10s e
10s ret
14
0Fs ret
0D
10s ΓεnΣym-59
12
0Fs ΓεnΣym-59
09o -42
09o 4
24
16
0D
10s ret
01
}
0Es reverse
0D
25v list/length v [l] v "Returns the length of list l" v #{
02i 0
0Es ret
0D
15
10s l
0Es ΓεnΣym-60
0D
10s ΓεnΣym-60
0Bo 56
02i 0
1B
1C
10s ΓεnΣym-60
0Bo 42
0D
10s ΓεnΣym-60
11
0Es e
0D
02i 1
10s ret
08i 2 v +
0Fs ret
0D
10s ΓεnΣym-60
12
0Fs ΓεnΣym-60
09o -44
09o 4
24
16
0D
10s ret
01
}
0Es list/length
0D
25v list/filter v [l p] v "Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" v #{
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-61
0D
10s ΓεnΣym-61
0Bo 71
02i 0
1B
1C
10s ΓεnΣym-61
0Bo 57
0D
10s ΓεnΣym-61
11
0Es e
0D
10s p
10s e
1Ai 1
0Bo 19
10s e
10s ret
14
0Fs ret
09o 4
24
0D
10s ΓεnΣym-61
12
0Fs ΓεnΣym-61
09o -59
09o 4
24
16
0D
10s ret
08i 1 v nreverse
01
}
0Es list/filter
0D
25v list/map v [l f] v "Runs f over every item in list l and returns the resulting list" v #{
24
0Es ret
0D
15
10s l
0Es ΓεnΣym-62
0D
10s ΓεnΣym-62
0Bo 60
02i 0
1B
1C
10s ΓεnΣym-62
0Bo 46
0D
10s ΓεnΣym-62
11
0Es e
0D
10s f
10s e
1Ai 1
10s ret
14
0Fs ret
0D
10s ΓεnΣym-62
12
0Fs ΓεnΣym-62
09o -48
09o 4
24
16
0D
10s ret
08i 1 v nreverse
01
}
0Es list/map
0D
25v append v [a b] v "Appends two lists A and B together" v #{
10s b
0Es ret
0D
10s a
08i 1 v reverse
0Fs a
0D
15
10s a
0Es ΓεnΣym-63
0D
10s ΓεnΣym-63
0Bo 54
02i 0
1B
1C
10s ΓεnΣym-63
0Bo 40
0D
10s ΓεnΣym-63
11
0Es t
0D
10s t
10s ret
14
0Fs ret
0D
10s ΓεnΣym-63
12
0Fs ΓεnΣym-63
09o -42
09o 4
24
16
0D
10s ret
01
}
0Es append
0D
25v sublist v [l start end ret] v "Returns a new list containing all elements of l from start to end" v #{
10s l
08i 1 v nil?
0Bo 15
10s ret
08i 1 v reverse
09o 166
10s end
08i 1 v neg?
0Bo 37
10s l
10s start
10s l
08i 1 v length
10s end
08i 2 v +
08i 3 v sublist
09o 120
10s end
08i 1 v zero?
0Bo 15
10s ret
08i 1 v reverse
09o 96
10s start
02i 0
22
0Bo 39
10s l
12
02i -1
10s start
08i 2 v +
02i -1
10s end
08i 2 v +
24
08i 4 v sublist
09o 50
10s end
02i 0
22
0Bo 39
10s l
12
02i 0
02i -1
10s end
08i 2 v +
10s l
11
10s ret
14
08i 4 v sublist
09o 4
24
01
}
0Es sublist
0D
25v list-head v [l k] v "Returns the first k elements of list l" v #{
10s l
02i 0
10s k
08i 3 v sublist
01
}
0Es list-head
0D
25v list-tail v [l k] v "Returns the sublist of l obtained by omitting the first l elements" v #{
10s l
10s k
10s l
08i 1 v length
08i 3 v sublist
01
}
0Es list-tail
0D
25v list/member v [l m] v "Returns the first pair of list l whose car is equal to m" v #{
10s l
08i 1 v nil?
0Bo 10
05v #f
09o 48
10s l
11
10s m
20
0Bo 10
10s l
09o 28
05v #t
0Bo 20
10s l
12
10s m
08i 2 v list/member
09o 4
24
01
}
0Es list/member
0D
25v getf v [l key] v "Return the value in LIST following KEY" v #{
10s l
08i 1 v nil?
0Bo 7
24
09o 53
10s key
10s l
11
20
0Bo 15
10s l
08i 1 v cadr
09o 28
05v #t
0Bo 20
10s l
12
10s key
08i 2 v getf
09o 4
24
01
}
0Es getf
0D
25v list/sort/bubble v [l] v "Terribly slow way to sort a list, though it was simple to write" v #{
10s l
0Bo 125
10s l
11
0Es top
0D
24
0Es next
0D
10s l
12
0Fs l
0D
02i 0
1B
1C
10s l
0Bo 70
0D
10s l
11
10s top
1F
0Bo 29
10s top
10s next
14
0Fs next
0D
10s l
11
0Fs top
09o 17
10s l
11
10s next
14
0Fs next
0D
10s l
12
0Fs l
09o -72
0D
10s top
10s next
08i 1 v list/sort/bubble
14
09o 4
24
01
}
0Es list/sort/bubble
0D
25v list/merge-sorted-lists v [l1 l2] v "" v #{
10s l1
08i 1 v nil?
0Bo 10
10s l2
09o 90
10s l2
08i 1 v nil?
0Bo 10
10s l1
09o 71
05v #t
0Bo 63
10s l1
11
10s l2
11
1E
0Bo 26
10s l1
11
10s l1
12
10s l2
08i 2 v list/merge-sorted-lists
14
09o 23
10s l2
11
10s l1
10s l2
12
08i 2 v list/merge-sorted-lists
14
09o 4
24
01
}
0Es list/merge-sorted-lists
0D
25v list/split-half-rec v [l acc1 acc2] v "" v #{
10s l
08i 1 v nil?
0Bo 15
10s acc1
10s acc2
14
09o 83
10s l
12
08i 1 v nil?
0Bo 21
10s l
11
10s acc1
14
10s acc2
14
09o 52
05v #t
0Bo 44
10s l
08i 1 v cddr
10s l
11
10s acc1
14
10s l
08i 1 v cadr
10s acc2
14
08i 3 v list/split-half-rec
09o 4
24
01
}
0Es list/split-half-rec
0D
25v list/split-half v [l] v "" v #{
10s l
24
24
08i 3 v list/split-half-rec
01
}
0Es list/split-half
0D
25v list/sort/merge v [l] v "Sorts a list" v #{
10s l
12
08i 1 v nil?
0Bo 10
10s l
09o 42
10s l
08i 1 v list/split-half
0Es parts
0D
10s parts
11
08i 1 v list/sort/merge
10s parts
12
08i 1 v list/sort/merge
08i 2 v list/merge-sorted-lists
01
}
0Es list/sort/merge
0D
10s list/sort/merge
0Es list/sort
0D
25v list/equal? v [a b] v "#t if A and B are equal" v #{
10s a
08i 1 v pair?
0Bo 41
10s a
11
10s b
11
08i 2 v list/equal?
0C
0Bo 19
0D
10s a
12
10s b
12
08i 2 v list/equal?
09o 16
10s a
10s b
08i 2 v equal?
01
}
0Es list/equal?
0D
25v list/take v [l count] v "Take the first COUNT elements from list L" v #{
10s count
02i 0
1F
0Bo 7
24
09o 30
10s l
11
10s l
12
10s count
02i 1
08i 2 v -
08i 2 v list/take
14
01
}
0Es list/take
0D
25v list/drop v [l count] v "Drop the final COUNT elements from list L" v #{
10s count
02i 0
1F
0Bo 10
10s l
09o 24
10s l
12
10s count
02i 1
08i 2 v -
08i 2 v list/drop
01
}
0Es list/drop
0D
25v list/cut v [l start end] v "Return a subsequence of L from START to END" v #{
10s l
02i 0
10s start
08i 2 v max
08i 2 v list/drop
10s end
02i 0
10s start
08i 2 v max
08i 2 v -
08i 2 v list/take
01
}
0Es list/cut
01
}#{
25v tree/zip v [keys values] v "Return a tree where KEYS point to VALUES" v #{
24
08i 1 v tree/new
0Es ret
0D
15
10s keys
0Es ΓεnΣym-66
0D
10s ΓεnΣym-66
0Bo 69
02i 0
1B
1C
10s ΓεnΣym-66
0Bo 55
0D
10s ΓεnΣym-66
11
0Es key
0D
10s ret
10s key
10s values
11
08i 3 v tree/set!
0D
10s values
12
0Fs values
0D
10s ΓεnΣym-66
12
0Fs ΓεnΣym-66
09o -57
09o 4
24
16
0D
10s ret
01
}
0Es tree/zip
0D
25v tree/+= v [t k v] v "Increment value at K in T by V" v #{
10s t
10s k
10s v
10s t
10s k
08i 2 v tree/ref
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
08i 1 v int
08i 2 v +
08i 3 v tree/set!
01
}
0Es tree/+=
0D
26v tree/-= v [t k v] v "Decrement value at K in T by V" v #{
23s tree/+=
10s t
10s k
23s -
10s v
24
14
14
24
14
14
14
14
01
}
0Es tree/-=
0D
26v tree/++ v [t k] v "Increment value at K in T by 1" v #{
23s tree/+=
10s t
10s k
02i 1
24
14
14
14
14
01
}
0Es tree/++
0D
26v tree/-- v [t k] v "Increment value at K in T by 1" v #{
23s tree/-=
10s t
10s k
02i 1
24
14
14
14
14
01
}
0Es tree/--
0D
25v tree/equal? v [a b] v "Compares two trees for equality" v #{
10s a
08i 1 v tree?
0C
0Bo 13
0D
10s b
08i 1 v tree?
0Bo 109
10s a
08i 1 v tree/key*
10s b
08i 1 v tree/key*
20
0C
0Bo 83
0D
10s a
08i 1 v tree/value*
10s b
08i 1 v tree/value*
08i 2 v equal?
0C
0Bo 55
0D
10s a
08i 1 v tree/left*
10s b
08i 1 v tree/left*
08i 2 v tree/equal?
0C
0Bo 27
0D
10s a
08i 1 v tree/right*
10s b
08i 1 v tree/right*
08i 2 v tree/equal?
09o 16
10s a
10s b
08i 2 v equal?
01
}
0Es tree/equal?
0D
25v tree/reduce v [l o s] v "Combine all elements in l using operation o and starting value s" v #{
10s l
08i 1 v tree/values
10s o
10s s
08i 3 v list/reduce
01
}
0Es tree/reduce
0D
25v tree/filter v [l f] v "Return a new tree with all elements from L where F retunrs true" v #{
24
08i 1 v tree/new
0Es ret
0D
15
10s l
08i 1 v tree/keys
0Es ΓεnΣym-67
0D
10s ΓεnΣym-67
0Bo 93
02i 0
1B
1C
10s ΓεnΣym-67
0Bo 79
0D
10s ΓεnΣym-67
11
0Es e
0D
10s l
10s e
08i 2 v tree/ref
0Es t
0D
10s f
10s t
1Ai 1
0Bo 23
10s ret
10s e
10s t
08i 3 v tree/set!
09o 4
24
0D
10s ΓεnΣym-67
12
0Fs ΓεnΣym-67
09o -81
09o 4
24
16
0D
10s ret
01
}
0Es tree/filter
01
}#{
25v val->bytecode-op v [v] v "" v #{
10s v
08i 1 v val->index
0Es i
0D
10s i
02i 16
08i 2 v >>
05v 255
08i 2 v logand
08i 1 v int->bytecode-op
10s i
02i 8
08i 2 v >>
05v 255
08i 2 v logand
08i 1 v int->bytecode-op
10s i
05v 255
08i 2 v logand
08i 1 v int->bytecode-op
08i 3 v list
01
}
0Es val->bytecode-op
0D
25v sym->bytecode-op v [v] v "" v #{
10s v
08i 1 v sym->index
0Es i
0D
10s i
02i 16
08i 2 v >>
05v 255
08i 2 v logand
08i 1 v int->bytecode-op
10s i
02i 8
08i 2 v >>
05v 255
08i 2 v logand
08i 1 v int->bytecode-op
10s i
05v 255
08i 2 v logand
08i 1 v int->bytecode-op
08i 3 v list
01
}
0Es sym->bytecode-op
0D
25v int-fit-in-byte? v [a] v "" v #{
10s a
02i 127
1F
0C
0Bo 11
0D
10s a
02i -128
21
01
}
0Es int-fit-in-byte?
0D
25v $nop v [] v "- | Do nothing" v #{
05v [#$0]
01
}
0Es $nop
0D
25v $ret v [] v "a - | Return top of value stack" v #{
05v [#$1]
01
}
0Es $ret
0D
25v $push/int/byte v [a] v "- a | Return top of value stack" v #{
10s a
08i 1 v int-fit-in-byte?
0Bo 7
24
09o 30
05v :invalid-bc-op
05v "$push/int/byte can only push a signed 8-bit value"
10s a
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
05v #$2
10s a
08i 1 v int->bytecode-op
08i 2 v list
01
}
0Es $push/int/byte
0D
25v $push/int v [a] v "- a | Return top of value stack" v #{
10s a
08i 1 v int-fit-in-byte?
0Bo 15
10s a
08i 1 v $push/int/byte
09o 12
10s a
08i 1 v $push/lval
01
}
0Es $push/int
0D
25v $add/int v [] v "a b - c | Adds the two topmost values and pushes the result" v #{
05v [#$3]
01
}
0Es $add/int
0D
25v $push/lval v [v] v "- v | Pushes v onto the stack" v #{
10s v
08i 1 v nil?
0Bo 33
05v :invalid-bc-op
05v "Can't push #nil as a normal lVal"
10s v
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
05v #$5
10s v
08i 1 v val->bytecode-op
08i 2 v list
01
}
0Es $push/lval
0D
25v $push/symbol v [v] v "- v | Pushes v onto the stack" v #{
05v #$23
10s v
08i 1 v sym->bytecode-op
08i 2 v list
01
}
0Es $push/symbol
0D
25v $apply/new v [arg-count fun] v "arguments ... - result | Read arg-count arguments from the stack, apply the to fun and push the result on the stack" v #{
15
10s arg-count
0Es ΓεnΣym-77
0D
10s ΓεnΣym-77
02i 1
20
0Bo 84
15
10s fun
0Es ΓεnΣym-78
0D
10s ΓεnΣym-78
10s car
20
0Bo 11
08i 0 v $car
09o 50
10s ΓεnΣym-78
10s cdr
20
0Bo 11
08i 0 v $cdr
09o 30
05v #$4
10s arg-count
08i 1 v int->bytecode-op
10s fun
08i 1 v val->bytecode-op
08i 3 v list
16
09o 221
10s ΓεnΣym-77
02i 2
20
0Bo 184
15
10s fun
0Es ΓεnΣym-79
0D
10s ΓεnΣym-79
10s add/int
20
0Bo 11
08i 0 v $add/int
09o 150
10s ΓεnΣym-79
10s cons
20
0Bo 11
08i 0 v $cons
09o 130
10s ΓεnΣym-79
10s <
20
0Bo 11
08i 0 v $<
09o 110
10s ΓεnΣym-79
10s <=
20
0Bo 11
08i 0 v $<=
09o 90
10s ΓεnΣym-79
10s ==
20
0Bo 11
08i 0 v $==
09o 70
10s ΓεnΣym-79
10s >=
20
0Bo 11
08i 0 v $>=
09o 50
10s ΓεnΣym-79
10s >
20
0Bo 11
08i 0 v $>
09o 30
05v #$4
10s arg-count
08i 1 v int->bytecode-op
10s fun
08i 1 v val->bytecode-op
08i 3 v list
16
09o 30
05v #$4
10s arg-count
08i 1 v int->bytecode-op
10s fun
08i 1 v val->bytecode-op
08i 3 v list
16
01
}
0Es $apply/new
0D
25v $apply v [arg-count fun] v "arguments ... - result | Read arg-count arguments from the stack, apply the to fun and push the result on the stack" v #{
15
10s arg-count
0Es ΓεnΣym-80
0D
10s ΓεnΣym-80
02i 1
20
0Bo 84
15
10s fun
0Es ΓεnΣym-81
0D
10s ΓεnΣym-81
10s car
20
0Bo 11
08i 0 v $car
09o 50
10s ΓεnΣym-81
10s cdr
20
0Bo 11
08i 0 v $cdr
09o 30
05v #$8
10s arg-count
08i 1 v int->bytecode-op
10s fun
08i 1 v val->bytecode-op
08i 3 v list
16
09o 221
10s ΓεnΣym-80
02i 2
20
0Bo 184
15
10s fun
0Es ΓεnΣym-82
0D
10s ΓεnΣym-82
10s add/int
20
0Bo 11
08i 0 v $add/int
09o 150
10s ΓεnΣym-82
10s cons
20
0Bo 11
08i 0 v $cons
09o 130
10s ΓεnΣym-82
10s <
20
0Bo 11
08i 0 v $<
09o 110
10s ΓεnΣym-82
10s <=
20
0Bo 11
08i 0 v $<=
09o 90
10s ΓεnΣym-82
10s ==
20
0Bo 11
08i 0 v $==
09o 70
10s ΓεnΣym-82
10s >=
20
0Bo 11
08i 0 v $>=
09o 50
10s ΓεnΣym-82
10s >
20
0Bo 11
08i 0 v $>
09o 30
05v #$8
10s arg-count
08i 1 v int->bytecode-op
10s fun
08i 1 v val->bytecode-op
08i 3 v list
16
09o 30
05v #$8
10s arg-count
08i 1 v int->bytecode-op
10s fun
08i 1 v val->bytecode-op
08i 3 v list
16
01
}
0Es $apply
0D
25v $apply/dynamic v [arg-count fun] v "" v #{
05v #$1A
10s arg-count
08i 1 v int->bytecode-op
08i 2 v list
01
}
0Es $apply/dynamic
0D
25v $try/old v [target] v " - | Try something, jumping to target if an exception occurs" v #{
05v #$18
05v :relocate
10s target
02i 8
02i 0
02i 0
08i 1 v int->bytecode-op
08i 5 v list
05v :relocate
10s target
02i 0
02i 1
02i 0
08i 1 v int->bytecode-op
08i 5 v list
08i 3 v list
01
}
0Es $try/old
0D
25v $try v [target] v " - | Try something, jumping to target if an exception occurs" v #{
05v #$19
05v :relocate
10s target
02i 8
02i 0
02i 0
08i 1 v int->bytecode-op
08i 5 v list
05v :relocate
10s target
02i 0
02i 1
02i 0
08i 1 v int->bytecode-op
08i 5 v list
08i 3 v list
01
}
0Es $try
0D
25v $jmp v [target] v "" v #{
05v #$9
05v :relocate
10s target
02i 8
02i 0
02i 0
08i 1 v int->bytecode-op
08i 5 v list
05v :relocate
10s target
02i 0
02i 1
02i 0
08i 1 v int->bytecode-op
08i 5 v list
08i 3 v list
01
}
0Es $jmp
0D
25v $jt v [target] v "" v #{
05v #$A
05v :relocate
10s target
02i 8
02i 0
02i 0
08i 1 v int->bytecode-op
08i 5 v list
05v :relocate
10s target
02i 0
02i 1
02i 0
08i 1 v int->bytecode-op
08i 5 v list
08i 3 v list
01
}
0Es $jt
0D
25v $jf v [target] v "" v #{
05v #$B
05v :relocate
10s target
02i 8
02i 0
02i 0
08i 1 v int->bytecode-op
08i 5 v list
05v :relocate
10s target
02i 0
02i 1
02i 0
08i 1 v int->bytecode-op
08i 5 v list
08i 3 v list
01
}
0Es $jf
0D
25v $dup v [] v "" v #{
05v [#$C]
01
}
0Es $dup
0D
25v $drop v [] v "" v #{
05v [#$D]
01
}
0Es $drop
0D
25v $def v [v] v "" v #{
05v #$E
10s v
08i 1 v sym->bytecode-op
08i 2 v list
01
}
0Es $def
0D
25v $set v [v] v "" v #{
05v #$F
10s v
08i 1 v sym->bytecode-op
08i 2 v list
01
}
0Es $set
0D
25v $get v [v] v "" v #{
05v #$10
10s v
08i 1 v sym->bytecode-op
08i 2 v list
01
}
0Es $get
0D
25v $fn v [name args docs body] v "" v #{
05v #$25
10s name
08i 1 v val->bytecode-op
10s args
08i 1 v val->bytecode-op
10s docs
08i 1 v val->bytecode-op
10s body
08i 1 v val->bytecode-op
08i 5 v list
01
}
0Es $fn
0D
25v $macro* v [name args docs body] v "" v #{
05v #$26
10s name
08i 1 v val->bytecode-op
10s args
08i 1 v val->bytecode-op
10s docs
08i 1 v val->bytecode-op
10s body
08i 1 v val->bytecode-op
08i 5 v list
01
}
0Es $macro*
0D
25v $closure/push v [] v "" v #{
05v [#$13]
01
}
0Es $closure/push
0D
25v $let v [] v "" v #{
05v [#$15]
01
}
0Es $let
0D
25v $closure/pop v [] v "" v #{
05v [#$16]
01
}
0Es $closure/pop
0D
25v $roots/save v [] v "" v #{
05v [#$1B]
01
}
0Es $roots/save
0D
25v $roots/restore v [] v "" v #{
05v [#$1C]
01
}
0Es $roots/restore
0D
25v $< v [] v "" v #{
05v [#$1E]
01
}
0Es $<
0D
25v $<= v [] v "" v #{
05v [#$1F]
01
}
0Es $<=
0D
25v $== v [] v "" v #{
05v [#$20]
01
}
0Es $==
0D
25v $>= v [] v "" v #{
05v [#$21]
01
}
0Es $>=
0D
25v $> v [] v "" v #{
05v [#$22]
01
}
0Es $>
0D
25v $push/nil v [] v "" v #{
05v [#$24]
01
}
0Es $push/nil
0D
25v $car v [] v "" v #{
05v [#$11]
01
}
0Es $car
0D
25v $cdr v [] v "" v #{
05v [#$12]
01
}
0Es $cdr
0D
25v $cons v [] v "" v #{
05v [#$14]
01
}
0Es $cons
0D
25v assemble/build-sym-map v [code sym-map pos] v "" v #{
02i 0
1B
1C
10s code
0Bo 190
0D
15
10s code
11
08i 1 v type-of
0Es ΓεnΣym-83
0D
10s ΓεnΣym-83
05v :bytecode-op
20
0Bo 34
10s sym-map
05v :last-op
02i 1
10s pos
08i 2 v +
0Fs pos
08i 3 v tree/set!
09o 116
10s ΓεnΣym-83
05v :symbol
20
0C
0Ao 22
0D
10s ΓεnΣym-83
05v :keyword
20
0C
0Ao 8
0D
05v #f
0Bo 43
10s code
11
05v :label
20
0C
0Bo 26
0D
10s sym-map
10s code
08i 1 v cadr
10s pos
08i 3 v tree/set!
09o 41
10s ΓεnΣym-83
05v :pair
20
0Bo 28
10s code
11
10s sym-map
10s pos
08i 3 v assemble/build-sym-map
0Fs pos
09o 4
24
16
0D
10s code
12
0Fs code
09o -192
0D
10s pos
01
}
0Es assemble/build-sym-map
0D
25v assemble/relocate-op v [code sym-map pos out] v "" v #{
10s sym-map
10s code
08i 1 v cadr
08i 2 v tree/ref
0Es target
0D
10s target
10s code
08i 1 v cadddr
08i 2 v +
10s pos
08i 2 v -
0Es off
0D
10s out
02i 1
10s pos
08i 2 v +
0Fs pos
10s off
10s code
08i 1 v caddr
08i 2 v >>
05v 255
08i 2 v logand
08i 1 v int->bytecode-op
08i 3 v array/set!
0D
10s pos
01
}
0Es assemble/relocate-op
0D
25v assemble/emit-relocated-ops v [code sym-map pos out] v "" v #{
10s code
11
05v :relocate
20
0Bo 31
10s code
10s sym-map
10s pos
10s out
08i 4 v assemble/relocate-op
0Fs pos
09o 160
15
10s code
0Es ΓεnΣym-84
0D
10s ΓεnΣym-84
0Bo 141
02i 0
1B
1C
10s ΓεnΣym-84
0Bo 127
0D
10s ΓεnΣym-84
11
0Es op
0D
15
10s op
08i 1 v type-of
0Es ΓεnΣym-85
0D
10s ΓεnΣym-85
05v :bytecode-op
20
0Bo 34
10s out
02i 1
10s pos
08i 2 v +
0Fs pos
10s op
08i 3 v array/set!
09o 44
10s ΓεnΣym-85
05v :pair
20
0Bo 31
10s op
10s sym-map
10s pos
10s out
08i 4 v assemble/emit-relocated-ops
0Fs pos
09o 4
24
16
0D
10s ΓεnΣym-84
12
0Fs ΓεnΣym-84
09o -129
09o 4
24
16
0D
10s pos
01
}
0Es assemble/emit-relocated-ops
0D
05v #f
0Es assemble/verbose
0D
25v assemble* v [code] v "Assemble all arguments into a single :bytecode-array" v #{
24
08i 1 v tree/new
0Es sym-map
0D
10s assemble/verbose
0C
0Bo 32
0D
05v "Input:\n"
10s code
08i 1 v str/write
08i 2 v ansi-blue
08i 1 v cat
08i 1 v println
0D
10s code
10s sym-map
02i 0
08i 3 v assemble/build-sym-map
0D
10s assemble/verbose
0C
0Bo 32
0D
05v "Symbol Map:\n"
10s sym-map
08i 1 v str/write
08i 2 v ansi-yellow
08i 1 v cat
08i 1 v println
0D
10s sym-map
05v :last-op
08i 2 v tree/ref
08i 1 v array/allocate
0Es out
0D
10s code
10s sym-map
02i -1
10s out
08i 4 v assemble/emit-relocated-ops
0D
10s assemble/verbose
0C
0Bo 32
0D
05v "Output:\n"
10s out
08i 1 v str/write
08i 2 v ansi-green
08i 1 v cat
08i 1 v println
0D
10s out
08i 1 v arr->bytecode-arr
01
}
0Es assemble*
0D
25v assemble v l v "Assemble all arguments into a single :bytecode-array" v #{
10s l
08i 1 v assemble*
01
}
0Es assemble
0D
26v asmrun v ops v "Assemble and evaluate all bytecode arguments" v #{
23s bytecode-eval
23s assemble
10s ops
24
08i 2 v append
14
24
14
14
01
}
0Es asmrun
01
}#{
02i 0
0Es bytecompile/gen-label/counter
0D
25v bytecompile/gen-label v [prefix] v "" v #{
02i 1
10s bytecompile/gen-label/counter
08i 2 v +
0Fs bytecompile/gen-label/counter
0D
10s prefix
05v "label-"
10s bytecompile/gen-label/counter
08i 3 v cat
08i 1 v str->sym
01
}
0Es bytecompile/gen-label
0D
25v bytecompile/literal v [source] v "" v #{
15
10s source
08i 1 v type-of
0Es ΓεnΣym-90
0D
10s ΓεnΣym-90
05v :symbol
20
0C
0Ao 22
0D
10s ΓεnΣym-90
05v :keyword
20
0C
0Ao 8
0D
05v #f
0Bo 39
10s source
08i 1 v keyword?
0Bo 15
10s source
08i 1 v $push/lval
09o 12
10s source
08i 1 v $get
09o 56
10s ΓεnΣym-90
05v :int
20
0Bo 15
10s source
08i 1 v $push/int
09o 32
10s ΓεnΣym-90
05v :nil
20
0Bo 11
08i 0 v $push/nil
09o 12
10s source
08i 1 v $push/lval
16
01
}
0Es bytecompile/literal
0D
25v bytecompile/quote v [source] v "" v #{
15
10s source
08i 1 v type-of
0Es ΓεnΣym-91
0D
10s ΓεnΣym-91
05v :int
20
0Bo 15
10s source
08i 1 v $push/int
09o 36
10s ΓεnΣym-91
05v :symbol
20
0Bo 15
10s source
08i 1 v $push/symbol
09o 12
10s source
08i 1 v $push/lval
16
01
}
0Es bytecompile/quote
0D
25v bytecompile/do/form v [source env] v "" v #{
10s source
0Bo 59
10s source
11
10s env
08i 2 v bytecompile*
10s source
08i 1 v last?
0Bo 7
24
09o 10
08i 0 v $drop
24
14
14
10s source
12
10s env
08i 2 v bytecompile/do/form
14
09o 4
24
01
}
0Es bytecompile/do/form
0D
25v bytecompile/do v [source env] v "" v #{
10s source
12
10s env
08i 2 v bytecompile/do/form
08i 1 v list
01
}
0Es bytecompile/do
0D
25v bytecompile/procedure v [op source env] v "" v #{
10s source
12
10s bytecompile*
08i 2 v map
0Es args
0D
10s args
10s args
08i 1 v length
10s op
08i 2 v $apply
08i 2 v list
01
}
0Es bytecompile/procedure
0D
25v bytecompile/def v [source env] v "" v #{
10s source
08i 1 v cadr
08i 1 v symbol?
08i 1 v not
0C
0Ao 27
0D
10s source
08i 1 v cddr
08i 1 v not
0C
0Ao 8
0D
05v #f
0Bo 29
05v :type-error
05v "[def] needs a symbol name and a value as arguments"
24
10s env
08i 4 v list
08i 1 v throw
09o 4
24
0D
10s source
08i 1 v caddr
10s env
08i 2 v bytecompile*
10s source
08i 1 v cadr
08i 1 v $def
08i 2 v list
01
}
0Es bytecompile/def
0D
25v bytecompile/set! v [source env] v "" v #{
10s source
08i 1 v cadr
08i 1 v symbol?
08i 1 v not
0C
0Ao 27
0D
10s source
08i 1 v cddr
08i 1 v not
0C
0Ao 8
0D
05v #f
0Bo 29
05v :type-error
05v "[set!] needs a symbol name and a value as arguments"
24
10s env
08i 4 v list
08i 1 v throw
09o 4
24
0D
10s source
08i 1 v caddr
10s env
08i 2 v bytecompile*
10s source
08i 1 v cadr
08i 1 v $set
08i 2 v list
01
}
0Es bytecompile/set!
0D
25v bytecompile/if v [source env] v "" v #{
15
08i 0 v bytecompile/gen-label
0Es sym-else
0D
08i 0 v bytecompile/gen-label
0Es sym-after
0D
10s source
08i 1 v cadr
10s env
08i 2 v bytecompile*
10s sym-else
08i 1 v $jf
10s source
08i 1 v caddr
10s env
08i 2 v bytecompile*
10s sym-after
08i 1 v $jmp
05v :label
10s sym-else
08i 2 v list
10s source
08i 1 v cadddr
10s env
08i 2 v bytecompile*
05v :label
10s sym-after
08i 2 v list
08i 7 v list
16
01
}
0Es bytecompile/if
0D
25v bytecompile/while v [source env] v "" v #{
08i 0 v bytecompile/gen-label
0Es sym-start
0D
08i 0 v bytecompile/gen-label
0Es sym-end
0D
02i 0
08i 1 v $push/int
08i 0 v $roots/save
05v :label
10s sym-start
08i 2 v list
08i 0 v $roots/restore
10s source
08i 1 v cadr
10s env
08i 2 v bytecompile*
10s sym-end
08i 1 v $jf
08i 0 v $drop
10s source
08i 1 v cddr
10s env
08i 2 v bytecompile/do/form
10s sym-start
08i 1 v $jmp
05v :label
10s sym-end
08i 2 v list
08i 10 v list
01
}
0Es bytecompile/while
0D
25v bytecompile/procedure/arg v [source env] v "" v #{
10s source
08i 1 v last?
0Bo 20
10s source
11
10s env
08i 2 v bytecompile*
09o 32
10s source
11
10s env
08i 2 v bytecompile*
10s source
12
10s env
08i 2 v bytecompile/procedure/arg
14
01
}
0Es bytecompile/procedure/arg
0D
25v bytecompile/procedure v [op args env] v "" v #{
10s args
08i 1 v length
0Es arg-count
0D
10s args
0Bo 33
10s args
08i 1 v bytecompile/procedure/arg
10s arg-count
10s op
08i 2 v $apply
08i 2 v list
09o 14
02i 0
10s op
08i 2 v $apply
01
}
0Es bytecompile/procedure
0D
25v bytecompile/procedure/dynamic v [op args env] v "" v #{
10s args
08i 1 v length
0Es arg-count
0D
10s op
10s env
08i 2 v bytecompile*
10s args
0Bo 15
10s args
08i 1 v bytecompile/procedure/arg
09o 4
24
10s arg-count
08i 1 v $apply/dynamic
08i 3 v list
01
}
0Es bytecompile/procedure/dynamic
0D
25v bytecompile/and/rec v [source env label-end] v "" v #{
10s source
11
10s env
08i 2 v bytecompile*
10s source
12
0Bo 48
08i 0 v $dup
10s label-end
08i 1 v $jf
08i 0 v $drop
10s source
12
10s env
10s label-end
08i 3 v bytecompile/and/rec
08i 4 v list
09o 4
24
08i 2 v list
01
}
0Es bytecompile/and/rec
0D
25v bytecompile/and v [source env] v "" v #{
08i 0 v bytecompile/gen-label
0Es label-end
0D
10s source
12
10s env
10s label-end
08i 3 v bytecompile/and/rec
05v :label
10s label-end
08i 2 v list
08i 2 v list
01
}
0Es bytecompile/and
0D
25v bytecompile/or/rec v [source env label-end] v "" v #{
10s source
0Bo 62
10s source
11
10s env
08i 2 v bytecompile*
08i 0 v $dup
10s label-end
08i 1 v $jt
08i 0 v $drop
10s source
12
10s env
10s label-end
08i 3 v bytecompile/or/rec
08i 5 v list
09o 4
24
01
}
0Es bytecompile/or/rec
0D
25v bytecompile/or v [source env] v "" v #{
08i 0 v bytecompile/gen-label
0Es label-end
0D
10s source
12
10s env
10s label-end
08i 3 v bytecompile/or/rec
05v #f
08i 1 v $push/lval
05v :label
10s label-end
08i 2 v list
08i 3 v list
01
}
0Es bytecompile/or
0D
25v bytecompile/string v [source env] v "" v #{
10s cat
10s source
10s env
08i 3 v bytecompile/procedure
01
}
0Es bytecompile/string
0D
25v bytecompile/array v [source env] v "" v #{
10s array/ref
10s source
10s env
08i 3 v bytecompile/procedure
01
}
0Es bytecompile/array
0D
25v bytecompile/tree v [source env] v "" v #{
10s tree/ref
10s source
10s env
08i 3 v bytecompile/procedure
01
}
0Es bytecompile/tree
0D
25v bytecompile/fn* v [source env] v "" v #{
10s $fn
10s source
12
08i 2 v apply
01
}
0Es bytecompile/fn*
0D
25v bytecompile/macro* v [source env] v "" v #{
10s $macro*
10s source
12
08i 2 v apply
01
}
0Es bytecompile/macro*
0D
25v bytecompile/ω* v [source env] v "" v #{
08i 0 v $let
10s source
12
10s env
08i 2 v bytecompile/do/form
08i 0 v $drop
08i 0 v $closure/push
08i 0 v $closure/pop
08i 5 v list
01
}
0Es bytecompile/ω*
0D
25v bytecompile/let* v [source env] v "" v #{
08i 0 v $let
10s source
08i 1 v cadr
10s env
08i 2 v bytecompile/do
08i 0 v $closure/pop
08i 3 v list
01
}
0Es bytecompile/let*
0D
25v bytecompile/return v [source env] v "" v #{
10s source
08i 1 v cadr
10s env
08i 2 v bytecompile*
08i 0 v $ret
08i 2 v list
01
}
0Es bytecompile/return
0D
25v bytecompile/try v [source env] v "" v #{
08i 0 v bytecompile/gen-label
0Es end-sym
0D
10s source
08i 1 v cadr
10s env
08i 2 v bytecompile*
10s end-sym
08i 1 v $try
10s source
08i 1 v cddr
10s env
08i 2 v bytecompile/do/form
08i 0 v $closure/pop
05v :label
10s end-sym
08i 2 v list
08i 5 v list
01
}
0Es bytecompile/try
0D
25v bytecompile* v [source env] v "Compile the forms in source" v #{
10s source
11
10s env
08i 2 v resolves?
0Bo 20
10s source
11
10s env
08i 2 v resolve
09o 8
10s source
11
0Es op
0D
15
10s op
08i 1 v type-of
0Es ΓεnΣym-92
0D
10s ΓεnΣym-92
05v :lambda
20
0C
0Ao 22
0D
10s ΓεnΣym-92
05v :native-function
20
0C
0Ao 8
0D
05v #f
0Bo 428
15
10s op
0Es ΓεnΣym-93
0D
10s ΓεnΣym-93
10s do
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/do
09o 386
10s ΓεnΣym-93
10s let*
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/let*
09o 358
10s ΓεnΣym-93
10s def
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/def
09o 330
10s ΓεnΣym-93
10s set!
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/set!
09o 302
10s ΓεnΣym-93
10s if
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/if
09o 274
10s ΓεnΣym-93
10s while
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/while
09o 246
10s ΓεnΣym-93
10s and
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/and
09o 218
10s ΓεnΣym-93
10s or
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/or
09o 190
10s ΓεnΣym-93
10s fn*
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/fn*
09o 162
10s ΓεnΣym-93
10s macro*
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/macro*
09o 134
10s ΓεnΣym-93
10s ω*
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/ω*
09o 106
10s ΓεnΣym-93
10s try
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/try
09o 78
10s ΓεnΣym-93
10s return
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/return
09o 50
10s ΓεnΣym-93
10s quote
20
0Bo 20
10s source
08i 1 v cadr
08i 1 v bytecompile/quote
09o 21
10s op
10s source
12
10s env
08i 3 v bytecompile/procedure
16
09o 152
10s ΓεnΣym-92
05v :pair
20
0C
0Ao 22
0D
10s ΓεnΣym-92
05v :symbol
20
0C
0Ao 8
0D
05v #f
0Bo 24
10s op
10s source
12
10s env
08i 3 v bytecompile/procedure/dynamic
09o 96
10s ΓεnΣym-92
05v :string
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/string
09o 68
10s ΓεnΣym-92
05v :array
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/array
09o 40
10s ΓεnΣym-92
05v :tree
20
0Bo 19
10s source
10s env
08i 2 v bytecompile/tree
09o 12
10s source
08i 1 v bytecompile/literal
16
01
}
0Es bytecompile*
0D
25v bytecompile v [form environment] v "" v #{
10s form
10s environment
08i 2 v bytecompile*
08i 0 v $ret
08i 2 v list
01
}
0Es bytecompile
01
}#{
08i 0 v current-closure
0Es compile/environment
0D
05v #f
0Es compile/verbose
0D
25v compile/do/args v [args] v "" v #{
10s args
08i 1 v last?
0Bo 18
10s args
11
08i 1 v compile*
24
14
09o 86
10s args
11
08i 1 v pair?
0Bo 63
15
10s args
11
08i 1 v compile*
0Es ocar
0D
10s ocar
08i 1 v pair?
0Bo 21
10s ocar
10s args
12
08i 1 v compile/do/args
14
09o 13
10s args
12
08i 1 v compile/do/args
16
09o 13
10s args
12
08i 1 v compile/do/args
01
}
0Es compile/do/args
0D
25v compile/do v [source] v "" v #{
10s source
08i 1 v compile/do/args
0Es args
0D
10s args
08i 1 v last?
0Bo 11
10s args
11
09o 12
23s do
10s args
14
01
}
0Es compile/do
0D
25v compile/def v [source] v "" v #{
10s source
08i 1 v cdddr
0Bo 33
05v :arity-error
05v "[def] can only have 2 arguments"
10s source
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
23s def
10s source
08i 1 v cadr
10s source
08i 1 v caddr
08i 1 v compile*
08i 3 v list
01
}
0Es compile/def
0D
25v compile/set! v [source] v "" v #{
10s source
08i 1 v cdddr
0Bo 33
05v :arity-error
05v "[set!] can only have 2 arguments"
10s source
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
23s set!
10s source
08i 1 v cadr
10s source
08i 1 v caddr
08i 1 v compile*
08i 3 v list
01
}
0Es compile/set!
0D
25v compile/fn* v [source] v "" v #{
10s source
08i 1 v cdddddr
0Bo 33
05v :arity-error
05v "[fn*] can only have 4 arguments"
10s source
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
23s fn*
10s source
08i 1 v cadr
10s source
08i 1 v caddr
10s source
08i 1 v cadddr
10s source
08i 1 v caddddr
08i 1 v compile
08i 5 v list
01
}
0Es compile/fn*
0D
25v compile/macro* v [source] v "" v #{
10s source
08i 1 v cdddddr
0Bo 33
05v :arity-error
05v "[macro*] can only have 4 arguments"
10s source
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
23s macro*
10s source
08i 1 v cadr
10s source
08i 1 v caddr
10s source
08i 1 v cadddr
10s source
08i 1 v caddddr
08i 1 v compile
08i 5 v list
01
}
0Es compile/macro*
0D
25v compile/ω* v [source] v "" v #{
23s ω*
10s source
12
08i 1 v compile/do
08i 2 v list
01
}
0Es compile/ω*
0D
25v compile/try v [source] v "" v #{
23s try
10s source
08i 1 v cadr
08i 1 v compile*
10s source
08i 1 v cddr
08i 1 v compile/do
08i 3 v list
01
}
0Es compile/try
0D
25v compile/return v [source] v "" v #{
10s source
08i 1 v cddr
0Bo 33
05v :arity-error
05v "[return] can only return a single value"
10s source
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
23s return
10s source
08i 1 v cadr
08i 1 v compile*
08i 2 v list
01
}
0Es compile/return
0D
25v compile/if v [source] v "" v #{
10s source
08i 1 v cddddr
0Bo 33
05v :arity-error
05v "[if] can only have 3 arguments"
10s source
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
23s if
10s source
08i 1 v cadr
08i 1 v compile*
10s source
08i 1 v caddr
08i 1 v compile*
10s source
08i 1 v cadddr
08i 1 v compile*
08i 4 v list
01
}
0Es compile/if
0D
25v compile/let* v [source] v "" v #{
23s let*
10s source
12
08i 1 v compile/do
08i 2 v list
01
}
0Es compile/let*
0D
25v compile/map v [source] v "" v #{
10s source
10s compile*
08i 2 v map
01
}
0Es compile/map
0D
25v compile/while v [source] v "" v #{
23s while
10s source
08i 1 v cadr
08i 1 v compile*
10s source
08i 1 v cddr
08i 1 v compile/do
08i 3 v list
01
}
0Es compile/while
0D
25v compile/macro v [macro source] v "" v #{
10s macro
10s source
12
08i 2 v macro-apply
08i 1 v compile*
01
}
0Es compile/macro
0D
25v compile/fold v [op source] v "" v #{
10s source
12
0Bo 96
10s source
08i 1 v cddr
0Bo 48
10s op
10s op
10s source
08i 1 v except-last-pair
08i 2 v compile/fold
10s source
08i 1 v last-pair
11
08i 1 v compile*
08i 3 v list
09o 36
10s op
10s source
11
08i 1 v compile*
10s source
08i 1 v cadr
08i 1 v compile*
08i 3 v list
09o 22
10s op
10s source
11
08i 1 v compile*
08i 2 v list
01
}
0Es compile/fold
0D
25v compile* v [source] v "Expand all macros within source" v #{
10s source
11
10s compile/environment
08i 2 v resolves?
0Bo 20
10s source
11
10s compile/environment
08i 2 v resolve
09o 8
10s source
11
0Es op
0D
15
10s op
08i 1 v type-of
0Es ΓεnΣym-97
0D
10s ΓεnΣym-97
05v :nil
20
0Bo 10
10s source
09o 461
10s ΓεnΣym-97
05v :native-function
20
0Bo 408
15
10s op
0Es ΓεnΣym-98
0D
10s ΓεnΣym-98
10s +
20
0C
0Ao 64
0D
10s ΓεnΣym-98
10s -
20
0C
0Ao 50
0D
10s ΓεnΣym-98
10s *
20
0C
0Ao 36
0D
10s ΓεnΣym-98
10s /
20
0C
0Ao 22
0D
10s ΓεnΣym-98
10s %
20
0C
0Ao 8
0D
05v #f
0Bo 21
10s source
11
10s source
12
08i 2 v compile/fold
09o 299
10s ΓεnΣym-98
10s do
20
0Bo 15
10s source
08i 1 v compile/do
09o 275
10s ΓεnΣym-98
10s def
20
0Bo 15
10s source
08i 1 v compile/def
09o 251
10s ΓεnΣym-98
10s set!
20
0Bo 15
10s source
08i 1 v compile/set!
09o 227
10s ΓεnΣym-98
10s let*
20
0Bo 15
10s source
08i 1 v compile/let*
09o 203
10s ΓεnΣym-98
10s fn*
20
0Bo 15
10s source
08i 1 v compile/fn*
09o 179
10s ΓεnΣym-98
10s macro*
20
0Bo 15
10s source
08i 1 v compile/macro*
09o 155
10s ΓεnΣym-98
10s environment*
20
0Bo 15
10s source
08i 1 v compile/ω*
09o 131
10s ΓεnΣym-98
10s if
20
0Bo 15
10s source
08i 1 v compile/if
09o 107
10s ΓεnΣym-98
10s try
20
0Bo 15
10s source
08i 1 v compile/try
09o 83
10s ΓεnΣym-98
10s while
20
0Bo 15
10s source
08i 1 v compile/while
09o 59
10s ΓεnΣym-98
10s return
20
0Bo 15
10s source
08i 1 v compile/return
09o 35
10s ΓεnΣym-98
10s quote
20
0Bo 10
10s source
09o 16
10s source
10s compile*
08i 2 v map
16
09o 44
10s ΓεnΣym-97
05v :macro
20
0Bo 19
10s op
10s source
08i 2 v compile/macro
09o 16
10s source
10s compile*
08i 2 v map
16
01
}
0Es compile*
0D
25v compile v [source new-environment new-verbose] v "Compile the forms in source" v #{
10s new-environment
0Bo 7
24
09o 12
08i 0 v current-closure
0Fs new-environment
0D
10s new-verbose
0Bo 7
24
09o 11
05v #f
0Fs new-verbose
0D
10s new-environment
0Fs compile/environment
0D
10s new-verbose
0Fs compile/verbose
0D
10s source
08i 1 v compile*
01
}
0Es compile
0D
25v load/forms v [source environment] v "Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" v #{
15
10s source
0Es ΓεnΣym-99
0D
10s ΓεnΣym-99
0Bo 74
02i 0
1B
1C
10s ΓεnΣym-99
0Bo 60
0D
10s ΓεnΣym-99
11
0Es form
0D
10s form
10s environment
08i 2 v compile
08i 1 v bytecompile
08i 1 v assemble*
24
10s environment
08i 3 v bytecode-eval
0D
10s ΓεnΣym-99
12
0Fs ΓεnΣym-99
09o -62
09o 4
24
16
01
}
0Es load/forms
0D
25v compile/forms v [source-raw environment] v "Compile multiple forms, evaluation the results in a temporary environment, so we can make use of macros we just defined" v #{
10s environment
0Bo 7
24
09o 12
15
24
0D
13
16
0Fs environment
0D
10s source-raw
10s environment
08i 2 v load/forms
0D
10s source-raw
10s environment
08i 2 v compile
01
}
0Es compile/forms
0D
26v defmacro v [name args . body] v "Define a new bytecoded macro" v #{
10s body
11
08i 1 v string?
0Bo 11
10s body
11
09o 7
05v ""
0Es doc-string
0D
23s def
10s name
10s macro*
10s name
10s args
10s doc-string
23s do
10s body
14
08i 0 v current-closure
08i 2 v compile
08i 1 v bytecompile
08i 1 v assemble*
08i 5 v list
08i 3 v list
01
}
0Es defmacro
0D
26v macro v [args . body] v "Return a new bytecoded macro" v #{
10s body
11
08i 1 v string?
0Bo 11
10s body
11
09o 7
05v ""
0Es doc-string
0D
10s macro*
24
10s args
10s doc-string
23s do
10s body
14
08i 0 v current-closure
08i 2 v compile
08i 1 v bytecompile
08i 1 v assemble*
08i 5 v list
01
}
0Es macro
0D
26v fn v [args . body] v "Define a λδ with the self-hosting Nujel compiler" v #{
10s body
11
08i 1 v string?
0Bo 11
10s body
11
09o 7
05v ""
0Es doc-string
0D
10s fn*
23s anonymous
10s args
10s doc-string
23s do
10s body
14
08i 0 v current-closure
08i 2 v compile
08i 1 v bytecompile
08i 1 v assemble*
08i 5 v list
01
}
0Es fn
0D
26v defn v [name args . body] v "Define a new bytecoded function" v #{
10s body
11
08i 1 v string?
0Bo 11
10s body
11
09o 7
05v ""
0Es doc-string
0D
23s def
10s name
10s fn*
10s name
10s args
10s doc-string
23s do
10s body
14
08i 0 v current-closure
08i 2 v compile
08i 1 v bytecompile
08i 1 v assemble*
08i 5 v list
08i 3 v list
01
}
0Es defn
0D
26v ω v body v "Defines and returns new object after evaluating body within" v #{
23s ω*
10s body
14
08i 1 v compile
01
}
0Es ω
0D
10s ω
0Es defobj
0D
25v eval-in v [closure expr] v "Compile and the immediatly evaluate the result, mostly used by lRun()" v #{
10s display/error
19o 37
10s expr
10s closure
08i 2 v compile
08i 1 v bytecompile
08i 1 v assemble*
24
10s closure
08i 3 v bytecode-eval
16
01
}
0Es eval-in
0D
25v eval-in/trace v [closure expr] v "Compile and the immediatly evaluate the result, mostly used by lRun()" v #{
10s display/error
19o 61
10s expr
10s closure
08i 2 v compile
08i 1 v bytecompile
08i 1 v assemble*
0Es bc
0D
10s bc
08i 1 v str/write
08i 1 v println
0D
10s bc
24
10s closure
08i 3 v bytecode-eval
16
01
}
0Es eval-in/trace
0D
26v eval v [expr] v "Compile, Evaluate and then return the result of EXPR" v #{
23s eval-in
23s current-closure
24
14
10s expr
24
14
14
14
01
}
0Es eval
0D
26v typecheck/only v [v t] v "" v #{
23s when-not
23s ==
23s type-of
10s v
24
14
14
10s t
24
14
14
14
23s throw
23s list
05v :type-error
05v "Expected a value of type "
10s t
08i 2 v cat
10s v
23s current-lambda
24
14
24
14
14
14
14
14
24
14
14
24
14
14
14
01
}
0Es typecheck/only
0D
25v compile/debug v [expr] v "" v #{
10s expr
08i 1 v compile
08i 1 v bytecompile
08i 1 v assemble*
08i 1 v disassemble
01
}
0Es compile/debug
01
}#{
25v disassemble/length v [op] v "Return the length in bytes of a bytecode operation and all its arguments" v #{
15
10s op
0Es ΓεnΣym-105
0D
10s ΓεnΣym-105
05v #$0
20
0C
0Ao 260
0D
10s ΓεnΣym-105
05v #$1
20
0C
0Ao 246
0D
10s ΓεnΣym-105
05v #$3
20
0C
0Ao 232
0D
10s ΓεnΣym-105
05v #$C
20
0C
0Ao 218
0D
10s ΓεnΣym-105
05v #$D
20
0C
0Ao 204
0D
10s ΓεnΣym-105
05v #$11
20
0C
0Ao 190
0D
10s ΓεnΣym-105
05v #$12
20
0C
0Ao 176
0D
10s ΓεnΣym-105
05v #$13
20
0C
0Ao 162
0D
10s ΓεnΣym-105
05v #$14
20
0C
0Ao 148
0D
10s ΓεnΣym-105
05v #$15
20
0C
0Ao 134
0D
10s ΓεnΣym-105
05v #$16
20
0C
0Ao 120
0D
10s ΓεnΣym-105
05v #$1B
20
0C
0Ao 106
0D
10s ΓεnΣym-105
05v #$1C
20
0C
0Ao 92
0D
10s ΓεnΣym-105
05v #$1E
20
0C
0Ao 78
0D
10s ΓεnΣym-105
05v #$1F
20
0C
0Ao 64
0D
10s ΓεnΣym-105
05v #$20
20
0C
0Ao 50
0D
10s ΓεnΣym-105
05v #$21
20
0C
0Ao 36
0D
10s ΓεnΣym-105
05v #$22
20
0C
0Ao 22
0D
10s ΓεnΣym-105
05v #$24
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 1
09o 314
10s ΓεnΣym-105
05v #$2
20
0C
0Ao 22
0D
10s ΓεnΣym-105
05v #$1A
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 2
09o 274
10s ΓεnΣym-105
05v #$9
20
0C
0Ao 64
0D
10s ΓεnΣym-105
05v #$A
20
0C
0Ao 50
0D
10s ΓεnΣym-105
05v #$B
20
0C
0Ao 36
0D
10s ΓεnΣym-105
05v #$18
20
0C
0Ao 22
0D
10s ΓεnΣym-105
05v #$19
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 3
09o 192
10s ΓεnΣym-105
05v #$5
20
0C
0Ao 64
0D
10s ΓεnΣym-105
05v #$E
20
0C
0Ao 50
0D
10s ΓεnΣym-105
05v #$F
20
0C
0Ao 36
0D
10s ΓεnΣym-105
05v #$10
20
0C
0Ao 22
0D
10s ΓεnΣym-105
05v #$23
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 4
09o 110
10s ΓεnΣym-105
05v #$4
20
0C
0Ao 22
0D
10s ΓεnΣym-105
05v #$8
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 5
09o 70
10s ΓεnΣym-105
05v #$25
20
0C
0Ao 22
0D
10s ΓεnΣym-105
05v #$26
20
0C
0Ao 8
0D
05v #f
0Bo 8
02i 13
09o 30
05v :unknown-op
05v "This op needs its length specified for disassembly to work"
10s op
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es disassemble/length
0D
25v bytecode/nil-catcher v [error] v "" v #{
10s error
11
05v :type-error
20
0Bo 7
24
09o 12
10s error
08i 1 v throw
01
}
0Es bytecode/nil-catcher
0D
25v bytecode-op->val v [a b c] v "Turn three bytecode ops representing an encoded value into an actual value" v #{
10s a
08i 1 v bytecode-op->int
02i 16
08i 2 v ash
10s b
08i 1 v bytecode-op->int
02i 8
08i 2 v ash
10s c
08i 1 v bytecode-op->int
08i 3 v logior
08i 1 v index->val
01
}
0Es bytecode-op->val
0D
25v bytecode-arr->val v [a i] v "Read a bytecode encoded value in A at I and return it" v #{
10s bytecode/nil-catcher
19o 62
10s a
10s i
08i 2 v ref
10s a
02i 1
10s i
08i 2 v +
08i 2 v ref
10s a
02i 2
10s i
08i 2 v +
08i 2 v ref
08i 3 v bytecode-op->val
16
01
}
0Es bytecode-arr->val
0D
25v bytecode-op->sym v [a b c] v "Turn three bytecode ops representing an encoded symbol into an actual symbol" v #{
10s a
08i 1 v bytecode-op->int
02i 16
08i 2 v ash
10s b
08i 1 v bytecode-op->int
02i 8
08i 2 v ash
10s c
08i 1 v bytecode-op->int
08i 3 v logior
08i 1 v index->sym
01
}
0Es bytecode-op->sym
0D
25v bytecode-arr->sym v [a i] v "Read a bytecode encoded symbol in A at I and return it" v #{
10s bytecode/nil-catcher
19o 62
10s a
10s i
08i 2 v ref
10s a
02i 1
10s i
08i 2 v +
08i 2 v ref
10s a
02i 2
10s i
08i 2 v +
08i 2 v ref
08i 3 v bytecode-op->sym
16
01
}
0Es bytecode-arr->sym
0D
25v bytecode-op->offset v [a b] v "Turn two bytecode ops encoding an offset into the integer representation" v #{
10s a
08i 1 v bytecode-op->int
02i 8
08i 2 v ash
10s b
08i 1 v bytecode-op->int
08i 2 v logior
0Es t
0D
10s t
05v 32768
22
0Bo 24
05v 65536
10s t
08i 2 v -
08i 1 v -
09o 7
10s t
01
}
0Es bytecode-op->offset
0D
25v bytecode-arr->offset v [a i] v "Read a bytecode encoded offset in A at I and return it as a signed integer" v #{
10s a
10s i
08i 2 v ref
10s a
02i 1
10s i
08i 2 v +
08i 2 v ref
08i 2 v bytecode-op->offset
01
}
0Es bytecode-arr->offset
0D
25v disassemble/op v [a i] v "Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" v #{
15
10s a
10s i
08i 2 v ref
0Es ΓεnΣym-106
0D
10s ΓεnΣym-106
05v #$0
20
0Bo 10
05v [$nop]
09o 1176
10s ΓεnΣym-106
05v #$1
20
0Bo 10
05v [$ret]
09o 1157
10s ΓεnΣym-106
05v #$2
20
0Bo 38
23s $push/int/byte
10s a
10s i
02i 1
08i 2 v +
08i 2 v ref
08i 1 v bytecode-op->int
24
14
14
09o 1110
10s ΓεnΣym-106
05v #$3
20
0Bo 10
05v [$add/int]
09o 1091
10s ΓεnΣym-106
05v #$4
20
0Bo 10
05v [$debug/print-stack]
09o 1072
10s ΓεnΣym-106
05v #$5
20
0Bo 33
23s $push/lval
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->val
24
14
14
09o 1030
10s ΓεnΣym-106
05v #$8
20
0Bo 59
23s $apply
10s a
10s i
02i 1
08i 2 v +
08i 2 v ref
08i 1 v bytecode-op->int
10s a
10s i
02i 2
08i 2 v +
08i 2 v bytecode-arr->val
24
14
14
14
09o 962
10s ΓεnΣym-106
05v #$9
20
0Bo 33
23s $jmp*
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->offset
24
14
14
09o 920
10s ΓεnΣym-106
05v #$A
20
0Bo 33
23s $jt*
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->offset
24
14
14
09o 878
10s ΓεnΣym-106
05v #$B
20
0Bo 33
23s $jf*
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->offset
24
14
14
09o 836
10s ΓεnΣym-106
05v #$C
20
0Bo 10
05v [$dup]
09o 817
10s ΓεnΣym-106
05v #$D
20
0Bo 10
05v [$drop]
09o 798
10s ΓεnΣym-106
05v #$E
20
0Bo 33
23s $def
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->sym
24
14
14
09o 756
10s ΓεnΣym-106
05v #$F
20
0Bo 33
23s $set
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->sym
24
14
14
09o 714
10s ΓεnΣym-106
05v #$10
20
0Bo 33
23s $get
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->sym
24
14
14
09o 672
10s ΓεnΣym-106
05v #$11
20
0Bo 10
05v [$car]
09o 653
10s ΓεnΣym-106
05v #$12
20
0Bo 10
05v [$cdr]
09o 634
10s ΓεnΣym-106
05v #$13
20
0Bo 10
05v [$closure/push]
09o 615
10s ΓεnΣym-106
05v #$14
20
0Bo 10
05v [$cons]
09o 596
10s ΓεnΣym-106
05v #$15
20
0Bo 10
05v [$let]
09o 577
10s ΓεnΣym-106
05v #$16
20
0Bo 10
05v [$closure/pop]
09o 558
10s ΓεnΣym-106
05v #$18
20
0Bo 33
23s $try/old
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->offset
24
14
14
09o 516
10s ΓεnΣym-106
05v #$19
20
0Bo 33
23s $try
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->offset
24
14
14
09o 474
10s ΓεnΣym-106
05v #$1A
20
0Bo 38
23s $apply/dynamic
10s a
10s i
02i 1
08i 2 v +
08i 2 v ref
08i 1 v bytecode-op->int
24
14
14
09o 427
10s ΓεnΣym-106
05v #$1B
20
0Bo 12
23s $roots/push
24
14
09o 406
10s ΓεnΣym-106
05v #$1C
20
0Bo 12
23s $roots/pop
24
14
09o 385
10s ΓεnΣym-106
05v #$1E
20
0Bo 12
23s $<
24
14
09o 364
10s ΓεnΣym-106
05v #$1F
20
0Bo 12
23s $<=
24
14
09o 343
10s ΓεnΣym-106
05v #$20
20
0Bo 12
23s $==
24
14
09o 322
10s ΓεnΣym-106
05v #$21
20
0Bo 12
23s $>=
24
14
09o 301
10s ΓεnΣym-106
05v #$22
20
0Bo 12
23s $>
24
14
09o 280
10s ΓεnΣym-106
05v #$23
20
0Bo 33
23s $push/symbol
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->sym
24
14
14
09o 238
10s ΓεnΣym-106
05v #$24
20
0Bo 12
23s $push/nil
24
14
09o 217
10s ΓεnΣym-106
05v #$25
20
0Bo 96
23s $fn
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->val
10s a
10s i
02i 4
08i 2 v +
08i 2 v bytecode-arr->val
10s a
10s i
02i 7
08i 2 v +
08i 2 v bytecode-arr->val
10s a
10s i
02i 10
08i 2 v +
08i 2 v bytecode-arr->val
24
14
14
14
14
14
09o 112
10s ΓεnΣym-106
05v #$26
20
0Bo 96
23s $macro*
10s a
10s i
02i 1
08i 2 v +
08i 2 v bytecode-arr->val
10s a
10s i
02i 4
08i 2 v +
08i 2 v bytecode-arr->val
10s a
10s i
02i 7
08i 2 v +
08i 2 v bytecode-arr->val
10s a
10s i
02i 10
08i 2 v +
08i 2 v bytecode-arr->val
24
14
14
14
14
14
09o 7
05v :unknown-op
16
01
}
0Es disassemble/op
0D
25v disassemble/array v [a i] v "Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" v #{
24
0Es ret
0D
02i 0
1B
1C
10s i
10s a
08i 1 v array/length
1E
0Bo 66
0D
10s i
10s a
10s i
08i 2 v disassemble/op
14
10s ret
14
0Fs ret
0D
10s i
10s a
10s i
08i 2 v ref
08i 1 v disassemble/length
08i 2 v +
0Fs i
09o -78
0D
10s ret
08i 1 v nreverse
01
}
0Es disassemble/array
0D
25v disassemble/bytecode-array v [code] v "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," v #{
10s code
08i 1 v bytecode-arr->arr
02i 0
08i 2 v disassemble/array
01
}
0Es disassemble/bytecode-array
0D
25v disassemble/print v [bc] v "" v #{
15
10s bc
08i 1 v disassemble/bytecode-array
0Es ΓεnΣym-107
0D
10s ΓεnΣym-107
0Bo 82
02i 0
1B
1C
10s ΓεnΣym-107
0Bo 68
0D
10s ΓεnΣym-107
11
0Es a
0D
10s a
11
08i 1 v string
02i 6
08i 2 v string/pad-start
08i 1 v ansi-blue
05v " - "
10s a
12
08i 3 v cat
08i 1 v println
0D
10s ΓεnΣym-107
12
0Fs ΓεnΣym-107
09o -70
09o 4
24
16
01
}
0Es disassemble/print
0D
25v disassemble v [bc] v "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," v #{
15
10s bc
08i 1 v type-of
0Es ΓεnΣym-108
0D
10s ΓεnΣym-108
05v :lambda
20
0C
0Ao 22
0D
10s ΓεnΣym-108
05v :macro
20
0C
0Ao 8
0D
05v #f
0Bo 29
10s bc
08i 1 v closure
05v :code
08i 2 v ref
08i 1 v disassemble/print
09o 54
10s ΓεnΣym-108
05v :bytecode-array
20
0Bo 15
10s bc
08i 1 v disassemble/print
09o 30
05v :type-error
05v "Can't disassemble that"
10s bc
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es disassemble
0D
25v disassemble/test v [asm] v "Verbose way of testing the disassembler" v #{
05v "--------- Assembly -----------"
08i 1 v ansi-blue
08i 1 v println
0D
02i 0
0Es cur-line
0D
15
10s asm
0Es ΓεnΣym-109
0D
10s ΓεnΣym-109
0Bo 86
02i 0
1B
1C
10s ΓεnΣym-109
0Bo 72
0D
10s ΓεnΣym-109
11
0Es a
0D
02i 1
10s cur-line
08i 2 v +
0Fs cur-line
02i 6
08i 2 v string/pad-start
08i 1 v ansi-yellow
05v " - "
10s a
08i 3 v cat
08i 1 v println
0D
10s ΓεnΣym-109
12
0Fs ΓεnΣym-109
09o -74
09o 4
24
16
0D
05v "--------- Raw Bytecode -----------"
08i 1 v ansi-yellow
08i 1 v println
0D
10s assemble
10s asm
08i 2 v apply
0Es bc
0D
10s bc
08i 1 v str/write
08i 1 v println
0D
05v "--------- Now for the disassembly -----------"
08i 1 v ansi-green
08i 1 v println
0D
10s bc
08i 1 v disassemble
0D
05v "--------- Fin -----------\n"
08i 1 v ansi-red
08i 1 v println
0D
10s display/error
19o 23
10s bc
08i 1 v bytecode-eval
08i 1 v str/write
08i 1 v println
16
01
}
0Es disassemble/test
01
}#{
24
0Es yield-queue
0D
25v yield v [pred fun] v "Evaluates FUN once PRED is true" v #{
10s pred
10s fun
14
10s yield-queue
14
0Fs yield-queue
0D
05v #t
01
}
0Es yield
0D
25v yield-run v [] v "Executes pending coroutines if their predicate evaluates to #t" v #{
10s yield-queue
0Es old
0D
24
0Fs yield-queue
0D
15
10s old
0Es ΓεnΣym-112
0D
10s ΓεnΣym-112
0Bo 74
02i 0
1B
1C
10s ΓεnΣym-112
0Bo 60
0D
10s ΓεnΣym-112
11
0Es cur
0D
10s cur
11
1Ai 0
0Bo 13
10s cur
12
1Ai 0
09o 16
10s cur
10s yield-queue
14
0Fs yield-queue
0D
10s ΓεnΣym-112
12
0Fs ΓεnΣym-112
09o -62
09o 4
24
16
01
}
0Es yield-run
0D
25v timeout v [milliseconds] v "Returns a function that evaluates to true once MILLISECONDS have passed" v #{
08i 0 v time/milliseconds
10s milliseconds
08i 2 v +
0Es goal
0D
25v anonymous v [] v "" v #{
08i 0 v time/milliseconds
10s goal
22
01
}
01
}
0Es timeout
0D
25v event-bind v [event id handler] v "Bind handler to be evaluated when event-name fires, overwriting whichever handler has been associated with id before." v #{
10s event
10s id
10s handler
08i 3 v tree/set!
01
}
0Es event-bind
0D
26v event-clear v [event] v "Clears all event handlers for event-name" v #{
23s set!
10s event
23s tree/new
24
24
14
14
24
14
14
14
01
}
0Es event-clear
0D
25v event-fire v [event val] v "Applies ...val to all event handlers associated with event-name" v #{
15
10s event
08i 1 v tree/values
0Es ΓεnΣym-113
0D
10s ΓεnΣym-113
0Bo 51
02i 0
1B
1C
10s ΓεnΣym-113
0Bo 37
0D
10s ΓεnΣym-113
11
0Es h
0D
10s h
10s val
1Ai 1
0D
10s ΓεnΣym-113
12
0Fs ΓεnΣym-113
09o -39
09o 4
24
16
01
}
0Es event-fire
01
}#{
25v let/arg v [arg] v "" v #{
10s arg
0Bo 101
10s arg
08i 1 v pair?
08i 1 v not
0C
0Ao 28
0D
10s arg
11
08i 1 v symbol?
08i 1 v not
0C
0Ao 8
0D
05v #f
0Bo 28
05v :invalid-let-form
05v "Please fix the structure of the let form"
10s arg
08i 3 v list
08i 1 v throw
09o 4
24
0D
23s def
10s arg
11
10s arg
08i 1 v cadr
24
14
14
14
09o 4
24
01
}
0Es let/arg
0D
25v let/args v [args] v "" v #{
10s args
0Bo 27
10s args
11
08i 1 v let/arg
10s args
12
08i 1 v let/args
14
09o 4
24
01
}
0Es let/args
0D
26v let v [bindings . body] v "Evalutes to BODY if PRED is true" v #{
23s let*
23s do
10s bindings
08i 1 v let/args
10s body
24
08i 2 v append
08i 2 v append
14
24
14
14
01
}
0Es let
0D
26v if-let v [binding then else] v "" v #{
23s let*
23s def
10s binding
11
10s binding
08i 1 v cadr
24
14
14
14
23s if
10s binding
11
10s then
10s else
24
14
14
14
14
24
14
14
14
01
}
0Es if-let
0D
26v when-let v [binding . body] v "" v #{
23s if-let
10s binding
23s do
10s body
14
24
24
14
14
14
14
01
}
0Es when-let
01
}#{
05v #t
0Es otherwise
0D
26v comment v body v "Does nothing" v #{
24
01
}
0Es comment
0D
26v += v [val inc] v "" v #{
23s set!
10s val
23s +
10s val
10s inc
24
14
14
14
24
14
14
14
01
}
0Es +=
0D
26v cdr! v [l] v "[set! l [cdr l]]" v #{
23s set!
10s l
23s cdr
10s l
24
14
14
24
14
14
14
01
}
0Es cdr!
0D
25v not v [v] v "Return true if V is false" v #{
10s v
0Bo 10
05v #f
09o 7
05v #t
01
}
0Es not
0D
25v identity v [α] v "Returns its argument" v #{
10s α
01
}
0Es identity
0D
25v list v arguments v "Return ARGUMENTS as a list" v #{
10s arguments
01
}
0Es list
0D
25v default v [arg default-value] v "Returns ARG or DEFAULT-VALUE if ARG is #nil" v #{
10s arg
0Bo 10
10s arg
09o 7
10s default-value
01
}
0Es default
0D
25v caar v [p] v "[car [car p]]" v #{
10s p
11
11
01
}
0Es caar
0D
25v cadr v [p] v "[car [cdr p]]" v #{
10s p
12
11
01
}
0Es cadr
0D
25v cdar v [p] v "[cdr [car p]]" v #{
10s p
11
12
01
}
0Es cdar
0D
25v cddr v [p] v "[cdr [cdr p]]" v #{
10s p
12
12
01
}
0Es cddr
0D
25v cadar v [p] v "[cdr [car p]]" v #{
10s p
11
12
11
01
}
0Es cadar
0D
25v caddr v [p] v "[car [cdr [cdr p]]]" v #{
10s p
12
12
11
01
}
0Es caddr
0D
25v cdddr v [p] v "[cdr [cdr [cdr p]]]" v #{
10s p
12
12
12
01
}
0Es cdddr
0D
25v cadddr v [p] v "[car [cdr [cdr [cdr p]]]]" v #{
10s p
12
12
12
11
01
}
0Es cadddr
0D
25v cddddr v [p] v "[car [cdr [cdr [cdr p]]]]" v #{
10s p
12
12
12
12
01
}
0Es cddddr
0D
25v caddddr v [p] v "[car [cdr [cdr [cdr p]]]]" v #{
10s p
12
12
12
12
11
01
}
0Es caddddr
0D
25v cdddddr v [p] v "[cdr [cdr [cdr [cdr p]]]]" v #{
10s p
12
12
12
12
12
01
}
0Es cdddddr
0D
25v keyword->string v [α] v "" v #{
10s α
08i 1 v keyword?
0Bo 7
24
09o 30
05v :type-error
05v "[keyword->string] can only be called on keywords"
10s α
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
10s α
08i 1 v keyword->symbol
08i 1 v sym->str
01
}
0Es keyword->string
0D
25v string->keyword v [α] v "" v #{
10s α
08i 1 v string?
0Bo 7
24
09o 30
05v :type-error
05v "[string->keyword] can only be called on strings"
10s α
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
10s α
08i 1 v str->sym
08i 1 v symbol->keyword
01
}
0Es string->keyword
0D
26v exception v [type description value] v "" v #{
23s throw
23s list
10s type
10s description
10s value
23s current-lambda
24
14
24
14
14
14
14
14
24
14
14
01
}
0Es exception
01
}#{
26v if-not v [pred then else] v "" v #{
23s if
10s pred
10s else
10s then
24
14
14
14
14
01
}
0Es if-not
0D
26v when-not v [pred . body] v "Evalutes to BODY if PRED is false" v #{
23s if
10s pred
24
23s do
10s body
24
08i 2 v append
14
24
14
14
14
14
01
}
0Es when-not
0D
26v when v [pred . body] v "Evalutes to BODY if PRED is true" v #{
23s if
10s pred
23s do
10s body
24
08i 2 v append
14
24
24
14
14
14
14
01
}
0Es when
0D
25v case/clauses/multiple v [key-sym cases] v "" v #{
10s cases
0Bo 39
23s ==
10s key-sym
10s cases
11
08i 3 v list
10s key-sym
10s cases
12
08i 2 v case/clauses/multiple
14
09o 4
24
01
}
0Es case/clauses/multiple
0D
25v case/clauses v [key-sym clauses] v "" v #{
10s clauses
0Bo 229
10s clauses
08i 1 v caar
23s otherwise
20
0Bo 20
23s do
10s clauses
08i 1 v cdar
14
09o 192
23s if
10s clauses
08i 1 v caar
08i 1 v pair?
0Bo 116
10s clauses
08i 1 v caar
11
23s quote
20
0C
0Bo 43
0D
10s clauses
08i 1 v caar
12
08i 1 v last?
0C
0Bo 23
0D
10s clauses
08i 1 v caar
08i 1 v cadr
08i 1 v symbol?
0Bo 28
23s ==
10s key-sym
10s clauses
08i 1 v caar
08i 3 v list
09o 26
23s or
10s key-sym
10s clauses
08i 1 v caar
08i 2 v case/clauses/multiple
14
09o 25
23s ==
10s key-sym
10s clauses
08i 1 v caar
08i 3 v list
23s do
10s clauses
08i 1 v cdar
14
10s key-sym
10s clauses
12
08i 2 v case/clauses
08i 4 v list
09o 4
24
01
}
0Es case/clauses
0D
26v case v [key-form . clauses] v "" v #{
08i 0 v gensym
0Es key-sym
0D
23s let*
23s def
10s key-sym
10s key-form
08i 3 v list
10s key-sym
10s clauses
08i 2 v case/clauses
08i 3 v list
01
}
0Es case
0D
26v cond v body v "Contains multiple cond clauses" v #{
10s body
0C
0Bo 13
0D
10s body
08i 1 v caar
0Bo 52
23s if
10s body
08i 1 v caar
23s do
10s body
08i 1 v cdar
14
10s cond
10s body
12
08i 2 v macro-apply
08i 4 v list
09o 4
24
01
}
0Es cond
0D
26v for v [for-loop . body] v "For loops, [for [name start stop] body]" v #{
10s for-loop
11
0Es symbol-name
0D
10s for-loop
08i 1 v cadr
0Es loop-start
0D
10s for-loop
08i 1 v caddr
0Es loop-stop
0D
08i 0 v gensym
0Es stop-var
0D
02i 1
0Es dir
0D
10s for-loop
08i 1 v cadddr
0Bo 19
10s for-loop
08i 1 v cadddr
0Fs dir
09o 4
24
0D
10s symbol-name
08i 1 v symbol?
0Bo 7
24
09o 25
05v :invalid-for
05v "Expected a symbol name within the for loop"
10s symbol-name
08i 3 v list
08i 1 v throw
0D
10s loop-start
0Bo 7
24
09o 25
05v :invalid-for
05v "Expected a start value at the second position"
10s for-loop
08i 3 v list
08i 1 v throw
0D
10s loop-stop
0Bo 7
24
09o 25
05v :invalid-for
05v "Expected a stop value at the third position"
10s for-loop
08i 3 v list
08i 1 v throw
0D
10s dir
02i 0
22
0Bo 10
10s <
09o 7
10s >
0Es pred
0D
23s let
10s symbol-name
10s loop-start
24
14
14
10s stop-var
10s loop-stop
24
14
14
24
14
14
23s while
10s pred
10s symbol-name
10s stop-var
24
14
14
14
10s body
23s set!
10s symbol-name
23s add/int
10s dir
10s symbol-name
24
14
14
14
24
14
14
14
24
14
08i 2 v append
14
14
24
14
14
14
01
}
0Es for
0D
26v for-in v [for-loop . body] v "[for-in [l [list 1 2 3 4]] [println l]]" v #{
08i 0 v gensym
0Es symbol-name
0D
23s let
10s symbol-name
10s for-loop
08i 1 v cadr
24
14
14
24
14
23s when
10s symbol-name
23s while
10s symbol-name
23s def
10s for-loop
11
23s car
10s symbol-name
24
14
14
24
14
14
14
10s body
23s cdr!
10s symbol-name
24
14
14
24
14
08i 2 v append
14
14
14
24
14
14
14
24
14
14
14
01
}
0Es for-in
0D
25v thread/-> v [init fun] v "" v #{
10s fun
0Bo 86
10s fun
11
08i 1 v pair?
0Bo 46
10s fun
08i 1 v caar
10s init
10s fun
12
08i 2 v thread/->
10s fun
08i 1 v cdar
24
08i 2 v append
14
14
09o 27
10s fun
11
10s init
10s fun
12
08i 2 v thread/->
08i 2 v list
09o 7
10s init
01
}
0Es thread/->
0D
26v -> v [init . fun] v "Thread init as the first argument through every function in fun" v #{
10s init
10s fun
08i 1 v reverse
08i 2 v thread/->
01
}
0Es ->
0D
25v thread/->> v [init fun] v "" v #{
10s fun
0Bo 32
10s fun
11
10s init
10s fun
12
08i 2 v thread/->>
24
14
08i 2 v append
09o 7
10s init
01
}
0Es thread/->>
0D
26v ->> v [init . fun] v "Thread init as the last argument through every function in fun" v #{
10s init
10s fun
08i 1 v reverse
08i 2 v thread/->>
01
}
0Es ->>
01
}#{
25v numeric? v [a] v "Return #t if a is a number" v #{
10s a
08i 1 v int?
0C
0Ao 36
0D
10s a
08i 1 v float?
0C
0Ao 22
0D
10s a
08i 1 v vec?
0C
0Ao 8
0D
05v #f
01
}
0Es numeric?
0D
25v last? v [a] v "Return #t if a is the last pair in a list" v #{
10s a
12
08i 1 v nil?
01
}
0Es last?
0D
25v pos? v [a] v "Return #t if a is positive" v #{
10s a
08i 1 v numeric?
0C
0Bo 18
0D
10s a
08i 1 v float
05v 0.0
21
01
}
0Es pos?
0D
25v zero-neg? v [a] v "Return #t if a is zero or negative" v #{
10s a
08i 1 v numeric?
0C
0Bo 18
0D
10s a
08i 1 v float
05v 0.0
1F
01
}
0Es zero-neg?
0D
25v neg? v [a] v "Returns #t if a is negative" v #{
10s a
08i 1 v numeric?
0C
0Bo 18
0D
10s a
08i 1 v float
05v 0.0
1E
01
}
0Es neg?
0D
25v odd? v [a] v "Predicate that returns #t if a is odd" v #{
10s a
08i 1 v int
02i 2
08i 2 v %
02i 1
20
01
}
0Es odd?
0D
25v even? v [a] v "Predicate that returns #t if a is even" v #{
10s a
08i 1 v int
02i 2
08i 2 v mod/int
02i 0
20
01
}
0Es even?
0D
25v zero? v [val] v "#t if VAL is zero" v #{
02i 0
10s val
20
01
}
0Es zero?
0D
25v not-zero? v [val] v "#t if VAL is not zero" v #{
02i 0
10s val
08i 2 v !=
01
}
0Es not-zero?
0D
25v equal? v [a b] v "High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." v #{
10s a
08i 1 v type-of
0Es cur-type
0D
10s cur-type
10s b
08i 1 v type-of
08i 2 v !=
0Bo 10
05v #f
09o 107
15
10s cur-type
0Es ΓεnΣym-115
0D
10s ΓεnΣym-115
05v :array
20
0Bo 19
10s a
10s b
08i 2 v array/equal?
09o 68
10s ΓεnΣym-115
05v :tree
20
0Bo 19
10s a
10s b
08i 2 v tree/equal?
09o 40
10s ΓεnΣym-115
05v :pair
20
0Bo 19
10s a
10s b
08i 2 v list/equal?
09o 12
10s a
10s b
20
16
01
}
0Es equal?
0D
25v inequal? v [a b] v "High level inequality comparator" v #{
10s a
10s b
08i 2 v equal?
08i 1 v not
01
}
0Es inequal?
0D
25v int? v [val] v "#t if VAL is a integer" v #{
05v :int
10s val
08i 1 v type-of
20
01
}
0Es int?
0D
25v float? v [val] v "#t if VAL is a floating-point number" v #{
05v :float
10s val
08i 1 v type-of
20
01
}
0Es float?
0D
25v vec? v [val] v "#t if VAL is a vector" v #{
05v :vec
10s val
08i 1 v type-of
20
01
}
0Es vec?
0D
25v bool? v [val] v "#t if VAL is a boolean" v #{
05v :bool
10s val
08i 1 v type-of
20
01
}
0Es bool?
0D
25v pair? v [val] v "#t if VAL is a pair" v #{
05v :pair
10s val
08i 1 v type-of
20
01
}
0Es pair?
0D
25v array? v [val] v "#t if VAL is an array" v #{
05v :array
10s val
08i 1 v type-of
20
01
}
0Es array?
0D
25v string? v [val] v "#t if VAL is a string" v #{
05v :string
10s val
08i 1 v type-of
20
01
}
0Es string?
0D
25v symbol? v [val] v "#t if VAL is a symbol" v #{
05v :symbol
10s val
08i 1 v type-of
20
01
}
0Es symbol?
0D
25v object? v [val] v "#t if VAL is an object" v #{
05v :object
10s val
08i 1 v type-of
20
01
}
0Es object?
0D
25v tree? v [val] v "#t if VAL is an object" v #{
05v :tree
10s val
08i 1 v type-of
20
01
}
0Es tree?
0D
25v macro? v [val] v "#t if VAL is an object" v #{
05v :macro
10s val
08i 1 v type-of
20
01
}
0Es macro?
0D
25v lambda? v [val] v "#t if VAL is a lambda" v #{
05v :lambda
10s val
08i 1 v type-of
20
0C
0Ao 8
0D
05v #f
01
}
0Es lambda?
0D
25v native? v [val] v "#t if VAL is a native function" v #{
05v :native-function
10s val
08i 1 v type-of
20
01
}
0Es native?
0D
25v procedure? v [val] v "#t if VAL is a native or lisp function" v #{
10s val
08i 1 v lambda?
0C
0Ao 22
0D
10s val
08i 1 v native?
0C
0Ao 8
0D
05v #f
01
}
0Es procedure?
0D
25v bytecode-array? v [v] v "" v #{
05v :bytecode-array
10s v
08i 1 v type-of
20
01
}
0Es bytecode-array?
0D
25v bytecode-op? v [v] v "" v #{
05v :bytecode-op
10s v
08i 1 v type-of
20
01
}
0Es bytecode-op?
0D
25v in-range? v [v min max] v "" v #{
10s v
10s min
21
0C
0Bo 13
0D
10s v
10s max
1F
01
}
0Es in-range?
01
}#{
25v quasiquote-real v [l depth] v "" v #{
10s l
08i 1 v nil?
0Bo 7
24
09o 372
10s l
08i 1 v pair?
0Bo 313
10s l
08i 1 v caar
23s unquote-splicing
20
0Bo 88
10s depth
08i 1 v zero?
0Bo 39
23s append
10s l
11
08i 1 v cadr
10s l
12
10s depth
08i 2 v quasiquote-real
08i 3 v list
09o 37
23s unquote-splicing
10s l
08i 1 v cadr
02i -1
10s depth
08i 2 v +
08i 2 v quasiquote-real
08i 2 v list
09o 208
10s l
11
23s unquote
20
0Bo 64
10s depth
08i 1 v zero?
0Bo 15
10s l
08i 1 v cadr
09o 37
23s unquote
10s l
08i 1 v cadr
02i -1
10s depth
08i 2 v +
08i 2 v quasiquote-real
08i 2 v list
09o 134
10s l
11
23s quasiquote
20
0Bo 40
10s l
08i 1 v cadr
02i 1
10s depth
08i 2 v +
08i 2 v quasiquote-real
10s depth
08i 2 v quasiquote-real
09o 84
10s depth
08i 1 v zero?
0Bo 43
23s cons
10s l
11
10s depth
08i 2 v quasiquote-real
10s l
12
10s depth
08i 2 v quasiquote-real
08i 3 v list
09o 32
10s l
11
10s depth
08i 2 v quasiquote-real
10s l
12
10s depth
08i 2 v quasiquote-real
14
09o 50
10s depth
08i 1 v zero?
0C
0Bo 13
0D
10s l
08i 1 v symbol?
0Bo 20
23s quote
10s l
08i 1 v cons
14
09o 7
10s l
01
}
0Es quasiquote-real
0D
26v quasiquote v [l] v "" v #{
10s l
02i 0
08i 2 v quasiquote-real
01
}
0Es quasiquote
0D
25v unquote v [expr] v "" v #{
05v :unquote-without-quasiquote
05v "unquote should only occur inside a quasiquote, never evaluated directly"
08i 2 v list
08i 1 v throw
01
}
0Es unquote
0D
25v unquote-splicing v [expr] v "" v #{
05v :unquote-splicing-without-quasiq
05v "unquote-splicing should only occur inside a quasiquote, never evaluated directly"
08i 2 v list
08i 1 v throw
01
}
0Es unquote-splicing
01
}#{
25v describe/closure v [c i] v "" v #{
10s c
0Bo 259
10s c
10s root-closure
20
0Bo 54
10s i
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
08i 1 v int
05v "# <root environment>"
08i 2 v cat
08i 1 v ansi-blue
05v "\r\n"
08i 2 v cat
09o 193
10s c
08i 1 v closure
0Es info
0D
10s info
0Bo 171
10s info
05v :data
08i 2 v ref
0Es data
0D
10s data
08i 1 v length
0Es l
0D
10s i
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
08i 1 v int
05v "# "
10s c
08i 1 v str/write
08i 3 v cat
08i 1 v ansi-blue
05v " - "
10s l
02i 16
1E
0Bo 15
10s data
08i 1 v str/write
09o 7
05v "-+- Very big tree structure -+-"
05v "\r\n"
10s c
08i 1 v closure/caller
10s i
0C
0Ao 15
0D
02i 0
0C
0Ao 8
0D
05v #f
08i 1 v int
02i 1
08i 2 v +
08i 2 v describe/closure
08i 5 v cat
09o 4
24
09o 4
24
01
}
0Es describe/closure
0D
25v stacktrace v [] v "" v #{
08i 0 v current-lambda
08i 1 v closure/caller
08i 1 v describe/closure
08i 1 v display
01
}
0Es stacktrace
01
}#{
25v time/seconds v [timestamp] v "Return the seconds part of TIMESTAMP, defaults to current time" v #{
10s timestamp
08i 0 v time
08i 2 v default
02i 60
08i 2 v %
01
}
0Es time/seconds
0D
25v time/minutes v [timestamp] v "Return the minutes part of TIMESTAMP, defaults to current time" v #{
10s timestamp
08i 0 v time
08i 2 v default
02i 60
08i 2 v /
02i 60
08i 2 v %
01
}
0Es time/minutes
0D
25v time/hours v [timestamp] v "Return the hours part of TIMESTAMP, defaults to current time" v #{
10s timestamp
08i 0 v time
08i 2 v default
05v 3600
08i 2 v /
02i 24
08i 2 v %
01
}
0Es time/hours
0D
25v profile-form v [raw] v "" v #{
08i 0 v time/milliseconds
0Es start-time
0D
08i 0 v current-closure
10s raw
08i 2 v eval-in
0Es val
0D
08i 0 v time/milliseconds
0Es end-time
0D
05v "Evaluating "
10s raw
08i 1 v str/write
08i 1 v ansi-yellow
05v " to "
10s val
08i 1 v str/write
08i 1 v ansi-green
05v " took "
10s end-time
10s start-time
08i 2 v -
05v "ms"
08i 2 v cat
05v "\n"
08i 2 v ansi-red
08i 6 v cat
08i 1 v display
01
}
0Es profile-form
0D
26v profile v body v "Measure and display how much time and ressources it takes for BODY to be evaluated" v #{
23s profile-form
23s quote
10s body
08i 1 v last?
0Bo 11
10s body
11
09o 12
23s do
10s body
14
24
14
14
24
14
14
01
}
0Es profile
01
}#{
25v hash/adler32 v [data] v "" v #{
02i 1
0Es a
0D
02i 0
0Es b
0D
15
02i 0
0Es i
0D
10s data
08i 1 v string/length
0Es ΓεnΣym-117
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-117
1E
0Bo 73
0D
10s a
10s data
10s i
08i 2 v char-at
03
05v 65521
08i 2 v mod/int
0Fs a
0D
10s a
10s b
03
05v 65521
08i 2 v mod/int
0Fs b
0D
02i 1
10s i
03
0Fs i
09o -80
16
0D
10s a
10s b
02i 16
08i 2 v ash
08i 2 v logior
01
}
0Es hash/adler32
01
}#{
05v 3.14159
0Es PI
0D
05v 3.14159
0Es π
0D
26v ++ v [i] v "Increment I by 1 and store the result in I" v #{
23s set!
10s i
23s +
02i 1
10s i
24
14
14
14
24
14
14
14
01
}
0Es ++
0D
26v -- v [i] v "Decrement I by 1 and store the result in I" v #{
23s set!
10s i
23s +
02i -1
10s i
24
14
14
14
24
14
14
14
01
}
0Es --
0D
25v +x v [α] v "Return a function that adds α to it's argument, useful for mapping" v #{
25v anonymous v [β] v "" v #{
10s α
10s β
08i 2 v +
01
}
01
}
0Es +x
0D
25v >> v [val amount] v "Shifts VAL by AMOUNT bits to the right" v #{
10s val
10s amount
08i 1 v -
08i 2 v ash
01
}
0Es >>
0D
25v fib v [i] v "Terribly inefficient, but, useful for testing the GC" v #{
10s i
02i 2
1E
0Bo 10
10s i
09o 40
10s i
02i 2
08i 2 v -
08i 1 v fib
10s i
02i 1
08i 2 v -
08i 1 v fib
08i 2 v +
01
}
0Es fib
0D
25v wrap-value v [val min max] v "Constrains VAL to be within MIN and MAX, wrapping it around" v #{
10s min
10s val
10s min
08i 2 v -
10s max
10s min
08i 2 v -
08i 2 v %
08i 2 v +
01
}
0Es wrap-value
0D
26v +1 v [v] v "" v #{
23s +
02i 1
10s v
24
14
14
14
01
}
0Es +1
0D
25v radians v [degrees] v "Convert a quantity in degrees to radians" v #{
10s π
10s degrees
08i 2 v *
05v 180.0
08i 2 v /
01
}
0Es radians
01
}#{
25v display/error/wrap v [i text] v "" v #{
15
10s i
0Es ΓεnΣym-119
0D
10s ΓεnΣym-119
02i 0
20
0Bo 15
10s text
08i 1 v ansi-red
09o 78
10s ΓεnΣym-119
02i 1
20
0Bo 15
10s text
08i 1 v string
09o 56
10s ΓεnΣym-119
02i 2
20
0Bo 20
10s text
08i 1 v str/write
08i 1 v ansi-yellow
09o 29
10s ΓεnΣym-119
02i 3
20
0Bo 15
10s text
08i 1 v describe/closure
09o 7
10s text
16
01
}
0Es display/error/wrap
0D
25v display/error/iter v [error i] v "" v #{
10s error
0Bo 42
10s i
10s error
11
08i 2 v display/error/wrap
10s error
12
02i 1
10s i
08i 2 v +
08i 2 v display/error/iter
14
09o 9
05v ""
24
14
01
}
0Es display/error/iter
0D
25v display/error v [error] v "Display ERROR in a nice, human readable way" v #{
10s error
02i 0
08i 2 v display/error/iter
05v "\r\n"
08i 2 v join
08i 1 v display
01
}
0Es display/error
0D
25v describe/thing v [o] v "Describe a specific value O" v #{
10s o
08i 1 v closure
0Es doc
0D
10s doc
05v :arguments
08i 2 v ref
08i 1 v str/write
05v " - "
10s doc
05v :documentation
08i 2 v ref
08i 3 v cat
01
}
0Es describe/thing
0D
25v describe/string v [a] v "Descibe whatever value string A resolves to" v #{
10s a
08i 1 v str->sym
08i 1 v resolve
08i 1 v describe/thing
01
}
0Es describe/string
0D
25v describe v [fun] v "Describe FUN, if there is documentation available" v #{
10s fun
08i 1 v string?
0Bo 15
10s fun
08i 1 v describe/string
09o 12
10s fun
08i 1 v describe/thing
01
}
0Es describe
0D
25v symbol-table v [off len environment] v "Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" v #{
10s environment
0Bo 7
24
09o 11
10s root-closure
0Fs environment
0D
10s off
0Bo 7
24
09o 9
02i 0
0Fs off
0D
10s len
0Bo 7
24
09o 11
05v 9999999
0Fs len
0D
10s environment
05v [symbol-table*]
08i 2 v eval-in
10s off
10s off
10s len
08i 2 v +
24
08i 4 v sublist
01
}
0Es symbol-table
0D
02i 0
0Es gensym/counter
0D
25v gensym v [prefix] v "" v #{
02i 1
10s gensym/counter
08i 2 v +
0Fs gensym/counter
0D
10s prefix
05v "ΓεnΣym-"
10s gensym/counter
08i 3 v cat
08i 1 v str->sym
01
}
0Es gensym
0D
08i 0 v current-closure
0Es root-closure
01
}#{
02i 0
0Es random/seed
0D
25v random/seed-initialize! v [] v "" v #{
08i 0 v time
08i 0 v time/milliseconds
08i 2 v logxor
0Fs random/seed
01
}
0Es random/seed-initialize!
0D
25v random/rng! v [] v "" v #{
05v 12345
10s random/seed
05v 1103515245
08i 2 v *
08i 2 v +
0Fs random/seed
0D
10s random/seed
05v 65535
08i 2 v logand
02i 16
08i 2 v ash
10s random/seed
02i -16
08i 2 v ash
05v 65535
08i 2 v logand
08i 2 v logior
01
}
0Es random/rng!
0D
25v random/seed! v [new-seed] v "Set a new seed value for the RNG" v #{
10s new-seed
0Fs seed
01
}
0Es random/seed!
0D
25v random/seed v [] v "Return the current RNG seed value" v #{
10s seed
01
}
0Es random/seed
0D
25v random v [max] v "Return a value from 0 to MAX, or, if left out, a random int" v #{
10s max
08i 1 v numeric?
0Bo 25
08i 0 v random/rng!
08i 1 v abs
10s max
08i 2 v %
09o 8
08i 0 v random/rng!
01
}
0Es random
0D
08i 0 v random/seed-initialize!
01
}#{
25v tree->json v [v] v "Converts a tree into a JSON encoded string, you should prefer VAL->JSON" v #{
05v "{"
10s v
08i 1 v tree/keys
25v anonymous v [k] v "" v #{
05v "\""
10s k
08i 1 v keyword->string
05v "\": "
10s v
10s k
08i 2 v tree/ref
08i 1 v val->json
08i 4 v cat
01
}
08i 2 v map
05v ",\n"
08i 2 v join
05v "}"
08i 3 v cat
01
}
0Es tree->json
0D
25v val->json v [v] v "Return V as a JSON encoded string" v #{
15
10s v
08i 1 v type-of
0Es ΓεnΣym-121
0D
10s ΓεnΣym-121
05v :nil
20
0Bo 10
05v "null"
09o 305
10s ΓεnΣym-121
05v :int
20
0C
0Ao 22
0D
10s ΓεnΣym-121
05v :float
20
0C
0Ao 8
0D
05v #f
0Bo 15
10s v
08i 1 v string
09o 258
10s ΓεnΣym-121
05v :bool
20
0Bo 24
10s v
0Bo 10
05v "true"
09o 7
05v "false"
09o 225
10s ΓεnΣym-121
05v :array
20
0C
0Ao 22
0D
10s ΓεnΣym-121
05v :pair
20
0C
0Ao 8
0D
05v #f
0Bo 41
05v "["
10s v
10s val->json
08i 2 v map
05v ","
08i 2 v join
05v "]"
08i 3 v cat
09o 152
10s ΓεnΣym-121
05v :string
20
0Bo 15
10s v
08i 1 v str/write
09o 128
10s ΓεnΣym-121
05v :symbol
20
0Bo 28
05v "\""
10s v
08i 1 v sym->str
05v "\""
08i 3 v cat
09o 91
10s ΓεnΣym-121
05v :keyword
20
0Bo 28
05v "\""
10s v
08i 1 v keyword->string
05v "\""
08i 3 v cat
09o 54
10s ΓεnΣym-121
05v :tree
20
0Bo 15
10s v
08i 1 v tree->json
09o 30
05v :type-error
05v "Can't encode the value into JSON"
10s v
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es val->json
01
}#{
05v #f
0Es ansi/disabled
0D
05v "\e[0m"
0Es ansi-reset
0D
05v "\e[0;39m"
0Es ansi-fg-reset
0D
05v "\e[49m"
0Es ansi-bg-reset
0D
05v "\e[0;30m"
05v "\e[0;31m"
05v "\e[0;32m"
05v "\e[0;33m"
05v "\e[0;34m"
05v "\e[0;35m"
05v "\e[0;36m"
05v "\e[0;37m"
05v "\e[1;30m"
05v "\e[1;31m"
05v "\e[1;32m"
05v "\e[1;33m"
05v "\e[1;34m"
05v "\e[1;35m"
05v "\e[1;36m"
05v "\e[1;37m"
08i 16 v array/new
0Es ansi-fg
0D
05v "\e[0m"
0Es ansi-reset
0D
05v "\e[40m"
05v "\e[41m"
05v "\e[42m"
05v "\e[43m"
05v "\e[44m"
05v "\e[45m"
05v "\e[46m"
05v "\e[47m"
08i 8 v array/new
0Es ansi-bg
0D
25v ansi-wrap v [code string] v "Wrap STRING in the ansi color CODE" v #{
10s ansi/disabled
0C
0Ao 26
0D
10s ansi-fg
10s code
08i 2 v array/ref
0C
0Ao 8
0D
05v #f
10s string
10s ansi/disabled
0C
0Ao 17
0D
10s ansi-reset
0C
0Ao 8
0D
05v #f
08i 3 v cat
01
}
0Es ansi-wrap
0D
25v ansi-black v args v "Wrap ARGS in black" v #{
02i 0
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-black
0D
25v ansi-dark-red v args v "Wrap ARGS in dark red" v #{
02i 1
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-dark-red
0D
25v ansi-dark-green v args v "Wrap ARGS in dark green" v #{
02i 2
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-dark-green
0D
25v ansi-brown v args v "Wrap ARGS in brown" v #{
02i 3
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-brown
0D
25v ansi-dark-blue v args v "Wrap ARGS in dark blue" v #{
02i 4
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-dark-blue
0D
25v ansi-purple v args v "Wrap ARGS in purple" v #{
02i 5
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-purple
0D
25v ansi-teal v args v "Wrap ARGS in teal" v #{
02i 6
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-teal
0D
25v ansi-dark-gray v args v "Wrap ARGS in dark gray" v #{
02i 7
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-dark-gray
0D
25v ansi-gray v args v "Wrap ARGS in gray" v #{
02i 8
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-gray
0D
25v ansi-red v args v "Wrap ARGS in red" v #{
02i 9
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-red
0D
25v ansi-green v args v "Wrap ARGS in green" v #{
02i 10
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-green
0D
25v ansi-yellow v args v "Wrap ARGS in yellow" v #{
02i 11
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-yellow
0D
25v ansi-blue v args v "Wrap ARGS in blue" v #{
02i 12
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-blue
0D
25v ansi-pink v args v "Wrap ARGS in pink" v #{
02i 13
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-pink
0D
25v ansi-cyan v args v "Wrap ARGS in cyan" v #{
02i 14
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-cyan
0D
25v ansi-white v args v "Wrap ARGS in white" v #{
02i 15
10s cat
10s args
08i 2 v apply
08i 2 v ansi-wrap
01
}
0Es ansi-white
0D
25v ansi-rainbow v args v "Wrap ARGS in the colors of the rainbow!" v #{
15
02i 0
0Es count
0D
10s cat
10s args
08i 2 v apply
05v ""
08i 2 v split
25v anonymous v [a] v "" v #{
02i 1
10s count
08i 2 v +
02i 7
08i 2 v logand
0Fs count
0D
10s ansi/disabled
0C
0Ao 50
0D
10s ansi-fg
10s count
08i 1 v zero?
0Bo 8
02i 7
09o 14
10s count
02i 8
08i 2 v +
08i 2 v array/ref
0C
0Ao 8
0D
05v #f
10s a
08i 2 v cat
01
}
08i 2 v map
05v ""
08i 2 v join
10s ansi/disabled
0C
0Ao 17
0D
10s ansi-fg-reset
0C
0Ao 8
0D
05v #f
08i 2 v cat
16
01
}
0Es ansi-rainbow
0D
25v ansi-rainbow-bg v args v "Wrap ARGS in the colors of the rainbow!" v #{
02i 0
0Es count
0D
10s cat
10s args
08i 2 v apply
05v ""
08i 2 v split
25v anonymous v [a] v "" v #{
02i 1
10s count
08i 2 v +
02i 7
08i 2 v logand
0Fs count
0D
10s ansi/disabled
0C
0Ao 33
0D
10s ansi-fg
10s count
02i 7
08i 2 v logxor
08i 2 v array/ref
0C
0Ao 8
0D
05v #f
10s ansi/disabled
0C
0Ao 26
0D
10s ansi-bg
10s count
08i 2 v array/ref
0C
0Ao 8
0D
05v #f
10s a
08i 3 v cat
01
}
08i 2 v map
0Es colored-list
0D
10s colored-list
05v ""
08i 2 v join
10s ansi/disabled
0C
0Ao 17
0D
10s ansi-reset
0C
0Ao 8
0D
05v #f
08i 2 v cat
01
}
0Es ansi-rainbow-bg
0D
25v reprint-line v [text width] v "" v #{
10s width
0Bo 7
24
09o 9
02i 20
0Fs width
0D
05v "\r"
08i 1 v print
0D
15
02i 0
0Es i
0D
10s width
0Es ΓεnΣym-123
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-123
1E
0Bo 28
0D
05v " "
08i 1 v print
0D
02i 1
10s i
03
0Fs i
09o -35
16
0D
05v "\r"
08i 1 v print
0D
10s text
08i 1 v print
01
}
0Es reprint-line
01
}#{
05v :align
05v :right
05v :debug
05v #f
05v :base
05v #f
05v :width
24
05v :padding-char
05v " "
08i 10 v tree/new
0Es fmt/format-arg/default
0D
25v fmt/find-non-digit-from-right v [s i] v "" v #{
10s i
02i 0
1E
0Bo 8
02i -1
09o 70
10s s
10s i
08i 2 v char-at
0Es char
0D
10s char
02i 48
21
0C
0Bo 11
0D
10s char
02i 57
1F
0Bo 26
10s s
10s i
02i 1
08i 2 v -
08i 2 v fmt/find-non-digit-from-right
09o 7
10s i
01
}
0Es fmt/find-non-digit-from-right
0D
25v fmt/parse-spec v [opts spec] v "" v #{
10s spec
08i 1 v string/length
08i 1 v zero?
0Bo 10
10s opts
09o 978
15
10s spec
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 2 v char-at
0Es ΓεnΣym-132
0D
10s ΓεnΣym-132
02i 48
20
0C
0Ao 116
0D
10s ΓεnΣym-132
02i 49
20
0C
0Ao 104
0D
10s ΓεnΣym-132
02i 50
20
0C
0Ao 92
0D
10s ΓεnΣym-132
02i 51
20
0C
0Ao 80
0D
10s ΓεnΣym-132
02i 52
20
0C
0Ao 68
0D
10s ΓεnΣym-132
02i 53
20
0C
0Ao 56
0D
10s ΓεnΣym-132
02i 54
20
0C
0Ao 44
0D
10s ΓεnΣym-132
02i 55
20
0C
0Ao 32
0D
10s ΓεnΣym-132
02i 56
20
0C
0Ao 20
0D
10s ΓεnΣym-132
02i 57
20
0C
0Ao 8
0D
05v #f
0Bo 163
10s spec
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 2 v fmt/find-non-digit-from-right
0Es next-non-digit
0D
10s spec
02i 1
10s next-non-digit
08i 2 v +
10s spec
08i 1 v string/length
08i 3 v string/cut
0Es number
0D
10s opts
05v :width
10s number
08i 1 v read/single
08i 3 v tree/set!
0D
02i 48
10s number
02i 0
08i 2 v char-at
20
0Bo 23
10s opts
05v :padding-char
05v "0"
08i 3 v tree/set!
09o 4
24
0D
10s opts
10s spec
02i 0
02i 1
10s next-non-digit
08i 2 v +
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 659
10s ΓεnΣym-132
02i 63
20
0Bo 55
10s opts
05v :debug
05v #t
08i 3 v tree/set!
10s spec
02i 0
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 597
10s ΓεnΣym-132
02i 88
20
0Bo 55
10s opts
05v :base
05v :HEXADECIMAL
08i 3 v tree/set!
10s spec
02i 0
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 535
10s ΓεnΣym-132
02i 120
20
0Bo 55
10s opts
05v :base
05v :hexadecimal
08i 3 v tree/set!
10s spec
02i 0
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 473
10s ΓεnΣym-132
02i 100
20
0Bo 55
10s opts
05v :base
05v :decimal
08i 3 v tree/set!
10s spec
02i 0
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 411
10s ΓεnΣym-132
02i 111
20
0Bo 55
10s opts
05v :base
05v :octal
08i 3 v tree/set!
10s spec
02i 0
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 349
10s ΓεnΣym-132
02i 98
20
0Bo 55
10s opts
05v :base
05v :binary
08i 3 v tree/set!
10s spec
02i 0
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 287
10s ΓεnΣym-132
02i 60
20
0Bo 55
10s opts
05v :align
05v :left
08i 3 v tree/set!
10s spec
02i 0
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 225
10s ΓεnΣym-132
02i 94
20
0Bo 55
10s opts
05v :align
05v :center
08i 3 v tree/set!
10s spec
02i 0
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 163
10s ΓεnΣym-132
02i 62
20
0Bo 55
10s opts
05v :align
05v :right
08i 3 v tree/set!
10s spec
02i 0
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 101
10s ΓεnΣym-132
02i 46
20
0Bo 64
10s opts
05v :precision
10s opts
05v :width
08i 2 v tree/ref
08i 3 v tree/set!
10s spec
02i 0
10s spec
08i 1 v string/length
02i 1
08i 2 v -
08i 3 v string/cut
08i 2 v fmt/parse-spec
09o 30
05v :format-error
05v "Unknown form-spec option"
10s spec
08i 0 v current-closure
08i 4 v list
08i 1 v throw
16
01
}
0Es fmt/parse-spec
0D
25v fmt/debug v [opts] v "" v #{
10s opts
05v :debug
08i 2 v tree/ref
0Bo 41
10s opts
05v :argument
10s str/write
10s opts
05v :argument
08i 2 v tree/ref
08i 2 v list
08i 3 v tree/set!
09o 7
10s opts
01
}
0Es fmt/debug
0D
25v fmt/number-format v [opts] v "" v #{
15
10s opts
05v :base
08i 2 v tree/ref
0Es ΓεnΣym-133
0D
10s ΓεnΣym-133
05v :binary
20
0Bo 41
10s opts
05v :argument
10s int->string/binary
10s opts
05v :argument
08i 2 v tree/ref
08i 2 v list
08i 3 v tree/set!
09o 207
10s ΓεnΣym-133
05v :octal
20
0Bo 41
10s opts
05v :argument
10s int->string/octal
10s opts
05v :argument
08i 2 v tree/ref
08i 2 v list
08i 3 v tree/set!
09o 157
10s ΓεnΣym-133
05v :decimal
20
0Bo 41
10s opts
05v :argument
10s int->string/decimal
10s opts
05v :argument
08i 2 v tree/ref
08i 2 v list
08i 3 v tree/set!
09o 107
10s ΓεnΣym-133
05v :hexadecimal
20
0Bo 41
10s opts
05v :argument
10s int->string/hex
10s opts
05v :argument
08i 2 v tree/ref
08i 2 v list
08i 3 v tree/set!
09o 57
10s ΓεnΣym-133
05v :HEXADECIMAL
20
0Bo 41
10s opts
05v :argument
10s int->string/HEX
10s opts
05v :argument
08i 2 v tree/ref
08i 2 v list
08i 3 v tree/set!
09o 7
10s opts
16
01
}
0Es fmt/number-format
0D
05v :binary
05v "#b"
05v :octal
05v "#o"
05v :decimal
05v "#d"
05v :hexadecimal
05v "#x"
05v :HEXADECIMAL
05v "#x"
08i 10 v tree/new
0Es fmt/number-format-prefixex
0D
25v fmt/number-format-prefix v [opts] v "" v #{
10s opts
05v :debug
08i 2 v tree/ref
08i 1 v not
0C
0Ao 31
0D
10s opts
05v :base
08i 2 v tree/ref
08i 1 v not
0C
0Ao 8
0D
05v #f
0Bo 10
10s opts
09o 105
05v [:binary :octal :decimal :hexadecimal :HEXADECIMAL]
10s opts
05v :base
08i 2 v tree/ref
08i 2 v member
0Bo 63
10s opts
05v :argument
10s cat
10s fmt/number-format-prefixex
10s opts
05v :base
08i 2 v tree/ref
08i 2 v tree/ref
10s opts
05v :argument
08i 2 v tree/ref
08i 3 v list
08i 3 v tree/set!
09o 7
10s opts
05v :debug
05v #f
08i 3 v tree/set!
01
}
0Es fmt/number-format-prefix
0D
25v fmt/add-padding v [opts] v "" v #{
10s opts
05v :width
08i 2 v tree/ref
0Bo 198
10s opts
05v :argument
15
10s opts
05v :align
08i 2 v tree/ref
0Es ΓεnΣym-134
0D
10s ΓεnΣym-134
05v :right
20
0Bo 10
10s string/pad-start
09o 42
10s ΓεnΣym-134
05v :center
20
0Bo 10
10s string/pad-middle
09o 23
10s ΓεnΣym-134
05v :left
20
0Bo 10
10s string/pad-end
09o 4
24
16
10s opts
05v :argument
08i 2 v tree/ref
10s opts
05v :debug
08i 2 v tree/ref
0C
0Bo 17
0D
10s opts
05v :base
08i 2 v tree/ref
0Bo 26
10s opts
05v :width
08i 2 v tree/ref
02i 2
08i 2 v -
09o 16
10s opts
05v :width
08i 2 v tree/ref
10s opts
05v :padding-char
08i 2 v tree/ref
08i 4 v list
08i 3 v tree/set!
09o 7
10s opts
01
}
0Es fmt/add-padding
0D
25v fmt/precision v [opts] v "" v #{
10s opts
05v :precision
08i 2 v tree/ref
0Bo 54
10s opts
05v :argument
10s string/round
10s opts
05v :argument
08i 2 v tree/ref
10s opts
05v :precision
08i 2 v tree/ref
08i 3 v list
08i 3 v tree/set!
09o 7
10s opts
01
}
0Es fmt/precision
0D
25v fmt/truncate v [opts] v "" v #{
10s opts
05v :width
08i 2 v tree/ref
0Bo 63
10s opts
05v :argument
10s string/cut
10s opts
05v :argument
08i 2 v tree/ref
02i 0
02i 1
10s opts
05v :width
08i 2 v tree/ref
08i 2 v +
08i 4 v list
08i 3 v tree/set!
09o 7
10s opts
01
}
0Es fmt/truncate
0D
25v fmt/output v [opts] v "" v #{
10s opts
05v :argument
08i 2 v tree/ref
01
}
0Es fmt/output
0D
25v fmt/format-arg v [spec argument] v "" v #{
10s fmt/format-arg/default
08i 1 v tree/dup
10s spec
08i 2 v fmt/parse-spec
05v :argument
10s argument
08i 3 v tree/set!
08i 1 v fmt/number-format
08i 1 v fmt/precision
08i 1 v fmt/add-padding
08i 1 v fmt/truncate
08i 1 v fmt/number-format-prefix
08i 1 v fmt/debug
08i 1 v fmt/output
01
}
0Es fmt/format-arg
0D
25v fmt/valid-argument? v [argument] v "" v #{
10s argument
08i 1 v int?
0C
0Ao 22
0D
10s argument
08i 1 v symbol?
0C
0Ao 8
0D
05v #f
01
}
0Es fmt/valid-argument?
0D
25v fmt/arg-sym v [v] v "" v #{
15
10s v
08i 1 v type-of
0Es ΓεnΣym-135
0D
10s ΓεnΣym-135
05v :int
20
0Bo 29
05v "fmt-arg-"
10s v
08i 1 v string
08i 2 v cat
08i 1 v fmt/arg-sym
09o 73
10s ΓεnΣym-135
05v :symbol
20
0Bo 10
10s v
09o 54
10s ΓεnΣym-135
05v :string
20
0Bo 15
10s v
08i 1 v str->sym
09o 30
05v :type-error
05v "Invalid fmt argument name"
10s v
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
16
01
}
0Es fmt/arg-sym
0D
25v fmt/expr v [expr arguments-used opts] v "" v #{
10s expr
08i 1 v string?
0Bo 7
24
09o 30
05v :format-error
05v "fmt needs a string literal as a first argument, since it is implemented as a macro"
10s expr
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
10s expr
05v ":"
08i 2 v split
0Es split-expr
0D
10s split-expr
11
0Es argument
0D
10s split-expr
08i 1 v cadr
0C
0Ao 17
0D
05v ""
0C
0Ao 8
0D
05v #f
0Es format-spec
0D
05v ""
10s argument
20
0Bo 81
10s opts
05v :expr-count
02i 1
08i 1 v -
08i 3 v tree/+=
0D
10s arguments-used
10s opts
05v :expr-count
08i 2 v tree/ref
05v #t
08i 3 v array/set!
0D
10s format-spec
10s opts
05v :expr-count
08i 2 v tree/ref
08i 1 v fmt/arg-sym
08i 2 v fmt/format-arg
09o 231
15
10s argument
08i 1 v read
0Es read-vals
0D
10s read-vals
12
0Bo 33
05v :format-error
05v "Format argument specifier contains more than a single atom"
10s argument
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
10s read-vals
11
08i 1 v fmt/valid-argument?
0Bo 7
24
09o 30
05v :format-error
05v "Format argument specifier should be either an integer or a symbol"
10s argument
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
10s read-vals
11
08i 1 v int?
0Bo 96
10s read-vals
11
02i 0
1E
0C
0Ao 28
0D
10s read-vals
11
10s arguments-used
08i 1 v array/length
21
0C
0Ao 8
0D
05v #f
0Bo 33
05v :format-error
05v "fmt numbered argument is out of bounds"
10s argument
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
10s arguments-used
10s read-vals
11
05v #t
08i 3 v array/set!
09o 4
24
0D
10s format-spec
10s read-vals
11
08i 1 v fmt/arg-sym
08i 2 v fmt/format-arg
16
01
}
0Es fmt/expr
0D
26v fmt v [format-string . args] v "Return a formatted string" v #{
10s format-string
08i 1 v string?
0Bo 7
24
09o 30
05v :type-error
05v "fmt needs a string literal as a first argument, since it is implemented as a macro"
10s format-string
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
24
0Es cuts
0D
15
02i 0
0Es i
0D
10s format-string
08i 1 v string/length
0Es ΓεnΣym-136
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-136
1E
0Bo 189
0D
15
10s format-string
10s i
08i 2 v char-at
0Es ΓεnΣym-137
0D
10s ΓεnΣym-137
02i 123
20
0Bo 64
10s cuts
11
08i 1 v int?
0Bo 33
05v :format-error
05v "fmt placeholders can't be nested"
10s format-string
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
10s i
10s cuts
14
0Fs cuts
09o 82
10s ΓεnΣym-137
02i 125
20
0Bo 71
10s cuts
11
08i 1 v int?
0Bo 7
24
09o 30
05v :format-error
05v "fmt expects all brackets to be closed"
10s format-string
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
10s cuts
11
10s i
14
10s cuts
12
14
0Fs cuts
09o 4
24
16
0D
02i 1
10s i
03
0Fs i
09o -196
16
0D
10s cuts
11
08i 1 v int?
0Bo 33
05v :format-error
05v "fmt placeholders can't be nested"
10s format-string
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
24
0Es expr-list
0D
10s format-string
08i 1 v string/length
0Es last-pos
0D
10s args
08i 1 v length
08i 1 v array/allocate
05v #f
08i 2 v array/fill!
0Es arguments-used
0D
05v :expr-count
10s arguments-used
08i 1 v array/length
08i 2 v tree/new
0Es opts
0D
15
10s cuts
0Es ΓεnΣym-138
0D
10s ΓεnΣym-138
0Bo 168
02i 0
1B
1C
10s ΓεnΣym-138
0Bo 154
0D
10s ΓεnΣym-138
11
0Es c
0D
10s format-string
10s c
12
02i 1
08i 2 v +
10s last-pos
08i 3 v string/cut
0Es lit
0D
05v ""
10s lit
20
0Bo 7
24
09o 16
10s lit
10s expr-list
14
0Fs expr-list
0D
10s format-string
02i 1
10s c
11
08i 2 v +
10s c
12
08i 3 v string/cut
10s arguments-used
10s opts
08i 3 v fmt/expr
0Es expr
0D
10s expr
10s expr-list
14
0Fs expr-list
0D
10s c
11
0Fs last-pos
0D
10s ΓεnΣym-138
12
0Fs ΓεnΣym-138
09o -156
09o 4
24
16
0D
10s last-pos
02i 0
22
0Bo 39
10s format-string
02i 0
10s last-pos
08i 3 v string/cut
0Es lit
0D
10s lit
10s expr-list
14
0Fs expr-list
09o 4
24
0D
15
02i 0
0Es i
0D
10s arguments-used
08i 1 v array/length
0Es ΓεnΣym-139
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-139
1E
0Bo 84
0D
10s arguments-used
10s i
08i 2 v array/ref
0Bo 7
24
09o 48
05v :format-error
05v "fmt expects all arguments to be used"
10s format-string
10s args
10s i
08i 2 v list/ref
08i 2 v list
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
02i 1
10s i
03
0Fs i
09o -91
16
0D
10s expr-list
12
0Bo 15
23s cat
10s expr-list
14
09o 33
10s expr-list
11
08i 1 v string?
0Bo 11
10s expr-list
11
09o 12
23s string
10s expr-list
14
0Es expr
0D
02i 0
0Es fmt/args/map-fun/count
0D
25v fmt/args/map-fun v [arg] v "" v #{
05v "fmt-arg-"
10s fmt/args/map-fun/count
08i 1 v string
08i 2 v cat
08i 1 v str->sym
0Es s
0D
02i 1
10s fmt/args/map-fun/count
08i 2 v +
0Fs fmt/args/map-fun/count
0D
23s def
10s s
10s arg
08i 3 v list
01
}
0Es fmt/args/map-fun
0D
10s args
0Bo 35
23s let*
10s args
10s fmt/args/map-fun
08i 2 v map
10s expr
24
14
08i 2 v append
14
09o 7
10s expr
01
}
0Es fmt
0D
26v pfmt v [format-string . args] v "Print a formatted string" v #{
23s print
23s fmt
10s format-string
10s args
24
08i 2 v append
14
14
24
14
14
01
}
0Es pfmt
0D
26v efmt v [format-string . args] v "Print a formatted string" v #{
23s error
23s fmt
10s format-string
10s args
24
08i 2 v append
14
14
24
14
14
01
}
0Es efmt
0D
26v pfmtln v [format-string . args] v "Print a formatted string" v #{
23s println
23s fmt
10s format-string
10s args
24
08i 2 v append
14
14
24
14
14
01
}
0Es pfmtln
0D
26v efmtln v [format-string . args] v "Print a formatted string" v #{
23s errorln
23s fmt
10s format-string
10s args
24
08i 2 v append
14
14
24
14
14
01
}
0Es efmtln
01
}#{
25v string->keyword v [α] v "Return string α as a keyword" v #{
10s α
08i 1 v str->sym
08i 1 v symbol->keyword
01
}
0Es string->keyword
0D
25v string->byte-array v [a] v "Turn a string into an UTF-8 encoded byte array" v #{
10s a
08i 1 v string/length
08i 1 v array/allocate
0Es ret
0D
15
02i 0
0Es i
0D
10s a
08i 1 v string/length
0Es ΓεnΣym-143
0D
02i 0
1B
1C
10s i
10s ΓεnΣym-143
1E
0Bo 45
0D
10s ret
10s i
10s a
10s i
08i 2 v char-at
08i 3 v array/set!
0D
02i 1
10s i
03
0Fs i
09o -52
16
0D
10s ret
01
}
0Es string->byte-array
0D
25v println v [str] v "Print STR on a single line" v #{
10s str
05v "\r\n"
08i 2 v cat
08i 1 v print
01
}
0Es println
0D
25v errorln v [str] v "Print to stderr STR on a single line" v #{
10s str
05v "\r\n"
08i 2 v cat
08i 1 v error
01
}
0Es errorln
0D
25v display v [value] v "Display VALUE" v #{
10s value
08i 1 v print
01
}
0Es display
0D
25v newline v [] v "Print a single line feed character" v #{
05v "\r\n"
08i 1 v display
01
}
0Es newline
0D
25v br v [num] v "Return NUM=1 linebreaks" v #{
10s num
08i 1 v nil?
0C
0Ao 25
0D
10s num
08i 1 v int
02i 1
1F
0C
0Ao 8
0D
05v #f
0Bo 10
05v "\n"
09o 28
05v "\n"
02i -1
10s num
08i 2 v +
08i 1 v br
08i 2 v cat
01
}
0Es br
0D
25v path/ext?! v [ext] v "Return a predicate that checks if a path ends on EXT" v #{
15
10s ext
08i 1 v type-of
0Es ΓεnΣym-144
0D
10s ΓεnΣym-144
05v :string
20
0Bo 19
25v anonymous v [path] v "" v #{
10s ext
10s path
08i 1 v path/extension
08i 1 v lowercase
20
01
}
09o 53
10s ΓεnΣym-144
05v :pair
20
0Bo 19
25v anonymous v [path] v "" v #{
10s path
08i 1 v path/extension
08i 1 v lowercase
0Es cext
0D
10s ext
25v anonymous v [α β] v "" v #{
10s α
0C
0Ao 22
0D
10s β
10s cext
20
0C
0Ao 8
0D
05v #f
01
}
08i 2 v reduce
01
}
09o 25
05v :type-error
05v "Expected a :string or :list"
10s ext
08i 3 v list
08i 1 v throw
16
01
}
0Es path/ext?!
0D
25v path/extension v [path] v "Return the extension of PATH" v #{
10s path
05v "."
08i 2 v last-index-of
0Es last-period
0D
10s last-period
02i 0
21
0Bo 35
10s path
02i 1
10s last-period
08i 2 v +
10s path
08i 1 v string/length
08i 3 v string/cut
09o 7
10s path
01
}
0Es path/extension
0D
25v path/without-extension v [path] v "Return PATH, but without the extension part" v #{
10s path
05v "."
08i 2 v last-index-of
0Es last-period
0D
10s last-period
02i 0
21
0Bo 21
10s path
02i 0
10s last-period
08i 3 v string/cut
09o 7
10s path
01
}
0Es path/without-extension
0D
25v int->string/binary v [α] v "Turn α into a its **binary** string representation" v #{
05v ""
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
10s α
08i 1 v zero?
0Bo 14
05v "0"
0Fs ret
09o 4
24
0D
02i 0
1B
1C
10s α
08i 1 v not-zero?
0Bo 59
0D
02i 48
10s α
02i 1
08i 2 v logand
08i 2 v +
08i 1 v from-char-code
10s ret
08i 2 v cat
0Fs ret
0D
10s α
02i -1
08i 2 v ash
0Fs α
09o -66
0D
10s ret
01
}
0Es int->string/binary
0D
25v int->string/octal v [α] v "Turn α into a its **octal** string representation" v #{
05v ""
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
10s α
08i 1 v zero?
0Bo 14
05v "0"
0Fs ret
09o 4
24
0D
02i 0
1B
1C
10s α
08i 1 v not-zero?
0Bo 59
0D
02i 48
10s α
02i 7
08i 2 v logand
08i 2 v +
08i 1 v from-char-code
10s ret
08i 2 v cat
0Fs ret
0D
10s α
02i -3
08i 2 v ash
0Fs α
09o -66
0D
10s ret
01
}
0Es int->string/octal
0D
05v "0"
05v "1"
05v "2"
05v "3"
05v "4"
05v "5"
05v "6"
05v "7"
05v "8"
05v "9"
05v "A"
05v "B"
05v "C"
05v "D"
05v "E"
05v "F"
08i 16 v array/new
0Es int->string/hex/conversion-arr
0D
25v int->string/HEX v [α] v "Turn α into a its **hexadecimal** string representation" v #{
05v ""
0Es ret
0D
10s α
0Bo 7
24
09o 9
02i 0
0Es α
0D
10s α
08i 1 v zero?
0Bo 14
05v "0"
0Fs ret
09o 4
24
0D
10s α
02i 0
1E
0Bo 33
05v :type-error
05v "Can't print negative numbers in hex for now"
10s α
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
09o 4
24
0D
02i 0
1B
1C
10s α
08i 1 v not-zero?
0Bo 56
0D
10s int->string/hex/conversion-arr
10s α
02i 15
08i 2 v logand
08i 2 v array/ref
10s ret
08i 2 v cat
0Fs ret
0D
10s α
02i -4
08i 2 v ash
0Fs α
09o -63
0D
10s ret
01
}
0Es int->string/HEX
0D
25v int->string/hex v [α] v "Turn α into a its **hexadecimal** string representation" v #{
10s α
08i 1 v int->string/HEX
08i 1 v lowercase
01
}
0Es int->string/hex
0D
25v int->string/decimal v [α] v "Turn α into a its **decimal** string representation" v #{
10s α
08i 1 v string
01
}
0Es int->string/decimal
0D
10s int->string/decimal
0Es int->string
0D
25v string/pad-start v [text goal-length char] v "Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" v #{
10s char
0Bo 7
24
09o 11
05v " "
0Fs char
0D
10s text
08i 1 v string?
0Bo 7
24
09o 16
10s text
08i 1 v string
0Fs text
0D
10s char
08i 1 v string?
0Bo 7
24
09o 30
05v :type-error
05v "string/pad-start needs char as a string, so that one can pad with multiple characters"
10s char
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
02i 0
1B
1C
10s text
08i 1 v string/length
10s goal-length
1E
0Bo 24
0D
10s char
10s text
08i 2 v cat
0Fs text
09o -36
0D
10s text
08i 1 v string/length
10s goal-length
22
0Bo 42
10s text
10s text
08i 1 v string/length
10s goal-length
08i 2 v -
10s text
08i 1 v string/length
08i 3 v string/cut
09o 7
10s text
01
}
0Es string/pad-start
0D
25v string/pad-end v [text goal-length char] v "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" v #{
10s char
0Bo 7
24
09o 11
05v " "
0Fs char
0D
10s text
08i 1 v string?
0Bo 7
24
09o 16
10s text
08i 1 v string
0Fs text
0D
10s char
08i 1 v string?
0Bo 7
24
09o 30
05v :type-error
05v "string/pad-start needs char as a string, so that one can pad with multiple characters"
10s char
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
02i 0
1B
1C
10s text
08i 1 v string/length
10s goal-length
1E
0Bo 24
0D
10s text
10s char
08i 2 v cat
0Fs text
09o -36
0D
10s text
08i 1 v string/length
10s goal-length
22
0Bo 21
10s text
02i 0
10s goal-length
08i 3 v string/cut
09o 7
10s text
01
}
0Es string/pad-end
0D
25v string/pad-middle v [text goal-length char] v "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" v #{
10s char
0Bo 7
24
09o 11
05v " "
0Fs char
0D
10s text
08i 1 v string?
0Bo 7
24
09o 16
10s text
08i 1 v string
0Fs text
0D
10s char
08i 1 v string?
0Bo 7
24
09o 30
05v :type-error
05v "string/pad-middle needs char as a string, so that one can pad with multiple characters"
10s char
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
02i 0
1B
1C
10s text
08i 1 v string/length
10s goal-length
1E
0Bo 28
0D
10s char
10s text
10s char
08i 3 v cat
0Fs text
09o -40
0D
10s text
08i 1 v string/length
10s goal-length
22
0Bo 96
15
10s text
08i 1 v string/length
10s goal-length
08i 2 v -
02i 2
08i 2 v /
0Es end-overflow
0D
10s text
08i 1 v string/length
10s goal-length
08i 2 v -
10s end-overflow
08i 2 v -
0Es start-overflow
0D
10s text
10s start-overflow
10s start-overflow
10s goal-length
08i 2 v +
08i 3 v string/cut
16
09o 7
10s text
01
}
0Es string/pad-middle
0D
25v string/round v [text decimal-digits] v "Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" v #{
10s text
05v "."
08i 2 v last-index-of
0Es pos
0D
10s pos
02i 0
21
0Bo 37
10s text
02i 0
10s pos
02i 1
08i 2 v +
10s decimal-digits
08i 2 v +
08i 3 v string/cut
09o 7
10s text
01
}
0Es string/round
0D
25v split/empty v [str separator] v "" v #{
10s str
08i 1 v string/length
0Es slen
0D
02i 0
0Es start
0D
24
0Es ret
0D
02i 0
1B
1C
10s start
10s slen
1E
0Bo 56
0D
10s str
10s start
02i 1
10s start
08i 2 v +
08i 3 v string/cut
10s ret
14
0Fs ret
0D
02i 1
10s start
08i 2 v +
0Fs start
09o -63
0D
10s ret
08i 1 v reverse
01
}
0Es split/empty
0D
25v split/string v [str separator start] v "" v #{
10s start
0Bo 7
24
09o 9
02i 0
0Fs start
0D
10s str
10s separator
10s start
08i 3 v index-of
0Es pos-found
0D
10s pos-found
02i 0
21
0Bo 55
10s str
10s start
10s pos-found
08i 3 v string/cut
10s str
10s separator
10s pos-found
10s separator
08i 1 v string/length
08i 2 v +
08i 3 v split/string
14
09o 27
10s str
10s start
10s str
08i 1 v string/length
08i 3 v string/cut
24
14
01
}
0Es split/string
0D
25v split v [str separator] v "Splits STR into a list at every occurunse of SEPARATOR" v #{
10s str
08i 1 v type-of
05v :string
20
0Bo 7
24
09o 30
05v :type-error
05v "Expected a value of type :string"
10s str
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
10s separator
08i 1 v type-of
05v :string
20
0Bo 7
24
09o 30
05v :type-error
05v "Expected a value of type :string"
10s separator
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
15
10s separator
08i 1 v string/length
0Es ΓεnΣym-145
0D
10s ΓεnΣym-145
02i 0
20
0Bo 15
10s str
08i 1 v split/empty
09o 18
10s str
10s separator
02i 0
08i 3 v split/string
16
01
}
0Es split
0D
25v read/single v [text] v "Uses the reader and returns the first single value read from string TEXT" v #{
10s text
08i 1 v type-of
05v :string
20
0Bo 7
24
09o 30
05v :type-error
05v "Expected a value of type :string"
10s text
08i 0 v current-lambda
08i 4 v list
08i 1 v throw
0D
10s text
08i 1 v read
11
01
}
0Es read/single
0D
25v read/int v [text] v "Reads the first string from TEXT" v #{
10s text
08i 1 v read/single
08i 1 v int
01
}
0Es read/int
0D
25v read/float v [text] v "Reads the first float from TEXT" v #{
10s text
08i 1 v read/single
08i 1 v float
01
}
0Es read/float
0D
25v string/length?! v [chars] v "" v #{
25v anonymous v [a] v "" v #{
10s chars
10s a
08i 1 v string/length
20
01
}
01
}
0Es string/length?!
0D
25v contains-any? v [str chars] v "" v #{
10s or
10s chars
05v ""
08i 2 v split
25v anonymous v [a] v "" v #{
10s str
10s a
08i 2 v index-of
02i 0
21
01
}
08i 2 v map
08i 2 v apply
01
}
0Es contains-any?
0D
25v contains-all? v [str chars] v "" v #{
10s and
10s chars
05v ""
08i 2 v split
25v anonymous v [a] v "" v #{
10s str
10s a
08i 2 v index-of
02i 0
21
01
}
08i 2 v map
08i 2 v apply
01
}
0Es contains-all?
01
}#{
05v "Nujel"
0Es test-context
0D
25v test/reset v [] v "" v #{
24
0Fs test-list
0D
02i 0
0Fs test-count
0D
02i 4
05v [do [+ 3 1]]
08i 2 v test/add*
01
}
0Es test/reset
0D
24
0Es test-list
0D
02i 0
0Es test-count
0D
02i 0
0Es nujel-start
0D
02i 0
0Es success-count
0D
02i 0
0Es error-count
0D
05v #t
0Es print-errors
0D
05v #f
0Es print-passes
0D
25v test/add* v [result expr] v "" v #{
10s result
10s expr
14
10s test-list
14
0Fs test-list
0D
10s test-count
02i 1
08i 2 v +
0Fs test-count
01
}
0Es test/add*
0D
26v test/add v [result . expr] v "Add a test where EXPR must eval to RESULT" v #{
23s test/add*
10s result
23s quote
23s do
10s expr
14
08i 2 v list
24
14
14
14
01
}
0Es test/add
0D
25v display-results v [] v "Prints the result Message" v #{
08i 0 v random/seed-initialize!
0D
15
10s error-count
08i 1 v zero?
0C
0Bo 11
0D
10s test-count
02i 0
22
0Bo 10
05v "Success"
09o 7
05v "Failed!"
0Es fmt-arg-0
0D
10s success-count
08i 1 v ansi-green
0Es fmt-arg-1
0D
10s error-count
08i 1 v ansi-red
0Es fmt-arg-2
0D
08i 0 v time/milliseconds
10s nujel-start
08i 2 v -
0Es fmt-arg-3
0D
10s error-count
08i 1 v zero?
0C
0Bo 11
0D
10s test-count
02i 0
22
0Bo 15
05v "Everything is working, very nice!"
08i 1 v ansi-rainbow
09o 12
05v "Better fix those!"
08i 1 v ansi-red
0Es fmt-arg-4
0D
10s test-context
05v " ["
10s System/OS
05v " "
10s System/Architecture
05v "] - "
10s fmt-arg-0
05v " - ["
10s fmt-arg-1
05v " / "
10s fmt-arg-2
05v "] in "
10s fmt-arg-3
05v " ms - "
10s fmt-arg-4
08i 15 v cat
16
08i 1 v errorln
01
}
0Es display-results
0D
25v test-success v [res-should res-is expr i] v "Should be called after a test has finished successfully" v #{
10s print-passes
0Bo 94
15
10s res-is
08i 1 v str/write
08i 1 v ansi-green
0Es fmt-arg-0
0D
10s res-should
08i 1 v str/write
08i 1 v ansi-green
0Es fmt-arg-1
0D
10s expr
08i 1 v str/write
0Es fmt-arg-2
0D
10s fmt-arg-0
05v " == "
10s fmt-arg-1
05v "\r\n"
10s fmt-arg-2
05v "\r\n\r\n"
08i 6 v cat
16
08i 1 v errorln
09o 4
24
0D
02i 1
10s success-count
08i 2 v +
0Fs success-count
01
}
0Es test-success
0D
25v test-failure v [res-should res-is expr i] v "Should be called if EXPR does not equal RES" v #{
10s print-errors
0Bo 94
15
10s res-is
08i 1 v str/write
08i 1 v ansi-red
0Es fmt-arg-0
0D
10s res-should
08i 1 v str/write
08i 1 v ansi-green
0Es fmt-arg-1
0D
10s expr
08i 1 v str/write
0Es fmt-arg-2
0D
10s fmt-arg-0
05v " != "
10s fmt-arg-1
05v "\r\n"
10s fmt-arg-2
05v "\r\n\r\n"
08i 6 v cat
16
08i 1 v println
09o 4
24
0D
02i 1
10s error-count
08i 2 v +
0Fs error-count
01
}
0Es test-failure
0D
25v test-default v [result rawexpr i] v "Tests that RAWEXPR evaluates to RESULT" v #{
25v anonymous v [err] v "" v #{
10s err
08i 1 v display/error
0D
10s result
05v :exception-caught
10s err
08i 2 v list
10s rawexpr
10s i
08i 4 v test-failure
01
}
19o 84
08i 0 v current-closure
10s rawexpr
08i 2 v eval-in
0Es expr
0D
10s result
10s expr
08i 2 v equal?
0Bo 27
10s result
10s expr
10s rawexpr
10s i
08i 4 v test-success
09o 24
10s result
10s expr
10s rawexpr
10s i
08i 4 v test-failure
16
01
}
0Es test-default
0D
25v test-run-real v [test] v "" v #{
08i 0 v time/milliseconds
0Fs nujel-start
0D
02i 0
0Fs success-count
0D
02i 0
0Fs error-count
0D
10s test-count
02i 1
08i 2 v +
0Es i
0D
15
10s test-list
0Es ΓεnΣym-147
0D
10s ΓεnΣym-147
0Bo 72
02i 0
1B
1C
10s ΓεnΣym-147
0Bo 58
0D
10s ΓεnΣym-147
11
0Es cur-test
0D
10s test
10s cur-test
11
10s cur-test
12
02i -1
10s i
08i 2 v +
0Fs i
1Ai 3
0D
10s ΓεnΣym-147
12
0Fs ΓεnΣym-147
09o -60
09o 4
24
16
0D
08i 0 v display-results
0D
10s error-count
01
}
0Es test-run-real
0D
25v test-run v [output-passes hide-errors] v "Run through all automated Tests" v #{
10s hide-errors
08i 1 v bool
08i 1 v not
0Fs print-errors
0D
10s output-passes
08i 1 v bool
0Fs print-passes
0D
10s test-default
08i 1 v test-run-real
01
}
0Es test-run
0D
08i 0 v test/reset
01
}