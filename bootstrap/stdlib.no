#{##[bit-nand l #@[documentation: "Returns the Nand of its arguments" source: ["Returns the Nand of its arguments" [bit-not [apply bit-and l]]]] #{##[bit-not apply bit-and l]
1A00051A01051A02051A03050402040101
} lognand bit-and-not [x y] #@[documentation: "Bitwise and with complement" source: ["Bitwise and with complement" [bit-and x [bit-not y]]]] #{##[bit-and x bit-not y]
1A00051A01051A02051A03050401040201
} bit-test? [α i] #@[documentation: "Test bit at position i" source: ["Test bit at position i" [typecheck/only α :int] [typecheck/only i :int] [not [zero? [bit-and α [bit-shift-left 1 i]]]]]] #{##[type-of α :int throw list :type-error "Expected a value of type :int" current-lambda i bit-and bit-shift-left #f #t]
1A00051A010504011A02200B0007240900191A03051A04051A051A061A01051A
07050400040404010D1A00051A080504011A02200B0007240900191A03051A04
051A051A061A08051A07050400040404010D1A09051A01051A0A0502011A0805
040204022A0B00081A0B0900051A0C01
} bit-set? bit-shift-right [α i] #@[documentation: "Bitwise shift right" source: ["Bitwise shift right" [bit-shift-left α [- i]]]] #{##[bit-shift-left α - i]
1A00051A01051A02051A03050401040201
} bit-set [x i] #@[documentation: "Set bit at i" source: ["Set bit at i" [bit-or x [bit-shift-left 1 i]]]] #{##[bit-or x bit-shift-left i]
1A00051A01051A020502011A03050402040201
} bit-flip [x i] #@[documentation: "Flip bit at i" source: ["Flip bit at i" [bit-xor x [bit-shift-left 1 i]]]] #{##[bit-xor x bit-shift-left i]
1A00051A01051A020502011A03050402040201
} bit-clear [x i] #@[documentation: "Clear bit at i" source: ["Clear bit at i" [bit-and x [bit-not [bit-shift-left 1 i]]]]] #{##[bit-and x bit-not bit-shift-left i]
1A00051A01051A02051A030502011A040504020401040201
}]
1A001A011A021A03171A00070D1A00051A04070D1A051A061A071A08171A0507
0D1A091A0A1A0B1A0C171A09070D1A09051A0D070D1A0E1A0F1A101A11171A0E
070D1A121A131A141A15171A12070D1A161A171A181A19171A16070D1A1A1A1B
1A1C1A1D171A1A0701
}#{##[array/+= [a i v] #@[documentation: "Add V to the value in A at position I and store the result in A returning A" source: ["Add V to the value in A at position I and store the result in A returning A" [array/set! a i [+ v [array/ref a i]]]]] #{##[array/set! a i v array/ref]
1A00051A01051A02051A03051A04051A01051A0205040225040301
} array/++ [a i] #@[documentation: "Increment position I in A and return A" source: ["Increment position I in A and return A" [array/+= a i 1]]] #{##[array/+= a i]
1A00051A01051A02050201040301
} array/fill! [a v] #@[documentation: "Fills array a with value v" source: ["Fills array a with value v" [def len [array/length a]] [dotimes [i len] [array/set! a i v]] [return a]]] #{##[array/length a len i array/set! v]
1A00051A010504011A02070D1502001A03070D241B09001D0D1C1A04051A0105
1A03051A050504030D02011A0305031A03081A03051A02051E0AFFDF0D24160D
1A01050101
} array/append [a b] #@[documentation: "Append array A to array B" source: ["Append array A to array B" [when-not [and [array? a] [array? b]] [throw [list :type-error "array/append expects two arrays as its arguments" #nil [current-lambda]]]] [def ret [array/allocate [+ [array/length a] [array/length b]]]] [dotimes [i [array/length a]] [array/set! ret i [array/ref a i]]] [let [[i [array/length a]] [rl [array/length ret]]] [while [< i rl] [array/set! ret i [array/ref b [- i [array/length a]]]] [set! i [add/int i 1]]]] [return ret]]] #{##[array? a b throw list :type-error "array/append expects two arrays as its arguments" current-lambda array/allocate array/length ret i array/set! array/ref rl]
1A00051A010504010C0B000C0D1A00051A020504010B0007240900171A03051A
04051A051A06241A07050400040404010D1A08051A09051A010504011A09051A
020504012504011A0A070D1502001A0B070D241B0900250D1C1A0C051A0A051A
0B051A0D051A01051A0B05040204030D02011A0B05031A0B081A0B051A09051A
010504011E0AFFD20D24160D151A09051A010504011A0B070D1A09051A0A0504
011A0E070D241B09002E0D1C1A0C051A0A051A0B051A0D051A02051A0B051A09
051A0105040126040204030D1A0B050201031A0B081A0B051A0E051E0AFFCE16
0D1A0A050101
} array/dup [a] #@[documentation: "Duplicate Array A" source: ["Duplicate Array A" [def ret [array/allocate [array/length a]]] [dotimes [i [array/length a]] [array/set! ret i [array/ref a i]]] [return ret]]] #{##[array/allocate array/length a ret i array/set! array/ref]
1A00051A01051A0205040104011A03070D1502001A04070D241B0900250D1C1A
05051A03051A04051A06051A02051A0405040204030D02011A0405031A04081A
04051A01051A020504011E0AFFD20D24160D1A03050101
} array/reduce [arr fun α] #@[documentation: "Reduce an array, [reduce] should be preferred" source: ["Reduce an array, [reduce] should be preferred" [def len [array/length arr]] [dotimes [i len] [set! α [fun α [array/ref arr i]]]] [return α]]] #{##[array/length arr len i fun α array/ref]
1A00051A010504011A02070D1502001A03070D241B0900250D1C1A04051A0505
1A06051A01051A0305040204021A05080D02011A0305031A03081A03051A0205
1E0AFFD70D24160D1A05050101
} array/map [arr fun] #@[documentation: "Map an array, [map] should be preferred" source: ["Map an array, [map] should be preferred" [def len [array/length arr]] [dotimes [i len] [array/set! arr i [fun [array/ref arr i]]]] [return arr]]] #{##[array/length arr len i array/set! fun array/ref]
1A00051A010504011A02070D1502001A03070D241B09002A0D1C1A04051A0105
1A03051A05051A06051A01051A03050402040104030D02011A0305031A03081A
03051A02051E0AFFD20D24160D1A01050101
} array/filter [arr pred] #@[documentation: "Filter an array, [filter] should be preferred" source: ["Filter an array, [filter] should be preferred" [def ri 0] [def len [array/length arr]] [def ret [array/allocate len]] [dotimes [ai len] [when [pred [array/ref arr ai]] [array/set! ret ri [array/ref arr ai]] [inc! ri]]] [array/length! ret ri]]] #{##[ri array/length arr len array/allocate ret ai pred array/ref array/set! array/length!]
02001A00070D1A01051A020504011A03070D1A04051A030504011A05070D1502
001A06070D241B0900460D1C1A07051A08051A02051A0605040204010B00261A
09051A05051A00051A08051A02051A0605040204030D1A00050201251A000809
0004240D02011A0605031A06081A06051A03051E0AFFB60D24160D1A0A051A05
051A0005040201
} array/equal? [a b] #@[source: [[if [or [not [array? a]] [not [array? b]] [not= [array/length a] [array/length b]]] [return #f] [let [[ret #t]] [dotimes [i [array/length a]] [when-not [equal? [array/ref a i] [array/ref b i]] [set! ret #f] [set! i [array/length a]]]] [return ret]]]]] #{##[array? a #f #t b not= array/length ret i equal? array/ref]
1A00051A010504010B00081A020900051A030C0A00370D1A00051A040504010B
00081A020900051A030C0A00200D1A05051A06051A010504011A06051A040504
0104020C0A00060D1A020B00091A020109006D151A031A07070D1502001A0807
0D241B0900420D1C1A09051A0A051A01051A080504021A0A051A04051A080504
0204020B0007240900141A021A07080D1A06051A010504011A08080D02011A08
05031A08081A08051A06051A010504011E0AFFB50D24160D1A0705011601
} array/push [arr val] #@[documentation: "Append VAL to ARR" source: ["Append VAL to ARR" [-> arr [array/length! [+ 1 [array/length arr]]] [array/set! [- [array/length arr] 1] val]]]] #{##[array/set! array/length! arr array/length val]
1A00051A01051A020502011A03051A020504012504021A03051A020504010201
261A0405040301
} array/swap [arr i j] #@[documentation: "Swap values at I and J in ARR" source: ["Swap values at I and J in ARR" [def tmp [array/ref arr i]] [-> arr [array/set! i [array/ref arr j]] [array/set! j tmp]]]] #{##[array/ref arr i tmp array/set! j]
1A00051A01051A020504021A03070D1A04051A04051A01051A02051A00051A01
051A0505040204031A05051A0305040301
} array/heapify [arr n at] #@[documentation: "bubble up the element from index AT to until the max-heap property is satisfied" source: ["bubble up the element from index AT to until the max-heap property is satisfied" [def top at] [def looping #t] [while looping [def l [+ [bit-shift-left at 1] 1]] [def r [+ [bit-shift-left at 1] 2]] [when [and [< l n] [> [array/ref arr l] [array/ref arr top]]] [set! top l]] [when [and [< r n] [> [array/ref arr r] [array/ref arr top]]] [set! top r]] [if [= top at] [set! looping #f] [do [array/swap arr at top] [set! at top]]]] [return arr]]] #{##[at top #t looping bit-shift-left l r n array/ref arr #f array/swap]
1A00051A01070D1A021A03070D241B0900B00D1C1A04051A0005020104020201
251A05070D1A04051A0005020104020202251A06070D1A05051A07051E0C0B00
1B0D1A08051A09051A050504021A08051A09051A01050402220B000C1A05051A
0108090004240D1A06051A07051E0C0B001B0D1A08051A09051A060504021A08
051A09051A01050402220B000C1A06051A0108090004240D1A01051A0005200B
000B1A0A1A03080900181A0B051A09051A00051A010504030D1A01051A00081A
03050AFF500D1A09050101
} array/make-heap [arr] #@[source: [[def l [array/length arr]] [def l2 [/ l 2]] [while [>= l2 0] [array/heapify arr l l2] [dec! l2]] [return arr]]] #{##[array/length arr l l2 array/heapify]
1A00051A010504011A02070D1A02050202281A03070D241B09001D0D1C1A0405
1A01051A02051A030504030D1A03050201261A03081A03050200210AFFE00D1A
01050101
} array/heap-sort [arr] #@[source: [[array/make-heap arr] [def l [array/length arr]] [while [> l 0] [dec! l] [array/swap arr 0 l] [array/heapify arr l 0]] [return arr]]] #{##[array/make-heap arr array/length l array/swap array/heapify]
1A00051A010504010D1A02051A010504011A03070D241B09002A0D1C1A030502
01261A03080D1A04051A010502001A030504030D1A05051A01051A0305020004
031A03050200220AFFD30D1A01050101
} array/sort array/cut [arr start end] #@[documentation: "Return a newly allocated array with the values of ARR from START to END" source: ["Return a newly allocated array with the values of ARR from START to END" [set! start [max 0 start]] [set! end [min [array/length arr] end]] [def ret [array/allocate [max 0 [- end start]]]] [def i start] [while [< i end] [array/set! ret [- i start] [array/ref arr i]] [set! i [add/int i 1]]] [return ret]]] #{##[max start min array/length arr end array/allocate ret i array/set! array/ref]
1A000502001A010504021A01080D1A02051A03051A040504011A050504021A05
080D1A06051A000502001A05051A010526040204011A07070D1A01051A08070D
241B0900290D1C1A09051A07051A08051A0105261A0A051A04051A0805040204
030D1A08050201031A08081A08051A05051E0AFFD30D1A07050101
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A14070D1A181A191A1A1A1B171A18070D1A1C1A1D1A
1E1A1F171A1C070D1A201A211A221A23171A20070D1A241A251A261A27171A24
070D1A281A291A2A1A2B171A28070D1A2C1A2D1A2E1A2F171A2C070D1A301A31
1A321A33171A30070D1A341A351A361A37171A34070D1A34051A38070D1A391A
3A1A3B1A3C171A390701
}#{##[sum [c] #@[documentation: "Return the sum of every value in collection C" source: ["Return the sum of every value in collection C" [reduce c + 0]]] #{##[reduce c +]
1A00051A01051A02050200040301
} every? [l p] #@[documentation: "Returns #t if P is true for every entry of collection L" source: ["Returns #t if P is true for every entry of collection L" [reduce l [fn [a b] [and a [p b]]] #t]]] #{##[reduce l anonymous [a b] #@[source: [[and a [p b]]]] #{##[a p b]
1A00050C0B000C0D1A01051A0205040101
} #t]
1A00051A01051A021A031A041A05171A06040301
} join [l glue] #@[documentation: "Join every element of α together into a string with GLUE inbetween" source: ["Join every element of α together into a string with GLUE inbetween" [when-not glue [set! glue ""]] [if-not l "" [reduce l [fn [a b] [if a [cat a glue b] b]] #nil]]]] #{##[glue "" l reduce anonymous [a b] #@[source: [[if a [cat a glue b] b]]] #{##[a cat glue b]
1A00050B00141A01051A00051A02051A030504030900061A030501
}]
1A00050B0007240900081A011A00080D1A02050B00181A03051A02051A041A05
1A061A07172404030900051A0101
} for-each [l f] #@[documentation: "Runs F over every item in collection L" source: ["Runs F over every item in collection L" [reduce l [fn [a b] [f b]] #nil]]] #{##[reduce l anonymous [a b] #@[source: [[f b]]] #{##[f b]
1A00051A0105040101
}]
1A00051A01051A021A031A041A051724040301
} count [l p] #@[documentation: "Count the number of items in L where P is true" source: ["Count the number of items in L where P is true" [if p [reduce l [fn [a b] [+ a [if [p b] 1 0]]] 0] [reduce l [fn [a b] [+ a 1]] 0]]]] #{##[p reduce l anonymous [a b] #@[source: [[+ a [if [p b] 1 0]]]] #{##[a p b]
1A00051A01051A020504010B0008020109000502002501
} [a b] #@[source: [[+ a 1]]] #{##[a]
1A000502012501
}]
1A00050B00191A01051A02051A031A041A051A0617020004030900161A01051A
02051A031A071A081A09170200040301
} min l #@[documentation: "Returns the minimum value of its arguments, or collection" source: ["Returns the minimum value of its arguments, or collection" [reduce [if [cdr l] l [car l]] [fn [a b] [if [< a b] a b]]]]] #{##[reduce l anonymous [a b] #@[source: [[if [< a b] a b]]] #{##[a b]
1A00051A01051E0B00091A00050900061A010501
}]
1A00051A0105120B00091A01050900071A0105111A021A031A041A0517040201
} max #@[documentation: "Returns the minimum value of its arguments, or collection" source: ["Returns the minimum value of its arguments, or collection" [reduce [if [cdr l] l [car l]] [fn [a b] [if [> a b] a b]]]]] #{##[reduce l anonymous [a b] #@[source: [[if [> a b] a b]]] #{##[a b]
1A00051A0105220B00091A00050900061A010501
}]
1A00051A0105120B00091A01050900071A0105111A021A031A041A0517040201
} delete [l e] #@[documentation: "Returns a filtered list l with all elements equal to e omitted" source: ["Returns a filtered list l with all elements equal to e omitted" [filter l [fn [a] [not [= a e]]]]]] #{##[filter l anonymous [a] #@[source: [[not [= a e]]]] #{##[a e #f #t]
1A00051A0105200B00081A020900051A0301
}]
1A00051A01051A021A031A041A0517040201
} remove [l p] #@[documentation: "Returns a filtered list l with all elements where P equal true removed" source: ["Returns a filtered list l with all elements where P equal true removed" [filter l [fn [a] [not [p a]]]]]] #{##[filter l anonymous [a] #@[source: [[not [p a]]]] #{##[p a #f #t]
1A00051A010504010B00081A020900051A0301
}]
1A00051A01051A021A031A041A0517040201
} flatten/λ [a b] #@[source: [[cond [[collection? b] [append [reduce b flatten/λ #nil] a]] [#t [cons b a]]]]] #{##[collection? b append reduce flatten/λ a #t]
1A00051A010504010B001A1A02051A03051A01051A04052404031A0505040209
00131A060B000D1A01051A0505140900042401
} flatten [l] #@[documentation: "Flatten a collection of collections into a simple list" source: ["Flatten a collection of collections into a simple list" [if-not [collection? l] l [nreverse [reduce l flatten/λ #nil]]]]] #{##[collection? l nreverse reduce flatten/λ]
1A00051A010504010B00171A02051A03051A01051A040524040304010900061A
010501
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A14070D1A181A151A191A1A171A18070D1A1B1A1C1A
1D1A1E171A1B070D1A1F1A201A211A22171A1F070D1A231A241A251A26171A23
070D1A271A281A291A2A171A270701
}#{##[ref [l i] #@[documentation: "Return whatver is at position I in L" source: ["Return whatver is at position I in L" [case [type-of l] [:nil #nil] [:tree [tree/ref l i]] [:string [char-at l i]] [:array [array/ref l i]] [:pair [list/ref l i]] [otherwise [throw [list :type-error "You can only use ref with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-1 :nil :tree tree/ref i :string char-at :array array/ref :pair list/ref throw list :type-error "You can only use ref with a collection" current-lambda]
151A00051A010504011A02070D1A02051A03200B0007240900751A02051A0420
0B00111A05051A01051A0605040209005E1A02051A07200B00111A08051A0105
1A060504020900471A02051A09200B00111A0A051A01051A060504020900301A
02051A0B200B00111A0C051A01051A060504020900191A0D051A0E051A0F1A10
1A01051A11050400040404011601
} filter [l p] #@[documentation: "Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" source: ["Runs predicate p over every item in collection l and returns a list consiting solely of items where p is true" [case [type-of l] [:nil #nil] [:tree [tree/filter l p]] [:pair [list/filter l p]] [:array [array/filter l p]] [otherwise [throw [list :type-error "You can only use filter with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-2 :nil :tree tree/filter p :pair list/filter :array array/filter throw list :type-error "You can only use filter with a collection" current-lambda]
151A00051A010504011A02070D1A02051A03200B00072409005E1A02051A0420
0B00111A05051A01051A060504020900471A02051A07200B00111A08051A0105
1A060504020900301A02051A09200B00111A0A051A01051A060504020900191A
0B051A0C051A0D1A0E1A01051A0F050400040404011601
} reduce [l f α] #@[documentation: "Combine all elements in collection l using operation F and starting value α" source: ["Combine all elements in collection l using operation F and starting value α" [case [type-of l] [:nil α] [:tree [tree/reduce l f α]] [:pair [list/reduce l f α]] [:array [array/reduce l f α]] [otherwise [f α l]]]]] #{##[type-of l ΓεnΣym-3 :nil α :tree tree/reduce f :pair list/reduce :array array/reduce]
151A00051A010504011A02070D1A02051A03200B00091A040509005C1A02051A
05200B00141A06051A01051A07051A040504030900421A02051A08200B00141A
09051A01051A07051A040504030900281A02051A0A200B00141A0B051A01051A
07051A0405040309000E1A07051A04051A010504021601
} length [α] #@[documentation: "Returns the length of collection α" source: ["Returns the length of collection α" [case [type-of α] [:nil 0] [:array [array/length α]] [:pair [list/length α]] [:string [string/length α]] [:tree [tree/size α]] [otherwise [throw [list :type-error "You can only use length with a collection" α [current-lambda]]]]]]] #{##[type-of α ΓεnΣym-4 :nil :array array/length :pair list/length :string string/length :tree tree/size throw list :type-error "You can only use length with a collection" current-lambda]
151A00051A010504011A02070D1A02051A03200B000802000900691A02051A04
200B000E1A05051A010504010900551A02051A06200B000E1A07051A01050401
0900411A02051A08200B000E1A09051A0105040109002D1A02051A0A200B000E
1A0B051A010504010900191A0C051A0D051A0E1A0F1A01051A10050400040404
011601
} map [l f] #@[documentation: "Runs f over every item in collection l and returns the resulting list" source: ["Runs f over every item in collection l and returns the resulting list" [case [type-of l] [:nil #nil] [:pair [list/map l f]] [:array [array/map l f]] [otherwise [throw [list :type-error "You can only use map with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-5 :nil :pair list/map f :array array/map throw list :type-error "You can only use map with a collection" current-lambda]
151A00051A010504011A02070D1A02051A03200B0007240900471A02051A0420
0B00111A05051A01051A060504020900301A02051A07200B00111A08051A0105
1A060504020900191A09051A0A051A0B1A0C1A01051A0D050400040404011601
} sort [l] #@[documentation: "Sorts the collection L" source: ["Sorts the collection L" [case [type-of l] [:nil #nil] [:pair [list/sort l]] [:array [array/sort l]] [otherwise [throw [list :type-error "You can only use sort with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-6 :nil :pair list/sort :array array/sort throw list :type-error "You can only use sort with a collection" current-lambda]
151A00051A010504011A02070D1A02051A03200B0007240900411A02051A0420
0B000E1A05051A0105040109002D1A02051A06200B000E1A07051A0105040109
00191A08051A09051A0A1A0B1A01051A0C050400040404011601
} member [l m] #@[documentation: "Returns the first pair/item of collection l whose car is equal to m" source: ["Returns the first pair/item of collection l whose car is equal to m" [case [type-of l] [:pair [list/member l m]] [otherwise [throw [list :type-error "You can only use member with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-7 :pair list/member m throw list :type-error "You can only use member with a collection" current-lambda]
151A00051A010504011A02070D1A02051A03200B00111A04051A01051A050504
020900191A06051A07051A081A091A01051A0A050400040404011601
} cut [l start end] #@[documentation: "Return a subcollection of L from START to END" source: ["Return a subcollection of L from START to END" [case [type-of l] [:array [array/cut l start end]] [:pair [list/cut l start end]] [:string [string/cut l start end]] [otherwise [throw [list :type-error "You can only use member with a collection" l [current-lambda]]]]]]] #{##[type-of l ΓεnΣym-8 :array array/cut start end :pair list/cut :string string/cut throw list :type-error "You can only use member with a collection" current-lambda]
151A00051A010504011A02070D1A02051A03200B00141A04051A01051A05051A
0605040309004D1A02051A07200B00141A08051A01051A05051A060504030900
331A02051A09200B00141A0A051A01051A05051A060504030900191A0B051A0C
051A0D1A0E1A01051A0F050400040404011601
} collection? [l] #@[source: [[case [type-of l] [[:pair :array :tree] #t] [otherwise #f]]]] #{##[type-of l ΓεnΣym-9 :pair :array :tree #f #t]
151A00051A010504011A02070D1A02051A03200C0A001C0D1A02051A04200C0A
00110D1A02051A05200C0A00060D1A060B00081A070900051A061601
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A14070D1A181A191A1A1A1B171A18070D1A1C1A1D1A
1E1A1F171A1C070D1A201A211A221A23171A200701
}#{##[array->list [arr] #@[source: [[def i [- [array/length arr] 1]] [def ret #nil] [while [>= i 0] [set! ret [cons [array/ref arr i] ret]] [dec! i]] [return ret]]] #{##[array/length arr i ret array/ref]
1A00051A010504010201261A02070D241A03070D241B0900210D1C1A04051A01
051A020504021A0305141A03080D1A02050201261A02081A02050200210AFFDC
0D1A03050101
} except-last-pair/iter [list rest] #@[documentation: "Iterator for except-last-pair" source: ["Iterator for except-last-pair" [if [nil? [cdr list]] [reverse rest] [except-last-pair/iter [cdr list] [cons [car list] rest]]]]] #{##[nil? list reverse rest except-last-pair/iter]
1A00051A01051204010B000E1A02051A030504010900141A04051A0105121A01
05111A030514040201
} except-last-pair [list] #@[documentation: "Return a copy of LIST without the last pair" source: ["Return a copy of LIST without the last pair" [except-last-pair/iter list #nil]]] #{##[except-last-pair/iter list]
1A00051A010524040201
} last-pair [list] #@[documentation: "Return the last pair of LIST" source: ["Return the last pair of LIST" [while [cdr list] [cdr! list]] list]] #{##[list]
241B09000C0D1C1A0005121A00081A0005120AFFF30D1A000501
} make-list [number value] #@[documentation: "Return a list of NUMBER elements containing VALUE in every car" source: ["Return a list of NUMBER elements containing VALUE in every car" [def list #nil] [while [>= [dec! number] 0] [set! list [cons value list]]] list]] #{##[list value number]
241A00070D241B09000F0D1C1A01051A0005141A00081A02050201261A020802
00210AFFE80D1A000501
} range [end start step] #@[documentation: "Return a list containing values from START (inclusive) to END (exclusive) by STEP" source: ["Return a list containing values from START (inclusive) to END (exclusive) by STEP" [when-not end [throw [list :arity-error "[range] needs at least a specific end"]]] [when-not start [set! start 0]] [when-not step [set! step 1]] [def pred [if [pos? step] < >]] [def ret #nil] [while [pred start end] [set! ret [cons start ret]] [set! start [+ start step]]] [nreverse ret]]] #{##[end throw list :arity-error "[range] needs at least a specific end" start step 0.0 < > pred ret nreverse]
1A00050B0007240900111A01051A02051A031A04040204010D1A05050B000724
09000802001A05080D1A06050B00072409000802011A06080D1A06051A07210B
00091A08050900061A09051A0A070D241A0B070D241B09001A0D1C1A05051A0B
05141A0B080D1A05051A0605251A05081A0A051A05051A000504020AFFDE0D1A
0C051A0B05040101
} list/reduce [l o s] #@[documentation: "Combine all elements in l using operation o and starting value s" source: ["Combine all elements in l using operation o and starting value s" [doseq [e l] [set! s [o s e]]] s]] #{##[l ΓεnΣym-1 e o s]
151A00051A01070D1A01050B0031241B0900230D1C1A0105111A02070D1A0305
1A04051A020504021A04080D1A0105121A01081A01050AFFDD09000424160D1A
040501
} list/ref [l i] #@[documentation: "Returns the the element of list l at location i" source: ["Returns the the element of list l at location i" [while [and l [> i 0]] [dec! i] [cdr! l]] [car l]]] #{##[i l]
241B0900160D1C1A00050201261A00080D1A0105121A01081A01050C0B000A0D
1A00050200220AFFDF0D1A01051101
} reverse [l] #@[documentation: "Return the list l in reverse order" source: ["Return the list l in reverse order" [def ret] [doseq [e l] [set! ret [cons e ret]]] ret]] #{##[ret l ΓεnΣym-2 e]
241A00070D151A01051A02070D1A02050B002D241B09001F0D1C1A0205111A03
070D1A03051A0005141A00080D1A0205121A02081A02050AFFE109000424160D
1A000501
} list/length [l] #@[documentation: "Returns the length of list l" source: ["Returns the length of list l" [def ret 0] [doseq [e l] [inc! ret]] ret]] #{##[ret l ΓεnΣym-3 e]
02001A00070D151A01051A02070D1A02050B002C241B09001E0D1C1A0205111A
03070D1A00050201251A00080D1A0205121A02081A02050AFFE209000424160D
1A000501
} list/filter [l p] #@[documentation: "Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" source: ["Runs predicate p over every item in list l and returns a list consiting solely of items where p is true" [def ret #nil] [doseq [e l] [when [p e] [set! ret [cons e ret]]]] [nreverse ret]]] #{##[ret l ΓεnΣym-4 e p nreverse]
241A00070D151A01051A02070D1A02050B003C241B09002E0D1C1A0205111A03
070D1A04051A030504010B00101A03051A0005141A0008090004240D1A020512
1A02081A02050AFFD209000424160D1A05051A0005040101
} list/map [l f] #@[documentation: "Runs f over every item in list l and returns the resulting list" source: ["Runs f over every item in list l and returns the resulting list" [def ret #nil] [doseq [e l] [set! ret [cons [f e] ret]]] [nreverse ret]]] #{##[ret l ΓεnΣym-5 e f nreverse]
241A00070D151A01051A02070D1A02050B0032241B0900240D1C1A0205111A03
070D1A04051A030504011A0005141A00080D1A0205121A02081A02050AFFDC09
000424160D1A05051A0005040101
} append [a b] #@[documentation: "Appends two lists A and B together" source: ["Appends two lists A and B together" [def ret b] [set! a [reverse a]] [doseq [t a] [set! ret [cons t ret]]] ret]] #{##[b ret reverse a ΓεnΣym-6 t]
1A00051A01070D1A02051A030504011A03080D151A03051A04070D1A04050B00
2D241B09001F0D1C1A0405111A05070D1A05051A0105141A01080D1A0405121A
04081A04050AFFE109000424160D1A010501
} sublist [l start end ret] #@[documentation: "Returns a new list containing all elements of l from start to end" source: ["Returns a new list containing all elements of l from start to end" [cond [[nil? l] [reverse ret]] [[neg? end] [sublist l start [+ [length l] end]]] [[zero? end] [reverse ret]] [[> start 0] [sublist [cdr l] [+ -1 start] [+ -1 end] #nil]] [[> end 0] [sublist [cdr l] 0 [+ -1 end] [cons [car l] ret]]]]]] #{##[nil? l reverse ret end 0.0 sublist start length]
1A00051A010504010B000E1A02051A030504010900801A04051A051E0B001D1A
06051A01051A07051A08051A010504011A040525040309005D1A04052A0B000E
1A02051A0305040109004B1A07050200220B001C1A06051A01051202FF1A0705
2502FF1A0405252404040900291A04050200220B001F1A06051A010512020002
FF1A0405251A0105111A03051404040900042401
} list-head [l k] #@[documentation: "Returns the first k elements of list l" source: ["Returns the first k elements of list l" [sublist l 0 k]]] #{##[sublist l k]
1A00051A010502001A0205040301
} list-tail [l k] #@[documentation: "Returns the sublist of l obtained by omitting the first l elements" source: ["Returns the sublist of l obtained by omitting the first l elements" [sublist l k [length l]]]] #{##[sublist l k length]
1A00051A01051A02051A03051A01050401040301
} list/member [l m] #@[documentation: "Returns the first pair of list l whose car is equal to m" source: ["Returns the first pair of list l whose car is equal to m" [cond [[nil? l] #f] [[= [car l] m] l] [#t [list/member [cdr l] m]]]]] #{##[nil? l #f m #t list/member]
1A00051A010504010B00081A020900291A0105111A0305200B00091A01050900
181A040B00121A05051A0105121A030504020900042401
} getf [l key] #@[documentation: "Return the value in LIST following KEY" source: ["Return the value in LIST following KEY" [cond [[nil? l] #nil] [[= key [car l]] [cadr l]] [#t [getf [cdr l] key]]]]] #{##[nil? l key #t getf]
1A00051A010504010B00072409002B1A02051A010511200B000B1A0105121109
00181A030B00121A04051A0105121A020504020900042401
} list/sort/bubble [l] #@[documentation: "Terribly slow way to sort a list, though it was simple to write" source: ["Terribly slow way to sort a list, though it was simple to write" [if-not l #nil [do [def top [car l]] [def next #nil] [cdr! l] [while l [if [<= [car l] top] [do [set! next [cons top next]] [set! top [car l]]] [set! next [cons [car l] next]]] [cdr! l]] [cons top [list/sort/bubble next]]]]]] #{##[l top next list/sort/bubble]
1A00050B00681A0005111A01070D241A02070D1A0005121A00080D241B090038
0D1C1A0005111A01051F0B00181A01051A0205141A02080D1A0005111A010809
000E1A0005111A0205141A02080D1A0005121A00081A00050AFFC80D1A01051A
03051A02050401140900042401
} list/merge-sorted-lists [l1 l2] #@[source: [[cond [[nil? l1] l2] [[nil? l2] l1] [#t [if [< [car l1] [car l2]] [cons [car l1] [list/merge-sorted-lists [cdr l1] l2]] [cons [car l2] [list/merge-sorted-lists l1 [cdr l2]]]]]]]] #{##[nil? l1 l2 #t list/merge-sorted-lists]
1A00051A010504010B00091A020509004E1A00051A020504010B00091A010509
003D1A030B00371A0105111A0205111E0B00171A0105111A04051A0105121A02
050402140900141A0205111A04051A01051A0205120402140900042401
} list/split-half-rec [l acc1 acc2] #@[source: [[cond [[nil? l] [cons acc1 acc2]] [[nil? [cdr l]] [cons [cons [car l] acc1] acc2]] [#t [list/split-half-rec [cddr l] [cons [car l] acc1] [cons [cadr l] acc2]]]]]] #{##[nil? l acc1 acc2 #t list/split-half-rec]
1A00051A010504010B000D1A02051A0305140900421A00051A01051204010B00
121A0105111A0205141A0305140900271A040B00211A05051A010512121A0105
111A0205141A010512111A03051404030900042401
} list/split-half [l] #@[source: [[list/split-half-rec l #nil #nil]]] #{##[list/split-half-rec l]
1A00051A01052424040301
} list/sort/merge [l] #@[documentation: "Sorts a list" source: ["Sorts a list" [if [nil? [cdr l]] l [do [def parts [list/split-half l]] [list/merge-sorted-lists [list/sort/merge [car parts]] [list/sort/merge [cdr parts]]]]]]] #{##[nil? l list/split-half parts list/merge-sorted-lists list/sort/merge]
1A00051A01051204010B00091A01050900261A02051A010504011A03070D1A04
051A05051A03051104011A05051A0305120401040201
} list/sort list? [a] #@[documentation: "Return #t is A is a proper list" source: ["Return #t is A is a proper list" [when-not a [return #f]] [while a [when-not [pair? a] [return #f]] [cdr! a]] [return #t]]] #{##[a #f pair? #t]
1A00050B0007240900061A01010D241B09001F0D1C1A02051A000504010B0007
240900061A01010D1A0005121A00081A00050AFFE10D1A030101
} list/equal? [a b] #@[documentation: "#t if A and B are equal" source: ["#t if A and B are equal" [if [pair? a] [and [list/equal? [car a] [car b]] [list/equal? [cdr a] [cdr b]]] [equal? a b]]]] #{##[pair? a list/equal? b equal?]
1A00051A010504010B00251A02051A0105111A03051104020C0B00110D1A0205
1A0105121A030512040209000E1A04051A01051A0305040201
} list/take [l count] #@[documentation: "Take the first COUNT elements from list L" source: ["Take the first COUNT elements from list L" [if [<= count 0] #nil [cons [car l] [list/take [cdr l] [- count 1]]]]]] #{##[count l list/take]
1A000502001F0B0007240900171A0105111A02051A0105121A00050201260402
1401
} list/drop [l count] #@[documentation: "Drop the final COUNT elements from list L" source: ["Drop the final COUNT elements from list L" [if [<= count 0] l [list/drop [cdr l] [- count 1]]]]] #{##[count l list/drop]
1A000502001F0B00091A01050900121A02051A0105121A0005020126040201
} list/cut [l start end] #@[documentation: "Return a subsequence of L from START to END" source: ["Return a subsequence of L from START to END" [list/take [list/drop l [max 0 start]] [- end [max 0 start]]]]] #{##[list/take list/drop l max start end]
1A00051A01051A02051A030502001A0405040204021A05051A030502001A0405
040226040201
} list/replace [l search-for replace-with] #@[documentation: "Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH\nUses [equal?] so we can search/replace lists/trees and other complex data structures" source: ["Return a new list where every occurence of SEARCH-FOR is replaced with REPLACE-WITH" "" "Uses [equal?] so we can search/replace lists/trees and other complex data structures" [cond [[not l] #nil] [[equal? l search-for] replace-with] [[equal? [car l] search-for] [cons replace-with [list/replace [cdr l] search-for replace-with]]] [#t [cons [if [pair? [car l]] [list/replace [car l] search-for replace-with] [car l]] [list/replace [cdr l] search-for replace-with]]]]]] #{##[l #f #t equal? search-for replace-with list/replace pair?]
1A00050B00081A010900051A020B0007240900771A03051A00051A040504020B
00091A05050900631A03051A0005111A040504020B00191A05051A06051A0005
121A04051A050504031409003E1A020B00381A07051A00051104010B00151A06
051A0005111A04051A050504030900071A0005111A06051A0005121A04051A05
050403140900042401
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A14070D1A181A191A1A1A1B171A18070D1A1C1A1D1A
1E1A1F171A1C070D1A201A211A221A23171A20070D1A241A251A261A27171A24
070D1A281A291A2A1A2B171A28070D1A2C1A2D1A2E1A2F171A2C070D1A301A31
1A321A33171A30070D1A341A351A361A37171A34070D1A381A391A3A1A3B171A
38070D1A3C1A3D1A3E1A3F171A3C070D1A401A411A421A43171A40070D1A441A
451A461A47171A44070D1A481A491A4A1A4B171A48070D1A4C1A4D1A4E1A4F17
1A4C070D1A501A511A521A53171A50070D1A541A551A561A57171A54070D1A58
1A591A5A1A5B171A58070D1A58051A5C070D1A5D1A5E1A5F1A60171A5D070D1A
611A621A631A64171A61070D1A651A661A671A68171A65070D1A691A6A1A6B1A
6C171A69070D1A6D1A6E1A6F1A70171A6D070D1A711A721A731A74171A710701
}#{##[tree/zip [keys values] #@[documentation: "Return a tree where KEYS point to VALUES" source: ["Return a tree where KEYS point to VALUES" [def ret [tree/new #nil]] [doseq [key keys] [tree/set! ret key [car values]] [cdr! values]] ret]] #{##[tree/new ret keys ΓεnΣym-1 key tree/set! values]
1A00052404011A01070D151A02051A03070D1A03050B003A241B09002C0D1C1A
0305111A04070D1A05051A01051A04051A06051104030D1A0605121A06080D1A
0305121A03081A03050AFFD409000424160D1A010501
} tree/+= [t k v] #@[documentation: "Increment value at K in T by V" source: ["Increment value at K in T by V" [tree/set! t k [+ v [int [or [tree/ref t k] 0]]]]]] #{##[tree/set! t k v int tree/ref #f]
1A00051A01051A02051A03051A04051A05051A01051A020504020C0A000D0D02
000C0A00060D1A06040125040301
} tree/-= [t k v] #@[documentation: "Decrement value at K in T by V" source: ["Decrement value at K in T by V" [quasiquote [tree/+= [unquote t] [unquote k] [- [unquote v]]]]]] #{##[tree/+= t k - v]
1A001A01051A02051A031A0405241414241414141401
} tree/++ [t k] #@[documentation: "Increment value at K in T by 1" source: ["Increment value at K in T by 1" [quasiquote [tree/+= [unquote t] [unquote k] 1]]]] #{##[tree/+= t k]
1A001A01051A02050201241414141401
} tree/-- [t k] #@[documentation: "Increment value at K in T by 1" source: ["Increment value at K in T by 1" [quasiquote [tree/-= [unquote t] [unquote k] 1]]]] #{##[tree/-= t k]
1A001A01051A02050201241414141401
} tree/equal? [a b] #@[documentation: "Compares two trees for equality" source: ["Compares two trees for equality" [if [and [tree? a] [tree? b]] [and [= [tree/key* a] [tree/key* b]] [equal? [tree/value* a] [tree/value* b]] [tree/equal? [tree/left* a] [tree/left* b]] [tree/equal? [tree/right* a] [tree/right* b]]] [equal? a b]]]] #{##[tree? a b tree/key* equal? tree/value* tree/equal? tree/left* tree/right*]
1A00051A010504010C0B000C0D1A00051A020504010B00651A03051A01050401
1A03051A02050401200C0B004D0D1A04051A05051A010504011A05051A020504
0104020C0B00330D1A06051A07051A010504011A07051A0205040104020C0B00
190D1A06051A08051A010504011A08051A02050401040209000E1A04051A0105
1A0205040201
} tree/reduce [l o s] #@[documentation: "Combine all elements in l using operation o and starting value s" source: ["Combine all elements in l using operation o and starting value s" [list/reduce [tree/values l] o s]]] #{##[list/reduce tree/values l o s]
1A00051A01051A020504011A03051A0405040301
} tree/filter [l f] #@[documentation: "Return a new tree with all elements from L where F retunrs true" source: ["Return a new tree with all elements from L where F retunrs true" [def ret [tree/new #nil]] [doseq [e [tree/keys l]] [def t [tree/ref l e]] [when [f t] [tree/set! ret e t]]] ret]] #{##[tree/new ret tree/keys l ΓεnΣym-2 e tree/ref t f tree/set!]
1A00052404011A01070D151A02051A030504011A04070D1A04050B004F241B09
00410D1C1A0405111A05070D1A06051A03051A050504021A07070D1A08051A07
0504010B00141A09051A01051A05051A07050403090004240D1A0405121A0408
1A04050AFFBF09000424160D1A010501
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B181A08070D1A0C1A0D1A0E1A0F181A0C070D1A101A111A121A13181A1007
0D1A141A151A161A17171A14070D1A181A191A1A1A1B171A18070D1A1C1A1D1A
1E1A1F171A1C0701
}#{##[$nop [] #@[documentation: "[] -> []\nDo nothing" source: ["[] -> []" "Do nothing" :inline '[#$0]] inline: #t] #{##[[#$0]]
1A0001
} $ret [] #@[documentation: "[a] -> []\nReturn top of value stack" source: ["[a] -> []" "Return top of value stack" :inline '[#$1]] inline: #t] #{##[[#$1]]
1A0001
} $add/int [] #@[documentation: "[a b] -> [result]\nAdds the two topmost values and pushes the result" source: ["[a b] -> [result]" "Adds the two topmost values and pushes the result" :inline '[#$3]] inline: #t] #{##[[#$3]]
1A0001
} $get [] #@[documentation: "[s] -> [a]\nResolve symbol S and put whatever is bound to it in the current context on the stack" source: ["[s] -> [a]" "Resolve symbol S and put whatever is bound to it in the current context on the stack" :inline '[#$5]] inline: #t] #{##[[#$5]]
1A0001
} $def [] #@[documentation: "[s v] -> [v]\nDefine S to resolve to V in the current environment" source: ["[s v] -> [v]" "Define S to resolve to V in the current environment" :inline '[#$7]] inline: #t] #{##[[#$7]]
1A0001
} $set [] #@[documentation: "[s v] -> [v]\nSet S to resolve to V in the current environment" source: ["[s v] -> [v]" "Set S to resolve to V in the current environment" :inline '[#$8]] inline: #t] #{##[[#$8]]
1A0001
} $dup [] #@[documentation: "[a] -> [a a]\nDuplicates the value that is on the top of the stack" source: ["[a] -> [a a]" "Duplicates the value that is on the top of the stack" :inline '[#$C]] inline: #t] #{##[[#$C]]
1A0001
} $drop [] #@[documentation: "[a] -> []\nDrop whatever is on top of the stack" source: ["[a] -> []" "Drop whatever is on top of the stack" :inline '[#$D]] inline: #t] #{##[[#$D]]
1A0001
} $closure/push [] #@[documentation: "[] -> [closure]\nPush the current closure as a λ on the stack" source: ["[] -> [closure]" "Push the current closure as a λ on the stack" :inline '[#$13]] inline: #t] #{##[[#$13]]
1A0001
} $let [] #@[documentation: "[] -> []\nCreate a new let closure and switch to it" source: ["[] -> []" "Create a new let closure and switch to it" :inline '[#$15]] inline: #t] #{##[[#$15]]
1A0001
} $closure/pop [] #@[documentation: "[] -> []\nLeave the current closure and return to the parent one" source: ["[] -> []" "Leave the current closure and return to the parent one" :inline '[#$16]] inline: #t] #{##[[#$16]]
1A0001
} $roots/save [] #@[documentation: "[] -> []\nStore the current root stack pointer used for guarding allocations into the current closure" source: ["[] -> []" "Store the current root stack pointer used for guarding allocations into the current closure" :inline '[#$1B]] inline: #t] #{##[[#$1B]]
1A0001
} $roots/restore [] #@[documentation: "[] -> []\nRestore the current root stack pointer to what is stored within the current closure" source: ["[] -> []" "Restore the current root stack pointer to what is stored within the current closure" :inline '[#$1C]] inline: #t] #{##[[#$1C]]
1A0001
} $< [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$1E]] inline: #t] #{##[[#$1E]]
1A0001
} $<= [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$1F]] inline: #t] #{##[[#$1F]]
1A0001
} $= [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$20]] inline: #t] #{##[[#$20]]
1A0001
} $>= [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$21]] inline: #t] #{##[[#$21]]
1A0001
} $> [] #@[documentation: "[a b] -> [bool]\nCompare A and B and push the result on the stack" source: ["[a b] -> [bool]" "Compare A and B and push the result on the stack" :inline '[#$22]] inline: #t] #{##[[#$22]]
1A0001
} $push/nil [] #@[documentation: "[] -> [nil]\nPush a #nil on the stack" source: ["[] -> [nil]" "Push a #nil on the stack" :inline '[#$24]] inline: #t] #{##[[#$24]]
1A0001
} $car [] #@[documentation: "[l] -> [car]\nReplace L with its car" source: ["[l] -> [car]" "Replace L with its car" :inline '[#$11]] inline: #t] #{##[[#$11]]
1A0001
} $cdr [] #@[documentation: "[l] -> [cdr]\nReplace L with its cdr" source: ["[l] -> [cdr]" "Replace L with its cdr" :inline '[#$12]] inline: #t] #{##[[#$12]]
1A0001
} $cons [] #@[documentation: "[car cdr] -> [pair]\nCons CAR and CDR together and put it on the stack" source: ["[car cdr] -> [pair]" "Cons CAR and CDR together and put it on the stack" :inline '[#$14]] inline: #t] #{##[[#$14]]
1A0001
} $fn/dynamic [] #@[documentation: "[name args docs body] -> [λ]\nCreate a new λ" source: ["[name args docs body] -> [λ]" "Create a new λ" :inline '[#$17]] inline: #t] #{##[[#$17]]
1A0001
} $macro/dynamic [] #@[documentation: "[name args docs body] -> [μ]\nCreate a new μ" source: ["[name args docs body] -> [μ]" "Create a new μ" :inline '[#$18]] inline: #t] #{##[[#$18]]
1A0001
} $add [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$25]] inline: #t] #{##[[#$25]]
1A0001
} $sub [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$26]] inline: #t] #{##[[#$26]]
1A0001
} $mul [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$27]] inline: #t] #{##[[#$27]]
1A0001
} $div [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$28]] inline: #t] #{##[[#$28]]
1A0001
} $rem [] #@[documentation: "[a b] -> [result]" source: ["[a b] -> [result]" :inline '[#$29]] inline: #t] #{##[[#$29]]
1A0001
} $zero? [] #@[documentation: "[a] -> [result]" source: ["[a] -> [result]" :inline '[#$2A]] inline: #t] #{##[[#$2A]]
1A0001
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A14070D1A181A191A1A1A1B171A18070D1A1C1A1D1A
1E1A1F171A1C070D1A201A211A221A23171A20070D1A241A251A261A27171A24
070D1A281A291A2A1A2B171A28070D1A2C1A2D1A2E1A2F171A2C070D1A301A31
1A321A33171A30070D1A341A351A361A37171A34070D1A381A391A3A1A3B171A
38070D1A3C1A3D1A3E1A3F171A3C070D1A401A411A421A43171A40070D1A441A
451A461A47171A44070D1A481A491A4A1A4B171A48070D1A4C1A4D1A4E1A4F17
1A4C070D1A501A511A521A53171A50070D1A541A551A561A57171A54070D1A58
1A591A5A1A5B171A58070D1A5C1A5D1A5E1A5F171A5C070D1A601A611A621A63
171A60070D1A641A651A661A67171A64070D1A681A691A6A1A6B171A68070D1A
6C1A6D1A6E1A6F171A6C070D1A701A711A721A73171A70070D1A741A751A761A
77171A740701
}#{##[int-fit-in-byte? [a] #@[source: [[and [<= a 127] [>= a -128]]]] #{##[a]
1A0005027F1F0C0B000A0D1A000502802101
} $push/int [a] #@[documentation: "[] -> [a]\nPush A on the stack as an :int" source: ["[] -> [a]" "Push A on the stack as an :int" [if [int-fit-in-byte? a] [$push/int/byte a] [$push/val a]]]] #{##[int-fit-in-byte? a $push/int/byte $push/val]
1A00051A010504010B000E1A02051A0105040109000B1A03051A0105040101
} $push/int/byte [a] #@[documentation: "[] -> [a]\nPush A on the stack as an :int that fits within a byte" source: ["[] -> [a]" "Push A on the stack as an :int that fits within a byte" [when-not [int-fit-in-byte? a] [throw [list :invalid-bc-op "$push/int/byte can only push a signed 8-bit value" a [current-lambda]]]] [list #$2 [int->bytecode-op a]]]] #{##[int-fit-in-byte? a throw list :invalid-bc-op "$push/int/byte can only push a signed 8-bit value" current-lambda #$2 int->bytecode-op]
1A00051A010504010B0007240900191A02051A03051A041A051A01051A060504
00040404010D1A03051A071A08051A01050401040201
} $apply/optimize? [fun arg-count] #@[source: [[case fun [[+ - * / rem] [= arg-count 2]] [[zero? car cdr add/int cons < <= = >= >] #t]]]] #{##[fun ΓεnΣym-1 + - * / rem #f arg-count zero? car cdr add/int cons < <= = >= > #t]
151A00051A01070D1A01051A0205200C0A00360D1A01051A0305200C0A002A0D
1A01051A0405200C0A001E0D1A01051A0505200C0A00120D1A01051A0605200C
0A00060D1A070B000C1A08050202200900861A01051A0905200C0A00720D1A01
051A0A05200C0A00660D1A01051A0B05200C0A005A0D1A01051A0C05200C0A00
4E0D1A01051A0D05200C0A00420D1A01051A0E05200C0A00360D1A01051A0F05
200C0A002A0D1A01051A1005200C0A001E0D1A01051A1105200C0A00120D1A01
051A1205200C0A00060D1A070B00081A13090004241601
} $apply [arg-count fun] #@[documentation: "arguments -> [result]\nRead arg-count arguments from the stack, apply the to fun and push the result on the stack" source: ["arguments -> [result]" "Read arg-count arguments from the stack, apply the to fun and push the result on the stack" [case arg-count [1 [case fun [car [$car]] [cdr [$cdr]] [zero? [$zero?]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]] [2 [case fun [add/int [$add/int]] [+ [$add]] [- [$sub]] [* [$mul]] [/ [$div]] [rem [$rem]] [cons [$cons]] [< [$<]] [<= [$<=]] [= [$=]] [>= [$>=]] [> [$>]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]] [otherwise [exception :arity-error "Wrong number of arguments for that function" fun]]]]] #{##[arg-count ΓεnΣym-2 fun ΓεnΣym-3 car [#$11] cdr [#$12] zero? [#$2A] throw list :arity-error "Wrong number of arguments for that function" current-lambda ΓεnΣym-4 add/int [#$3] + [#$25] - [#$26] * [#$27] / [#$28] rem [#$29] cons [#$14] < [#$1E] <= [#$1F] = [#$20] >= [#$21] > [#$22]]
151A00051A01070D1A01050201200B0052151A02051A03070D1A03051A040520
0B00081A050900371A03051A0605200B00081A070900281A03051A0805200B00
081A090900191A0A051A0B051A0C1A0D1A02051A0E05040004040401160900F8
1A01050202200B00D9151A02051A0F070D1A0F051A1005200B00081A110900BE
1A0F051A1205200B00081A130900AF1A0F051A1405200B00081A150900A01A0F
051A1605200B00081A170900911A0F051A1805200B00081A190900821A0F051A
1A05200B00081A1B0900731A0F051A1C05200B00081A1D0900641A0F051A1E05
200B00081A1F0900551A0F051A2005200B00081A210900461A0F051A2205200B
00081A230900371A0F051A2405200B00081A250900281A0F051A2605200B0008
1A270900191A0A051A0B051A0C1A0D1A02051A0E05040004040401160900191A
0A051A0B051A0C1A0D1A02051A0E050400040404011601
} $apply/dynamic [arg-count fun] #@[source: [[when [> arg-count 255] [exception :arity-error "Functions can only take up to 255 arguments directly, you can use [apply] instead though" arg-count]] [list #$4 [int->bytecode-op arg-count]]]] #{##[arg-count 255 throw list :arity-error "Functions can only take up to 255 arguments directly, you can use [apply] instead though" current-lambda #$4 int->bytecode-op]
1A00051A01220B001C1A02051A03051A041A051A00051A060504000404040109
0004240D1A03051A071A08051A00050401040201
} $try [target] #@[documentation: "[] -> []\nTry something, jumping to target if an exception occurs" source: ["[] -> []" "Try something, jumping to target if an exception occurs" [list #$19 [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[list #$19 :relocate target int->bytecode-op]
1A00051A011A00051A021A0305020802001A04050200040104051A00051A021A
0305020002011A0405020004010405040301
} $jmp [target] #@[source: [[list #$9 [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[list #$9 :relocate target int->bytecode-op]
1A00051A011A00051A021A0305020802001A04050200040104051A00051A021A
0305020002011A0405020004010405040301
} $push/val [v] #@[documentation: "[] -> [v]\nPushes v onto the stack" source: ["[] -> [v]" "Pushes v onto the stack" [when [nil? v] [throw [list :invalid-bc-op "Can't push #nil as a normal lVal" v [current-lambda]]]] [list #$1A [list :literal v]]]] #{##[nil? v throw list :invalid-bc-op "Can't push #nil as a normal lVal" current-lambda #$1A :literal]
1A00051A010504010B001C1A02051A03051A041A051A01051A06050400040404
01090004240D1A03051A071A03051A081A01050402040201
} $push/val/ext $jt [target] #@[source: [[list #$A [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[list #$A :relocate target int->bytecode-op]
1A00051A011A00051A021A0305020802001A04050200040104051A00051A021A
0305020002011A0405020004010405040301
} $jf [target] #@[source: [[list #$B [list :relocate target 8 0 [int->bytecode-op 0]] [list :relocate target 0 1 [int->bytecode-op 0]]]]] #{##[list #$B :relocate target int->bytecode-op]
1A00051A011A00051A021A0305020802001A04050200040104051A00051A021A
0305020002011A0405020004010405040301
} $fn [name args docs body] #@[source: [[list #$25 [val->bytecode-op name] [val->bytecode-op args] [val->bytecode-op docs] [val->bytecode-op body]]]] #{##[list #$25 val->bytecode-op name args docs body]
1A00051A011A02051A030504011A02051A040504011A02051A050504011A0205
1A06050401040501
} $macro* [name args docs body] #@[source: [[list #$26 [val->bytecode-op name] [val->bytecode-op args] [val->bytecode-op docs] [val->bytecode-op body]]]] #{##[list #$26 val->bytecode-op name args docs body]
1A00051A011A02051A030504011A02051A040504011A02051A050504011A0205
1A06050401040501
} assemble/build-sym-map [code sym-map pos] #@[source: [[while code [case [type-of [car code]] [:bytecode-op [tree/set! sym-map :last-op [inc! pos]]] [:keyword [case [car code] [:label [tree/set! sym-map [cadr code] pos] [cdr! code]] [:literal [cdr! code]]]] [:pair [set! pos [assemble/build-sym-map [car code] sym-map pos]]]] [cdr! code]] [return pos]]] #{##[type-of code ΓεnΣym-5 :bytecode-op tree/set! sym-map :last-op pos :keyword ΓεnΣym-6 :label :literal :pair assemble/build-sym-map]
241B0900A80D1C151A00051A01051104011A02070D1A02051A03200B00191A04
051A05051A061A07050201251A070804030900701A02051A08200B0048151A01
05111A09070D1A09051A0A200B001E1A04051A05051A010512111A070504030D
1A0105121A01080900171A09051A0B200B000D1A0105121A0108090004241609
00221A02051A0C200B00181A0D051A0105111A05051A070504031A0708090004
24160D1A0105121A01081A01050AFF580D1A07050101
} assemble/relocate-op [code sym-map pos out] #@[source: [[def target [tree/ref sym-map [cadr code]]] [def off [- [+ target [cadddr code]] pos]] [array/set! out [inc! pos] [int->bytecode-op [bit-and [bit-shift-right off [caddr code]] 255]]] [return pos]]] #{##[tree/ref sym-map code target cadddr pos off array/set! out int->bytecode-op bit-and bit-shift-right caddr 255]
1A00051A01051A0205121104021A03070D1A03051A04051A02050401251A0505
261A06070D1A07051A08051A05050201251A05081A09051A0A051A0B051A0605
1A0C051A0205040104021A0D0402040104030D1A05050101
} assemble/emit-relocated-ops [code sym-map pos out] #@[source: [[if [= [car code] :relocate] [set! pos [assemble/relocate-op code sym-map pos out]] [doseq [op code] [case [type-of op] [:bytecode-op [array/set! out [inc! pos] op]] [:pair [set! pos [assemble/emit-relocated-ops op sym-map pos out]]]]]] [return pos]]] #{##[code :relocate assemble/relocate-op sym-map pos out ΓεnΣym-7 op type-of ΓεnΣym-8 :bytecode-op array/set! :pair assemble/emit-relocated-ops]
1A0005111A01200B001A1A02051A00051A03051A04051A050504041A04080900
82151A00051A06070D1A06050B0072241B0900640D1C1A0605111A07070D151A
08051A070504011A09070D1A09051A0A200B001A1A0B051A05051A0405020125
1A04081A070504030900241A09051A0C200B001A1A0D051A07051A03051A0405
1A050504041A040809000424160D1A0605121A06081A06050AFF9C0900042416
0D1A04050101
} literal-index->bytecode-op [i] #@[source: [[if [< i 256] [int->bytecode-op i] [list [int->bytecode-op [bit-and [bit-shift-right i 8] 255]] [int->bytecode-op [bit-and i 255]]]]]] #{##[i 256 int->bytecode-op list bit-and bit-shift-right 255]
1A00051A011E0B000E1A02051A0005040109002D1A03051A02051A04051A0505
1A0005020804021A06040204011A02051A04051A00051A0604020401040201
} *max-literal-arr* assemble/add-literal [lit lit-arr] #@[source: [[when [>= [array/length lit-arr] 65535] [exception :out-of-bounds "Can only store up to 255 literals per bytecode-arr" code]] [when [not= [type-of lit] :pair] [dotimes [i [array/length lit-arr]] [when [equal? [array/ref lit-arr i] lit] [return [literal-index->bytecode-op i]]]]] [array/length! lit-arr [+ 1 [array/length lit-arr]]] [array/set! lit-arr [- [array/length lit-arr] 1] lit] [literal-index->bytecode-op [- [array/length lit-arr] 1]]]] #{##[array/length lit-arr 65535 throw list :out-of-bounds "Can only store up to 255 literals per bytecode-arr" code current-lambda not= type-of lit :pair i equal? array/ref literal-index->bytecode-op array/length! array/set!]
1A00051A010504011A02210B001C1A03051A04051A051A061A07051A08050400
04040401090004240D1A09051A0A051A0B0504011A0C04020B00531502001A0D
070D241B0900320D1C1A0E051A0F051A01051A0D0504021A0B0504020B000F1A
10051A0D05040101090004240D02011A0D05031A0D081A0D051A00051A010504
011E0AFFC50D2416090004240D1A11051A010502011A00051A01050401250402
0D1A12051A01051A00051A010504010201261A0B0504030D1A10051A00051A01
050401020126040101
} assemble/build-lit-arr [code lit-arr] #@[source: [[when-not code [return #nil]] [cond [[pair? [car code]] [cons [assemble/build-lit-arr [car code] lit-arr] [assemble/build-lit-arr [cdr code] lit-arr]]] [[and [= [car code] #$1A] [= [car [cadr code]] :literal]] [cdr! code] [def index-op [assemble/add-literal [cadar code] lit-arr]] [cons [if [pair? index-op] #$6 #$1A] [cons index-op [assemble/build-lit-arr [cdr code] lit-arr]]]] [[= :literal [car code]] [cdr! code] [cons [assemble/add-literal [car code] lit-arr] [assemble/build-lit-arr [cdr code] lit-arr]]] [otherwise [cons [car code] [assemble/build-lit-arr [cdr code] lit-arr]]]]]] #{##[code pair? assemble/build-lit-arr lit-arr #$1A :literal assemble/add-literal cadar index-op #$6 otherwise]
1A00050B00072409000524010D1A01051A00051104010B001F1A02051A000511
1A030504021A02051A0005121A03050402140900A61A0005111A04200C0B000D
0D1A00051211111A05200B00451A0005121A00080D1A06051A07051A00050401
1A030504021A08070D1A01051A080504010B00081A090900051A041A08051A02
051A0005121A03050402141409004C1A051A000511200B00271A0005121A0008
0D1A06051A0005111A030504021A02051A0005121A030504021409001E1A0A05
0B00171A0005111A02051A0005121A03050402140900042401
} assemble/flatten [code ret] #@[source: [[when-not code [return ret]] [when-not [pair? code] [return ret]] [set! ret [assemble/flatten [cdr code] ret]] [if [and [pair? [car code]] [not [keyword? [caar code]]]] [assemble/flatten [car code] ret] [cons [car code] ret]]]] #{##[code ret pair? assemble/flatten keyword? #f #t]
1A00050B0007240900071A0105010D1A02051A000504010B0007240900071A01
05010D1A03051A0005121A010504021A01080D1A02051A00051104010C0B0018
0D1A04051A0005111104010B00081A050900051A060B00121A03051A0005111A
0105040209000B1A0005111A01051401
} assemble* [code] #@[documentation: "Assemble all arguments into a single :bytecode-array" source: ["Assemble all arguments into a single :bytecode-array" [def sym-map [tree/new #nil]] [def lit-arr [array/new #nil]] [def tmp [-> [assemble/flatten code] [assemble/build-lit-arr lit-arr]]] [assemble/build-sym-map tmp sym-map 0] [def out [array/allocate [tree/ref sym-map :last-op]]] [assemble/emit-relocated-ops tmp sym-map -1 out] [arr->bytecode-arr out lit-arr]]] #{##[tree/new sym-map array/new lit-arr assemble/build-lit-arr assemble/flatten code tmp assemble/build-sym-map array/allocate tree/ref :last-op out assemble/emit-relocated-ops arr->bytecode-arr]
1A00052404011A01070D1A02052404011A03070D1A04051A05051A060504011A
030504021A07070D1A08051A07051A0105020004030D1A09051A0A051A01051A
0B040204011A0C070D1A0D051A07051A010502FF1A0C0504040D1A0E051A0C05
1A0305040201
} assemble l #@[documentation: "Assemble all arguments into a single :bytecode-array" source: ["Assemble all arguments into a single :bytecode-array" [assemble* l]]] #{##[assemble* l]
1A00051A0105040101
} asmrun ops #@[documentation: "Assemble and evaluate all bytecode arguments" source: ["Assemble and evaluate all bytecode arguments" [quasiquote [apply [current-closure] [assemble [unquote-splicing ops]]]]]] #{##[apply current-closure assemble append ops]
1A001A0124141A021A03051A0405240402142414141401
} asmdebug #@[documentation: "Assemble and evaluate all bytecode arguments" source: ["Assemble and evaluate all bytecode arguments" [def bc [apply assemble ops]] [disassemble bc] [def v [apply [current-closure] bc #t]] [pfmtln "Result: {:?}{}" v [type-of v]]]] #{##[apply assemble ops bc disassemble current-closure #t v println fmt-arg-0 type-of fmt-arg-1 cat "Result: " string/write]
1A00051A01051A020504021A03070D1A04051A030504010D1A00051A05050400
1A03051A0604031A07070D1A0805151A07051A09070D1A0A051A070504011A0B
070D1A0C051A0D1A0E051A090504011A0B05040316040101
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A14070D1A181A191A1A1A1B171A18070D1A1C1A1D1A
1E1A1F171A1C070D1A201A211A221A23171A20070D1A20051A24070D1A251A26
1A271A28171A25070D1A291A2A1A2B1A2C171A29070D1A2D1A2E1A2F1A30171A
2D070D1A311A321A331A34171A31070D1A351A361A371A38171A35070D1A391A
3A1A3B1A3C171A39070D1A3D1A3E1A3F1A40171A3D070D1A411A421A431A4417
1A41070D02001A45070D1A461A471A481A49171A46070D1A4A1A4B1A4C1A4D17
1A4A070D1A4E1A4F1A501A51171A4E070D1A521A531A541A55171A52070D1A56
1A571A581A59171A56070D1A5A1A5B1A5C1A5D181A5A070D1A5E1A5B1A5F1A60
171A5E0701
}#{##[bytecompile/gen-label/counter bytecompile/gen-label [prefix] #@[source: [[inc! bytecompile/gen-label/counter] [string->symbol [cat prefix "label-" bytecompile/gen-label/counter]]]] #{##[bytecompile/gen-label/counter string->symbol cat prefix "label-"]
1A00050201251A00080D1A01051A02051A03051A041A00050403040101
} bytecompile/literal [source] #@[source: [[case [type-of source] [:int [$push/int source]] [:nil [$push/nil]] [:symbol [list [$push/val source] [$get]]] [[:native-function :lambda] [bytecompile/literal [closure/name source]]] [otherwise [$push/val source]]]]] #{##[type-of source ΓεnΣym-1 :int $push/int :nil [#$24] :symbol list $push/val [#$5] :native-function :lambda #f bytecompile/literal closure/name]
151A00051A010504011A02070D1A02051A03200B000E1A04051A010504010900
5F1A02051A05200B00081A060900511A02051A07200B00151A08051A09051A01
0504011A0A04020900361A02051A0B200C0A00110D1A02051A0C200C0A00060D
1A0D0B00131A0E051A0F051A01050401040109000B1A09051A010504011601
} bytecompile/quote [source] #@[source: [[case [type-of source] [:nil [$push/nil]] [:int [$push/int source]] [otherwise [$push/val source]]]]] #{##[type-of source ΓεnΣym-2 :nil [#$24] :int $push/int $push/val]
151A00051A010504011A02070D1A02051A03200B00081A0409001F1A02051A05
200B000E1A06051A0105040109000B1A07051A010504011601
} bytecompile/do/form [source env] #@[source: [[when source [cons [cons [bytecompile* [car source] env] [if [last? source] #nil [cons [$drop] #nil]]] [bytecompile/do/form [cdr source] env]]]]] #{##[source bytecompile* env nil? [#$D] bytecompile/do/form]
1A00050B00341A01051A0005111A020504021A03051A00051204010B00072409
00071A042414141A05051A0005121A02050402140900042401
} bytecompile/do [source env] #@[source: [[list [bytecompile/do/form [cdr source] env]]]] #{##[list bytecompile/do/form source env]
1A00051A01051A0205121A03050402040101
} bytecompile/def [source env] #@[source: [[when [or [not [symbol? [cadr source]]] [not [cddr source]]] [throw [list :type-error "[def] needs a symbol name and a value as arguments" #nil env]]] [list [bytecompile* [caddr source] env] [$push/val [cadr source]] [$def]]]] #{##[symbol? source #f #t throw list :type-error "[def] needs a symbol name and a value as arguments" env bytecompile* caddr $push/val $def]
1A00051A0105121104010B00081A020900051A030C0A001A0D1A010512120B00
081A020900051A030C0A00060D1A020B00181A04051A05051A061A07241A0805
04040401090004240D1A05051A09051A0A051A010504011A080504021A0B051A
0105121104011A0C050400040301
} bytecompile/set! [source env] #@[source: [[when [or [not [symbol? [cadr source]]] [not [cddr source]]] [throw [list :type-error "[set!] needs a symbol name and a value as arguments" #nil env]]] [list [bytecompile* [caddr source] env] [$push/val [cadr source]] [$set]]]] #{##[symbol? source #f #t throw list :type-error "[set!] needs a symbol name and a value as arguments" env bytecompile* caddr $push/val $set]
1A00051A0105121104010B00081A020900051A030C0A001A0D1A010512120B00
081A020900051A030C0A00060D1A020B00181A04051A05051A061A07241A0805
04040401090004240D1A05051A09051A0A051A010504011A080504021A0B051A
0105121104011A0C050400040301
} bytecompile/if [source env] #@[source: [[let [[sym-else [bytecompile/gen-label]] [sym-after [bytecompile/gen-label]]] [list [bytecompile* [cadr source] env] [$jf sym-else] [bytecompile* [caddr source] env] [$jmp sym-after] [list :label sym-else] [bytecompile* [cadddr source] env] [list :label sym-after]]]]] #{##[bytecompile/gen-label sym-else sym-after list bytecompile* source env $jf caddr $jmp :label cadddr]
151A000504001A01070D1A000504001A02070D1A03051A04051A050512111A06
0504021A07051A010504011A04051A08051A050504011A060504021A09051A02
0504011A03051A0A1A010504021A04051A0B051A050504011A060504021A0305
1A0A1A0205040204071601
} bytecompile/while [source env] #@[source: [[def sym-start [bytecompile/gen-label]] [def sym-end [bytecompile/gen-label]] [list [$push/nil] [$roots/save] [$jmp sym-end] [list :label sym-start] [$drop] [$roots/restore] [bytecompile/do/form [cddr source] env] [list :label sym-end] [bytecompile* [cadr source] env] [$jt sym-start]]]] #{##[bytecompile/gen-label sym-start sym-end list [#$24] [#$1B] $jmp :label [#$D] [#$1C] bytecompile/do/form source env bytecompile* $jt]
1A000504001A01070D1A000504001A02070D1A03051A041A051A06051A020504
011A03051A071A010504021A081A091A0A051A0B0512121A0C0504021A03051A
071A020504021A0D051A0B0512111A0C0504021A0E051A01050401040A01
} bytecompile/procedure/arg [source env] #@[source: [[if [last? source] [bytecompile* [car source] env] [cons [bytecompile* [car source] env] [bytecompile/procedure/arg [cdr source] env]]]]] #{##[nil? source bytecompile* env bytecompile/procedure/arg]
1A00051A01051204010B00121A02051A0105111A0305040209001C1A02051A01
05111A030504021A04051A0105121A030504021401
} bytecompile/procedure/inline? [op] #@[source: [[case [type-of op] [:lambda [meta op :inline]] [#t #f]]]] #{##[type-of op ΓεnΣym-3 :lambda meta :inline #t #f]
151A00051A010504011A02070D1A02051A03200B00101A04051A01051A050402
0900121A02051A06200B00081A07090004241601
} bytecompile/procedure/inline [op args env] #@[source: [[def arg-count [length args]] [when [> arg-count 1] [throw [list :compiler-error "For now only monadic functions can be inlined" op [current-lambda]]]] [def form [macroexpand/do [meta op :source] env]] [def arg-name [car [closure/arguments op]]] [if args [bytecompile* [list/replace form arg-name [car args]] env] [bytecompile* form env]]]] #{##[length args arg-count throw list :compiler-error "For now only monadic functions can be inlined" op current-lambda macroexpand/do meta :source env form closure/arguments arg-name bytecompile* list/replace]
1A00051A010504011A02070D1A02050201220B001C1A03051A04051A051A061A
07051A0805040004040401090004240D1A09051A0A051A07051A0B04021A0C05
04021A0D070D1A0E051A07050401111A0F070D1A01050B001D1A10051A11051A
0D051A0F051A01051104031A0C05040209000E1A10051A0D051A0C05040201
} bytecompile/procedure [op args env op-raw] #@[source: [[if [bytecompile/procedure/inline? op] [bytecompile/procedure/inline op args env] [bytecompile/procedure/default op args env op-raw]]]] #{##[bytecompile/procedure/inline? op bytecompile/procedure/inline args env bytecompile/procedure/default op-raw]
1A00051A010504010B00141A02051A01051A03051A040504030900141A05051A
01051A03051A04051A0605040401
} bytecompile/procedure/default [op args env op-raw] #@[source: [[def arg-count [length args]] [if [$apply/optimize? op arg-count] [list [when args [bytecompile/procedure/arg args]] [$apply arg-count op]] [list [bytecompile* op-raw env] [when args [bytecompile/procedure/arg args]] [$apply/dynamic arg-count]]]]] #{##[length args arg-count $apply/optimize? op list bytecompile/procedure/arg $apply bytecompile* op-raw env $apply/dynamic]
1A00051A010504011A02070D1A03051A04051A020504020B00281A05051A0105
0B000E1A06051A01050401090004241A07051A02051A04050402040209002D1A
05051A08051A09051A0A0504021A01050B000E1A06051A01050401090004241A
0B051A02050401040301
} bytecompile/and/rec [source env label-end] #@[source: [[list [bytecompile* [car source] env] [when [cdr source] [list [$dup] [$jf label-end] [$drop] [bytecompile/and/rec [cdr source] env label-end]]]]]] #{##[list bytecompile* source env [#$C] $jf label-end [#$D] bytecompile/and/rec]
1A00051A01051A0205111A030504021A0205120B00261A00051A041A05051A06
0504011A071A08051A0205121A03051A06050403040409000424040201
} bytecompile/and [source env] #@[source: [[def label-end [bytecompile/gen-label]] [list [bytecompile/and/rec [cdr source] env label-end] [list :label label-end]]]] #{##[bytecompile/gen-label label-end list bytecompile/and/rec source env :label]
1A000504001A01070D1A02051A03051A0405121A05051A010504031A02051A06
1A01050402040201
} bytecompile/or/rec [source env label-end] #@[source: [[when source [list [bytecompile* [car source] env] [$dup] [$jt label-end] [$drop] [bytecompile/or/rec [cdr source] env label-end]]]]] #{##[source list bytecompile* env [#$C] $jt label-end [#$D] bytecompile/or/rec]
1A00050B00321A01051A02051A0005111A030504021A041A05051A060504011A
071A08051A0005121A03051A0605040304050900042401
} bytecompile/or [source env] #@[source: [[def label-end [bytecompile/gen-label]] [list [bytecompile/or/rec [cdr source] env label-end] [$push/val #f] [list :label label-end]]]] #{##[bytecompile/gen-label label-end list bytecompile/or/rec source env $push/val #f :label]
1A000504001A01070D1A02051A03051A0405121A05051A010504031A06051A07
04011A02051A081A01050402040301
} bytecompile/fn* [source env] #@[source: [[def arg-count [length [cdr source]]] [when [not= arg-count 5] [exception :arity-error "[fn*] needs exactly 4 arguments" source]] [cdr! source] [list [bytecompile* [car source] env] [bytecompile* [cadr source] env] [bytecompile* [caddr source] env] [bytecompile* [cadddr source] env] [$fn/dynamic]]]] #{##[length source arg-count not= throw list :arity-error "[fn*] needs exactly 4 arguments" current-lambda bytecompile* env caddr cadddr [#$17]]
1A00051A01051204011A02070D1A03051A0205020504020B001C1A04051A0505
1A061A071A01051A0805040004040401090004240D1A0105121A01080D1A0505
1A09051A0105111A0A0504021A09051A010512111A0A0504021A09051A0B051A
010504011A0A0504021A09051A0C051A010504011A0A0504021A0D040501
} bytecompile/macro* [source env] #@[source: [[def arg-count [length [cdr source]]] [when [not= arg-count 5] [exception :arity-error "[macro*] needs exactly 4 arguments" source]] [cdr! source] [list [bytecompile* [car source] env] [bytecompile* [cadr source] env] [bytecompile* [caddr source] env] [bytecompile* [cadddr source] env] [$macro/dynamic]]]] #{##[length source arg-count not= throw list :arity-error "[macro*] needs exactly 4 arguments" current-lambda bytecompile* env caddr cadddr [#$18]]
1A00051A01051204011A02070D1A03051A0205020504020B001C1A04051A0505
1A061A071A01051A0805040004040401090004240D1A0105121A01080D1A0505
1A09051A0105111A0A0504021A09051A010512111A0A0504021A09051A0B051A
010504011A0A0504021A09051A0C051A010504011A0A0504021A0D040501
} bytecompile/environment* [source env] #@[source: [[list [$let] [bytecompile/do/form [cdr source] env] [$drop] [$closure/push] [$closure/pop]]]] #{##[list [#$15] bytecompile/do/form source env [#$D] [#$13] [#$16]]
1A00051A011A02051A0305121A040504021A051A061A07040501
} bytecompile/let* [source env] #@[source: [[list [$let] [bytecompile/do [cadr source] env] [$closure/pop]]]] #{##[list [#$15] bytecompile/do source env [#$16]]
1A00051A011A02051A030512111A040504021A05040301
} bytecompile/return [source env] #@[source: [[list [bytecompile* [cadr source] env] [$ret]]]] #{##[list bytecompile* source env [#$1]]
1A00051A01051A020512111A030504021A04040201
} bytecompile/try [source env] #@[source: [[def end-sym [bytecompile/gen-label]] [list [bytecompile* [cadr source] env] [$try end-sym] [bytecompile/do/form [cddr source] env] [$closure/pop] [list :label end-sym]]]] #{##[bytecompile/gen-label end-sym list bytecompile* source env $try bytecompile/do/form [#$16] :label]
1A000504001A01070D1A02051A03051A040512111A050504021A06051A010504
011A07051A040512121A050504021A081A02051A091A01050402040501
} bytecompile* [source env] #@[documentation: "Compile the forms in source" source: ["Compile the forms in source" [def op [if [resolves? [car source] env] [resolve [car source] env] [car source]]] [case [type-of op] [[:lambda :native-function :pair :symbol] [case op [do [bytecompile/do source env]] [let* [bytecompile/let* source env]] [def [bytecompile/def source env]] [set! [bytecompile/set! source env]] [if [bytecompile/if source env]] [while [bytecompile/while source env]] [and [bytecompile/and source env]] [or [bytecompile/or source env]] [fn* [bytecompile/fn* source env]] [macro* [bytecompile/macro* source env]] [environment* [bytecompile/environment* source env]] [try [bytecompile/try source env]] [return [bytecompile/return source env]] '[bytecompile/quote [cadr source]] [otherwise [bytecompile/procedure op [cdr source] env [car source]]]]] [otherwise [bytecompile/literal source]]]]] #{##[resolves? source env resolve op type-of ΓεnΣym-4 :lambda :native-function :pair :symbol #f ΓεnΣym-5 do bytecompile/do let* bytecompile/let* def bytecompile/def set! bytecompile/set! if bytecompile/if while bytecompile/while and bytecompile/and or bytecompile/or fn* bytecompile/fn* macro* bytecompile/macro* environment* bytecompile/environment* try bytecompile/try return bytecompile/return quote bytecompile/quote bytecompile/procedure bytecompile/literal]
1A00051A0105111A020504020B00121A03051A0105111A020504020900071A01
05111A04070D151A05051A040504011A06070D1A06051A07200C0A00270D1A06
051A08200C0A001C0D1A06051A09200C0A00110D1A06051A0A200C0A00060D1A
0B0B0171151A04051A0C070D1A0C051A0D05200B00111A0E051A01051A020504
0209014D1A0C051A0F05200B00111A10051A01051A020504020901351A0C051A
1105200B00111A12051A01051A0205040209011D1A0C051A1305200B00111A14
051A01051A020504020901051A0C051A1505200B00111A16051A01051A020504
020900ED1A0C051A1705200B00111A18051A01051A020504020900D51A0C051A
1905200B00111A1A051A01051A020504020900BD1A0C051A1B05200B00111A1C
051A01051A020504020900A51A0C051A1D05200B00111A1E051A01051A020504
0209008D1A0C051A1F05200B00111A20051A01051A020504020900751A0C051A
2105200B00111A22051A01051A0205040209005D1A0C051A2305200B00111A24
051A01051A020504020900451A0C051A2505200B00111A26051A01051A020504
0209002D1A0C051A2705200B00101A28051A0105121104010900161A29051A04
051A0105121A02051A01051104041609000B1A2A051A010504011601
} bytecompile [form environment] #@[source: [[list [bytecompile* form environment] [$ret]]]] #{##[list bytecompile* form environment [#$1]]
1A00051A01051A02051A030504021A04040201
}]
02001A00070D1A011A021A031A04171A01070D1A051A061A071A08171A05070D
1A091A0A1A0B1A0C171A09070D1A0D1A0E1A0F1A10171A0D070D1A111A121A13
1A14171A11070D1A151A161A171A18171A15070D1A191A1A1A1B1A1C171A1907
0D1A1D1A1E1A1F1A20171A1D070D1A211A221A231A24171A21070D1A251A261A
271A28171A25070D1A291A2A1A2B1A2C171A29070D1A2D1A2E1A2F1A30171A2D
070D1A311A321A331A34171A31070D1A351A361A371A38171A35070D1A391A3A
1A3B1A3C171A39070D1A3D1A3E1A3F1A40171A3D070D1A411A421A431A44171A
41070D1A451A461A471A48171A45070D1A491A4A1A4B1A4C171A49070D1A4D1A
4E1A4F1A50171A4D070D1A511A521A531A54171A51070D1A551A561A571A5817
1A55070D1A591A5A1A5B1A5C171A59070D1A5D1A5E1A5F1A60171A5D070D1A61
1A621A631A64171A61070D1A651A661A671A68171A650701
}#{##[disassemble/length [op] #@[documentation: "Return the length in bytes of a bytecode operation and all its arguments" source: ["Return the length in bytes of a bytecode operation and all its arguments" [case op [[#$0 #$1 #$3 #$5 #$7 #$8 #$C #$D #$11 #$12 #$13 #$14 #$15 #$16 #$1B #$1C #$1E #$1F #$20 #$21 #$22 #$24 #$25 #$26 #$27 #$28 #$29 #$2A] 1] [[#$2 #$4 #$1A] 2] [[#$6 #$9 #$A #$B #$18 #$19] 3] [otherwise [throw [list :unknown-op "This op needs its length specified for disassembly to work" op [current-lambda]]]]]]] #{##[op ΓεnΣym-1 #$0 #$1 #$3 #$5 #$7 #$8 #$C #$D #$11 #$12 #$13 #$14 #$15 #$16 #$1B #$1C #$1E #$1F #$20 #$21 #$22 #$24 #$25 #$26 #$27 #$28 #$29 #$2A #f #$2 #$4 #$1A #$6 #$9 #$A #$B #$18 #$19 throw list :unknown-op "This op needs its length specified for disassembly to work" current-lambda]
151A00051A01070D1A01051A02200C0A012F0D1A01051A03200C0A01240D1A01
051A04200C0A01190D1A01051A05200C0A010E0D1A01051A06200C0A01030D1A
01051A07200C0A00F80D1A01051A08200C0A00ED0D1A01051A09200C0A00E20D
1A01051A0A200C0A00D70D1A01051A0B200C0A00CC0D1A01051A0C200C0A00C1
0D1A01051A0D200C0A00B60D1A01051A0E200C0A00AB0D1A01051A0F200C0A00
A00D1A01051A10200C0A00950D1A01051A11200C0A008A0D1A01051A12200C0A
007F0D1A01051A13200C0A00740D1A01051A14200C0A00690D1A01051A15200C
0A005E0D1A01051A16200C0A00530D1A01051A17200C0A00480D1A01051A1820
0C0A003D0D1A01051A19200C0A00320D1A01051A1A200C0A00270D1A01051A1B
200C0A001C0D1A01051A1C200C0A00110D1A01051A1D200C0A00060D1A1E0B00
0802010900901A01051A1F200C0A001C0D1A01051A20200C0A00110D1A01051A
21200C0A00060D1A1E0B000802020900651A01051A22200C0A003D0D1A01051A
23200C0A00320D1A01051A24200C0A00270D1A01051A25200C0A001C0D1A0105
1A26200C0A00110D1A01051A27200C0A00060D1A1E0B000802030900191A2805
1A29051A2A1A2B1A00051A2C050400040404011601
} bytecode/nil-catcher [error] #@[source: [[if [= [car error] :type-error] #nil [throw error]]]] #{##[error :type-error throw]
1A0005111A01200B00072409000B1A02051A0005040101
} bytecode-arr->val [a i] #@[documentation: "Read a bytecode encoded value in A at I and return it" source: ["Read a bytecode encoded value in A at I and return it" [try bytecode/nil-catcher [bytecode-op->val [ref a i] [ref a [+ 1 i]] [ref a [+ 2 i]]]]]] #{##[bytecode/nil-catcher bytecode-op->val ref a i]
1A00051900301A01051A02051A03051A040504021A02051A030502011A040525
04021A02051A030502021A040525040204031601
} bytecode-arr->sym [a i] #@[documentation: "Read a bytecode encoded symbol in A at I and return it" source: ["Read a bytecode encoded symbol in A at I and return it" [try bytecode/nil-catcher [bytecode-op->sym [ref a i] [ref a [+ 1 i]] [ref a [+ 2 i]]]]]] #{##[bytecode/nil-catcher bytecode-op->sym ref a i]
1A00051900301A01051A02051A03051A040504021A02051A030502011A040525
04021A02051A030502021A040525040204031601
} bytecode-op->offset [a b] #@[documentation: "Turn two bytecode ops encoding an offset into the integer representation" source: ["Turn two bytecode ops encoding an offset into the integer representation" [def t [bit-or [bit-shift-left [bytecode-op->int a] 8] [bytecode-op->int b]]] [if-not [> t 32768] t [- [- 65536 t]]]]] #{##[bit-or bit-shift-left bytecode-op->int a b t 32768 - 65536]
1A00051A01051A02051A03050401020804021A02051A0405040104021A05070D
1A05051A06220B00111A07051A081A05052604010900061A050501
} bytecode-arr->offset [a i] #@[documentation: "Read a bytecode encoded offset in A at I and return it as a signed integer" source: ["Read a bytecode encoded offset in A at I and return it as a signed integer" [bytecode-op->offset [ref a i] [ref a [+ 1 i]]]]] #{##[bytecode-op->offset ref a i]
1A00051A01051A02051A030504021A01051A020502011A0305250402040201
} disassemble/maybe-quote [v] #@[documentation: "Quotes symbols but just passes through every other value" source: ["Quotes symbols but just passes through every other value" [if [symbol? v] [list 'quote v] v]]] #{##[symbol? v list quote]
1A00051A010504010B00101A02051A031A010504020900061A010501
} disassemble/op [a i literals] #@[documentation: "Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" source: ["Disassemble a single bytecode op in A at I and return it as an s-expression, that could be applied to eval" [case [ref a i] [#$0 '[$nop]] [#$1 '[$ret]] [#$2 [quasiquote [$push/int/byte [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$3 '[$add/int]] [#$4 [quasiquote [$apply/dynamic [unquote [bytecode-op->int [ref a [+ i 1]]]]]]] [#$5 '[$get]] [#$6 [quasiquote [$push/val/ext [unquote [ref literals [bit-or [bytecode-op->int [ref a [+ i 1]]] [bit-shift-left [bytecode-op->int [ref a [+ i 2]]] 8]]]]]]] [#$7 [quasiquote [$def/new]]] [#$8 [quasiquote [$set/new]]] [#$9 [quasiquote [$jmp* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$A [quasiquote [$jt* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$B [quasiquote [$jf* [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$C '[$dup]] [#$D '[$drop]] [#$11 '[$car]] [#$12 '[$cdr]] [#$13 '[$closure/push]] [#$14 '[$cons]] [#$15 '[$let]] [#$16 '[$closure/pop]] [#$18 [quasiquote [$try/old [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$19 [quasiquote [$try [unquote [bytecode-arr->offset a [+ i 1]]]]]] [#$1A [quasiquote [$push/val [unquote [disassemble/maybe-quote [ref literals [bytecode-op->int [ref a [+ i 1]]]]]]]]] [#$1B '[$roots/push]] [#$1C '[$roots/pop]] [#$1E '[$<]] [#$1F '[$<=]] [#$20 '[$=]] [#$21 '[$>=]] [#$22 '[$>]] [#$24 '[$push/nil]] [#$25 '[$add]] [#$26 '[$sub]] [#$27 '[$mul]] [#$28 '[$div]] [#$29 '[$rem]] [#$2A '[$zero?]] [otherwise :unknown-op]]]] #{##[ref a i ΓεnΣym-2 #$0 [$nop] #$1 [$ret] #$2 $push/int/byte bytecode-op->int #$3 [$add/int] #$4 $apply/dynamic #$5 [$get] #$6 $push/val/ext literals bit-or bit-shift-left #$7 $def/new #$8 $set/new #$9 $jmp* bytecode-arr->offset #$A $jt* #$B $jf* #$C [$dup] #$D [$drop] #$11 [$car] #$12 [$cdr] #$13 [$closure/push] #$14 [$cons] #$15 [$let] #$16 [$closure/pop] #$18 $try/old #$19 $try #$1A $push/val disassemble/maybe-quote #$1B [$roots/push] #$1C [$roots/pop] #$1E [$<] #$1F [$<=] #$20 [$=] #$21 [$>=] #$22 [$>] #$24 [$push/nil] #$25 [$add] #$26 [$sub] #$27 [$mul] #$28 [$div] #$29 [$rem] #$2A [$zero?] :unknown-op]
151A00051A01051A020504021A03070D1A03051A04200B00081A050902E21A03
051A06200B00081A070902D41A03051A08200B001E1A091A0A051A00051A0105
1A0205020125040204012414140902B01A03051A0B200B00081A0C0902A21A03
051A0D200B001E1A0E1A0A051A00051A01051A02050201250402040124141409
027E1A03051A0F200B00081A100902701A03051A11200B00451A121A00051A13
051A14051A0A051A00051A01051A0205020125040204011A15051A0A051A0005
1A01051A02050202250402040102080402040204022414140902251A03051A16
200B000A1A1724140902151A03051A18200B000A1A1924140902051A03051A1A
200B00191A1B1A1C051A01051A020502012504022414140901E61A03051A1D20
0B00191A1E1A1C051A01051A020502012504022414140901C71A03051A1F200B
00191A201A1C051A01051A020502012504022414140901A81A03051A21200B00
081A2209019A1A03051A23200B00081A2409018C1A03051A25200B00081A2609
017E1A03051A27200B00081A280901701A03051A29200B00081A2A0901621A03
051A2B200B00081A2C0901541A03051A2D200B00081A2E0901461A03051A2F20
0B00081A300901381A03051A31200B00191A321A1C051A01051A020502012504
022414140901191A03051A33200B00191A341A1C051A01051A02050201250402
2414140900FA1A03051A35200B002B1A361A37051A00051A13051A0A051A0005
1A01051A020502012504020401040204012414140900C91A03051A38200B0008
1A390900BB1A03051A3A200B00081A3B0900AD1A03051A3C200B00081A3D0900
9F1A03051A3E200B00081A3F0900911A03051A40200B00081A410900831A0305
1A42200B00081A430900751A03051A44200B00081A450900671A03051A46200B
00081A470900591A03051A48200B00081A4909004B1A03051A4A200B00081A4B
09003D1A03051A4C200B00081A4D09002F1A03051A4E200B00081A4F0900211A
03051A50200B00081A510900131A03051A52200B00081A530900051A541601
} disassemble/array [a i literals] #@[documentation: "Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" source: ["Disassemble all bytecode operations in the plain array A starting at I, turning it into an assembler S-Expression and return it as a dotted pair, with the car containing the offset and the cdr containing the S-Expression" [def ret #nil] [while [< i [array/length a]] [set! ret [cons [cons i [disassemble/op a i literals]] ret]] [set! i [+ i [disassemble/length [ref a i]]]]] [nreverse ret]]] #{##[ret i disassemble/op a literals disassemble/length ref array/length nreverse]
241A00070D241B0900360D1C1A01051A02051A03051A01051A04050403141A00
05141A00080D1A01051A05051A06051A03051A010504020401251A01081A0105
1A07051A030504011E0AFFC10D1A08051A0005040101
} disassemble/bytecode-array [code] #@[documentation: "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," source: ["Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," [disassemble/array [bytecode-arr->arr code] 0 [bytecode-literals code]]]] #{##[disassemble/array bytecode-arr->arr code bytecode-literals]
1A00051A01051A0205040102001A03051A02050401040301
} disassemble/print [bc] #@[source: [[doseq [a [disassemble/bytecode-array bc]] [println [cat [ansi-blue [string/pad-start [string [car a]] 6]] " - " [cdr a]]]]]] #{##[disassemble/bytecode-array bc ΓεnΣym-3 a println cat ansi-blue string/pad-start string " - "]
151A00051A010504011A02070D1A02050B0048241B09003A0D1C1A0205111A03
070D1A04051A05051A06051A07051A08051A03051104010206040204011A091A
030512040304010D1A0205121A02081A02050AFFC6090004241601
} disassemble [bc] #@[documentation: "Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," source: ["Disassemble the bytecode array CODE, turning it into a list of dotted pairs, with the car containing the offset and the cdr containing assembler S-Expressions," [case [type-of bc] [[:lambda :macro] [disassemble/print [closure/code bc]]] [:bytecode-array [disassemble/print bc]] [otherwise [throw [list :type-error "Can't disassemble that" bc [current-lambda]]]]]]] #{##[type-of bc ΓεnΣym-4 :lambda :macro #f disassemble/print closure/code :bytecode-array throw list :type-error "Can't disassemble that" current-lambda]
151A00051A010504011A02070D1A02051A03200C0A00110D1A02051A04200C0A
00060D1A050B00131A06051A07051A01050401040109002D1A02051A08200B00
0E1A06051A010504010900191A09051A0A051A0B1A0C1A01051A0D0504000404
04011601
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A14070D1A181A191A1A1A1B171A18070D1A1C1A1D1A
1E1A1F171A1C070D1A201A211A221A23171A20070D1A241A251A261A27171A24
070D1A281A291A2A1A2B171A28070D1A2C1A2D1A2E1A2F171A2C0701
}#{##[compile/backend/none [expr] #@[source: [expr]] #{##[expr]
1A000501
} compile/backend/bytecode [expr] #@[source: [[-> [bytecompile expr] assemble*]]] #{##[assemble* bytecompile expr]
1A00051A01051A02050401040101
} :bytecode *active-backend* tree/new :none backend/tree backend [expr] #@[source: [[[tree/ref backend/tree *active-backend*] expr]]] #{##[tree/ref backend/tree *active-backend* expr]
1A00051A01051A020504021A0305040101
} compile/for [backend expr environment] #@[source: [[def last-backend *active-backend*] [def ret #nil] [try [fn [e] [set! *active-backend* last-backend] [throw e]] [set! *active-backend* backend] [set! ret [compile expr environment]] [set! *active-backend* last-backend] [return ret]]]] #{##[*active-backend* last-backend ret anonymous [e] #@[source: [[set! *active-backend* last-backend] [throw e]]] #{##[last-backend *active-backend* throw e]
1A00051A01080D1A02051A0305040101
} backend compile* expr current-closure]
1A00051A01070D241A02070D1A031A041A051A06171900271A07051A00080D1A
08051A09051A0A05040004021A02080D1A01051A00080D1A0205011601
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A09070D
1A0A051A081A04051A0B1A000504041A0C070D1A0D1A0E1A0F1A10171A0D070D
1A111A121A131A14171A110701
}#{##[load/forms [source environment] #@[documentation: "Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" source: ["Load multiple forms, evaluating the results in environment, so we can make use of macros we just defined" [doseq [form source] [apply environment [compile* source environment]]]]] #{##[source ΓεnΣym-1 form apply environment compile*]
151A00051A01070D1A01050B0036241B0900280D1C1A0105111A02070D1A0305
1A04051A05051A00051A0405040204020D1A0105121A01081A01050AFFD80900
04241601
} macroexpand/forms [source-raw environment] #@[documentation: "Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined." source: ["Expand multiple forms, evaluating the source in a temporary environment, so we can make use of macros we just defined." [when-not environment [set! environment [environment*]]] [load/forms source-raw environment] [macroexpand source-raw environment]]] #{##[environment load/forms source-raw macroexpand]
1A00050B00072409000B15240D13161A00080D1A01051A02051A000504020D1A
03051A02051A0005040201
} compile* [source environment] #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [-> [macroexpand source environment] constant-fold backend]]] #{##[backend constant-fold macroexpand source environment]
1A00051A01051A02051A03051A040504020401040101
} compile/debug [expr] #@[source: [[disassemble [compile expr]]]] #{##[disassemble compile* expr current-closure]
1A00051A01051A02051A030504000402040101
} compile/do* [source environment] #@[source: [[compile* [cons do source] environment]]] #{##[compile* do source environment]
1A00051A01051A0205141A0305040201
} compile [source] #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [quasiquote [compile* [unquote source] [current-closure]]]]] #{##[compile* source current-closure]
1A001A01051A0224142414141401
} compile/do [source] #@[documentation: "Compile SOURCE so it can be evaluated/applied" source: ["Compile SOURCE so it can be evaluated/applied" [quasiquote [compile* [cons do [unquote source]] [current-closure]]]]] #{##[compile* cons do source current-closure]
1A001A011A021A0305241414141A0424142414141401
} meta/parse/body [type args body] #@[source: [[def meta [tree/new #nil]] [doseq [v body] [case [type-of v] [:pair [return meta]] [:string [tree/set! meta :documentation [trim [cat [string [tree/ref meta :documentation]] "\n" v]]]] [:keyword [tree/set! meta v #t]]]] [return meta]]] #{##[tree/new meta body ΓεnΣym-2 v type-of ΓεnΣym-3 :pair :string tree/set! :documentation trim cat string tree/ref "\n" :keyword #t]
1A00052404011A01070D151A02051A03070D1A03050B008F241B0900810D1C1A
0305111A04070D151A05051A040504011A06070D1A06051A07200B000A1A0105
010900511A06051A08200B002E1A09051A01051A0A1A0B051A0C051A0D051A0E
051A01051A0A040204011A0F1A040504030401040309001D1A06051A10200B00
131A09051A01051A04051A11040309000424160D1A0305121A03081A03050AFF
7F09000424160D1A01050101
} defmacro [name args . body] #@[documentation: "Define a new macro" source: ["Define a new macro" [quasiquote [def [unquote name] [macro* '[unquote name] '[unquote args] [unquote [tree/set! [meta/parse/body :macro args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]]] #{##[def name macro* quote args tree/set! meta/parse/body :macro body :source compile/do* current-closure]
1A001A01051A021A031A01052414141A031A04052414141A05051A06051A071A
04051A080504031A091A080504031A031A0A051A08051A0B0504000402241414
2414141414142414141401
} fn [args . body] #@[documentation: "Define an anonymous function" source: ["Define an anonymous function" [quasiquote [fn* 'anonymous '[unquote args] [unquote [tree/set! [meta/parse/body :lambda args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]] #{##[fn* quote anonymous args tree/set! meta/parse/body :lambda body :source compile/do* current-closure]
1A001A011A022414141A011A03052414141A04051A05051A061A03051A070504
031A081A070504031A011A09051A07051A0A0504000402241414241414141414
01
} defn [name args . body] #@[documentation: "Define a new function" source: ["Define a new function" [quasiquote [def [unquote name] [fn* '[unquote name] '[unquote args] [unquote [tree/set! [meta/parse/body :lambda args body] :source body]] '[unquote [compile/do* body [current-closure]]]]]]]] #{##[def name fn* quote args tree/set! meta/parse/body :lambda body :source compile/do* current-closure]
1A001A01051A021A031A01052414141A031A04052414141A05051A06051A071A
04051A080504031A091A080504031A031A0A051A08051A0B0504000402241414
2414141414142414141401
} eval-in [closure expr] #@[documentation: "Compile and the immediatly evaluate the result\nMostly used by lRun()" source: ["Compile and the immediatly evaluate the result" "" "Mostly used by lRun()" [try display/error [apply closure [compile* expr closure]]]]] #{##[display/error apply closure compile* expr]
1A00051900171A01051A02051A03051A04051A0205040204021601
} eval [expr] #@[documentation: "Compile, Evaluate and then return the result of EXPR" source: ["Compile, Evaluate and then return the result of EXPR" [quasiquote [eval-in [current-closure] [unquote expr]]]]] #{##[eval-in current-closure expr]
1A001A0124141A02052414141401
} typecheck/only [v t] #@[source: [[quasiquote [when-not [= [type-of [unquote v]] [unquote t]] [throw [list :type-error [unquote [fmt "Expected a value of type {t}"]] [unquote v] [current-lambda]]]]]]] #{##[when-not = type-of v t throw list :type-error cat "Expected a value of type " current-lambda]
1A001A011A021A03052414141A0405241414141A051A061A071A08051A091A04
0504021A03051A0A24142414141414142414142414141401
} typecheck/numeric/single [v] #@[source: [[quasiquote [when-not [numeric? [unquote v]] [throw [list :type-error [unquote [fmt "Expected numeric value"]] [unquote v] [current-lambda]]]]]]] #{##[when-not numeric? v throw list :type-error "Expected numeric value" current-lambda]
1A001A011A02052414141A031A041A051A061A02051A07241424141414141424
14142414141401
} typecheck/numeric v #@[source: [[map v typecheck/numeric/single]]] #{##[map v typecheck/numeric/single]
1A00051A01051A0205040201
} profile-form [raw] #@[source: [[def start-time [time/milliseconds]] [def val [eval raw]] [def end-time [time/milliseconds]] [display [cat "Evaluating " [ansi-yellow [string/write raw]] " to " [ansi-green [string/write val]] " took " [ansi-red [cat [- end-time start-time] "ms"] "\n"]]]]] #{##[time/milliseconds start-time eval-in current-closure raw val end-time print cat "Evaluating " ansi-yellow string/write " to " ansi-green " took " ansi-red "ms" "\n"]
1A000504001A01070D1A02051A030504001A040504021A05070D1A000504001A
06070D1A07051A08051A091A0A051A0B051A0405040104011A0C1A0D051A0B05
1A0505040104011A0E1A0F051A08051A06051A0105261A1004021A1104020406
040101
} profile body #@[documentation: "Measure and display how much time and ressources it takes for BODY to be evaluated" source: ["Measure and display how much time and ressources it takes for BODY to be evaluated" [quasiquote [profile-form '[unquote [if [last? body] [car body] [cons 'do body]]]]]]] #{##[profile-form quote nil? body do]
1A001A011A02051A03051204010B000A1A0305110900091A041A030514241414
24141401
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17181A14070D1A181A191A1A1A1B181A18070D1A1C1A1D1A
1E1A1F171A1C070D1A201A211A221A23181A20070D1A241A251A261A27181A24
070D1A281A291A2A1A2B181A28070D1A2C1A2D1A2E1A2F171A2C070D1A301A31
1A321A33181A30070D1A341A351A361A37181A34070D1A381A391A3A1A3B171A
38070D1A3C1A3D1A3E1A3F181A3C070D1A401A411A421A43171A40070D1A441A
451A461A47181A440701
}#{##[pure? [expr] #@[source: [[and [not [pair? expr]] [not [symbol? expr]] #t]]] #{##[pair? expr #f #t symbol?]
1A00051A010504010B00081A020900051A030C0B001D0D1A04051A010504010B
00081A020900051A030C0B00060D1A0301
} constant-foldable? [fun] #@[source: [[case fun [[add/int bit-and bit-or bit-xor bit-not bit-shift-left bit-shift-right popcount abs sqrt pow rem + - * / cat trim string/length uppercase lowercase capitalize] #t] [['add/int 'bit-and 'bit-or 'bit-xor 'bit-not 'bit-shift-left 'bit-shift-right 'popcount 'abs 'sqrt 'pow 'rem '+ '- '* '/ 'cat 'trim 'string/length 'uppercase 'lowercase 'capitalize] #t] [#t #f]]]] #{##[fun ΓεnΣym-1 add/int bit-and bit-or bit-xor bit-not bit-shift-left bit-shift-right popcount abs sqrt pow rem + - * / cat trim string/length uppercase lowercase capitalize #f #t]
151A00051A01070D1A01051A0205200C0A01020D1A01051A0305200C0A00F60D
1A01051A0405200C0A00EA0D1A01051A0505200C0A00DE0D1A01051A0605200C
0A00D20D1A01051A0705200C0A00C60D1A01051A0805200C0A00BA0D1A01051A
0905200C0A00AE0D1A01051A0A05200C0A00A20D1A01051A0B05200C0A00960D
1A01051A0C05200C0A008A0D1A01051A0D05200C0A007E0D1A01051A0E05200C
0A00720D1A01051A0F05200C0A00660D1A01051A1005200C0A005A0D1A01051A
1105200C0A004E0D1A01051A1205200C0A00420D1A01051A1305200C0A00360D
1A01051A1405200C0A002A0D1A01051A1505200C0A001E0D1A01051A1605200C
0A00120D1A01051A1705200C0A00060D1A180B00081A1909010E1A01051A0220
0C0A00ED0D1A01051A03200C0A00E20D1A01051A04200C0A00D70D1A01051A05
200C0A00CC0D1A01051A06200C0A00C10D1A01051A07200C0A00B60D1A01051A
08200C0A00AB0D1A01051A09200C0A00A00D1A01051A0A200C0A00950D1A0105
1A0B200C0A008A0D1A01051A0C200C0A007F0D1A01051A0D200C0A00740D1A01
051A0E200C0A00690D1A01051A0F200C0A005E0D1A01051A10200C0A00530D1A
01051A11200C0A00480D1A01051A12200C0A003D0D1A01051A13200C0A00320D
1A01051A14200C0A00270D1A01051A15200C0A001C0D1A01051A16200C0A0011
0D1A01051A17200C0A00060D1A180B00081A190900121A01051A19200B00081A
18090004241601
} constant-fold/resolve [sym] #@[source: [[when-not [symbol? sym] [return sym]] [resolve sym]]] #{##[symbol? sym resolve]
1A00051A010504010B0007240900071A0105010D1A02051A0105040101
} constant-fold/args [expr] #@[source: [[when-not expr [return expr]] [if [pair? [car expr]] [cons [constant-fold [car expr]] [constant-fold/args [cdr expr]]] [cons [car expr] [constant-fold/args [cdr expr]]]]]] #{##[expr pair? constant-fold constant-fold/args]
1A00050B0007240900071A0005010D1A01051A00051104010B00191A02051A00
051104011A03051A0005120401140900111A0005111A03051A00051204011401
} constant-fold [expr] #@[documentation: "Will try and evaluate as many constant as possible to make the expression simpler." source: ["Will try and evaluate as many constant as possible to make the expression simpler." [if-not [pair? expr] expr [do [def folded-fun [car expr]] [when [= 'quote folded-fun] [return expr]] [def folded-args [constant-fold/args [cdr expr]]] [if [and [constant-foldable? folded-fun] [every? folded-args pure?]] [try [fn [] [cons folded-fun folded-args]] [apply [constant-fold/resolve folded-fun] folded-args]] [cons folded-fun folded-args]]]]]] #{##[pair? expr folded-fun quote constant-fold/args folded-args constant-foldable? every? pure? anonymous [] #@[source: [[cons folded-fun folded-args]]] #{##[folded-fun folded-args]
1A00051A01051401
} apply constant-fold/resolve]
1A00051A010504010B006F1A0105111A02070D1A031A0205200B000A1A010501
090004240D1A04051A01051204011A05070D1A06051A020504010C0B000F0D1A
07051A05051A080504020B00231A091A0A1A0B1A0C171900141A0D051A0E051A
020504011A050504021609000A1A02051A0505140900061A010501
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
01
}#{##[macroexpand/do/args [args env] #@[source: [[if [last? args] [cons [macroexpand* [car args] env] #nil] [if [pair? [car args]] [let* [def ocar [macroexpand* [car args] env]] [if [pair? ocar] [cons ocar [macroexpand/do/args [cdr args] env]] [macroexpand/do/args [cdr args] env]]] [macroexpand/do/args [cdr args] env]]]]] #{##[nil? args macroexpand* env pair? ocar macroexpand/do/args]
1A00051A01051204010B00141A02051A0105111A03050402241409005A1A0405
1A01051104010B0042151A02051A0105111A030504021A05070D1A04051A0505
04010B00161A05051A06051A0105121A030504021409000F1A06051A0105121A
030504021609000F1A06051A0105121A0305040201
} macroexpand/do [source env] #@[source: [[def args [macroexpand/do/args source env]] [if [last? args] [car args] [cons 'do args]]]] #{##[macroexpand/do/args source env args nil? do]
1A00051A01051A020504021A03070D1A04051A03051204010B000A1A03051109
00091A051A03051401
} macroexpand/form [source env op arity implicit-do? no-expand-bitmap] #@[source: [[def ret [cons op #nil]] [def l [cdr source]] [dotimes [i arity] [set! ret [cons [if [bit-set? no-expand-bitmap i] [car l] [macroexpand* [car l] env]] ret]] [cdr! l]] [if implicit-do? [set! ret [cons [macroexpand/do l env] ret]] [when l [throw [list :arity-error [cat "form contains more than " arity " arguments"] source [current-lambda]]]]] [return [nreverse ret]]]] #{##[op ret source l i bit-set? no-expand-bitmap macroexpand* env arity implicit-do? macroexpand/do throw list :arity-error cat "form contains more than " " arguments" current-lambda nreverse]
1A000524141A01070D1A0205121A03070D1502001A04070D241B09003F0D1C1A
05051A06051A040504020B000A1A03051109000F1A07051A0305111A08050402
1A0105141A01080D1A0305121A03080D02011A0405031A04081A04051A09051E
0AFFBD0D24160D1A0A050B00181A0B051A03051A080504021A0105141A010809
002D1A03050B00261A0C051A0D051A0E1A0F051A101A09051A1104031A02051A
1205040004040401090004240D1A13051A010504010101
} macroexpand/fold [op source env] #@[source: [[if [cdr source] [if [cddr source] [list op [macroexpand/fold op [except-last-pair source] env] [macroexpand* [car [last-pair source]] env]] [list op [macroexpand* [car source] env] [macroexpand* [cadr source] env]]] [list op [macroexpand* [car source] env]]]]] #{##[source list op macroexpand/fold except-last-pair env macroexpand* last-pair]
1A0005120B005E1A000512120B00321A01051A02051A03051A02051A04051A00
0504011A050504031A06051A07051A00050401111A0505040204030900241A01
051A02051A06051A0005111A050504021A06051A000512111A05050402040309
00171A01051A02051A06051A0005111A05050402040201
} macroexpand* [source env] #@[documentation: "Expand all macros within source" source: ["Expand all macros within source" [def op [if [resolves? [car source] env] [resolve [car source] env] [car source]]] [case [type-of op] [:nil source] [:native-function [case op [[+ - * / rem bit-and bit-or bit-xor] [macroexpand/fold op [cdr source]]] [do [macroexpand/do source env]] [return [macroexpand/form source env op 1 #f 0]] [[try while] [macroexpand/form source env op 1 #t 0]] [[def set!] [macroexpand/form source env op 2 #f 1]] [if [macroexpand/form source env op 3 #f 0]] [[fn* macro*] [macroexpand/form source env op 4 #t 7]] [[let* environment*] [list op [macroexpand/do [cdr source] env]]] 'source [otherwise [map source [fn [α] [macroexpand* α env]]]]]] [:macro [macroexpand* [macro-apply op [cdr source]] env]] [otherwise [map source [fn [α] [macroexpand* α env]]]]]]] #{##[resolves? source env resolve op type-of ΓεnΣym-1 :nil :native-function ΓεnΣym-2 + - * / rem bit-and bit-or bit-xor #f macroexpand/fold do macroexpand/do return macroexpand/form try while #t def set! if fn* macro* let* environment* list quote map anonymous [α] #@[source: [[macroexpand* α env]]] #{##[macroexpand* α env]
1A00051A01051A0205040201
} :macro macroexpand* macro-apply [α] #{##[macroexpand* α env]
1A00051A01051A0205040201
}]
1A00051A0105111A020504020B00121A03051A0105111A020504020900071A01
05111A04070D151A05051A040504011A06070D1A06051A07200B00091A010509
02081A06051A08200B01CE151A04051A09070D1A09051A0A05200C0A005A0D1A
09051A0B05200C0A004E0D1A09051A0C05200C0A00420D1A09051A0D05200C0A
00360D1A09051A0E05200C0A002A0D1A09051A0F05200C0A001E0D1A09051A10
05200C0A00120D1A09051A1105200C0A00060D1A120B00121A13051A04051A01
0512040209014E1A09051A1405200B00111A15051A01051A020504020901361A
09051A1605200B001A1A17051A01051A02051A040502011A1202000406090115
1A09051A1805200C0A00120D1A09051A1905200C0A00060D1A120B001A1A1705
1A01051A02051A040502011A1A020004060900E11A09051A1B05200C0A00120D
1A09051A1C05200C0A00060D1A120B001A1A17051A01051A02051A040502021A
12020104060900AD1A09051A1D05200B001A1A17051A01051A02051A04050203
1A120200040609008C1A09051A1E05200C0A00120D1A09051A1F05200C0A0006
0D1A120B001A1A17051A01051A02051A040502041A1A020704060900581A0905
1A2005200C0A00120D1A09051A2105200C0A00060D1A120B001A1A22051A0405
1A15051A0105121A0205040204020900241A09051A2305200B00091A01050900
141A24051A01051A251A261A271A28170402160900341A06051A29200B001A1A
2A051A2B051A04051A01051204021A020504020900141A24051A01051A251A2C
1A271A2D1704021601
} macroexpand [source env] #@[documentation: "Macroexpand the forms in source" source: ["Macroexpand the forms in source" [macroexpand* source [or env [current-closure]]]]] #{##[macroexpand* source env current-closure #f]
1A00051A01051A02050C0A00100D1A030504000C0A00060D1A04040201
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A140701
}#{##[let/arg [arg] #@[source: [[when arg [when [or [not [pair? arg]] [not [symbol? [car arg]]]] [throw [list :invalid-let-form "Please fix the structure of the let form" arg]]] [quasiquote [def [unquote [car arg]] [unquote [cadr arg]]]]]]] #{##[arg pair? #f #t symbol? throw list :invalid-let-form "Please fix the structure of the let form" def]
1A00050B005F1A01051A000504010B00081A020900051A030C0A001E0D1A0405
1A00051104010B00081A020900051A030C0A00060D1A020B00171A05051A0605
1A071A081A000504030401090004240D1A091A0005111A000512112414141409
00042401
} let/args [args] #@[source: [[if-not args #nil [cons [let/arg [car args]] [let/args [cdr args]]]]]] #{##[args let/arg let/args]
1A00050B00191A01051A00051104011A02051A0005120401140900042401
} let [bindings . body] #@[documentation: "Evalutes to BODY if PRED is true" source: ["Evalutes to BODY if PRED is true" [quasiquote [let* [do [unquote-splicing [let/args bindings]] [unquote-splicing body]]]]]] #{##[let* do append let/args bindings body]
1A001A011A02051A03051A040504011A02051A050524040204021424141401
} if-let [binding then else] #@[source: [[quasiquote [let* [def [unquote [car binding]] [unquote [cadr binding]]] [if [unquote [car binding]] [unquote then] [unquote else]]]]]] #{##[let* def binding if then else]
1A001A011A0205111A02051211241414141A031A0205111A04051A0505241414
14142414141401
} when-let [binding . body] #@[source: [[quasiquote [if-let [unquote binding] [unquote [cons 'do body]] #nil]]]] #{##[if-let binding do body]
1A001A01051A021A03051424241414141401
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B181A08070D1A0C1A0D1A0E1A0F181A0C070D1A101A111A121A13181A1007
01
}#{##[#t otherwise deftest l #@[source: []] #{##[]
2401
} defqtest #{##[]
2401
} comment body #@[documentation: "Does nothing" source: ["Does nothing" #nil]] #{##[]
2401
} += [val inc] #@[source: [[quasiquote [set! [unquote val] [+ [unquote val] [unquote inc]]]]]] #{##[set! val + inc]
1A001A01051A021A01051A0305241414142414141401
} cdr! [l] #@[documentation: "[set! l [cdr l]]" source: ["[set! l [cdr l]]" [quasiquote [set! [unquote l] [cdr [unquote l]]]]]] #{##[set! l cdr]
1A001A01051A021A01052414142414141401
} boolean [v] #@[documentation: "Coerce to boolean" source: [:inline "Coerce to boolean" [if v #t #f]] inline: #t] #{##[v #t #f]
1A00050B00081A010900051A0201
} not [v] #@[documentation: "Return true if V is false" source: [:inline "Return true if V is false" [if v #f #t]] inline: #t] #{##[v #f #t]
1A00050B00081A010900051A0201
} identity [α] #@[documentation: "Returns its argument" source: [:inline "Returns its argument" α] inline: #t] #{##[α]
1A000501
} list arguments #@[documentation: "Return ARGUMENTS as a list" source: ["Return ARGUMENTS as a list" arguments]] #{##[arguments]
1A000501
} caar [p] #@[documentation: "[car [car p]]" source: [:inline "[car [car p]]" [car [car p]]] inline: #t] #{##[p]
1A0005111101
} cadr [p] #@[documentation: "[car [cdr p]]" source: [:inline "[car [cdr p]]" [car [cdr p]]] inline: #t] #{##[p]
1A0005121101
} cdar [p] #@[documentation: "[cdr [car p]]" source: [:inline "[cdr [car p]]" [cdr [car p]]] inline: #t] #{##[p]
1A0005111201
} cddr [p] #@[documentation: "[cdr [cdr p]]" source: [:inline "[cdr [cdr p]]" [cdr [cdr p]]] inline: #t] #{##[p]
1A0005121201
} cadar [p] #@[documentation: "[cdr [car p]]" source: ["[cdr [car p]]" [car [cdr [car p]]]]] #{##[p]
1A000511121101
} caddr [p] #@[documentation: "[car [cdr [cdr p]]]" source: ["[car [cdr [cdr p]]]" [car [cdr [cdr p]]]]] #{##[p]
1A000512121101
} cdddr [p] #@[documentation: "[cdr [cdr [cdr p]]]" source: ["[cdr [cdr [cdr p]]]" [cdr [cdr [cdr p]]]]] #{##[p]
1A000512121201
} cadddr [p] #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [car [cdr [cdr [cdr p]]]]]] #{##[p]
1A00051212121101
} cddddr [p] #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [cdr [cdr [cdr [cdr p]]]]]] #{##[p]
1A00051212121201
} caddddr [p] #@[documentation: "[car [cdr [cdr [cdr p]]]]" source: ["[car [cdr [cdr [cdr p]]]]" [car [cdr [cdr [cdr [cdr p]]]]]]] #{##[p]
1A0005121212121101
} cdddddr [p] #@[documentation: "[cdr [cdr [cdr [cdr p]]]]" source: ["[cdr [cdr [cdr [cdr p]]]]" [cdr [cdr [cdr [cdr [cdr p]]]]]]] #{##[p]
1A0005121212121201
} keyword->string [α] #@[source: [[when-not [keyword? α] [throw [list :type-error "[keyword->string] can only be called on keywords" α [current-lambda]]]] [symbol->string [keyword->symbol α]]]] #{##[keyword? α throw list :type-error "[keyword->string] can only be called on keywords" current-lambda symbol->string keyword->symbol]
1A00051A010504010B0007240900191A02051A03051A041A051A01051A060504
00040404010D1A07051A08051A01050401040101
} string->keyword [α] #@[source: [[when-not [string? α] [throw [list :type-error "[string->keyword] can only be called on strings" α [current-lambda]]]] [symbol->keyword [string->symbol α]]]] #{##[string? α throw list :type-error "[string->keyword] can only be called on strings" current-lambda symbol->keyword string->symbol]
1A00051A010504010B0007240900191A02051A03051A041A051A01051A060504
00040404010D1A07051A08051A01050401040101
} exception [type description value] #@[source: [[quasiquote [throw [list [unquote type] [unquote description] [unquote value] [current-lambda]]]]]] #{##[throw list type description value current-lambda]
1A001A011A02051A03051A04051A05241424141414141424141401
}]
1A001A01070D1A021A031A041A05181A02070D1A061A031A041A07181A06070D
1A081A091A0A1A0B181A08070D1A0C1A0D1A0E1A0F181A0C070D1A101A111A12
1A13181A10070D1A141A151A161A17171A14070D1A181A191A1A1A1B171A1807
0D1A1C1A1D1A1E1A1F171A1C070D1A201A211A221A23171A20070D1A241A251A
261A27171A24070D1A281A291A2A1A2B171A28070D1A2C1A2D1A2E1A2F171A2C
070D1A301A311A321A33171A30070D1A341A351A361A37171A34070D1A381A39
1A3A1A3B171A38070D1A3C1A3D1A3E1A3F171A3C070D1A401A411A421A43171A
40070D1A441A451A461A47171A44070D1A481A491A4A1A4B171A48070D1A4C1A
4D1A4E1A4F171A4C070D1A501A511A521A53171A50070D1A541A551A561A5717
1A54070D1A581A591A5A1A5B181A580701
}#{##[if-not [pred then else] #@[source: [[quasiquote [if [unquote pred] [unquote else] [unquote then]]]]] #{##[if pred else then]
1A001A01051A02051A0305241414141401
} when-not [pred . body] #@[documentation: "Evalutes to BODY if PRED is false" source: ["Evalutes to BODY if PRED is false" [quasiquote [if [unquote pred] #nil [do [unquote-splicing body]]]]]] #{##[if pred do append body]
1A001A0105241A021A03051A040524040214241414141401
} when [pred . body] #@[documentation: "Evalutes to BODY if PRED is true" source: ["Evalutes to BODY if PRED is true" [quasiquote [if [unquote pred] [do [unquote-splicing body]] #nil]]]] #{##[if pred do append body]
1A001A01051A021A03051A04052404021424241414141401
} case/clauses/multiple [key-sym cases] #@[source: [[when cases [cons [list '= key-sym [car cases]] [case/clauses/multiple key-sym [cdr cases]]]]]] #{##[cases list = key-sym case/clauses/multiple]
1A00050B00211A01051A021A03051A00051104031A04051A03051A0005120402
140900042401
} case/clauses [key-sym clauses] #@[source: [[when clauses [if [= [caar clauses] 'otherwise] [cons 'do [cdar clauses]] [list 'if [if [pair? [caar clauses]] [if [and [= [car [caar clauses]] 'quote] [last? [cdr [caar clauses]]] [symbol? [cadr [caar clauses]]]] [list '= key-sym [caar clauses]] [cons 'or [case/clauses/multiple key-sym [caar clauses]]]] [list '= key-sym [caar clauses]]] [cons 'do [cdar clauses]] [case/clauses key-sym [cdr clauses]]]]]]] #{##[clauses otherwise do list if pair? quote nil? symbol? = key-sym or case/clauses/multiple case/clauses]
1A00050B00A61A000511111A01200B000E1A021A000511121409008D1A03051A
041A05051A0005111104010B00561A00051111111A06200C0B00210D1A07051A
00051111121204010C0B00100D1A08051A00051111121104010B00151A03051A
091A0A051A0005111104030900131A0B1A0C051A0A051A000511110402140900
121A03051A091A0A051A0005111104031A021A00051112141A0D051A0A051A00
0512040204040900042401
} case [key-form . clauses] #@[source: [[def key-sym [gensym]] [list 'let* [list 'def key-sym key-form] [case/clauses key-sym clauses]]]] #{##[gensym key-sym list let* def key-form case/clauses clauses]
1A000504001A01070D1A02051A031A02051A041A01051A050504031A06051A01
051A07050402040301
} cond body #@[documentation: "Contains multiple cond clauses" source: ["Contains multiple cond clauses" [when [and body [caar body]] [list 'if [caar body] [cons 'do [cdar body]] [macro-apply cond [cdr body]]]]]] #{##[body list if do macro-apply cond]
1A00050C0B00090D1A000511110B00261A01051A021A000511111A031A000511
12141A04051A05051A000512040204040900042401
} dotimes [binding . body] #@[documentation: "binding => [name n result-form]\nRepeatedly executes body with name bound to integers from 0 through n-1. Returns result-form or #nil." source: ["binding => [name n result-form]" "Repeatedly executes body with name bound to integers from 0 through n-1. Returns result-form or #nil." [def sym [car binding]] [typecheck/only sym :symbol] [def times [cadr binding]] [def result-form [caddr binding]] [quasiquote [let [[[unquote sym] 0]] [while [< [unquote sym] [unquote times]] [unquote-splicing body] [set! [unquote sym] [add/int 1 [unquote sym]]]] [unquote result-form]]]]] #{##[binding sym type-of :symbol throw list :type-error "Expected a value of type :symbol" current-lambda times caddr result-form let while < append body set! add/int]
1A0005111A01070D1A02051A010504011A03200B0007240900191A04051A0505
1A061A071A01051A08050400040404010D1A000512111A09070D1A0A051A0005
04011A0B070D1A0C1A0105020024141424141A0D1A0E1A01051A090524141414
1A0F051A10051A111A01051A1202011A01052414141424141414241404021414
1A0B05241414141401
} doseq [for-loop . body] #@[documentation: "[doseq [l [list 1 2 3 4]] [println l]]" source: ["[doseq [l [list 1 2 3 4]] [println l]]" [def symbol-name [gensym]] [quasiquote [let [[[unquote symbol-name] [unquote [cadr for-loop]]]] [when [unquote symbol-name] [while [unquote symbol-name] [def [unquote [car for-loop]] [car [unquote symbol-name]]] [unquote-splicing body] [cdr! [unquote symbol-name]]]]]]]] #{##[gensym symbol-name let for-loop when while def car append body cdr!]
1A000504001A01070D1A021A01051A0305121124141424141A041A01051A051A
01051A061A0305111A071A0105241414241414141A08051A09051A0A1A010524
141424140402141414241414142414141401
} thread/-> [init fun] #@[source: [[if-not fun init [if [pair? [car fun]] [quasiquote [[unquote [caar fun]] [unquote [thread/-> init [cdr fun]]] [unquote-splicing [cdar fun]]]] [list [car fun] [thread/-> init [cdr fun]]]]]]] #{##[fun pair? thread/-> init append list]
1A00050B00481A01051A00051104010B00241A000511111A02051A03051A0005
1204021A04051A0005111224040214140900181A05051A0005111A02051A0305
1A000512040204020900061A030501
} -> [init . fun] #@[documentation: "Thread init as the first argument through every function in fun" source: ["Thread init as the first argument through every function in fun" [thread/-> init [reverse fun]]]] #{##[thread/-> init reverse fun]
1A00051A01051A02051A03050401040201
} thread/->> [init fun] #@[source: [[if-not fun init [append [car fun] [cons [thread/->> init [cdr fun]] #nil]]]]] #{##[fun append thread/->> init]
1A00050B001D1A01051A0005111A02051A03051A000512040224140402090006
1A030501
} ->> [init . fun] #@[documentation: "Thread init as the last argument through every function in fun" source: ["Thread init as the last argument through every function in fun" [thread/->> init [reverse fun]]]] #{##[thread/->> init reverse fun]
1A00051A01051A02051A03050401040201
}]
1A001A011A021A03181A00070D1A041A051A061A07181A04070D1A081A091A0A
1A0B181A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17181A14070D1A181A191A1A1A1B181A18070D1A1C1A1D1A
1E1A1F181A1C070D1A201A211A221A23181A20070D1A241A251A261A27171A24
070D1A281A291A2A1A2B181A28070D1A2C1A2D1A2E1A2F171A2C070D1A301A31
1A321A33181A300701
}#{##[tree/new module/cache module/loader module/add-loader [f] #@[source: [[set! module/loader [cons f module/loader]]]] #{##[f module/loader]
1A00051A0105141A010801
} module/save-state [] #@[source: [[tree/new :cache module/cache :loader module/loader]]] #{##[tree/new :cache module/cache :loader module/loader]
1A00051A011A02051A031A0405040401
} module/restore-state [c] #@[source: [[set! module/cache [tree/ref c :cache]] [set! module/loader [tree/ref c :loader]]]] #{##[tree/ref c :cache module/cache :loader module/loader]
1A00051A01051A0204021A03080D1A00051A01051A0404021A050801
} module/qualify-symbol [module-name symbol] #@[source: [[string->symbol [cat [keyword->symbol module-name] "/" [string symbol]]]]] #{##[string->symbol cat keyword->symbol module-name "/" string symbol]
1A00051A01051A02051A030504011A041A05051A060504010403040101
} module body #@[documentation: "Define a new module and return it" source: ["Define a new module and return it" [macroexpand [cons 'environment* [cons '[def exports [tree/new #nil]] body]]]]] #{##[macroexpand environment* [def exports [tree/new #nil]] body]
1A00051A011A021A03051414040101
} defmodule [name . body] #@[documentation: "Define a new named module" source: ["Define a new named module" [quasiquote [module/insert [unquote name] [unquote [cons module body]]]]]] #{##[module/insert name module body]
1A001A01051A02051A0305142414141401
} export [name value] #@[source: [[quasiquote [tree/set! exports '[unquote name] [unquote value]]]]] #{##[tree/set! exports quote name value]
1A001A011A021A03052414141A0405241414141401
} require* [module env qualify?] #@[source: [[def mod [module/load module]] [def exports [resolve 'exports mod]] [doseq [k [tree/keys exports]] [def q [if qualify? [module/qualify-symbol module [keyword->symbol k]] [keyword->symbol k]]] [def expr [quasiquote [def [unquote q] [module/import [unquote mod] '[unquote [keyword->symbol k]]]]]] [apply env [compile* expr env]]]]] #{##[module/load module mod resolve exports tree/keys ΓεnΣym-1 k qualify? module/qualify-symbol keyword->symbol q def module/import quote expr apply env compile*]
1A00051A010504011A02070D1A03051A041A020504021A04070D151A05051A04
0504011A06070D1A06050B007E241B0900700D1C1A0605111A07070D1A08050B
00161A09051A01051A0A051A07050401040209000B1A0A051A070504011A0B07
0D1A0C1A0B051A0D1A02051A0E1A0A051A070504012414142414141424141414
1A0F070D1A10051A11051A12051A0F051A1105040204020D1A0605121A06081A
06050AFF90090004241601
} use [module] #@[source: [[quasiquote [require* [unquote module] [current-closure] #f]]]] #{##[require* module current-closure #f]
1A001A01051A0224141A03241414141401
} require [module] #@[source: [[quasiquote [require* [unquote module] [current-closure] #t]]]] #{##[require* module current-closure #t]
1A001A01051A0224141A03241414141401
} import* [local-symbol module module-symbol] #@[source: [[quasiquote [def [unquote local-symbol] [module/import [unquote module] '[unquote module-symbol]]]]]] #{##[def local-symbol module/import module quote module-symbol]
1A001A01051A021A03051A041A0505241414241414142414141401
} import [names module] #@[source: [[when-not [list? names] [return [quasiquote [import* [unquote names] [module/load [unquote module]] [unquote names]]]]] [def ret #nil] [while names [if [= [cadr names] :as] [do [set! ret [cons [quasiquote [import* [unquote [caddr names]] [module/load [unquote module]] [unquote [car names]]]] ret]] [set! names [cddr names]]] [set! ret [cons [quasiquote [import* [unquote [car names]] [module/load [unquote module]] [unquote [car names]]]] ret]]] [cdr! names]] [cons do [nreverse ret]]]] #{##[list? names import* module/load module ret :as caddr do nreverse]
1A00051A010504010B0007240900191A021A01051A031A04052414141A010524
14141414010D241A05070D241B0900640D1C1A010512111A06200B00311A021A
07051A010504011A031A04052414141A01051124141414141A0505141A05080D
1A010512121A01080900211A021A0105111A031A04052414141A010511241414
14141A0505141A05080D1A0105121A01081A01050AFF9C0D1A08051A09051A05
0504011401
} module/load/external [name] #@[source: [[doseq [loader module/loader] [def mod [loader name]] [when mod [return mod]]] [return #nil]]] #{##[module/loader ΓεnΣym-2 loader name mod]
151A00051A01070D1A01050B003D241B09002F0D1C1A0105111A02070D1A0205
1A030504011A04070D1A04050B000A1A040501090004240D1A0105121A01081A
01050AFFD109000424160D240101
} module/insert [name module] #@[source: [[tree/set! module/cache name module]]] #{##[tree/set! module/cache name module]
1A00051A01051A02051A0305040301
} module/load [name] #@[source: [[case [type-of name] [:object name] [:keyword [or [tree/ref module/cache name] [do [def mod [module/load/external name]] [when mod [tree/set! module/cache name mod]] [return mod]]]]]]] #{##[type-of name ΓεnΣym-3 :object :keyword tree/ref module/cache module/load/external mod tree/set! #f]
151A00051A010504011A02070D1A02051A03200B00091A01050900501A02051A
04200B00461A05051A06051A010504020C0A00340D1A07051A010504011A0807
0D1A08050B00141A09051A06051A01051A08050403090004240D1A0805010C0A
00060D1A0A090004241601
} module/import-all [module symbol] #@[source: [[def exports [resolve 'exports module]] [typecheck/only exports :tree] [return exports]]] #{##[resolve exports module type-of :tree throw list :type-error "Expected a value of type :tree" current-lambda]
1A00051A011A020504021A01070D1A03051A010504011A04200B000724090019
1A05051A06051A071A081A01051A09050400040404010D1A01050101
} module/import [module symbol] #@[source: [[def exports [module/import-all module symbol]] [when-not [tree/has? exports symbol] [exception :import-error [if [resolves? symbol module] "That symbol was not exported" "That symbol does not exist in that module"]]] [tree/ref exports symbol]]] #{##[module/import-all module symbol exports tree/has? throw list :import-error resolves? "That symbol was not exported" "That symbol does not exist in that module" current-lambda tree/ref]
1A00051A01051A020504021A03070D1A04051A03051A020504020B0007240900
2A1A05051A06051A071A08051A02051A010504020B00081A090900051A0A241A
0B050400040404010D1A0C051A03051A0205040201
}]
1A00052404011A01070D241A02070D1A031A041A051A06171A03070D1A071A08
1A091A0A171A07070D1A0B1A0C1A0D1A0E171A0B070D1A0F1A101A111A12171A
0F070D1A131A141A151A16181A13070D1A171A181A191A1A181A17070D1A1B1A
1C1A1D1A1E181A1B070D1A1F1A201A211A22171A1F070D1A231A241A251A2618
1A23070D1A271A281A291A2A181A27070D1A2B1A2C1A2D1A2E181A2B070D1A2F
1A301A311A32181A2F070D1A331A341A351A36171A33070D1A371A381A391A3A
171A37070D1A3B1A3C1A3D1A3E171A3B070D1A3F1A401A411A42171A3F070D1A
431A441A451A46171A430701
}#{##[numeric? [a] #@[documentation: "Return #t if a is a number" source: ["Return #t if a is a number" [or [int? a] [float? a] [vec? a]]]] #{##[int? a float? vec? #f]
1A00051A010504010C0A00200D1A02051A010504010C0A00130D1A03051A0105
04010C0A00060D1A0401
} last? [a] #@[documentation: "Return #t if a is the last pair in a list" source: [:inline "Return #t if a is the last pair in a list" [nil? [cdr a]]] inline: #t] #{##[nil? a]
1A00051A010512040101
} pos? [a] #@[documentation: "Return #t if a is positive" source: [:inline "Return #t if a is positive" [>= a 0.0]] inline: #t] #{##[a 0.0]
1A00051A012101
} zero-neg? [a] #@[documentation: "Return #t if a is zero or negative" source: [:inline "Return #t if a is zero or negative" [<= a 0.0]] inline: #t] #{##[a 0.0]
1A00051A011F01
} neg? [a] #@[documentation: "Returns #t if a is negative" source: [:inline "Returns #t if a is negative" [< a 0.0]] inline: #t] #{##[a 0.0]
1A00051A011E01
} odd? [a] #@[documentation: "Predicate that returns #t if a is odd" source: ["Predicate that returns #t if a is odd" [= [rem [int a] 2] 1]]] #{##[int a]
1A00051A0105040102022902012001
} even? [a] #@[documentation: "Predicate that returns #t if a is even" source: ["Predicate that returns #t if a is even" [= [mod/int [int a] 2] 0]]] #{##[mod/int int a]
1A00051A01051A020504010202040202002001
} not-zero? [val] #@[documentation: "#t if VAL is not zero" source: [:inline "#t if VAL is not zero" [not= 0 val]] inline: #t] #{##[not= val]
1A000502001A0105040201
} equal? [a b] #@[documentation: "High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." source: ["High level equality comparator, can also recursively test lists/arrays for equivalence, can be slow." [def cur-type [type-of a]] [if [not= cur-type [type-of b]] #f [case cur-type [:array [array/equal? a b]] [:tree [tree/equal? a b]] [:pair [list/equal? a b]] [otherwise [= a b]]]]]] #{##[type-of a cur-type not= b #f ΓεnΣym-1 :array array/equal? :tree tree/equal? :pair list/equal?]
1A00051A010504011A02070D1A03051A02051A00051A0405040104020B00081A
05090058151A02051A06070D1A06051A07200B00111A08051A01051A04050402
0900381A06051A09200B00111A0A051A01051A040504020900211A06051A0B20
0B00111A0C051A01051A0405040209000A1A01051A0405201601
} inequal? [a b] #@[documentation: "High level inequality comparator" source: ["High level inequality comparator" [not [equal? a b]]]] #{##[equal? a b #f #t]
1A00051A01051A020504020B00081A030900051A0401
} int? [val] #@[source: [[= :int [type-of val]]]] #{##[:int type-of val]
1A001A01051A020504012001
} float? [val] #@[source: [[= :float [type-of val]]]] #{##[:float type-of val]
1A001A01051A020504012001
} vec? [val] #@[source: [[= :vec [type-of val]]]] #{##[:vec type-of val]
1A001A01051A020504012001
} boolean? [val] #@[source: [[= :bool [type-of val]]]] #{##[:bool type-of val]
1A001A01051A020504012001
} pair? [val] #@[source: [[= :pair [type-of val]]]] #{##[:pair type-of val]
1A001A01051A020504012001
} array? [val] #@[source: [[= :array [type-of val]]]] #{##[:array type-of val]
1A001A01051A020504012001
} string? [val] #@[source: [[= :string [type-of val]]]] #{##[:string type-of val]
1A001A01051A020504012001
} symbol? [val] #@[source: [[= :symbol [type-of val]]]] #{##[:symbol type-of val]
1A001A01051A020504012001
} object? [val] #@[source: [[= :object [type-of val]]]] #{##[:object type-of val]
1A001A01051A020504012001
} tree? [val] #@[source: [[= :tree [type-of val]]]] #{##[:tree type-of val]
1A001A01051A020504012001
} keyword? [v] #@[source: [[= :keyword [type-of v]]]] #{##[:keyword type-of v]
1A001A01051A020504012001
} macro? [val] #@[source: [[= :macro [type-of val]]]] #{##[:macro type-of val]
1A001A01051A020504012001
} lambda? [val] #@[source: [[or [= :lambda [type-of val]]]]] #{##[:lambda type-of val #f]
1A001A01051A02050401200C0A00060D1A0301
} native? [val] #@[source: [[= :native-function [type-of val]]]] #{##[:native-function type-of val]
1A001A01051A020504012001
} procedure? [val] #@[source: [[or [lambda? val] [native? val]]]] #{##[lambda? val native? #f]
1A00051A010504010C0A00130D1A02051A010504010C0A00060D1A0301
} buffer? [v] #@[source: [[= :buffer [type-of v]]]] #{##[:buffer type-of v]
1A001A01051A020504012001
} buffer-view? [v] #@[source: [[= :buffer-view [type-of v]]]] #{##[:buffer-view type-of v]
1A001A01051A020504012001
} bytecode-array? [v] #@[source: [[= :bytecode-array [type-of v]]]] #{##[:bytecode-array type-of v]
1A001A01051A020504012001
} bytecode-op? [v] #@[source: [[= :bytecode-op [type-of v]]]] #{##[:bytecode-op type-of v]
1A001A01051A020504012001
} in-range? [v min max] #@[source: [[and [>= v min] [<= v max]]]] #{##[v min max]
1A00051A0105210C0B000B0D1A00051A02051F01
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A14070D1A181A191A1A1A1B171A18070D1A1C1A1D1A
1E1A1F171A1C070D1A201A211A221A23171A20070D1A241A251A261A27171A24
070D1A281A291A2A1A2B171A28070D1A2C1A2D1A2E1A2F171A2C070D1A301A31
1A321A33171A30070D1A341A351A361A37171A34070D1A381A391A3A1A3B171A
38070D1A3C1A3D1A3E1A3F171A3C070D1A401A411A421A43171A40070D1A441A
451A461A47171A44070D1A481A491A4A1A4B171A48070D1A4C1A4D1A4E1A4F17
1A4C070D1A501A511A521A53171A50070D1A541A551A561A57171A54070D1A58
1A591A5A1A5B171A58070D1A5C1A5D1A5E1A5F171A5C070D1A601A611A621A63
171A60070D1A641A651A661A67171A64070D1A681A691A6A1A6B171A68070D1A
6C1A6D1A6E1A6F171A6C070D1A701A711A721A73171A70070D1A741A751A761A
77171A740701
}#{##[quasiquote-real [l depth] #@[source: [[if [nil? l] #nil [if [pair? l] [if [= [caar l] 'unquote-splicing] [if [zero? depth] [list 'append [cadr [car l]] [quasiquote-real [cdr l] depth]] [list 'unquote-splicing [quasiquote-real [cadr l] [+ -1 depth]]]] [if [= [car l] 'unquote] [if [zero? depth] [cadr l] [list 'unquote [quasiquote-real [cadr l] [+ -1 depth]]]] [if [= [car l] 'quasiquote] [quasiquote-real [quasiquote-real [cadr l] [+ 1 depth]] depth] [if [zero? depth] [list 'cons [quasiquote-real [car l] depth] [quasiquote-real [cdr l] depth]] [cons [quasiquote-real [car l] depth] [quasiquote-real [cdr l] depth]]]]]] [if [and [zero? depth] [symbol? l]] [cons 'quote [cons l #nil]] l]]]]] #{##[nil? l pair? unquote-splicing depth list append quasiquote-real unquote quasiquote cons symbol? quote]
1A00051A010504010B0007240901151A02051A010504010B00E81A010511111A
03200B00401A04052A0B001F1A05051A061A01051112111A07051A0105121A04
050402040309001A1A05051A031A07051A0105121102FF1A0405250402040209
009D1A0105111A08200B002C1A04052A0B000B1A0105121109001A1A05051A08
1A07051A0105121102FF1A0405250402040209006A1A0105111A09200B001E1A
07051A07051A0105121102011A04052504021A040504020900451A04052A0B00
251A05051A0A1A07051A0105111A040504021A07051A0105121A040504020403
09001C1A07051A0105111A040504021A07051A0105121A04050402140900251A
04052A0C0B000C0D1A0B051A010504010B000E1A0C1A01052414140900061A01
0501
} quasiquote [l] #@[source: [[quasiquote-real l 0]]] #{##[quasiquote-real l]
1A00051A01050200040201
} unquote [expr] #@[source: [[throw [list :unquote-without-quasiquote "unquote should only occur inside a quasiquote, never evaluated directly"]]]] #{##[throw list :unquote-without-quasiquote "unquote should only occur inside a quasiquote, never evaluated directly"]
1A00051A01051A021A030402040101
} unquote-splicing [expr] #@[source: [[throw [list :unquote-splicing-without-quasiq "unquote-splicing should only occur inside a quasiquote, never evaluated directly"]]]] #{##[throw list :unquote-splicing-without-quasiq "unquote-splicing should only occur inside a quasiquote, never evaluated directly"]
1A00051A01051A021A030402040101
}]
1A001A011A021A03171A00070D1A041A051A061A07181A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C0701
}#{##[3.14159 PI π inc [x] #@[documentation: "Return a number 1 greater than x" source: [:inline "Return a number 1 greater than x" [+ 1 x]] inline: #t] #{##[x]
02011A00052501
} inc! [i v] #@[documentation: "Decrement I by V (defaults to 1) and store the result in I" source: ["Decrement I by V (defaults to 1) and store the result in I" [quasiquote [set! [unquote i] [+ [unquote i] [unquote [or v 1]]]]]]] #{##[set! i + v #f]
1A001A01051A021A01051A03050C0A000D0D02010C0A00060D1A042414141424
14141401
} dec [x] #@[documentation: "Return a number 1 less than x" source: [:inline "Return a number 1 less than x" [+ -1 x]] inline: #t] #{##[x]
02FF1A00052501
} dec! [i v] #@[documentation: "Decrement I by V and store the result in I" source: ["Decrement I by V and store the result in I" [quasiquote [set! [unquote i] [- [unquote i] [unquote [or v 1]]]]]]] #{##[set! i - v #f]
1A001A01051A021A01051A03050C0A000D0D02010C0A00060D1A042414141424
14141401
} +x [α] #@[documentation: "Return a function that adds α to it's argument, useful for mapping" source: ["Return a function that adds α to it's argument, useful for mapping" [fn [β] [+ α β]]]] #{##[anonymous [β] #@[source: [[+ α β]]] #{##[α β]
1A00051A01052501
}]
1A001A011A021A031701
} fib [i] #@[documentation: "Terribly inefficient, but, useful for testing the GC" source: ["Terribly inefficient, but, useful for testing the GC" [if [< i 2] i [+ [fib [- i 2]] [fib [- i 1]]]]]] #{##[i fib]
1A000502021E0B00091A000509001A1A01051A000502022604011A01051A0005
02012604012501
} wrap-value [val min max] #@[documentation: "Constrains VAL to be within MIN and MAX, wrapping it around" source: ["Constrains VAL to be within MIN and MAX, wrapping it around" [+ min [rem [- val min] [- max min]]]]] #{##[min val max]
1A00051A01051A0005261A02051A000526292501
} +1 [v] #@[source: [[quasiquote [+ 1 [unquote v]]]]] #{##[+ v]
1A0002011A01052414141401
} radians [degrees] #@[documentation: "Convert a quantity in degrees to radians" source: ["Convert a quantity in degrees to radians" [/ [* π degrees] 180.0]]] #{##[π degrees 180.0]
1A00051A0105271A022801
}]
1A001A01070D1A001A02070D1A031A041A051A06171A03070D1A071A081A091A
0A181A07070D1A0B1A0C1A0D1A0E171A0B070D1A0F1A101A111A12181A0F070D
1A131A141A151A16171A13070D1A171A181A191A1A171A17070D1A1B1A1C1A1D
1A1E171A1B070D1A1F1A201A211A22181A1F070D1A231A241A251A26171A2307
01
}#{##[describe/closure [c i] #@[source: [[when c [if [= c root-closure] [cat [ansi-blue [cat [int [or i 0]] "# <root environment>"]] "\r\n"] [do [def data [closure/data c]] [def l [length data]] [cat [ansi-blue [cat [int [or i 0]] "# " [string/write c]]] " - " [if [< l 16] [string/write data] "-+- Very big tree structure -+-"] "\r\n" [describe/closure [closure/caller c] [+ [int [or i 0]] 1]]]]]]]] #{##[c root-closure cat ansi-blue int i #f "# <root environment>" "\r\n" closure/data data length l "# " string/write " - " "-+- Very big tree structure -+-" describe/closure closure/caller]
1A00050B00C31A00051A0105200B002F1A02051A03051A02051A04051A05050C
0A000D0D02000C0A00060D1A0604011A07040204011A08040209008A1A09051A
000504011A0A070D1A0B051A0A0504011A0C070D1A02051A03051A02051A0405
1A05050C0A000D0D02000C0A00060D1A0604011A0D1A0E051A00050401040304
011A0F1A0C0502101E0B000E1A0E051A0A0504010900051A101A081A11051A12
051A000504011A04051A05050C0A000D0D02000C0A00060D1A06040102012504
0204050900042401
} stacktrace [] #@[source: [[display [describe/closure [closure/caller [current-lambda]]]]]] #{##[print describe/closure closure/caller current-lambda]
1A00051A01051A02051A0305040004010401040101
} display/error/wrap [i text] #@[source: [[case i [0 [ansi-red text]] [1 [string text]] [2 [ansi-yellow [string/write text]]] [3 [describe/closure text]] [otherwise text]]]] #{##[i ΓεnΣym-1 ansi-red text string ansi-yellow string/write describe/closure]
151A00051A01070D1A01050200200B000E1A02051A030504010900471A010502
01200B000E1A04051A030504010900331A01050202200B00131A05051A06051A
03050401040109001A1A01050203200B000E1A07051A030504010900061A0305
1601
} display/error/iter [error i] #@[source: [[if error [cons [display/error/wrap i [car error]] [display/error/iter [cdr error] [+ 1 i]]] [cons "" #nil]]]] #{##[error display/error/wrap i display/error/iter ""]
1A00050B00221A01051A02051A00051104021A03051A00051202011A02052504
02140900071A04241401
} display/error [error] #@[documentation: "Display ERROR in a nice, human readable way" source: ["Display ERROR in a nice, human readable way" [display [join [display/error/iter error 0] "\r\n"]]]] #{##[print join display/error/iter error "\r\n"]
1A00051A01051A02051A0305020004021A040402040101
} closure/documentation [o] #@[source: [[meta o :documentation]]] #{##[meta o :documentation]
1A00051A01051A02040201
} describe/thing [o] #@[documentation: "Describe a specific value O" source: ["Describe a specific value O" [def documentation [closure/documentation o]] [def arguments [closure/arguments o]] [fmt "{arguments:?} - {documentation}"]]] #{##[closure/documentation o documentation closure/arguments arguments cat string/write " - "]
1A00051A010504011A02070D1A03051A010504011A04070D1A05051A06051A04
0504011A071A0205040301
} describe/string [a] #@[documentation: "Descibe whatever value string A resolves to" source: ["Descibe whatever value string A resolves to" [describe/thing [resolve [string->symbol a]]]]] #{##[describe/thing resolve string->symbol a]
1A00051A01051A02051A030504010401040101
} describe [fun] #@[documentation: "Describe FUN, if there is documentation available" source: ["Describe FUN, if there is documentation available" [if [string? fun] [describe/string fun] [describe/thing fun]]]] #{##[string? fun describe/string describe/thing]
1A00051A010504010B000E1A02051A0105040109000B1A03051A0105040101
} symbol-table [off len environment] #@[documentation: "Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" source: ["Return a list of LEN symbols defined in ENVIRONMENT starting at OFF" [when-not environment [set! environment root-closure]] [when-not off [set! off 0]] [when-not len [set! len 9999999]] [sublist [eval-in environment '[symbol-table*]] off [+ off len] #nil]]] #{##[environment root-closure off len 9999999 sublist eval-in [symbol-table*]]
1A00050B0007240900091A01051A00080D1A02050B00072409000802001A0208
0D1A03050B0007240900081A041A03080D1A05051A06051A00051A0704021A02
051A02051A03052524040401
} gensym/counter gensym [prefix] #@[source: [[inc! gensym/counter] [string->symbol [cat prefix "ΓεnΣym-" gensym/counter]]]] #{##[gensym/counter string->symbol cat prefix "ΓεnΣym-"]
1A00050201251A00080D1A01051A02051A03051A041A00050403040101
} current-closure root-closure]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A14070D1A181A191A1A1A1B171A18070D1A1C1A1D1A
1E1A1F171A1C070D1A201A211A221A23171A20070D1A241A251A261A27171A24
070D02001A28070D1A291A2A1A2B1A2C171A29070D1A2D0504001A2E0701
}#{##[random/seed random/seed-initialize! [] #@[source: [[set! random/seed [bit-xor [time] [time/milliseconds]]]]] #{##[bit-xor time time/milliseconds random/seed]
1A00051A010504001A0205040004021A030801
} random/rng! [] #@[source: [[set! random/seed [+ 12345 [* random/seed 1103515245]]] [bit-or [bit-shift-left [bit-and random/seed 65535] 16] [bit-and [bit-shift-right random/seed 16] 65535]]]] #{##[12345 random/seed 1103515245 bit-or bit-shift-left bit-and 65535 bit-shift-right]
1A001A01051A0227251A01080D1A03051A04051A05051A01051A060402021004
021A05051A07051A0105021004021A060402040201
} random/seed! [new-seed] #@[documentation: "Set a new seed value for the RNG" source: ["Set a new seed value for the RNG" [set! seed new-seed]]] #{##[new-seed seed]
1A00051A010801
} [] #@[documentation: "Return the current RNG seed value" source: ["Return the current RNG seed value" seed]] #{##[seed]
1A000501
} random [max] #@[documentation: "Return a value from 0 to MAX, or, if left out, a random int" source: ["Return a value from 0 to MAX, or, if left out, a random int" [if [numeric? max] [rem [abs [random/rng!]] max] [random/rng!]]]] #{##[numeric? max abs random/rng!]
1A00051A010504010B00141A02051A0305040004011A0105290900081A030504
0001
}]
02001A00070D1A011A021A031A04171A01070D1A051A061A071A08171A05070D
1A091A0A1A0B1A0C171A09070D1A001A0D1A0E1A0F171A00070D1A101A111A12
1A13171A10070D1A0105040001
}#{##[#f ansi/disabled "\e[0m" ansi-reset "\e[0;39m" ansi-fg-reset "\e[49m" ansi-bg-reset array/new "\e[0;30m" "\e[0;31m" "\e[0;32m" "\e[0;33m" "\e[0;34m" "\e[0;35m" "\e[0;36m" "\e[0;37m" "\e[1;30m" "\e[1;31m" "\e[1;32m" "\e[1;33m" "\e[1;34m" "\e[1;35m" "\e[1;36m" "\e[1;37m" ansi-fg "\e[40m" "\e[41m" "\e[42m" "\e[43m" "\e[44m" "\e[45m" "\e[46m" "\e[47m" ansi-bg ansi-wrap [code string] #@[documentation: "Wrap STRING in the ansi color CODE" source: ["Wrap STRING in the ansi color CODE" [cat [or ansi/disabled [array/ref ansi-fg code]] string [or ansi/disabled ansi-reset]]]] #{##[cat ansi/disabled array/ref ansi-fg code #f string ansi-reset]
1A00051A01050C0A00160D1A02051A03051A040504020C0A00060D1A051A0605
1A01050C0A000E0D1A07050C0A00060D1A05040301
} ansi-black args #@[documentation: "Wrap ARGS in black" source: ["Wrap ARGS in black" [ansi-wrap 0 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A000502001A01051A02051A03050402040201
} ansi-dark-red #@[documentation: "Wrap ARGS in dark red" source: ["Wrap ARGS in dark red" [ansi-wrap 1 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A000502011A01051A02051A03050402040201
} ansi-dark-green #@[documentation: "Wrap ARGS in dark green" source: ["Wrap ARGS in dark green" [ansi-wrap 2 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A000502021A01051A02051A03050402040201
} ansi-brown #@[documentation: "Wrap ARGS in brown" source: ["Wrap ARGS in brown" [ansi-wrap 3 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A000502031A01051A02051A03050402040201
} ansi-dark-blue #@[documentation: "Wrap ARGS in dark blue" source: ["Wrap ARGS in dark blue" [ansi-wrap 4 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A000502041A01051A02051A03050402040201
} ansi-purple #@[documentation: "Wrap ARGS in purple" source: ["Wrap ARGS in purple" [ansi-wrap 5 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A000502051A01051A02051A03050402040201
} ansi-teal #@[documentation: "Wrap ARGS in teal" source: ["Wrap ARGS in teal" [ansi-wrap 6 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A000502061A01051A02051A03050402040201
} ansi-dark-gray #@[documentation: "Wrap ARGS in dark gray" source: ["Wrap ARGS in dark gray" [ansi-wrap 7 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A000502071A01051A02051A03050402040201
} ansi-gray #@[documentation: "Wrap ARGS in gray" source: ["Wrap ARGS in gray" [ansi-wrap 8 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A000502081A01051A02051A03050402040201
} ansi-red #@[documentation: "Wrap ARGS in red" source: ["Wrap ARGS in red" [ansi-wrap 9 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A000502091A01051A02051A03050402040201
} ansi-green #@[documentation: "Wrap ARGS in green" source: ["Wrap ARGS in green" [ansi-wrap 10 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A0005020A1A01051A02051A03050402040201
} ansi-yellow #@[documentation: "Wrap ARGS in yellow" source: ["Wrap ARGS in yellow" [ansi-wrap 11 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A0005020B1A01051A02051A03050402040201
} ansi-blue #@[documentation: "Wrap ARGS in blue" source: ["Wrap ARGS in blue" [ansi-wrap 12 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A0005020C1A01051A02051A03050402040201
} ansi-pink #@[documentation: "Wrap ARGS in pink" source: ["Wrap ARGS in pink" [ansi-wrap 13 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A0005020D1A01051A02051A03050402040201
} ansi-cyan #@[documentation: "Wrap ARGS in cyan" source: ["Wrap ARGS in cyan" [ansi-wrap 14 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A0005020E1A01051A02051A03050402040201
} ansi-white #@[documentation: "Wrap ARGS in white" source: ["Wrap ARGS in white" [ansi-wrap 15 [apply cat args]]]] #{##[ansi-wrap apply cat args]
1A0005020F1A01051A02051A03050402040201
} ansi-rainbow #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [let* [def count 0] [cat [join [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] ""] [or ansi/disabled ansi-fg-reset]]]]] #{##[count cat join map split apply args "" anonymous [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] #{##[bit-and count cat ansi/disabled array/ref ansi-fg #f a]
1A000502011A010525020704021A01080D1A02051A03050C0A00250D1A04051A
05051A01052A0B000802070900091A010502082504020C0A00060D1A061A0705
040201
} ansi/disabled ansi-fg-reset #f]
1502001A00070D1A01051A02051A03051A04051A05051A01051A060504021A07
04021A081A091A0A1A0B1704021A0704021A0C050C0A000E0D1A0D050C0A0006
0D1A0E04021601
} ansi-rainbow-bg #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [def count 0] [def colored-list [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [bit-xor count 7]]] [or ansi/disabled [array/ref ansi-bg count]] a]]]] [cat [join colored-list ""] [or ansi/disabled ansi-reset]]]] #{##[count map split apply cat args "" anonymous [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or ansi/disabled [array/ref ansi-fg [bit-xor count 7]]] [or ansi/disabled [array/ref ansi-bg count]] a]]] #{##[bit-and count cat ansi/disabled array/ref ansi-fg bit-xor #f ansi-bg a]
1A000502011A010525020704021A01080D1A02051A03050C0A001D0D1A04051A
05051A06051A01050207040204020C0A00060D1A071A03050C0A00160D1A0405
1A08051A010504020C0A00060D1A071A0905040301
} colored-list join ansi/disabled ansi-reset #f]
02001A00070D1A01051A02051A03051A04051A050504021A0604021A071A081A
091A0A1704021A0B070D1A04051A0C051A0B051A0604021A0D050C0A000E0D1A
0E050C0A00060D1A0F040201
} reprint-line [text width] #@[source: [[when-not width [set! width 20]] [print "\r"] [dotimes [i width] [print " "]] [print "\r"] [print text]]] #{##[width print "\r" i " " text]
1A00050B00072409000802141A00080D1A01051A0204010D1502001A03070D24
1B0900160D1C1A01051A0404010D02011A0305031A03081A03051A00051E0AFF
E60D24160D1A01051A0204010D1A01051A0505040101
}]
1A001A01070D1A021A03070D1A041A05070D1A061A07070D1A08051A091A0A1A
0B1A0C1A0D1A0E1A0F1A101A111A121A131A141A151A161A171A1804101A1907
0D1A021A03070D1A08051A1A1A1B1A1C1A1D1A1E1A1F1A201A2104081A22070D
1A231A241A251A26171A23070D1A271A281A291A2A171A27070D1A2B1A281A2C
1A2D171A2B070D1A2E1A281A2F1A30171A2E070D1A311A281A321A33171A3107
0D1A341A281A351A36171A34070D1A371A281A381A39171A37070D1A3A1A281A
3B1A3C171A3A070D1A3D1A281A3E1A3F171A3D070D1A401A281A411A42171A40
070D1A431A281A441A45171A43070D1A461A281A471A48171A46070D1A491A28
1A4A1A4B171A49070D1A4C1A281A4D1A4E171A4C070D1A4F1A281A501A51171A
4F070D1A521A281A531A54171A52070D1A551A281A561A57171A55070D1A581A
281A591A5A171A58070D1A5B1A281A5C1A5D171A5B070D1A5E1A5F1A601A6117
1A5E0701
}#{##[tree/new :align :right :debug #f :base :width :padding-char " " fmt/format-arg/default fmt/find-non-digit-from-right [s i] #@[source: [[if [< i 0] -1 [do [def char [char-at s i]] [if [and [>= char 48] [<= char 57]] [fmt/find-non-digit-from-right s [- i 1]] i]]]]] #{##[i char-at s char fmt/find-non-digit-from-right]
1A000502001E0B000802FF09003A1A01051A02051A000504021A03070D1A0305
0230210C0B000A0D1A030502391F0B00141A04051A02051A0005020126040209
00061A000501
} fmt/parse-spec [opts spec] #@[source: [[if [zero? [string/length spec]] opts [case [char-at spec [- [string/length spec] 1]] [[48 49 50 51 52 53 54 55 56 57] [def next-non-digit [fmt/find-non-digit-from-right spec [- [string/length spec] 1]]] [def number [string/cut spec [+ 1 next-non-digit] [string/length spec]]] [tree/set! opts :width [read/single number]] [when [= 48 [char-at number 0]] [tree/set! opts :padding-char "0"]] [fmt/parse-spec opts [string/cut spec 0 [+ 1 next-non-digit]]]] [63 [fmt/parse-spec [tree/set! opts :debug #t] [string/cut spec 0 [- [string/length spec] 1]]]] [88 [fmt/parse-spec [tree/set! opts :base :HEXADECIMAL] [string/cut spec 0 [- [string/length spec] 1]]]] [120 [fmt/parse-spec [tree/set! opts :base :hexadecimal] [string/cut spec 0 [- [string/length spec] 1]]]] [100 [fmt/parse-spec [tree/set! opts :base :decimal] [string/cut spec 0 [- [string/length spec] 1]]]] [111 [fmt/parse-spec [tree/set! opts :base :octal] [string/cut spec 0 [- [string/length spec] 1]]]] [98 [fmt/parse-spec [tree/set! opts :base :binary] [string/cut spec 0 [- [string/length spec] 1]]]] [60 [fmt/parse-spec [tree/set! opts :align :left] [string/cut spec 0 [- [string/length spec] 1]]]] [94 [fmt/parse-spec [tree/set! opts :align :center] [string/cut spec 0 [- [string/length spec] 1]]]] [62 [fmt/parse-spec [tree/set! opts :align :right] [string/cut spec 0 [- [string/length spec] 1]]]] [46 [fmt/parse-spec [tree/set! opts :precision [tree/ref opts :width]] [string/cut spec 0 [- [string/length spec] 1]]]] [otherwise [throw [list :format-error "Unknown form-spec option" spec [current-closure]]]]]]]] #{##[string/length spec opts char-at ΓεnΣym-1 #f fmt/find-non-digit-from-right next-non-digit string/cut number tree/set! :width read/single :padding-char "0" fmt/parse-spec :debug #t :base :HEXADECIMAL :hexadecimal :decimal :octal :binary :align :left :center :right :precision tree/ref throw list :format-error "Unknown form-spec option" current-closure]
1A00051A010504012A0B00091A0205090321151A03051A01051A00051A010504
0102012604021A04070D1A04050230200C0A00690D1A04050231200C0A005E0D
1A04050232200C0A00530D1A04050233200C0A00480D1A04050234200C0A003D
0D1A04050235200C0A00320D1A04050236200C0A00270D1A04050237200C0A00
1C0D1A04050238200C0A00110D1A04050239200C0A00060D1A050B00831A0605
1A01051A00051A0105040102012604021A07070D1A08051A010502011A070525
1A00051A0105040104031A09070D1A0A051A02051A0B1A0C051A090504010403
0D02301A03051A090502000402200B00121A0A051A02051A0D1A0E0403090004
240D1A0F051A02051A08051A0105020002011A070525040304020902151A0405
023F200B002C1A0F051A0A051A02051A101A1104031A08051A010502001A0005
1A01050401020126040304020901E31A04050258200B002C1A0F051A0A051A02
051A121A1304031A08051A010502001A00051A01050401020126040304020901
B11A04050278200B002C1A0F051A0A051A02051A121A1404031A08051A010502
001A00051A010504010201260403040209017F1A04050264200B002C1A0F051A
0A051A02051A121A1504031A08051A010502001A00051A010504010201260403
040209014D1A0405026F200B002C1A0F051A0A051A02051A121A1604031A0805
1A010502001A00051A010504010201260403040209011B1A04050262200B002C
1A0F051A0A051A02051A121A1704031A08051A010502001A00051A0105040102
0126040304020900E91A0405023C200B002C1A0F051A0A051A02051A181A1904
031A08051A010502001A00051A01050401020126040304020900B71A0405025E
200B002C1A0F051A0A051A02051A181A1A04031A08051A010502001A00051A01
050401020126040304020900851A0405023E200B002C1A0F051A0A051A02051A
181A1B04031A08051A010502001A00051A01050401020126040304020900531A
0405022E200B00341A0F051A0A051A02051A1C1A1D051A02051A0B040204031A
08051A010502001A00051A01050401020126040304020900191A1E051A1F051A
201A211A01051A22050400040404011601
} fmt/debug [opts] #@[source: [[if-not [tree/ref opts :debug] opts [tree/set! opts :argument [list string/write [tree/ref opts :argument]]]]]] #{##[tree/ref opts :debug tree/set! :argument list string/write]
1A00051A01051A0204020B00221A03051A01051A041A05051A06051A00051A01
051A040402040204030900061A010501
} fmt/number-format [opts] #@[source: [[case [tree/ref opts :base] [:binary [tree/set! opts :argument [list int->string/binary [tree/ref opts :argument]]]] [:octal [tree/set! opts :argument [list int->string/octal [tree/ref opts :argument]]]] [:decimal [tree/set! opts :argument [list int->string/decimal [tree/ref opts :argument]]]] [:hexadecimal [tree/set! opts :argument [list int->string/hex [tree/ref opts :argument]]]] [:HEXADECIMAL [tree/set! opts :argument [list int->string/HEX [tree/ref opts :argument]]]] [otherwise opts]]]] #{##[tree/ref opts :base ΓεnΣym-2 :binary tree/set! :argument list int->string/binary :octal int->string/octal :decimal int->string/decimal :hexadecimal int->string/hex :HEXADECIMAL int->string/HEX]
151A00051A01051A0204021A03070D1A03051A04200B00221A05051A01051A06
1A07051A08051A00051A01051A060402040204030900A61A03051A09200B0022
1A05051A01051A061A07051A0A051A00051A01051A0604020402040309007E1A
03051A0B200B00221A05051A01051A061A07051A0C051A00051A01051A060402
040204030900561A03051A0D200B00221A05051A01051A061A07051A0E051A00
051A01051A0604020402040309002E1A03051A0F200B00221A05051A01051A06
1A07051A10051A00051A01051A060402040204030900061A01051601
} :binary "#b" :octal "#o" :decimal "#d" :hexadecimal "#x" :HEXADECIMAL fmt/number-format-prefixex fmt/number-format-prefix [opts] #@[source: [[if [or [not [tree/ref opts :debug]] [not [tree/ref opts :base]]] opts [-> [if [member '[:binary :octal :decimal :hexadecimal :HEXADECIMAL] [tree/ref opts :base]] [tree/set! opts :argument [list cat [tree/ref fmt/number-format-prefixex [tree/ref opts :base]] [tree/ref opts :argument]]] opts] [tree/set! :debug #f]]]]] #{##[tree/ref opts :debug #f #t :base tree/set! member [:binary :octal :decimal :hexadecimal :HEXADECIMAL] :argument list cat fmt/number-format-prefixex]
1A00051A01051A0204020B00081A030900051A040C0A001F0D1A00051A01051A
0504020B00081A030900051A040C0A00060D1A030B00091A01050900541A0605
1A07051A081A00051A01051A05040204020B00341A06051A01051A091A0A051A
0B051A00051A0C051A00051A01051A05040204021A00051A01051A0904020403
04030900061A01051A021A03040301
} fmt/add-padding [opts] #@[source: [[if-not [tree/ref opts :width] opts [tree/set! opts :argument [list [case [tree/ref opts :align] [:right string/pad-start] [:center string/pad-middle] [:left string/pad-end]] [tree/ref opts :argument] [if [and [tree/ref opts :debug] [tree/ref opts :base]] [- [tree/ref opts :width] 2] [tree/ref opts :width]] [tree/ref opts :padding-char]]]]]] #{##[tree/ref opts :width tree/set! :argument list :align ΓεnΣym-3 :right string/pad-start :center string/pad-middle :left string/pad-end :debug :base :padding-char]
1A00051A01051A0204020B009D1A03051A01051A041A0505151A00051A01051A
0604021A07070D1A07051A08200B00091A09050900221A07051A0A200B00091A
0B050900131A07051A0C200B00091A0D0509000424161A00051A01051A040402
1A00051A01051A0E04020C0B000E0D1A00051A01051A0F04020B00131A00051A
01051A02040202022609000D1A00051A01051A0204021A00051A01051A100402
040404030900061A010501
} fmt/precision [opts] #@[source: [[if-not [tree/ref opts :precision] opts [tree/set! opts :argument [list string/round [tree/ref opts :argument] [tree/ref opts :precision]]]]]] #{##[tree/ref opts :precision tree/set! :argument list string/round]
1A00051A01051A0204020B002C1A03051A01051A041A05051A06051A00051A01
051A0404021A00051A01051A020402040304030900061A010501
} fmt/truncate [opts] #@[source: [[if-not [tree/ref opts :width] opts [tree/set! opts :argument [list string/cut [tree/ref opts :argument] 0 [+ 1 [tree/ref opts :width]]]]]]] #{##[tree/ref opts :width tree/set! :argument list string/cut]
1A00051A01051A0204020B00311A03051A01051A041A05051A06051A00051A01
051A040402020002011A00051A01051A02040225040404030900061A010501
} fmt/output [opts] #@[source: [[tree/ref opts :argument]]] #{##[tree/ref opts :argument]
1A00051A01051A02040201
} fmt/format-arg [spec argument] #@[source: [[-> [tree/set! [fmt/parse-spec [tree/dup fmt/format-arg/default] spec] :argument argument] fmt/number-format fmt/precision fmt/add-padding fmt/truncate fmt/number-format-prefix fmt/debug fmt/output]]] #{##[fmt/output fmt/debug fmt/number-format-prefix fmt/truncate fmt/add-padding fmt/precision fmt/number-format tree/set! fmt/parse-spec tree/dup fmt/format-arg/default spec :argument argument]
1A00051A01051A02051A03051A04051A05051A06051A07051A08051A09051A0A
0504011A0B0504021A0C1A0D050403040104010401040104010401040101
} fmt/valid-argument? [argument] #@[source: [[or [int? argument] [symbol? argument]]]] #{##[int? argument symbol? #f]
1A00051A010504010C0A00130D1A02051A010504010C0A00060D1A0301
} fmt/arg-sym [v] #@[source: [[case [type-of v] [:int [fmt/arg-sym [cat "fmt-arg-" [string v]]]] [:symbol v] [:string [string->symbol v]] [otherwise [throw [list :type-error "Invalid fmt argument name" v [current-lambda]]]]]]] #{##[type-of v ΓεnΣym-4 :int fmt/arg-sym cat "fmt-arg-" string :symbol :string string->symbol throw list :type-error "Invalid fmt argument name" current-lambda]
151A00051A010504011A02070D1A02051A03200B001A1A04051A05051A061A07
051A010504010402040109003C1A02051A08200B00091A010509002D1A02051A
09200B000E1A0A051A010504010900191A0B051A0C051A0D1A0E1A01051A0F05
0400040404011601
} fmt/expr [expr arguments-used opts] #@[source: [[when-not [string? expr] [throw [list :format-error "fmt needs a string literal as a first argument, since it is implemented as a macro" expr [current-lambda]]]] [def split-expr [split expr ":"]] [def argument [car split-expr]] [def format-spec [or [cadr split-expr] ""]] [if [= "" argument] [do [tree/-- opts :expr-count] [array/set! arguments-used [tree/ref opts :expr-count] #t] [fmt/format-arg format-spec [fmt/arg-sym [tree/ref opts :expr-count]]]] [let [[read-vals [read argument]]] [when [cdr read-vals] [throw [list :format-error "Format argument specifier contains more than a single atom" argument [current-lambda]]]] [when-not [fmt/valid-argument? [car read-vals]] [throw [list :format-error "Format argument specifier should be either an integer or a symbol" argument [current-lambda]]]] [when [int? [car read-vals]] [when [or [< [car read-vals] 0] [>= [car read-vals] [array/length arguments-used]]] [throw [list :format-error "fmt numbered argument is out of bounds" argument [current-lambda]]]] [array/set! arguments-used [car read-vals] #t]] [fmt/format-arg format-spec [fmt/arg-sym [car read-vals]]]]]]] #{##[string? expr throw list :format-error "fmt needs a string literal as a first argument, since it is implemented as a macro" current-lambda split ":" split-expr argument "" #f format-spec tree/+= opts :expr-count array/set! arguments-used tree/ref #t fmt/format-arg fmt/arg-sym read read-vals "Format argument specifier contains more than a single atom" fmt/valid-argument? "Format argument specifier should be either an integer or a symbol" int? array/length "fmt numbered argument is out of bounds"]
1A00051A010504010B0007240900191A02051A03051A041A051A01051A060504
00040404010D1A07051A01051A0804021A09070D1A0905111A0A070D1A090512
110C0A000D0D1A0B0C0A00060D1A0C1A0D070D1A0B1A0A05200B003F1A0E051A
0F051A1002FF04030D1A11051A12051A13051A0F051A1004021A1404030D1A15
051A0D051A16051A13051A0F051A100402040104020900C8151A17051A0A0504
011A18070D1A1805120B001C1A02051A03051A041A191A0A051A060504000404
0401090004240D1A1A051A18051104010B0007240900191A02051A03051A041A
1B1A0A051A06050400040404010D1A1C051A18051104010B00521A1805110200
1E0C0A00180D1A1805111A1D051A12050401210C0A00060D1A0C0B001C1A0205
1A03051A041A1E1A0A051A0605040004040401090004240D1A11051A12051A18
05111A140403090004240D1A15051A0D051A16051A180511040104021601
} fmt [format-string . args] #@[documentation: "Return a formatted string" source: ["Return a formatted string" [when-not [string? format-string] [throw [list :type-error "fmt needs a string literal as a first argument, since it is implemented as a macro" format-string [current-lambda]]]] [def cuts #nil] [dotimes [i [string/length format-string]] [case [char-at format-string i] [123 [do [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]] [set! cuts [cons i cuts]]]] [125 [do [when-not [int? [car cuts]] [throw [list :format-error "fmt expects all brackets to be closed" format-string [current-lambda]]]] [set! cuts [cons [cons [car cuts] i] [cdr cuts]]]]]]] [when [int? [car cuts]] [throw [list :format-error "fmt placeholders can't be nested" format-string [current-lambda]]]] [def expr-list #nil] [def last-pos [string/length format-string]] [def arguments-used [-> [array/allocate [length args]] [array/fill! #f]]] [def opts [tree/new :expr-count [array/length arguments-used]]] [doseq [c cuts] [def lit [string/cut format-string [+ [cdr c] 1] last-pos]] [when-not [= "" lit] [set! expr-list [cons lit expr-list]]] [def expr [fmt/expr [string/cut format-string [+ 1 [car c]] [cdr c]] arguments-used opts]] [set! expr-list [cons expr expr-list]] [set! last-pos [car c]]] [when [> last-pos 0] [def lit [string/cut format-string 0 last-pos]] [set! expr-list [cons lit expr-list]]] [dotimes [i [array/length arguments-used]] [when-not [array/ref arguments-used i] [throw [list :format-error "fmt expects all arguments to be used" [list format-string [list/ref args i]] [current-lambda]]]]] [def expr [if [cdr expr-list] [cons 'cat expr-list] [if [string? [car expr-list]] [car expr-list] [cons 'string expr-list]]]] [def fmt/args/map-fun/count 0] [defn fmt/args/map-fun [arg] [def s [string->symbol [cat "fmt-arg-" [string fmt/args/map-fun/count]]]] [inc! fmt/args/map-fun/count] [list 'def s arg]] [if args [quasiquote [let* [unquote-splicing [map args fmt/args/map-fun]] [unquote expr]]] expr]]] #{##[string? format-string throw list :type-error "fmt needs a string literal as a first argument, since it is implemented as a macro" current-lambda cuts i char-at ΓεnΣym-5 int? :format-error "fmt placeholders can't be nested" "fmt expects all brackets to be closed" string/length expr-list last-pos array/fill! array/allocate length args #f arguments-used tree/new :expr-count array/length opts ΓεnΣym-6 c string/cut lit "" fmt/expr expr array/ref "fmt expects all arguments to be used" list/ref cat string fmt/args/map-fun/count fmt/args/map-fun [arg] #@[source: [[def s [string->symbol [cat "fmt-arg-" [string fmt/args/map-fun/count]]]] [inc! fmt/args/map-fun/count] [list 'def s arg]]] #{##[string->symbol cat "fmt-arg-" string fmt/args/map-fun/count s list def arg]
1A00051A01051A021A03051A04050401040204011A05070D1A04050201251A04
080D1A06051A071A05051A0805040301
} let* append map]
1A00051A010504010B0007240900191A02051A03051A041A051A01051A060504
00040404010D241A07070D1502001A08070D241B0900A10D1C151A09051A0105
1A080504021A0A070D1A0A05027B200B00371A0B051A07051104010B001C1A02
051A03051A0C1A0D1A01051A0605040004040401090004240D1A08051A070514
1A07080900471A0A05027D200B003D1A0B051A07051104010B0007240900191A
02051A03051A0C1A0E1A01051A06050400040404010D1A0705111A0805141A07
0512141A070809000424160D02011A0805031A08081A08051A0F051A01050401
1E0AFF560D24160D1A0B051A07051104010B001C1A02051A03051A0C1A0D1A01
051A0605040004040401090004240D241A10070D1A0F051A010504011A11070D
1A12051A13051A14051A1505040104011A1604021A17070D1A18051A191A1A05
1A1705040104021A1B070D151A07051A1C070D1A1C050B0085241B0900770D1C
1A1C05111A1D070D1A1E051A01051A1D05120201251A110504031A1F070D1A20
1A1F05200B00072409000D1A1F051A1005141A10080D1A21051A1E051A010502
011A1D0511251A1D051204031A17051A1B0504031A22070D1A22051A1005141A
10080D1A1D05111A11080D1A1C05121A1C081A1C050AFF8909000424160D1A11
050200220B00211A1E051A010502001A110504031A1F070D1A1F051A1005141A
1008090004240D1502001A08070D241B0900470D1C1A23051A17051A08050402
0B0007240900291A02051A03051A0C1A241A03051A01051A25051A15051A0805
040204021A06050400040404010D02011A0805031A08081A08051A1A051A1705
04011E0AFFB00D24160D1A1005120B000C1A261A10051409001C1A00051A1005
1104010B000A1A1005110900091A271A1005141A22070D02001A28070D1A291A
2A1A2B1A2C171A29070D1A15050B001E1A2D1A2E051A2F051A15051A29050402
1A220524140402140900061A220501
} pfmt [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [print [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[print fmt format-string append args]
1A001A011A02051A03051A0405240402141424141401
} efmt [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [error [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[error fmt format-string append args]
1A001A011A02051A03051A0405240402141424141401
} pfmtln [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [println [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[println fmt format-string append args]
1A001A011A02051A03051A0405240402141424141401
} efmtln [format-string . args] #@[documentation: "Print a formatted string" source: ["Print a formatted string" [quasiquote [errorln [fmt [unquote format-string] [unquote-splicing args]]]]]] #{##[errorln fmt format-string append args]
1A001A011A02051A03051A0405240402141424141401
}]
1A00051A011A021A031A041A051A041A06241A071A08040A1A09070D1A0A1A0B
1A0C1A0D171A0A070D1A0E1A0F1A101A11171A0E070D1A121A131A141A15171A
12070D1A161A171A181A19171A16070D1A00051A1A1A1B1A1C1A1D1A1E1A1F1A
201A211A221A21040A1A23070D1A241A251A261A27171A24070D1A281A291A2A
1A2B171A28070D1A2C1A2D1A2E1A2F171A2C070D1A301A311A321A33171A3007
0D1A341A351A361A37171A34070D1A381A391A3A1A3B171A38070D1A3C1A3D1A
3E1A3F171A3C070D1A401A411A421A43171A40070D1A441A451A461A47171A44
070D1A481A491A4A1A4B181A48070D1A4C1A4D1A4E1A4F181A4C070D1A501A51
1A521A53181A50070D1A541A551A561A57181A54070D1A581A591A5A1A5B181A
580701
}#{##[string->keyword [α] #@[documentation: "Return string α as a keyword" source: [:inline "Return string α as a keyword" [symbol->keyword [string->symbol α]]] inline: #t] #{##[symbol->keyword string->symbol α]
1A00051A01051A02050401040101
} string->byte-array [a] #@[documentation: "Turn a string into an UTF-8 encoded byte array" source: ["Turn a string into an UTF-8 encoded byte array" [def ret [array/allocate [string/length a]]] [dotimes [i [string/length a]] [array/set! ret i [char-at a i]]] ret]] #{##[array/allocate string/length a ret i array/set! char-at]
1A00051A01051A0205040104011A03070D1502001A04070D241B0900250D1C1A
05051A03051A04051A06051A02051A0405040204030D02011A0405031A04081A
04051A01051A020504011E0AFFD20D24160D1A030501
} println [str] #@[documentation: "Print STR on a single line" source: ["Print STR on a single line" [print [cat str "\r\n"]]]] #{##[print cat str "\r\n"]
1A00051A01051A02051A030402040101
} errorln [str] #@[documentation: "Print to stderr STR on a single line" source: ["Print to stderr STR on a single line" [error [cat str "\r\n"]]]] #{##[error cat str "\r\n"]
1A00051A01051A02051A030402040101
} display [value] #@[documentation: "Display VALUE" source: [:inline "Display VALUE" [print value]] inline: #t] #{##[print value]
1A00051A0105040101
} newline [] #@[documentation: "Print a single line feed character" source: ["Print a single line feed character" [print "\r\n"]]] #{##[print "\r\n"]
1A00051A01040101
} br [num] #@[documentation: "Return NUM=1 linebreaks" source: ["Return NUM=1 linebreaks" [if [or [nil? num] [<= [int num] 1]] "\n" [cat "\n" [br [+ -1 num]]]]]] #{##[nil? num int #f "\n" cat br]
1A00051A010504010C0A00160D1A02051A0105040102011F0C0A00060D1A030B
00081A040900151A05051A041A060502FF1A0105250401040201
} path/ext?! [ext] #@[documentation: "Return a predicate that checks if a path ends on EXT" source: ["Return a predicate that checks if a path ends on EXT" [case [type-of ext] [:string [fn [path] [= ext [lowercase [path/extension path]]]]] [:pair [fn [path] [def cext [lowercase [path/extension path]]] [reduce ext [fn [α β] [or α [= β cext]]]]]] [otherwise [throw [list :type-error "Expected a :string or :list" ext]]]]]] #{##[type-of ext ΓεnΣym-1 :string anonymous [path] #@[source: [[= ext [lowercase [path/extension path]]]]] #{##[ext lowercase path/extension path]
1A00051A01051A02051A0305040104012001
} :pair [path] #@[source: [[def cext [lowercase [path/extension path]]] [reduce ext [fn [α β] [or α [= β cext]]]]]] #{##[lowercase path/extension path cext reduce ext anonymous [α β] #@[source: [[or α [= β cext]]]] #{##[α β cext #f]
1A00050C0A00120D1A01051A0205200C0A00060D1A0301
}]
1A00051A01051A0205040104011A03070D1A04051A05051A061A071A081A0917
040201
} throw list :type-error "Expected a :string or :list"]
151A00051A010504011A02070D1A02051A03200B000F1A041A051A061A071709
00291A02051A08200B000F1A041A091A0A1A0B170900141A0C051A0D051A0E1A
0F1A0105040304011601
} path/extension [path] #@[documentation: "Return the extension of PATH" source: ["Return the extension of PATH" [def last-period [last-index-of path "."]] [if [>= last-period 0] [string/cut path [+ 1 last-period] [string/length path]] path]]] #{##[last-index-of path "." last-period string/cut string/length]
1A00051A01051A0204021A03070D1A03050200210B001C1A04051A010502011A
0305251A05051A0105040104030900061A010501
} path/without-extension [path] #@[documentation: "Return PATH, but without the extension part" source: ["Return PATH, but without the extension part" [def last-period [last-index-of path "."]] [if [>= last-period 0] [string/cut path 0 last-period] path]]] #{##[last-index-of path "." last-period string/cut]
1A00051A01051A0204021A03070D1A03050200210B00131A04051A010502001A
030504030900061A010501
} int->string/binary [α] #@[documentation: "Turn α into a its **binary** string representation" source: ["Turn α into a its **binary** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [while [not-zero? α] [set! ret [cat [from-char-code [+ 48 [bit-and α 1]]] ret]] [set! α [bit-shift-right α 1]]] ret]] #{##["" ret α "0" cat from-char-code bit-and bit-shift-right not=]
1A001A01070D1A02050B00072409000802001A02070D1A02052A0B000B1A031A
0108090004240D241B0900300D1C1A04051A050502301A06051A020502010402
2504011A010504021A01080D1A07051A0205020104021A02081A080502001A02
0504020AFFC90D1A010501
} int->string/octal [α] #@[documentation: "Turn α into a its **octal** string representation" source: ["Turn α into a its **octal** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [while [not-zero? α] [set! ret [cat [from-char-code [+ 48 [bit-and α 7]]] ret]] [set! α [bit-shift-right α 3]]] ret]] #{##["" ret α "0" cat from-char-code bit-and bit-shift-right not=]
1A001A01070D1A02050B00072409000802001A02070D1A02052A0B000B1A031A
0108090004240D241B0900300D1C1A04051A050502301A06051A020502070402
2504011A010504021A01080D1A07051A0205020304021A02081A080502001A02
0504020AFFC90D1A010501
} array/new "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" int->string/hex/conversion-arr int->string/HEX [α] #@[documentation: "Turn α into a its **hexadecimal** string representation" source: ["Turn α into a its **hexadecimal** string representation" [def ret ""] [when-not α [def α 0]] [when [zero? α] [set! ret "0"]] [when [< α 0] [throw [list :type-error "Can't print negative numbers in hex for now" α [current-lambda]]]] [while [not-zero? α] [set! ret [cat [array/ref int->string/hex/conversion-arr [bit-and α 15]] ret]] [set! α [bit-shift-right α 4]]] ret]] #{##["" ret α "0" throw list :type-error "Can't print negative numbers in hex for now" current-lambda cat array/ref int->string/hex/conversion-arr bit-and bit-shift-right not=]
1A001A01070D1A02050B00072409000802001A02070D1A02052A0B000B1A031A
0108090004240D1A020502001E0B001C1A04051A05051A061A071A02051A0805
040004040401090004240D241B0900300D1C1A09051A0A051A0B051A0C051A02
05020F040204021A010504021A01080D1A0D051A0205020404021A02081A0E05
02001A020504020AFFC90D1A010501
} int->string/hex [α] #@[documentation: "Turn α into a its **hexadecimal** string representation" source: ["Turn α into a its **hexadecimal** string representation" [lowercase [int->string/HEX α]]]] #{##[lowercase int->string/HEX α]
1A00051A01051A02050401040101
} int->string/decimal [α] #@[documentation: "Turn α into a its **decimal** string representation" source: ["Turn α into a its **decimal** string representation" [string α]]] #{##[string α]
1A00051A0105040101
} int->string string/pad-start [text goal-length char] #@[documentation: "Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the start until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat char text]]] [if [> [string/length text] goal-length] [string/cut text [- [string/length text] goal-length] [string/length text]] text]]] #{##[char " " string? text string throw list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" current-lambda cat string/length goal-length string/cut]
1A00050B0007240900081A011A00080D1A02051A030504010B00072409000E1A
04051A030504011A03080D1A02051A000504010B0007240900191A05051A0605
1A071A081A00051A09050400040404010D241B0900130D1C1A0A051A00051A03
0504021A03081A0B051A030504011A0C051E0AFFE40D1A0B051A030504011A0C
05220B00221A0D051A03051A0B051A030504011A0C05261A0B051A0305040104
030900061A030501
} string/pad-end [text goal-length char] #@[documentation: "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat text char]]] [if [> [string/length text] goal-length] [string/cut text 0 goal-length] text]]] #{##[char " " string? text string throw list :type-error "string/pad-start needs char as a string, so that one can pad with multiple characters" current-lambda cat string/length goal-length string/cut]
1A00050B0007240900081A011A00080D1A02051A030504010B00072409000E1A
04051A030504011A03080D1A02051A000504010B0007240900191A05051A0605
1A071A081A00051A09050400040404010D241B0900130D1C1A0A051A03051A00
0504021A03081A0B051A030504011A0C051E0AFFE40D1A0B051A030504011A0C
05220B00131A0D051A030502001A0C0504030900061A030501
} string/pad-middle [text goal-length char] #@[documentation: "Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" source: ["Pad out TEXT with CHAR at the end until it is GOAL-LENGTH chars long, may also truncate the string" [when-not char [set! char " "]] [when-not [string? text] [set! text [string text]]] [when-not [string? char] [throw [list :type-error "string/pad-middle needs char as a string, so that one can pad with multiple characters" char [current-lambda]]]] [while [< [string/length text] goal-length] [set! text [cat char text char]]] [if [> [string/length text] goal-length] [let [[end-overflow [/ [- [string/length text] goal-length] 2]] [start-overflow [- [- [string/length text] goal-length] end-overflow]]] [string/cut text start-overflow [+ start-overflow goal-length]]] text]]] #{##[char " " string? text string throw list :type-error "string/pad-middle needs char as a string, so that one can pad with multiple characters" current-lambda cat string/length goal-length end-overflow start-overflow string/cut]
1A00050B0007240900081A011A00080D1A02051A030504010B00072409000E1A
04051A030504011A03080D1A02051A000504010B0007240900191A05051A0605
1A071A081A00051A09050400040404010D241B0900160D1C1A0A051A00051A03
051A000504031A03081A0B051A030504011A0C051E0AFFE10D1A0B051A030504
011A0C05220B0041151A0B051A030504011A0C05260202281A0D070D1A0B051A
030504011A0C05261A0D05261A0E070D1A0F051A03051A0E051A0E051A0C0525
0403160900061A030501
} string/round [text decimal-digits] #@[documentation: "Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" source: ["Round the floating point representation in TEXT to have at most DECIMAL-DIGITS after the period" [def pos [last-index-of text "."]] [if [>= pos 0] [string/cut text 0 [+ pos 1 decimal-digits]] text]]] #{##[last-index-of text "." pos string/cut decimal-digits]
1A00051A01051A0204021A03070D1A03050200210B001A1A04051A010502001A
03050201251A05052504030900061A010501
} split/empty [str separator] #@[source: [[def slen [string/length str]] [def start 0] [def ret #nil] [while [< start slen] [set! ret [cons [string/cut str start [+ 1 start]] ret]] [inc! start]] [reverse ret]]] #{##[string/length str slen start ret string/cut reverse]
1A00051A010504011A02070D02001A03070D241A04070D241B0900270D1C1A05
051A01051A030502011A03052504031A0405141A04080D1A03050201251A0308
1A03051A02051E0AFFD50D1A06051A0405040101
} split/string [str separator start] #@[source: [[when-not start [set! start 0]] [def pos-found [index-of str separator start]] [if [>= pos-found 0] [cons [string/cut str start pos-found] [split/string str separator [+ pos-found [string/length separator]]]] [cons [string/cut str start [string/length str]] #nil]]]] #{##[start index-of str separator pos-found string/cut split/string string/length]
1A00050B00072409000802001A00080D1A01051A02051A03051A000504031A04
070D1A04050200210B002C1A05051A02051A00051A040504031A06051A02051A
03051A04051A07051A03050401250403140900181A05051A02051A00051A0705
1A020504010403241401
} split [str separator] #@[documentation: "Splits STR into a list at every occurunse of SEPARATOR" source: ["Splits STR into a list at every occurunse of SEPARATOR" [typecheck/only str :string] [typecheck/only separator :string] [case [string/length separator] [0 [split/empty str]] [otherwise [split/string str separator 0]]]]] #{##[type-of str :string throw list :type-error "Expected a value of type :string" current-lambda separator string/length ΓεnΣym-2 split/empty split/string]
1A00051A010504011A02200B0007240900191A03051A04051A051A061A01051A
07050400040404010D1A00051A080504011A02200B0007240900191A03051A04
051A051A061A08051A07050400040404010D151A09051A080504011A0A070D1A
0A050200200B000E1A0B051A010504010900101A0C051A01051A080502000403
1601
} read/single [text] #@[documentation: "Uses the reader and returns the first single value read from string TEXT" source: ["Uses the reader and returns the first single value read from string TEXT" [typecheck/only text :string] [car [read text]]]] #{##[type-of text :string throw list :type-error "Expected a value of type :string" current-lambda read]
1A00051A010504011A02200B0007240900191A03051A04051A051A061A01051A
07050400040404010D1A08051A010504011101
} read/int [text] #@[documentation: "Reads the first string from TEXT" source: ["Reads the first string from TEXT" [int [read/single text]]]] #{##[int read/single text]
1A00051A01051A02050401040101
} read/float [text] #@[documentation: "Reads the first float from TEXT" source: ["Reads the first float from TEXT" [float [read/single text]]]] #{##[float read/single text]
1A00051A01051A02050401040101
} string/length?! [chars] #@[source: [[fn [a] [= chars [string/length a]]]]] #{##[anonymous [a] #@[source: [[= chars [string/length a]]]] #{##[chars string/length a]
1A00051A01051A020504012001
}]
1A001A011A021A031701
} contains-any? [str chars] #@[source: [[apply or [map [split chars ""] [fn [a] [>= [index-of str a] 0]]]]]] #{##[apply or map split chars "" anonymous [a] #@[source: [[>= [index-of str a] 0]]] #{##[index-of str a]
1A00051A01051A0205040202002101
}]
1A00051A01051A02051A03051A04051A0504021A061A071A081A091704020402
01
} contains-all? [str chars] #@[source: [[apply and [map [split chars ""] [fn [a] [>= [index-of str a] 0]]]]]] #{##[apply and map split chars "" anonymous [a] #@[source: [[>= [index-of str a] 0]]] #{##[index-of str a]
1A00051A01051A0205040202002101
}]
1A00051A01051A02051A03051A04051A0504021A061A071A081A091704020402
01
}]
1A001A011A021A03171A00070D1A041A051A061A07171A04070D1A081A091A0A
1A0B171A08070D1A0C1A0D1A0E1A0F171A0C070D1A101A111A121A13171A1007
0D1A141A151A161A17171A14070D1A181A191A1A1A1B171A18070D1A1C1A1D1A
1E1A1F171A1C070D1A201A211A221A23171A20070D1A241A251A261A27171A24
070D1A281A291A2A1A2B171A28070D1A2C1A2D1A2E1A2F171A2C070D1A30051A
311A321A331A341A351A361A371A381A391A3A1A3B1A3C1A3D1A3E1A3F1A4004
101A41070D1A421A431A441A45171A42070D1A461A471A481A49171A46070D1A
4A1A4B1A4C1A4D171A4A070D1A4A051A4E070D1A4F1A501A511A52171A4F070D
1A531A541A551A56171A53070D1A571A581A591A5A171A57070D1A5B1A5C1A5D
1A5E171A5B070D1A5F1A601A611A62171A5F070D1A631A641A651A66171A6307
0D1A671A681A691A6A171A67070D1A6B1A6C1A6D1A6E171A6B070D1A6F1A701A
711A72171A6F070D1A731A741A751A76171A73070D1A771A781A791A7A171A77
070D1A7B1A7C1A7D1A7E171A7B070D1A7F1A801A811A82171A7F0701
}#{##[module/insert :array/2d tree/new exports *module* tree/set! allocate array/2d/allocate [width height] #@[source: [[tree/new :data [-> [array/allocate [* width height]] [array/fill! 0]] :width width :height height]]] #{##[tree/new :data array/fill! array/allocate width height :width :height]
1A00051A011A02051A03051A04051A0505270401020004021A061A04051A071A
0505040601
} fill! array/2d/fill! [data v] #@[source: [[array/fill! [tree/ref data :data] v] [return data]]] #{##[array/fill! tree/ref data :data v]
1A00051A01051A02051A0304021A040504020D1A02050101
} ref array/2d/ref [data x y oob-val] #@[source: [[if [or [>= x [tree/ref data :width]] [>= y [tree/ref data :height]] [< x 0] [< y 0]] oob-val [array/ref [tree/ref data :data] [+ x [* y [tree/ref data :width]]]]]]] #{##[x tree/ref data :width y :height #f oob-val array/ref :data]
1A00051A01051A02051A030402210C0A002F0D1A04051A01051A02051A050402
210C0A001C0D1A000502001E0C0A00110D1A040502001E0C0A00060D1A060B00
091A07050900241A08051A01051A02051A0904021A00051A04051A01051A0205
1A0304022725040201
} set! array/2d/set! [data x y val] #@[source: [[if [or [>= x [tree/ref data :width]] [>= y [tree/ref data :height]] [< x 0] [< y 0]] [exception :out-of-bounds "Trying to set an array out of bounds" data] [array/set! [tree/ref data :data] [+ x [* y [tree/ref data :width]]] val]] [return data]]] #{##[x tree/ref data :width y :height #f throw list :out-of-bounds "Trying to set an array out of bounds" current-lambda array/set! :data val]
1A00051A01051A02051A030402210C0A002F0D1A04051A01051A02051A050402
210C0A001C0D1A000502001E0C0A00110D1A040502001E0C0A00060D1A060B00
1C1A07051A08051A091A0A1A02051A0B050400040404010900271A0C051A0105
1A02051A0D04021A00051A04051A01051A02051A03040227251A0E0504030D1A
02050101
} print array/2d/print [data] #@[source: [[dotimes [y [tree/ref data :height]] [dotimes [x [tree/ref data :width]] [display [cat [array/2d/ref data x y] " "]]] [newline]] [return data]]] #{##[y x print cat array/2d/ref data " " tree/ref :width newline :height]
1502001A00070D241B09005B0D1C1502001A01070D241B0900290D1C1A02051A
03051A04051A05051A01051A000504031A06040204010D02011A0105031A0108
1A01051A07051A05051A0804021E0AFFCC0D24160D1A090504000D02011A0005
031A00081A00051A07051A05051A0A04021E0AFF9A0D24160D1A05050101
}]
1A00051A01151A02052404011A03070D1A011A04070D1A05051A03051A061A07
1A081A091A0A171A070704030D1A05051A03051A0B1A0C1A0D1A0E1A0F171A0C
0704030D1A05051A03051A101A111A121A131A14171A110704030D1A05051A03
051A151A161A171A181A19171A160704030D1A05051A03051A1A1A1B1A1C1A1D
1A1E171A1B0704030D240D1316040201
}#{##[module/insert :avl tree/new exports *module* :e avl/empty avl/empty? [n] #@[source: [[= :e n]]] #{##[:e n]
1A001A01052001
} tree/set! default-cmp avl/default-cmp [x y] #@[source: [[if [< x y] -1 [if [> x y] 1 0]]]] #{##[x y]
1A00051A01051E0B000802FF0900141A00051A0105220B000802010900050200
01
} avl/typecheck [r k] #@[source: [[or [avl/empty? [avl/root r]] [= [type-of k] [type-of [avl/key [avl/root r]]]] [throw [list :type-error "AVL trees can only contains keys of a single type" k [current-lambda]]]]]] #{##[avl/empty? avl/root r type-of k avl/key throw list :type-error "AVL trees can only contains keys of a single type" current-lambda #f]
1A00051A01051A0205040104010C0A00410D1A03051A040504011A03051A0505
1A01051A0205040104010401200C0A00210D1A06051A07051A081A091A04051A
0A050400040404010C0A00060D1A0B01
} tree avl/tree [cmp] #@[source: [[array/new avl/empty [or cmp avl/default-cmp]]]] #{##[array/new avl/empty cmp avl/default-cmp #f]
1A00051A01051A02050C0A000E0D1A03050C0A00060D1A04040201
} avl/height [n] #@[source: [[if [avl/empty? n] 0 [array/ref n 0]]]] #{##[avl/empty? n array/ref]
1A00051A010504010B0008020009000D1A02051A01050200040201
} avl/key [n] #@[source: [[array/ref n 1]]] #{##[array/ref n]
1A00051A01050201040201
} avl/left [n] #@[source: [[array/ref n 2]]] #{##[array/ref n]
1A00051A01050202040201
} avl/right [n] #@[source: [[array/ref n 3]]] #{##[array/ref n]
1A00051A01050203040201
} avl/root [r] #@[source: [[array/ref r 0]]] #{##[array/ref r]
1A00051A01050200040201
} avl/cmp [r] #@[source: [[array/ref r 1]]] #{##[array/ref r]
1A00051A01050201040201
} avl/min-node [n] #@[source: [[if [avl/empty? n] avl/empty [let [[l [avl/left n]]] [if [avl/empty? l] n [avl/min-mode l]]]]]] #{##[avl/empty? n avl/empty avl/left l avl/min-mode]
1A00051A010504010B00091A020509002A151A03051A010504011A04070D1A00
051A040504010B00091A010509000B1A05051A040504011601
} avl/update-left [n l] #@[source: [[array/set! [array/dup n] 2 l]]] #{##[array/set! array/dup n l]
1A00051A01051A0205040102021A0305040301
} avl/update-right [n r] #@[source: [[array/set! [array/dup n] 3 r]]] #{##[array/set! array/dup n r]
1A00051A01051A0205040102031A0305040301
} avl/update-key [n k] #@[source: [[array/set! [array/dup n] 1 k]]] #{##[array/set! array/dup n k]
1A00051A01051A0205040102011A0305040301
} avl/update-root [t r] #@[source: [[array/set! [array/dup t] 0 r]]] #{##[array/set! array/dup t r]
1A00051A01051A0205040102001A0305040301
} avl/update-height [n] #@[source: [[array/set! [array/dup n] 0 [+ 1 [max [avl/height [avl/left n]] [avl/height [avl/right n]]]]]]] #{##[array/set! array/dup n max avl/height avl/left avl/right]
1A00051A01051A02050401020002011A03051A04051A05051A0205040104011A
04051A06051A020504010401040225040301
} avl/rotate-right [y] #@[source: [[let [[x [avl/left y]]] [avl/update-height [avl/update-right x [avl/update-height [avl/update-left y [avl/right x]]]]]]]] #{##[avl/left y x avl/update-height avl/update-right avl/update-left avl/right]
151A00051A010504011A02070D1A03051A04051A02051A03051A05051A01051A
06051A0205040104020401040204011601
} avl/rotate-left [x] #@[source: [[let [[y [avl/right x]]] [avl/update-height [avl/update-left y [avl/update-height [avl/update-right x [avl/left y]]]]]]]] #{##[avl/right x y avl/update-height avl/update-left avl/update-right avl/left]
151A00051A010504011A02070D1A03051A04051A02051A03051A05051A01051A
06051A0205040104020401040204011601
} avl/balance [n] #@[source: [[if [avl/empty? n] 0 [- [avl/height [avl/left n]] [avl/height [avl/right n]]]]]] #{##[avl/empty? n avl/height avl/left avl/right]
1A00051A010504010B0008020009001E1A02051A03051A0105040104011A0205
1A04051A0105040104012601
} avl/insert-rebalance [n cmp v] #@[source: [[let [[b [avl/balance n]]] [cond [[> b 1] [case [cmp v [avl/key [avl/left n]]] [-1 [avl/rotate-right n]] [1 [avl/rotate-right [avl/update-left n [avl/rotate-left [avl/left n]]]]] [0 n]]] [[< b -1] [case [cmp v [avl/key [avl/right n]]] [1 [avl/rotate-left n]] [-1 [avl/rotate-left [avl/update-right n [avl/rotate-right [avl/right n]]]]] [0 n]]] [#t n]]]]] #{##[avl/balance n b cmp v avl/key avl/left ΓεnΣym-1 avl/rotate-right avl/update-left avl/rotate-left avl/right ΓεnΣym-2 avl/update-right #t]
151A00051A010504011A02070D1A02050201220B006B151A03051A04051A0505
1A06051A01050401040104021A07070D1A070502FF200B000E1A08051A010504
010900391A07050201200B00201A08051A09051A01051A0A051A06051A010504
010401040204010900131A07050200200B00091A010509000424160900801A02
0502FF1E0B006B151A03051A04051A05051A0B051A01050401040104021A0C07
0D1A0C050201200B000E1A0A051A010504010900391A0C0502FF200B00201A0A
051A0D051A01051A08051A0B051A010504010401040204010900131A0C050200
200B00091A0105090004241609000F1A0E0B00091A0105090004241601
} avl/node-insert [n cmp v] #@[source: [[if [avl/empty? n] [array/new 1 v avl/empty avl/empty] [case [cmp v [avl/key n]] [-1 [avl/insert-rebalance [avl/update-height [avl/update-left n [avl/node-insert [avl/left n] cmp v]]] cmp v]] [1 [avl/insert-rebalance [avl/update-height [avl/update-right n [avl/node-insert [avl/right n] cmp v]]] cmp v]] [0 [avl/update-key n v]]]]]] #{##[avl/empty? n array/new v avl/empty cmp avl/key ΓεnΣym-3 avl/insert-rebalance avl/update-height avl/update-left avl/node-insert avl/left avl/update-right avl/right avl/update-key]
1A00051A010504010B00161A020502011A03051A04051A0405040409009F151A
05051A03051A06051A0105040104021A07070D1A070502FF200B00311A08051A
09051A0A051A01051A0B051A0C051A010504011A05051A03050403040204011A
05051A030504030900521A07050201200B00311A08051A09051A0D051A01051A
0B051A0E051A010504011A05051A03050403040204011A05051A030504030900
1B1A07050200200B00111A0F051A01051A03050402090004241601
} insert avl/insert [t v] #@[documentation: "Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" source: ["Insert key V into tree T.  If a node with an equivalent key already exists, its key is updated to V" [avl/typecheck t v] [avl/update-root t [avl/node-insert [avl/root t] [avl/cmp t] v]]]] #{##[avl/typecheck t v avl/update-root avl/node-insert avl/root avl/cmp]
1A00051A01051A020504020D1A03051A01051A04051A05051A010504011A0605
1A010504011A02050403040201
} avl/node-get [n cmp v] #@[source: [[if [avl/empty? n] #nil [case [cmp v [avl/key n]] [0 [avl/key n]] [-1 [avl/node-get [avl/left n] cmp v]] [1 [avl/node-get [avl/right n] cmp v]]]]]] #{##[avl/empty? n cmp v avl/key ΓεnΣym-4 avl/node-get avl/left avl/right]
1A00051A010504010B00072409006C151A02051A03051A04051A010504010402
1A05070D1A05050200200B000E1A04051A010504010900421A050502FF200B00
191A06051A07051A010504011A02051A030504030900231A05050201200B0019
1A06051A08051A010504011A02051A03050403090004241601
} get avl/get [t v] #@[documentation: "Retrieve the key V from tree T, or #nil if V is not in it" source: ["Retrieve the key V from tree T, or #nil if V is not in it" [if [or [avl/empty? [avl/root t]] [not= [type-of v] [type-of [avl/key [avl/root t]]]]] #nil [avl/node-get [avl/root t] [avl/cmp t] v]]]] #{##[avl/empty? avl/root t not= type-of v avl/key #f avl/node-get avl/cmp]
1A00051A01051A0205040104010C0A002A0D1A03051A04051A050504011A0405
1A06051A01051A020504010401040104020C0A00060D1A070B00072409001B1A
08051A01051A020504011A09051A020504011A0505040301
} from-list avl/from-list [l cmp] #@[documentation: "Create a new avl tree using the keys in L and the comparison function CMP" source: ["Create a new avl tree using the keys in L and the comparison function CMP" [list/reduce l avl/insert [avl/tree cmp]]]] #{##[list/reduce l avl/insert avl/tree cmp]
1A00051A01051A02051A03051A04050401040301
} avl/remove-rebalance [n] #@[source: [[if [avl/empty? n] n [let [[b [avl/balance n]] [l [avl/left n]] [r [avl/right n]]] [cond [[> b 1] [if [>= [avl/balance l] 0] [avl/rotate-right n] [avl/rotate-right [avl/update-left n [avl/rotate-left l]]]]] [[< b -1] [if [<= [avl/balance r] 0] [avl/rotate-left n] [avl/rotate-left [avl/update-right n [avl/rotate-right r]]]]] [#t n]]]]]] #{##[avl/empty? n avl/balance b avl/left l avl/right r avl/rotate-right avl/update-left avl/rotate-left avl/update-right #t]
1A00051A010504010B00091A01050900A9151A02051A010504011A03070D1A04
051A010504011A05070D1A06051A010504011A07070D1A03050201220B00341A
02051A050504010200210B000E1A08051A010504010900181A08051A09051A01
051A0A051A05050401040204010900491A030502FF1E0B00341A02051A070504
0102001F0B000E1A0A051A010504010900181A0A051A0B051A01051A08051A07
0504010402040109000F1A0C0B00091A0105090004241601
} avl/node-remove [n cmp v] #@[source: [[if [avl/empty? n] n [let [[root [case [cmp v [avl/key n]] [-1 [avl/update-left n [avl/node-remove [avl/left n] cmp v]]] [1 [avl/update-right n [avl/node-remove [avl/right n] cmp v]]] [0 [cond [[avl/empty? [avl/left n]] [avl/right n]] [[avl/empty? [avl/right n]] [avl/left n]] [#t [let [[k [avl/key [avl/min-node [avl/right n]]]]] [avl/update-key [avl/update-right [avl/right n] [avl/node-remove [avl/right n] cmp v]] k]]]]]]]] [set! root [avl/update-height root]] [avl/remove-rebalance root]]]]] #{##[avl/empty? n cmp v avl/key ΓεnΣym-5 avl/update-left avl/node-remove avl/left avl/update-right avl/right #t avl/min-node k avl/update-key root avl/update-height avl/remove-rebalance]
1A00051A010504010B00091A010509010D15151A02051A03051A04051A010504
0104021A05070D1A050502FF200B00211A06051A01051A07051A08051A010504
011A02051A0305040304020900B61A05050201200B00211A09051A01051A0705
1A0A051A010504011A02051A03050403040209008F1A05050200200B00851A00
051A08051A0105040104010B000E1A0A051A010504010900671A00051A0A051A
0105040104010B000E1A08051A0105040109004C1A0B0B0046151A04051A0C05
1A0A051A01050401040104011A0D070D1A0E051A09051A0A051A010504011A07
051A0A051A010504011A02051A0305040304021A0D0504021609000424090004
24161A0F070D1A10051A0F0504011A0F080D1A11051A0F0504011601
} remove avl/remove [t v] #@[documentation: "Remove the key V from tree T if it is contained within it" source: ["Remove the key V from tree T if it is contained within it" [avl/update-root t [avl/node-remove [avl/root t] [avl/cmp t] v]]]] #{##[avl/update-root t avl/node-remove avl/root avl/cmp v]
1A00051A01051A02051A03051A010504011A04051A010504011A050504030402
01
} avl/equal-node? [a b] #@[source: [[if [avl/empty? a] [avl/empty? b] [and [equal? [avl/key a] [avl/key b]] [avl/equal-node? [avl/left a] [avl/left b]] [avl/equal-node? [avl/right a] [avl/right b]]]]]] #{##[avl/empty? a b equal? avl/key avl/equal-node? avl/left avl/right]
1A00051A010504010B000E1A00051A0205040109004C1A03051A04051A010504
011A04051A0205040104020C0B00330D1A05051A06051A010504011A06051A02
05040104020C0B00190D1A05051A07051A010504011A07051A02050401040201
} equal? avl/equal? [a b] #@[documentation: "Test if two avl trees are equal" source: ["Test if two avl trees are equal" [avl/equal-node? [avl/root a] [avl/root b]]]] #{##[avl/equal-node? avl/root a b]
1A00051A01051A020504011A01051A03050401040201
} avl/reduce-node [node o s] #@[source: [[if [avl/empty? node] s [o [avl/key node] [avl/reduce-node [avl/right node] o [avl/reduce-node [avl/left node] o s]]]]]] #{##[avl/empty? node s o avl/key avl/reduce-node avl/right avl/left]
1A00051A010504010B00091A02050900331A03051A04051A010504011A05051A
06051A010504011A03051A05051A07051A010504011A03051A02050403040304
0201
} reduce avl/reduce [t o s] #@[documentation: "Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" source: ["Reduce T in-order with a reducer O taking a key and the result of the reductions of one subtree" [avl/reduce-node [avl/root t] o s]]] #{##[avl/reduce-node avl/root t o s]
1A00051A01051A020504011A03051A0405040301
} avl/reduce-node-bin [n o s] #@[source: [[if [avl/empty? n] s [o [o [avl/key n] [avl/reduce-node-bin [avl/left n] o s]] [avl/reduce-node-bin [avl/right n] o s]]]]] #{##[avl/empty? n s o avl/key avl/reduce-node-bin avl/left avl/right]
1A00051A010504010B00091A020509003B1A03051A03051A04051A010504011A
05051A06051A010504011A03051A0205040304021A05051A07051A010504011A
03051A02050403040201
} reduce-bin avl/reduce-bin [t o s] #@[documentation: "Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" source: ["Reduce T with a reducer O taking a key and the result of the reductions of both subtrees" [avl/reduce-node-bin [avl/root t] o s]]] #{##[avl/reduce-node-bin avl/root t o s]
1A00051A01051A020504011A03051A0405040301
} map avl/map [t f] #@[documentation: "Create a new avl tree by mapping each key in T using F, using the same comparison function as T" source: ["Create a new avl tree by mapping each key in T using F, using the same comparison function as T" [avl/reduce t [fn [x acc] [avl/insert acc [f x]]] [avl/tree [avl/cmp t]]]]] #{##[avl/reduce t anonymous [x acc] #@[source: [[avl/insert acc [f x]]]] #{##[avl/insert acc f x]
1A00051A01051A02051A03050401040201
} avl/tree avl/cmp]
1A00051A01051A021A031A041A05171A06051A07051A010504010401040301
} map-to avl/map-to [t f cmp] #@[documentation: "Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" source: ["Create a new avl tree by mapping each key in in T using F, using the comparison function CMP, which may be different from the comparison used in T" [avl/reduce t [fn [x acc] [avl/insert acc [f x]]] [avl/tree cmp]]]] #{##[avl/reduce t anonymous [x acc] #@[source: [[avl/insert acc [f x]]]] #{##[avl/insert acc f x]
1A00051A01051A02051A03050401040201
} avl/tree cmp]
1A00051A01051A021A031A041A05171A06051A07050401040301
} to-list avl/to-list [t] #@[source: [[avl/reduce t cons #nil]]] #{##[avl/reduce t cons]
1A00051A01051A020524040301
}]
1A00051A01151A02052404011A03070D1A011A04070D1A051A06070D1A071A08
1A091A0A171A07070D1A0B051A03051A0C1A0D1A0E1A0F1A10171A0D0704030D
1A111A121A131A14171A11070D1A0B051A03051A151A161A171A181A19171A16
0704030D1A1A1A1B1A1C1A1D171A1A070D1A1E1A1F1A201A21171A1E070D1A22
1A231A241A25171A22070D1A261A271A281A29171A26070D1A2A1A2B1A2C1A2D
171A2A070D1A2E1A2F1A301A31171A2E070D1A321A331A341A35171A32070D1A
361A371A381A39171A36070D1A3A1A3B1A3C1A3D171A3A070D1A3E1A3F1A401A
41171A3E070D1A421A431A441A45171A42070D1A461A471A481A49171A46070D
1A4A1A4B1A4C1A4D171A4A070D1A4E1A4F1A501A51171A4E070D1A521A531A54
1A55171A52070D1A561A571A581A59171A56070D1A5A1A5B1A5C1A5D171A5A07
0D1A0B051A03051A5E1A5F1A601A611A62171A5F0704030D1A631A641A651A66
171A63070D1A0B051A03051A671A681A691A6A1A6B171A680704030D1A0B051A
03051A6C1A6D1A6E1A6F1A70171A6D0704030D1A711A721A731A74171A71070D
1A751A761A771A78171A75070D1A0B051A03051A791A7A1A7B1A7C1A7D171A7A
0704030D1A7E1A7F1A801A81171A7E070D1A0B051A03051A821A831A841A851A
86171A830704030D1A871A881A891A8A171A87070D1A0B051A03051A8B1A8C1A
8D1A8E1A8F171A8C0704030D1A901A911A921A93171A90070D1A0B051A03051A
941A951A961A971A98171A950704030D1A0B051A03051A991A9A1A9B1A9C1A9D
171A9A0704030D1A0B051A03051A9E1A9F1AA01AA11AA2171A9F0704030D1A0B
051A03051AA31AA41AA51AA61AA7171AA40704030D240D1316040201
}#{##[module/insert :crypto/adler32 tree/new exports *module* tree/set! hash [data] #@[source: [[def a 1] [def b 0] [when [string? data] [set! data [string->buffer data]]] [when [not= [type-of data] :buffer] [exception :type-error "Can only hash buffers or strings"]] [def v [buffer/view/u8* data]] [dotimes [i [buffer/length data]] [set! a [mod/int [add/int a [buffer/view/ref v i]] 65521]] [set! b [mod/int [add/int a b] 65521]]] [bit-or a [bit-shift-left b 16]]]] #{##[a b string? data string->buffer not= type-of :buffer throw list :type-error "Can only hash buffers or strings" current-lambda buffer/view/u8* v i mod/int buffer/view/ref 65521 buffer/length bit-or bit-shift-left]
02011A00070D02001A01070D1A02051A030504010B00111A04051A030504011A
0308090004240D1A05051A06051A030504011A0704020B001A1A08051A09051A
0A1A0B241A0C05040004040401090004240D1A0D051A030504011A0E070D1502
001A0F070D241B09003A0D1C1A10051A00051A11051A0E051A0F050402031A12
04021A00080D1A10051A00051A0105031A1204021A01080D02011A0F05031A0F
081A0F051A13051A030504011E0AFFBD0D24160D1A14051A00051A15051A0105
02100402040201
}]
1A00051A01151A02052404011A03070D1A011A04070D1A05051A03051A061A06
1A071A081A09171A060704030D240D1316040201
}#{##[module/insert :image/bmp tree/new exports *module* buffer/view/le/set! [u8v offset bytes val] #@[source: [[while [> bytes 0] [buffer/view/set! u8v [inc! offset] [bit-and 255 val]] [dec! bytes] [set! val [bit-shift-right val 8]]] offset]] #{##[buffer/view/set! u8v offset bit-and 255 val bytes bit-shift-right]
241B0900380D1C1A00051A01051A02050201251A02081A03051A041A05050402
04030D1A06050201261A06080D1A07051A0505020804021A05081A0605020022
0AFFC50D1A020501
} image/bmp/row-padding [width pixel-length] #@[source: [[def ret [- 4 [bit-and [* width pixel-length] 3]]] [if [= ret 4] 0 ret]]] #{##[bit-and width pixel-length ret]
02041A00051A01051A02052702030402261A03070D1A03050204200B00080200
0900061A030501
} tree/set! encode image/bmp/encode [image] #@[source: [[require :image] [def image-size [* [tree/ref image :height] 3 [+ [tree/ref image :width] [image/bmp/row-padding [tree/ref image :width] 3]]]] [def header-size [+ 14 40]] [def file-size [+ image-size header-size]] [def out [buffer/allocate file-size]] [def b [buffer/view/u8* out]] [def i -1] [buffer/view/set! b [inc! i] 66] [buffer/view/set! b [inc! i] 77] [set! i [buffer/view/le/set! b i 4 file-size]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 header-size]] [set! i [buffer/view/le/set! b i 4 40]] [set! i [buffer/view/le/set! b i 4 [tree/ref image :width]]] [set! i [buffer/view/le/set! b i 4 [tree/ref image :height]]] [set! i [buffer/view/le/set! b i 2 1]] [set! i [buffer/view/le/set! b i 2 24]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 image-size]] [set! i [buffer/view/le/set! b i 4 8192]] [set! i [buffer/view/le/set! b i 4 8192]] [set! i [buffer/view/le/set! b i 4 0]] [set! i [buffer/view/le/set! b i 4 0]] [def row-padding [image/bmp/row-padding [tree/ref image :width] 3]] [def pixels [- header-size 1]] [let [[y [- [tree/ref image :height] 1]]] [while [>= y 0] [dotimes [x [tree/ref image :width]] [set! pixels [buffer/view/le/set! b pixels 3 [image/ref image x y]]]] [set! pixels [+ pixels row-padding]] [set! y [add/int y -1]]]] [return out]]] #{##[require* :image current-closure #t tree/ref image :height :width image/bmp/row-padding image-size header-size file-size buffer/allocate out buffer/view/u8* b i buffer/view/set! buffer/view/le/set! 8192 row-padding pixels y x image/ref]
1A00051A011A020504001A0304030D1A04051A05051A0604020203271A04051A
05051A0704021A08051A04051A05051A0704020203040225271A09070D02361A
0A070D1A09051A0A05251A0B070D1A0C051A0B0504011A0D070D1A0E051A0D05
04011A0F070D02FF1A10070D1A11051A0F051A10050201251A1008024204030D
1A11051A0F051A10050201251A1008024D04030D1A12051A0F051A100502041A
0B0504041A10080D1A12051A0F051A10050204020004041A10080D1A12051A0F
051A100502041A0A0504041A10080D1A12051A0F051A10050204022804041A10
080D1A12051A0F051A100502041A04051A05051A07040204041A10080D1A1205
1A0F051A100502041A04051A05051A06040204041A10080D1A12051A0F051A10
050202020104041A10080D1A12051A0F051A10050202021804041A10080D1A12
051A0F051A10050204020004041A10080D1A12051A0F051A100502041A090504
041A10080D1A12051A0F051A100502041A1304041A10080D1A12051A0F051A10
0502041A1304041A10080D1A12051A0F051A10050204020004041A10080D1A12
051A0F051A10050204020004041A10080D1A08051A04051A05051A0704020203
04021A14070D1A0A050201261A15070D151A04051A05051A0604020201261A16
070D241B0900640D1C1502001A17070D241B09002D0D1C1A12051A0F051A1505
02031A18051A05051A17051A1605040304041A15080D02011A1705031A17081A
17051A04051A05051A0704021E0AFFC80D24160D1A15051A1405251A15080D1A
160502FF031A16081A16050200210AFF99160D1A0D050101
} init! image/bmp/init! [] #@[source: [[require :image] [image/add-encoder! "bmp" image/bmp/encode]]] #{##[require* :image current-closure #t image/add-encoder! "bmp" image/bmp/encode]
1A00051A011A020504001A0304030D1A04051A051A0605040201
}]
1A00051A01151A02052404011A03070D1A011A04070D1A051A061A071A08171A
05070D1A091A0A1A0B1A0C171A09070D1A0D051A03051A0E1A0F1A101A111A12
171A0F0704030D1A0D051A03051A131A141A151A161A17171A140704030D240D
1316040201
}#{##[module/insert :image tree/new exports *module* image/decoders image/encoders tree/set! add-encoder! image/add-encoder! [ext enc] #@[source: [[def ext [string->keyword [lowercase ext]]] [tree/set! image/encoders ext enc]]] #{##[symbol->keyword string->symbol lowercase ext tree/set! image/encoders enc]
1A00051A01051A02051A03050401040104011A03070D1A04051A05051A03051A
0605040301
} add-decoder! image/add-decoder! [ext dec] #@[source: [[def ext [string->keyword [lowercase ext]]] [tree/set! image/decoders ext dec]]] #{##[symbol->keyword string->symbol lowercase ext tree/set! image/decoders dec]
1A00051A01051A02051A03050401040104011A03070D1A04051A05051A03051A
0605040301
} image/get-encoder [path] #@[source: [[def ext [string->keyword [lowercase [path/extension path]]]] [tree/ref image/encoders ext]]] #{##[symbol->keyword string->symbol lowercase path/extension path ext tree/ref image/encoders]
1A00051A01051A02051A03051A040504010401040104011A05070D1A06051A07
051A0505040201
} image/get-decoder [path] #@[source: [[def ext [string->keyword [lowercase [path/extension path]]]] [tree/ref image/decoders ext]]] #{##[symbol->keyword string->symbol lowercase path/extension path ext tree/ref image/decoders]
1A00051A01051A02051A03051A040504010401040104011A05070D1A06051A07
051A0505040201
} new image/new [width height] #@[source: [[def buffer [buffer/allocate [* width height 4]]] [tree/new :width width :height height :buffer buffer :pixels [buffer/view/u32* buffer]]]] #{##[buffer/allocate width height buffer tree/new :width :height :buffer :pixels buffer/view/u32*]
1A00051A01051A02052702042704011A03070D1A04051A051A01051A061A0205
1A071A03051A081A09051A03050401040801
} ref image/ref [img x y] #@[source: [[def i [+ [int x] [* [int y] [tree/ref img :width]]]] [buffer/view/ref [tree/ref img :pixels] i]]] #{##[int x y tree/ref img :width i buffer/view/ref :pixels]
1A00051A010504011A00051A020504011A03051A04051A05040227251A06070D
1A07051A03051A04051A0804021A0605040201
} set! image/set! [img x y value] #@[source: [[def i [+ [int x] [* [int y] [tree/ref img :width]]]] [buffer/view/set! [tree/ref img :pixels] i value]]] #{##[int x y tree/ref img :width i buffer/view/set! :pixels value]
1A00051A010504011A00051A020504011A03051A04051A05040227251A06070D
1A07051A03051A04051A0804021A06051A0905040301
} fill! image/fill! [img value] #@[source: [[def p [tree/ref img :pixels]] [dotimes [i [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! p i value]] [return img]]] #{##[tree/ref img :pixels p i buffer/view/set! value :width :height]
1A00051A01051A0204021A03070D1502001A04070D241B09001D0D1C1A05051A
03051A04051A060504030D02011A0405031A04081A04051A00051A01051A0704
021A00051A01051A080402271E0AFFCD0D24160D1A01050101
} map! image/map! [img fun] #@[source: [[def p [tree/ref img :pixels]] [dotimes [i [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! p i [fun [buffer/view/ref p i]]]] [return img]]] #{##[tree/ref img :pixels p i buffer/view/set! fun buffer/view/ref :width :height]
1A00051A01051A0204021A03070D1502001A04070D241B09002A0D1C1A05051A
03051A04051A06051A07051A03051A04050402040104030D02011A0405031A04
081A04051A00051A01051A0804021A00051A01051A090402271E0AFFC00D2416
0D1A01050101
} dup image/dup [img] #@[source: [[def ret [image/new [tree/ref img :width] [tree/ref img :height]]] [def in [tree/ref img :pixels]] [def out [tree/ref ret :pixels]] [dotimes [i [* [tree/ref img :width] [tree/ref img :height]]] [buffer/view/set! out i [buffer/view/ref in i]]] [return ret]]] #{##[image/new tree/ref img :width :height ret :pixels in out i buffer/view/set! buffer/view/ref]
1A00051A01051A02051A0304021A01051A02051A04040204021A05070D1A0105
1A02051A0604021A07070D1A01051A05051A0604021A08070D1502001A09070D
241B0900250D1C1A0A051A08051A09051A0B051A07051A0905040204030D0201
1A0905031A09081A09051A01051A02051A0304021A01051A02051A040402271E
0AFFC50D24160D1A05050101
} save! image/save! [img path] #@[source: [[def enc [image/get-encoder path]] [if enc [file/write [enc img] path] [exception :missing-encoder "Currently there is no encoder loaded for that image format" path]]]] #{##[image/get-encoder path enc file/write img throw list :missing-encoder "Currently there is no encoder loaded for that image format" current-lambda]
1A00051A010504011A02070D1A02050B00161A03051A02051A040504011A0105
04020900191A05051A06051A071A081A01051A090504000404040101
} adler32 image/adler32 [img] #@[source: [[import [hash] :crypto/adler32] [hash [tree/ref img :buffer]]]] #{##[module/import module/load :crypto/adler32 hash tree/ref img :buffer]
1A00051A01051A0204011A0304021A03070D1A03051A04051A05051A06040204
0101
} test-image-xor image/test-image-xor [] #@[source: [[def w 256] [def h 256] [def out [image/new w h]] [dotimes [x w] [dotimes [y h] [image/set! out x y [bit-or x [bit-shift-left y 8] [bit-shift-left [bit-xor x y] 16]]]]] [return out]]] #{##[256 w h image/new out x y image/set! bit-or bit-shift-left bit-xor]
1A001A01070D1A001A02070D1A03051A01051A020504021A04070D1502001A05
070D241B09006B0D1C1502001A06070D241B0900460D1C1A07051A04051A0505
1A06051A08051A08051A05051A09051A06050208040204021A09051A0A051A05
051A0605040202100402040204040D02011A0605031A06081A06051A02051E0A
FFB60D24160D02011A0505031A05081A05051A01051E0AFF910D24160D1A0405
0101
}]
1A00051A01151A02052404011A03070D1A011A04070D1A02052404011A05070D
1A02052404011A06070D1A07051A03051A081A091A0A1A0B1A0C171A09070403
0D1A07051A03051A0D1A0E1A0F1A101A11171A0E0704030D1A121A131A141A15
171A12070D1A161A171A181A19171A16070D1A07051A03051A1A1A1B1A1C1A1D
1A1E171A1B0704030D1A07051A03051A1F1A201A211A221A23171A200704030D
1A07051A03051A241A251A261A271A28171A250704030D1A07051A03051A291A
2A1A2B1A2C1A2D171A2A0704030D1A07051A03051A2E1A2F1A301A311A32171A
2F0704030D1A07051A03051A331A341A351A361A37171A340704030D1A07051A
03051A381A391A3A1A3B1A3C171A390704030D1A07051A03051A3D1A3E1A3F1A
401A41171A3E0704030D1A07051A03051A421A431A441A451A46171A43070403
0D240D1316040201
}#{##[module/insert :io/ansi tree/new exports *module* #f disabled tree/set! disable! [v] #@[source: [[set! disabled [if [nil? v] #t v]]]] #{##[nil? v #t disabled]
1A00051A010504010B00081A020900061A01051A030801
} "\e[0m" reset "\e[0;39m" fg-reset "\e[49m" bg-reset array/new "\e[0;30m" "\e[0;31m" "\e[0;32m" "\e[0;33m" "\e[0;34m" "\e[0;35m" "\e[0;36m" "\e[0;37m" "\e[1;30m" "\e[1;31m" "\e[1;32m" "\e[1;33m" "\e[1;34m" "\e[1;35m" "\e[1;36m" "\e[1;37m" ansi-fg "\e[40m" "\e[41m" "\e[42m" "\e[43m" "\e[44m" "\e[45m" "\e[46m" "\e[47m" ansi-bg wrap [code string] #@[documentation: "Wrap STRING in the ansi color CODE" source: ["Wrap STRING in the ansi color CODE" [cat [or disabled [array/ref ansi-fg code]] string [or disabled reset]]]] #{##[cat disabled array/ref ansi-fg code #f string reset]
1A00051A01050C0A00160D1A02051A03051A040504020C0A00060D1A051A0605
1A01050C0A000E0D1A07050C0A00060D1A05040301
} black args #@[source: [[wrap 0 [apply cat args]]]] #{##[wrap apply cat args]
1A000502001A01051A02051A03050402040201
} dark-red #@[source: [[wrap 1 [apply cat args]]]] #{##[wrap apply cat args]
1A000502011A01051A02051A03050402040201
} dark-green #@[source: [[wrap 2 [apply cat args]]]] #{##[wrap apply cat args]
1A000502021A01051A02051A03050402040201
} dark-brown brown #@[source: [[wrap 3 [apply cat args]]]] #{##[wrap apply cat args]
1A000502031A01051A02051A03050402040201
} dark-blue #@[source: [[wrap 4 [apply cat args]]]] #{##[wrap apply cat args]
1A000502041A01051A02051A03050402040201
} purple #@[source: [[wrap 5 [apply cat args]]]] #{##[wrap apply cat args]
1A000502051A01051A02051A03050402040201
} teal #@[source: [[wrap 6 [apply cat args]]]] #{##[wrap apply cat args]
1A000502061A01051A02051A03050402040201
} dark-gray #@[source: [[wrap 7 [apply cat args]]]] #{##[wrap apply cat args]
1A000502071A01051A02051A03050402040201
} gray #@[source: [[wrap 8 [apply cat args]]]] #{##[wrap apply cat args]
1A000502081A01051A02051A03050402040201
} red #@[source: [[wrap 9 [apply cat args]]]] #{##[wrap apply cat args]
1A000502091A01051A02051A03050402040201
} green #@[source: [[wrap 10 [apply cat args]]]] #{##[wrap apply cat args]
1A0005020A1A01051A02051A03050402040201
} yellow #@[source: [[wrap 11 [apply cat args]]]] #{##[wrap apply cat args]
1A0005020B1A01051A02051A03050402040201
} blue #@[source: [[wrap 12 [apply cat args]]]] #{##[wrap apply cat args]
1A0005020C1A01051A02051A03050402040201
} pink #@[source: [[wrap 13 [apply cat args]]]] #{##[wrap apply cat args]
1A0005020D1A01051A02051A03050402040201
} cyan #@[source: [[wrap 14 [apply cat args]]]] #{##[wrap apply cat args]
1A0005020E1A01051A02051A03050402040201
} white #@[source: [[wrap 15 [apply cat args]]]] #{##[wrap apply cat args]
1A0005020F1A01051A02051A03050402040201
} rainbow #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [let* [def count 0] [cat [join [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] ""] [or disabled fg-reset]]]]] #{##[count cat join map split apply args "" anonymous [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [if [zero? count] 7 [+ count 8]]]] a]]] #{##[bit-and count cat disabled array/ref ansi-fg #f a]
1A000502011A010525020704021A01080D1A02051A03050C0A00250D1A04051A
05051A01052A0B000802070900091A010502082504020C0A00060D1A061A0705
040201
} disabled fg-reset #f]
1502001A00070D1A01051A02051A03051A04051A05051A01051A060504021A07
04021A081A091A0A1A0B1704021A0704021A0C050C0A000E0D1A0D050C0A0006
0D1A0E04021601
} rainbow-bg #@[documentation: "Wrap ARGS in the colors of the rainbow!" source: ["Wrap ARGS in the colors of the rainbow!" [def count 0] [def colored-list [map [split [apply cat args] ""] [fn [a] [set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [bit-xor count 7]]] [or disabled [array/ref ansi-bg count]] a]]]] [cat [join colored-list ""] [or disabled reset]]]] #{##[count map split apply cat args "" anonymous [a] #@[source: [[set! count [bit-and [+ 1 count] 7]] [cat [or disabled [array/ref ansi-fg [bit-xor count 7]]] [or disabled [array/ref ansi-bg count]] a]]] #{##[bit-and count cat disabled array/ref ansi-fg bit-xor #f ansi-bg a]
1A000502011A010525020704021A01080D1A02051A03050C0A001D0D1A04051A
05051A06051A01050207040204020C0A00060D1A071A03050C0A00160D1A0405
1A08051A010504020C0A00060D1A071A0905040301
} colored-list join disabled reset #f]
02001A00070D1A01051A02051A03051A04051A050504021A0604021A071A081A
091A0A1704021A0B070D1A04051A0C051A0B051A0604021A0D050C0A000E0D1A
0E050C0A00060D1A0F040201
} reprint-line [text width] #@[source: [[when-not width [set! width 20]] [print "\r"] [dotimes [i width] [print " "]] [print "\r"] [print text]]] #{##[width print "\r" i " " text]
1A00050B00072409000802141A00080D1A01051A0204010D1502001A03070D24
1B0900160D1C1A01051A0404010D02011A0305031A03081A03051A00051E0AFF
E60D24160D1A01051A0204010D1A01051A0505040101
}]
1A00051A01151A02052404011A03070D1A011A04070D1A051A06070D1A07051A
03051A081A081A091A0A1A0B171A080704030D1A0C1A0D070D1A0E1A0F070D1A
101A11070D1A12051A131A141A151A161A171A181A191A1A1A1B1A1C1A1D1A1E
1A1F1A201A211A2204101A23070D1A12051A241A251A261A271A281A291A2A1A
2B04081A2C070D1A07051A03051A2D1A2D1A2E1A2F1A30171A2D0704030D1A07
051A03051A311A311A321A331A34171A310704030D1A07051A03051A351A351A
321A361A37171A350704030D1A07051A03051A381A381A321A391A3A171A3807
04030D1A07051A03051A3B1A3C1A321A3D1A3E171A3C0704030D1A07051A0305
1A3F1A3F1A321A401A41171A3F0704030D1A07051A03051A421A421A321A431A
44171A420704030D1A07051A03051A451A451A321A461A47171A450704030D1A
07051A03051A481A481A321A491A4A171A480704030D1A07051A03051A4B1A4B
1A321A4C1A4D171A4B0704030D1A07051A03051A4E1A4E1A321A4F1A50171A4E
0704030D1A07051A03051A511A511A321A521A53171A510704030D1A07051A03
051A541A541A321A551A56171A540704030D1A07051A03051A571A571A321A58
1A59171A570704030D1A07051A03051A5A1A5A1A321A5B1A5C171A5A0704030D
1A07051A03051A5D1A5D1A321A5E1A5F171A5D0704030D1A07051A03051A601A
601A321A611A62171A600704030D1A07051A03051A631A631A321A641A65171A
630704030D1A07051A03051A661A661A321A671A68171A660704030D1A07051A
03051A691A691A6A1A6B1A6C171A690704030D240D1316040201
}#{##[module/insert :serialization/json tree/new exports *module* tree->json [v] #@[documentation: "Converts a tree into a JSON encoded string, you should prefer VAL->JSON" source: ["Converts a tree into a JSON encoded string, you should prefer VAL->JSON" [cat "{" [join [map [tree/keys v] [fn [k] [cat "\"" [keyword->string k] "\": " [val->json [tree/ref v k]]]]] ",\n"] "}"]]] #{##[cat "{" join map tree/keys v anonymous [k] #@[source: [[cat "\"" [keyword->string k] "\": " [val->json [tree/ref v k]]]]] #{##[cat "\"" keyword->string k "\": " val->json tree/ref v]
1A00051A011A02051A030504011A041A05051A06051A07051A03050402040104
0401
} ",\n" "}"]
1A00051A011A02051A03051A04051A050504011A061A071A081A091704021A0A
04021A0B040301
} tree/set! serialize val->json [v] #@[documentation: "Return V as a JSON encoded string" source: ["Return V as a JSON encoded string" [case [type-of v] [:nil "null"] [[:int :float] [string v]] [:bool [if v "true" "false"]] [[:array :pair] [cat "[" [join [map v val->json] ","] "]"]] [:string [string/write v]] [:symbol [cat "\"" [symbol->string v] "\""]] [:keyword [cat "\"" [keyword->string v] "\""]] [:tree [tree->json v]] [otherwise [throw [list :type-error "Can't encode the value into JSON" v [current-lambda]]]]]]] #{##[type-of v ΓεnΣym-1 :nil "null" :int :float #f string :bool "true" "false" :array :pair cat "[" join map val->json "," "]" :string string/write :symbol "\"" symbol->string :keyword keyword->string :tree tree->json throw list :type-error "Can't encode the value into JSON" current-lambda]
151A00051A010504011A02070D1A02051A03200B00081A040900F31A02051A05
200C0A00110D1A02051A06200C0A00060D1A070B000E1A08051A010504010900
CD1A02051A09200B00131A01050B00081A0A0900051A0B0900B41A02051A0C20
0C0A00110D1A02051A0D200C0A00060D1A070B00211A0E051A0F1A10051A1105
1A01051A120504021A1304021A14040309007B1A02051A15200B000E1A16051A
010504010900671A02051A17200B00171A0E051A181A19051A010504011A1804
0309004A1A02051A1A200B00171A0E051A181A1B051A010504011A1804030900
2D1A02051A1C200B000E1A1D051A010504010900191A1E051A1F051A201A211A
01051A22050400040404011601
}]
1A00051A01151A02052404011A03070D1A011A04070D1A051A061A071A08171A
05070D1A09051A03051A0A1A0B1A0C1A0D1A0E171A0B0704030D240D13160402
01
}#{##[module/insert :test tree/new exports *module* test-list test-count nujel-start success-count error-count #t print-errors #f print-passes tree/set! add* test/add* [result expr] #@[source: [[set! test-list [cons [cons result expr] test-list]] [set! test-count [+ test-count 1]]]] #{##[result expr test-list test-count]
1A00051A0105141A0205141A02080D1A03050201251A030801
} add test/add [result . expr] #@[documentation: "Add a test where EXPR must eval to RESULT" source: ["Add a test where EXPR must eval to RESULT" [quasiquote [[unquote test/add*] [unquote result] [unquote [list 'quote [cons 'do expr]]]]]]] #{##[test/add* result list quote do expr]
1A00051A01051A02051A031A041A05051404022414141401
} reset! [] #@[source: [[set! test-list [cons 4 '[+ 3 1]]] [set! test-count 1]]] #{##[[+ 3 1] test-list test-count]
02041A00141A01080D02011A020801
} display-results [description] #@[documentation: "Prints the result Message" source: ["Prints the result Message" [random/seed-initialize!] [efmtln "{} {} - [{} / {}] in {} ms" [if [and [zero? error-count] [> test-count 0]] [if [zero? success-count] [ansi-yellow "?"] [ansi-green "✓"]] [ansi-red "✗"]] description [if [zero? success-count] [ansi-yellow success-count] [ansi-green success-count]] [if [zero? error-count] [ansi-gray error-count] [ansi-red error-count]] [- [time/milliseconds] nujel-start]]]] #{##[random/seed-initialize! errorln error-count test-count success-count ansi-yellow "?" ansi-green "✓" ansi-red "✗" fmt-arg-0 description fmt-arg-1 fmt-arg-2 ansi-gray fmt-arg-3 time/milliseconds nujel-start fmt-arg-4 cat " " " - [" " / " "] in " " ms"]
1A000504000D1A0105151A02052A0C0B000A0D1A03050200220B001E1A04052A
0B000D1A05051A06040109000A1A07051A08040109000A1A09051A0A04011A0B
070D1A0C051A0D070D1A04052A0B000E1A05051A0405040109000B1A07051A04
0504011A0E070D1A02052A0B000E1A0F051A0205040109000B1A09051A020504
011A10070D1A110504001A1205261A13070D1A14051A0B051A151A0D051A161A
0E051A171A10051A181A13051A19040A16040101
} test-success [res-should res-is expr] #@[documentation: "Should be called after a test has finished successfully" source: ["Should be called after a test has finished successfully" [when print-passes [efmtln "{} == {}\r\n{}\r\n\r\n" [ansi-green [string/write res-is]] [ansi-green [string/write res-should]] [string/write expr]]] [set! success-count [+ 1 success-count]]]] #{##[print-passes errorln ansi-green string/write res-is fmt-arg-0 res-should fmt-arg-1 expr fmt-arg-2 cat " == " "\r\n" "\r\n\r\n" success-count]
1A00050B004F1A0105151A02051A03051A0405040104011A05070D1A02051A03
051A0605040104011A07070D1A03051A080504011A09070D1A0A051A05051A0B
1A07051A0C1A09051A0D0406160401090004240D02011A0E05251A0E0801
} test-failure [res-should res-is expr] #@[documentation: "Should be called if EXPR does not equal RES" source: ["Should be called if EXPR does not equal RES" [when print-errors [pfmtln "{} != {}\r\n{}\r\n\r\n" [ansi-red [string/write res-is]] [ansi-green [string/write res-should]] [string/write expr]]] [set! error-count [+ 1 error-count]]]] #{##[print-errors println ansi-red string/write res-is fmt-arg-0 ansi-green res-should fmt-arg-1 expr fmt-arg-2 cat " != " "\r\n" "\r\n\r\n" error-count]
1A00050B004F1A0105151A02051A03051A0405040104011A05070D1A06051A03
051A0705040104011A08070D1A03051A090504011A0A070D1A0B051A05051A0C
1A08051A0D1A0A051A0E0406160401090004240D02011A0F05251A0F0801
} run-test! [result rawexpr i] #@[documentation: "Tests that RAWEXPR evaluates to RESULT" source: ["Tests that RAWEXPR evaluates to RESULT" [try [fn [err] [display/error err] [test-failure result [list :exception-caught err] rawexpr]] [def expr [eval rawexpr]] [if [equal? result expr] [test-success result expr rawexpr] [test-failure result expr rawexpr]]]]] #{##[anonymous [err] #@[source: [[display/error err] [test-failure result [list :exception-caught err] rawexpr]]] #{##[display/error err test-failure result list :exception-caught rawexpr]
1A00051A010504010D1A02051A03051A04051A051A010504021A0605040301
} eval-in current-closure rawexpr expr equal? result test-success test-failure]
1A001A011A021A03171900421A04051A050504001A060504021A07070D1A0805
1A09051A070504020B00141A0A051A09051A07051A060504030900111A0B051A
09051A07051A060504031601
} init! [output-passes hide-errors] #@[documentation: "Initialize the testing framework" source: ["Initialize the testing framework" [set! print-errors [not [boolean hide-errors]]] [set! print-passes [boolean output-passes]] [set! nujel-start [time/milliseconds]] [set! success-count 0] [set! error-count 0]]] #{##[hide-errors #t #f print-errors output-passes print-passes time/milliseconds nujel-start success-count error-count]
1A00050B00081A010900051A020B00081A020900051A011A03080D1A04050B00
081A010900051A021A05080D1A060504001A07080D02001A08080D02001A0908
01
} finish! [description] #@[source: [[display-results description] [return error-count]]] #{##[display-results description error-count]
1A00051A010504010D1A02050101
} run [output-passes hide-errors] #@[documentation: "Run through all automated Tests" source: ["Run through all automated Tests" [init!] [doseq [cur-test test-list] [run-test! [car cur-test] [cdr cur-test]]] [finish! [fmt "{} {} [{System/OS} {System/Architecture}]" [ansi-blue ":core"] [ansi-rainbow "Nujel"]]]]] #{##[init! test-list ΓεnΣym-1 cur-test run-test! finish! ansi-blue ":core" fmt-arg-0 ansi-rainbow "Nujel" fmt-arg-1 cat " " " [" System/OS System/Architecture "]"]
1A000504000D151A01051A02070D1A02050B0030241B0900220D1C1A0205111A
03070D1A04051A0305111A03051204020D1A0205121A02081A02050AFFDE0900
0424160D1A0505151A06051A0704011A08070D1A09051A0A04011A0B070D1A0C
051A08051A0D1A0B051A0E1A0F051A0D1A10051A11040816040101
}]
1A00051A01151A02052404011A03070D1A011A04070D241A05070D02001A0607
0D02001A07070D02001A08070D02001A09070D1A0A1A0B070D1A0C1A0D070D1A
0E051A03051A0F1A101A111A121A13171A100704030D1A0E051A03051A141A15
1A161A171A18181A150704030D1A0E051A03051A191A191A1A1A1B1A1C171A19
0704030D1A1D1A1E1A1F1A20171A1D070D1A211A221A231A24171A21070D1A25
1A261A271A28171A25070D1A0E051A03051A291A291A2A1A2B1A2C171A290704
030D1A0E051A03051A2D1A2D1A2E1A2F1A30171A2D0704030D1A0E051A03051A
311A311A321A331A34171A310704030D1A0E051A03051A351A351A361A371A38
171A350704030D1A190504000D240D1316040201
}#{##[module/insert :time tree/new exports *module* tree/set! seconds [timestamp] #@[documentation: "Return the seconds part of TIMESTAMP, defaults to current time" source: ["Return the seconds part of TIMESTAMP, defaults to current time" [rem [or timestamp [time]] 60]]] #{##[timestamp time #f]
1A00050C0A00100D1A010504000C0A00060D1A02023C2901
} minutes [timestamp] #@[documentation: "Return the minutes part of TIMESTAMP, defaults to current time" source: ["Return the minutes part of TIMESTAMP, defaults to current time" [rem [/ [or timestamp [time]] 60] 60]]] #{##[timestamp time #f]
1A00050C0A00100D1A010504000C0A00060D1A02023C28023C2901
} hours [timestamp] #@[documentation: "Return the hours part of TIMESTAMP, defaults to current time" source: ["Return the hours part of TIMESTAMP, defaults to current time" [rem [/ [or timestamp [time]] 3600] 24]]] #{##[timestamp time #f 3600]
1A00050C0A00100D1A010504000C0A00060D1A021A032802182901
}]
1A00051A01151A02052404011A03070D1A011A04070D1A05051A03051A061A06
1A071A081A09171A060704030D1A05051A03051A0A1A0A1A0B1A0C1A0D171A0A
0704030D1A05051A03051A0E1A0E1A0F1A101A11171A0E0704030D240D131604
0201
}