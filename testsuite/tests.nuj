[test/add 3 [def eins 1] [def zwei 2] [+ eins zwei]]
[test/add -3 [def eins 1] [def zwei 2] [def drei [+ eins zwei]] [set! eins [- drei drei drei]]]
[test/add 1073741824 [ash 1 30]]
[test/add -2147483649 [lognot [ash 1 31]]]
[test/add 128 [def zahl 1_2_8] zahl]
[test/add 10 [let [[a 10]] a]]
[test/add 20 [def b 20] [let [[a b]] a]]
[test/add 10 [def b 20] [let [[a b]] [set! a 10] a]]
[test/add 20 [def b 20] [let [[a b]] [set! a 10] b]]
[test/add 42 [let [[a 12] [b 30]] [+ a b]]]
[test/add 16 [def square [fn [a] [* a a]]] [square 4]]
[test/add 0  [- -1 -1]]
[test/add 11 [length "Hallo, Welt"]]
[test/add #t [bool #t]]
[test/add #f [bool #nil]]
[test/add #f [bool #f]]
[test/add #t [bool 0]]
[test/add #t [bool 1]]
[test/add #t [bool 0.1]]
[test/add #t [bool ""]]
[test/add #t [bool "a"]]
[test/add #t [and [or #f #t] [and #t #t]]]
[test/add 12340 [- [read/int [cat 12 "3" "45 Test"]] 5]]
[test/add 12340 [let [[a [cat 12 "3" 45]]] [- [read/int a] [length a]]]]
[test/add :read-error [try car [read/int [cat "123" "abc" 456]]]]
[test/add 123 [read/int [cat "123" " abc" 456]]]
[test/add 28 [+ [int 10] [int 10.23] [read/int "8"]]]
[test/add 1 [int [vec/x [+ [vec 1] [vec 0 9 9]]]]]
[test/add #t [and [pair? [cons 1 '[2]]] [not [pair? 1]]]]
[test/add 1 [car [cons 1 '[2]]]]
[test/add 3 [+ [cadr '[1 2]] [car '[1]]]]
[test/add #t [string? [describe "min"]]]
[test/add 3 [+ 1 [- [length '[1 2 3]] 1]]]
[test/add #t [and [== "asd" "asd"] [not [== "asd" "bsd"]] [not [== "asd" "asdasd"]]]]
[test/add #nil [list/ref '[1 2] 3]]
[test/add 1  [list/ref '[1 2] 0]]
[test/add 2  [list/ref '[1 2 3 4] 1]]
[test/add #nil [ref '[1 2] 3]]
[test/add 1  [ref '[1 2] 0]]
[test/add 2  [ref '[1 2 3 4] 1]]
[test/add 20 [reduce [make-list 10 2] + 0]]
[test/add 4 [let [[a 10]] [when [when #t [set! a [+ 2 2]] #f] [set! a -1]] a]]
[test/add 6 [eval '[+ 1 2 3]]]
[test/add :arity-error [try car [+ [apply + '[1 2 3]] [apply [fn [α] [+ 1 α]] '[3]]]]]
[test/add 7 [+ [apply + '[1 2]] [apply [fn [α] [+ 1 α]] '[3]]]]
[test/add 0 [apply +]]                  ;
[test/add 0 [def cb +] [apply cb]]
[test/add 2 [apply [fn [α] [+ 1 α]] '[1]]]
[test/add 1 [def cb [fn [α] [+ 1 α]]] [apply cb '[0]]]
[test/add 1 [let [[cb [fn [α] [+ 1 α]]]] [apply cb '[0]]]]
[test/add 1 [let* [def cb [fn [α] [+ 1 α]]] [apply cb '[0]]]]
[test/add 5 [length "12345"]]
[test/add 0 [or 0 0]]
[test/add 2  [and 1 2]]
[test/add #t [bool [and 1 1]]]
[test/add #t [bool 1]]
[test/add 6 [[fn [a] [+ a 4]] 2]]
[test/add 2 [def test 1] [def test 2] test]
[test/add #t [int? [random]]]
[test/add #t [set! random/seed 123] [def first-value [random]] [set! random/seed 123] [== first-value [random]]]
[test/add #t [!= [random] [random]]]
[test/add 1 [def a 1] [when-not [== 2 2] [set! a 4]] a]
[test/add 4 [def a 1] [when-not [== 2 3] [set! a 4]] a]
[test/add 4 [def a 1] [when     [== 2 2] [set! a 4]] a]
[test/add 1 [def a 1] [when     [== 2 3] [set! a 4]] a]
[test/add -1 [lognot 0]]
[test/add 0 [lognot -1]]
[test/add 16 [ash 1 4]]
[test/add 65536 [ash 1 16]]
[test/add -16 [ash -1 4]]
[test/add -16 [lognand #b1111 #b1111]]
[test/add 6 [eval [read/single "[+ 1 2 3]"]]]
[test/add #[72 97 108 108 111 44 32 87 101 108 116 33] [string->byte-array "Hallo, Welt!"]]
[test/add ##[72 97 108 108 111 44 32 87 101 108 116 33] [string->byte-array "Hallo, Welt!"]]
[test/add "" [string/cut "\n" 1 1]]
[test/add "" [string/cut "\n" 1 -1]]
[test/add "" [string/cut "Hallo, Welt!" 0 -5]]
[test/add "" [string/cut "Hallo, Welt!" 15 5]]
[test/add "Hallo" [string/cut "Hallo, Welt!" 0 5]]
[test/add "Welt" [string/cut "Hallo, Welt!" 7 11]]
[test/add "" [cut "asd" 0 -1]]
[test/add "a" [cut "asd" -10 1]]
[test/add "a" [cut "asd" 0 1]]
[test/add "s" [cut "asd" 1 2]]
[test/add "sd" [cut "asd" 1 3]]
[test/add "d" [cut "asd" 2 3]]
[test/add ""  [cut "asd" 3 4]]
[test/add #nil [cut '[:a :s :d] 0 -1]]
[test/add #nil [cut '[:a :s :d] -10 -1]]
[test/add '[:a] [cut '[:a :s :d] -10 1]]
[test/add '[:a] [cut '[:a :s :d] 0 1]]
[test/add '[:s] [cut '[:a :s :d] 1 2]]
[test/add '[:s :d] [cut '[:a :s :d] 1 3]]
[test/add '[:d] [cut '[:a :s :d] 2 3]]
[test/add '[]  [cut '[:a :s :d] 3 4]]
[test/add #[] [cut #[:a :s :d] 0 -1]]
[test/add #[] [cut #[:a :s :d] -10 -1]]
[test/add #[:a] [cut #[:a :s :d] -10 1]]
[test/add #[:a] [cut #[:a :s :d] 0 1]]
[test/add #[:s] [cut #[:a :s :d] 1 2]]
[test/add #[:s :d] [cut #[:a :s :d] 1 3]]
[test/add #[:d] [cut #[:a :s :d] 2 3]]
[test/add #[]  [cut #[:a :s :d] 3 4]]
[test/add "Test" [def a "Test"] a]
[test/add '[] [cons #nil #nil]]
[test/add '[1] [cons 1 #nil]]
[test/add 1 [car [cons 1 2]]]
[test/add 2 [cdr [cons 1 2]]]
[test/add '[1 2 3] [read/single "[1 2 3]"]]
[test/add '[1 2 . 3] [read/single "[1 2 . 3]"]]
[test/add '[4 3 2 1] [reverse '[1 2 3 4]]]
[test/add '[1 4] [filter '[1 2.0 #t 4] int?]]
[test/add '[#t]  [filter '[1 2.0 #t 4] bool?]]
[test/add '[1 3 5] [filter '[1 2 3 4 5 6] odd?]]
[test/add 3 [count '[1 2 3 4 5 6] odd?]]
[test/add 3 [count '[1 2 3 4 5 6] even?]]
[test/add 6 [count '[1 2 3 4 5 6] int?]]
[test/add 0 [count '[1 2 3 4 5 6] float?]]
[test/add '[2 4 6] [filter '[1 2 3 4 5 6] even?]]
[test/add '["vier"] [filter '[1 2 3 "vier" 5 6] string?]]
[test/add '[1 2 3 5 6] [filter '[1 2 3 "vier" 5 6] int?]]
[test/add '[2 3] [sublist '[1 2 3 4 5 6] 1 3]]
[test/add '[1 2 3] [list-head '[1 2 3 4 5 6] 3]]
[test/add '[4 5 6] [list-tail [list 1 2 3 4 5 6] 3]]
[test/add '[3] [last-pair [list 1 2 3]]]
[test/add '[1 2] [except-last-pair '[1 2 3]]]
[test/add "[1.0 #t \"a\"]" [str/write [let [[l '[1.0 #t "a"]]] [append [except-last-pair l] [last-pair l]]]]]
[test/add "[\"asd\" #t #f]" [str/write [member '[123 456 "asd" #t #f] "asd"]]]
[test/add "[#v[4.0 4.0 4.0] 9 16.0]" [str/write [map [cons [vec 2] '[3 4.0]] [fn [a] [* a a]]]]]
[test/add "11.0" [cat 1 1.0]]
[test/add "#v[9.0 9.0 9.0]" [str/write [/ [vec 99] [read/float [cat 1 1.0]]]]]
[test/add :type-error [try car [apply #nil]]]
[test/add "#v[1.0 3.0 9.0]" [def vs [fn [a] [vec [vec/z a] [vec/y a] [vec/x a]]]] [str/write [vs [vec 9 3.0 1]]]]
[test/add 3 [def fib [fn [a] [cond [[zero? a] 0] [[== a 1] 1] [#t [+ [fib [- a 1]] [fib [- a 2]]]]]]] [fib 4]]
[test/add 21 [def fib [fn [a] [cond [[zero? a] 0] [[== a 1] 1] [#t [+ [fib [- a 1]] [fib [- a 2]]]]]]] [fib 8]]
[test/add "ASD123" [uppercase "asD123"]]
[test/add "asd123" [lowercase "aSD123"]]
[test/add "Asd123" [capitalize "aSD123"]]
[test/add "123" [string 123]]
[test/add "#t" [string #t]]
[test/add :unbound-variable [try car testerle]]
[test/add :testerle :testerle]
[test/add "[1 . 2]" [def test [cons 1 2]] [str/write test]]
[test/add "asd" [cat "a" "s" "d"]]
[test/add "a" [cat "a"]]
[test/add "Trim Test" [trim "   Trim Test    \n"]]
[test/add "1,asd,3.0,#f" [join '[1 "asd" 3.0 #f] ","]]
[test/add "[\"dies ist\" \"ein\" \"test\"]" [str/write [split "dies ist/ein/test" "/"]]]
[test/add 1 [index-of "1,2,3" ","]]
[test/add #x123 [car [read [join [cons "#x" [split "123" ""]]]]]]
[test/add 7 [char-at "\a" 0]]
[test/add 5 [char-at [from-char-code 5 10 20] 0]]
[test/add 2600 [read/int [from-char-code [char-at "2" 0] #\6 48 48]]]
[test/add #t [== 32 #\ ]]
[test/add #t [== #\Backspace 8]]
[test/add #t [== #\Tab [char-at "\t" 0]]]
[test/add #t [and [== #\cr 13] [== #\Return 13]]]
[test/add #t [and [== #\lf 10] [== 10 #\Linefeed]]]
[test/add #x07 [char-at "\a" 0]]
[test/add #x08 [char-at "\b" 0]]
[test/add #x1B [char-at "\e" 0]]
[test/add #x0c [char-at "\f" 0]]
[test/add #\lf [char-at "\n" 0]]
[test/add #\cr [char-at "\r" 0]]
[test/add #x09 [char-at "\t" 0]]
[test/add #x0B [char-at "\v" 0]]
[test/add #x27 [char-at "'" 0]]
[test/add #x22 [char-at "\"" 0]]
[test/add #t [== + +]]
[test/add #t [== min min]]
[test/add #t [let [[some-value #f]] [not some-value]]]
[test/add 4 [>> 8 1]]
[test/add 9 [- 10 1]]
[test/add 5 [/ 10 2]]
[test/add 256 [ash 1 8]]
[test/add 2 [getf [list :a 1 :b 2 :c 3] :b]]
[test/add "#nil" [str/write [getf [list :a 1 :b 2 :c 3] :d]]]
[test/add "\n" "\n"]
[test/add "\n" [br]]
[test/add "\n\n\n" [br 3]]
[test/add #t [== 4 [+ 2 2]]]
[test/add :int [type-of [+ 2 2]]]
[test/add :float [type-of [+ 2.0 2.1]]]
[test/add :float [type-of [+ 2 2.1]]]
[test/add -1 [do -1]]
[test/add -1 [- 1]]
[test/add -1 [let [[a 1]] [- a]]]
[test/add  0 [wrap-value 0 0 2]]
[test/add  1 [wrap-value 1 0 2]]
[test/add  0 [wrap-value 2 0 2]]
[test/add  1 [wrap-value 3 0 2]]
[test/add  0 [wrap-value 4 0 2]]
[test/add 0.0 [let [[tmp [vec 0 0 0]]] [+ tmp [vec 1 1 1]] [vec/y tmp]]]
[test/add 0 [let [[tmp 0]] [+ tmp 1] tmp]]
[test/add 2 [wrap-value 2 2 4]]
[test/add 3 [wrap-value 3 2 4]]
[test/add 2 [wrap-value 4 2 4]]
[test/add 3 [wrap-value 5 2 4]]
[test/add #nil [and #nil #nil]]
[test/add 10,000 [let [] [def i 0] [while [< i 10,000] [set! i [+ 1 i]]]]]
[test/add '[1 :a "q"] '[1 :a "q"]]
[test/add 4 [macroexpand '[do "Test" 4]]]
[test/add '[do [display "Test"] 4] [macroexpand '[do [display "Test"] 4]]]
[test/add '[do [display "Test"] 4] [macroexpand '[do [display "Test"] 9 4]]]
[test/add '[1 2] [except-last-pair '[1 2 3]]]
[test/add '[3] [last-pair '[1 2 3]]]
[test/add '[2 3 4] [map '[1 2 3] [fn [v] [+ 1 v]]]]
[test/add '[2 4 6] [map '[1 2 3] [fn [v] [* 2 v]]]]
[test/add '["1" "2" "3"] [map '[1 2 3] str/write]]
[test/add 0 [tree/size @[]]]
[test/add 1 [tree/size @[:a 1]]]
[test/add 3 [tree/size @[:a 1 :b 2 :c 3]]]
[test/add #f [tree/has? @[:a 123] :b]]
[test/add #t [tree/has? @[:a 123] :a]]
[test/add 123 [tree/ref @[:a 123] :a]]
[test/add 123 [tree/ref @[b: 2, a: 123] :a]]
[test/add 2 [tree/ref @[b: 2, a: 123] :b:]]
[test/add 9 [tree/ref [tree/set! @[:b 2 :a 123] :a 9] :a]]
[test/add :type-error [try car [tree/set! #@[:b 2 :a 123] :a 9]]]
[test/add 2 [tree/ref @[:b 2 :a 123] :b]]
[test/add 2 [tree/ref @['b 2 'a 123] :b]]
[test/add 2 [tree/ref #@[:b 2 :a 123] :b]]
[test/add 2 [tree/ref #@[b 2 a: 123] :b]]
[test/add #t [let* [def keys [tree/keys @[:b 2 :a 123]]] [or [list/equal? keys '[:b :a]] [list/equal? keys '[:a :b]]]]]
[test/add #t [let* [def vals [tree/values @[:b 2 :a 123]]] [or [list/equal? vals '[2 123]] [list/equal? vals '[123 2]]]]]
[test/add 2 [length [tree/keys @[:b 2 :a 123]]]]
[test/add 2 [length [tree/values @[:b 2 :a 123]]]]
[test/add 3 [length [tree/keys @[:b 2 :a 123 :c 7]]]]
[test/add '[:asd 123]   [car [read "[:asd 123]"]]]
[test/add '[123 [:asd]] [car [read "[123[:asd]]"]]]
[test/add '[123 [:asd]] [car [read "(123(:asd))"]]]
[test/add '[123 [:asd]] [car [read "(123[:asd])"]]]
[test/add '[:asd [123]] [car [read "(:asd[123])"]]]
[test/add #x123 [car '[#x123[#o234]]]]
[test/add '[#o234] [cadr '[#x123[#o234]]]]
[test/add #o234 [cadr '[#x123#o234]]]
[test/add #b101 [car '[#b101"asd"]]]
[test/add "asd" [cadr '[#b101"asd"]]]
[test/add #t [pair? [symbol-table]]]
[test/add #t [> [length [symbol-table]] 200]]
[test/add :one [car '[:one :two :three]]]
[test/add :two [cadr '[:one :two :three]]]
[test/add :three [caddr '[:one :two :three]]]
[test/add '[:two :three] [cdr '[:one :two :three]]]
[test/add '[:three] [cddr '[:one :two :three]]]
[test/add 'two [cadr '[:one two :three]]]
[test/add 102334155 [let* [def i 1] [def a 0] [def b 1] [while [< i 40] [let [[new [+ a b]]] [set! a b] [set! b new] [set! i [+ 1 i]]]] b]]
[test/add 832040 [let* [def i 1] [def a 0] [def b 1] [while [< i 30] [let [[new [+ a b]]] [set! a b] [set! b new] [set! i [+ 1 i]]]] b]]
[test/add 17711 [let* [def i 1] [def a 0] [def b 1] [while [< i 22] [let [[new [+ a b]]] [set! a b] [set! b new] [set! i [+ 1 i]]]] b]]
[test/add 6765  [let* [def fib-slow [fn [v] [if [< v 2] v [+ [fib-slow [- v 2]] [fib-slow [- v 1]]]]]] [fib-slow 20]]]
[test/add 10946 [let* [def fib-slow [fn [v] [if [< v 2] v [+ [fib-slow [- v 1]] [fib-slow [- v 2]]]]]] [fib-slow 21]]]
[test/add 4 [[fn [v] [+ v 2]] 2]]
[test/add 4 [[fn [fn] [+ fn 2]] 2]]
[test/add 4 [[fn [+ *] [- + *]] 6 2]]
[test/add 246 [let* [def - 123] [+ - -]]]
[test/add 'v [car '[v]]]
[test/add '+ [car '[+]]]
[test/add #t [== '+ [str->sym "+"]]]
[test/add '-- [car '[--]]]
[test/add '- [car '[-]]]
[test/add -1 [let* [def + -] [[resolve '+] 1 2]]]
[test/add #t [procedure? [let* [def t -] t]]]
[test/add #nil [when #f 1]]
[test/add 1 [when #t 1]]
[test/add '[1 . 2] [cons 1 2]]
[test/add '[1 . 2] '[1 . 2]]
[test/add 1 [car '[1 . 2]]]
[test/add 2 [cdr '[1 . 2]]]
[test/add 2 [tree/ref @[:asd 1 :bsd 2] :bsd]]
[test/add 0 [+]]
[test/add 1 [*]]
[test/add :unresolved-procedure [try [fn [err] [if [== [caddr err] 'asdqwe] [if [== [car err] :unbound-variable] :unresolved-procedure [car err]] #nil]] [asdqwe qweasdzxc]]]
[test/add #t [try [fn [error] [string? [cadr error]]] [/ 3 0]]]
[test/add :success [try [fn [error] error] [throw :success] :failure]]
[test/add 123 [try [fn [error] error] [throw 123] 0]]
[test/add #t [try [fn [error] error] [throw #t] #f]]
[test/add "asd" [try [fn [error] error] [throw "asd"] #nil]]
[test/add :test-exception [try [fn [error] [car error]] [throw [list :test-exception "Testing the exception system"]] #nil]]
[test/add #t [try [fn [error] [string? [cadr error]]] [throw [list :test-exception "Testing the exception system"]] #nil]]
[test/add :division-by-zero [try [fn [err] [car err]] [try [fn [err] [/ 3 0] err] [throw :test-exception]]]]
[test/add :test [[fn [e] [car e]] [cons :test "Test"]]]
[test/add 10 #d10]
[test/add -31 #x-1F]
[test/add -15 #o-17]
[test/add -3 #b-11]
[test/add :division-by-zero [try [fn [error] [car error]] [/ 3 0]]]
[test/add :division-by-zero [try [fn [error] [car error]] [try [fn [error] [/ 3 0] error] [throw :test-exception]]]]
[test/add :float-inf [try [fn [err] [car err]] [/  1.0 0.0]]]
[test/add :float-nan [try [fn [err] [car err]] [/  0.0 0.0]]]
[test/add :float-inf [try [fn [err] [car err]] [/ -1.0 0.0]]]
[test/add 1 `1]
[test/add '[1] `[1]]
[test/add '[1 2] `[1 2]]
[test/add '[1 "asd"] `[1 "asd"]]
[test/add '[1 :asd] `[1 :asd]]
[test/add '[@[:asd 123]] `[@[:asd 123]]]
[test/add '[#[1 2 3]] `[#[1 2 3]]]
[test/add '["1.0001"] `["1.0001"]]
[test/add '[:asd] `[:asd]]
[test/add '[1 2 3] `[1 ~[+ 1 1] 3]]
[test/add '[1 2 3 4] `[1 ~[+ 1 1] ~@[read "3 4"]]]
[test/add '[1 2 3] [let* [def v 2] `[1 ~v 3]]]
[test/add '[resolve 123] [do [let [[source [cons 123 #nil] #nil]] `[resolve ~[car source]]]]]
[test/add '[resolve asd] [do [let [[source [cons 'asd #nil]]] `[resolve ~[car source]]]]]
[test/add 4 [let* [defn double [α] [* α 2]] [double 2]]]
[test/add 6 [let* [def sum 0] [for-each '[1 2 3] [fn [a] [set! sum [+ sum a]]]] sum]]
[test/add "nuj" [path/extension "test.nuj"]]
[test/add "nuj" [path/extension "Another/test.nuj"]]
[test/add "NUJ" [uppercase [path/extension "Another/test.nuj"]]]
[test/add "no" [path/extension "asd/test.nuj.no"]]
[test/add "asd/test.nuj" [path/without-extension "asd/test.nuj.no"]]
[test/add 'source [car [closure/arguments macroexpand]]]
[test/add '[1 2 3] `[1 ~@`[2 3]]]
[test/add '[1 [2 [3 4]]] `[1 `[2 ~[3 ~[+ 2 2]]]]]
[test/add 2 [cadar '[[1 2 3] 4 5]]]
[test/add #f [bit-set? 0 0]]
[test/add #t [bit-set? #b1 0]]
[test/add #f [bit-set? #b1 1]]
[test/add #f [bit-set? #b1011 2]]
[test/add #t [bit-set? #b1111 2]]
[test/add #t [bit-set? #b1111 3]]
[test/add #f [bit-set? #b1111 4]]
[test/add #nil [when-not #t 123]]
[test/add 123 [when-not #f 123]]
[test/add :invalid-let-form [try [fn [err] [car err]] [macroexpand '[let [1] 1]]]]
[test/add :invalid-let-form [try [fn [err] [car err]] [macroexpand '[let [[] 1] 1]]]]
[test/add 1 [if #t 1 2]]
[test/add 2 [if-not :test 1 2]]
[test/add 1 [if-not #f 1 2]]
[test/add 7 [if-let [a 3] [+ a 4] 1]]
[test/add 1 [if-let [a #f] [+ a 4] 1]]
[test/add 7 [when-let [a 3] [+ a 4]]]
[test/add #nil [when-let [a #nil] [+ a 4]]]
[test/add 34 [time/seconds 1637755714]]
[test/add  8 [time/minutes 1637755714]]
[test/add 12 [time/hours   1637755714]]
[test/add 59 [time/seconds 1637755739]]
[test/add  0 [time/seconds 1637755740]]
[test/add '[4 5 6] [map '[1 2 3] [+x 3]]]
[test/add 4 [def α 3] [++ α] α]
[test/add #t [case "1" [[1] #f] [['1] #f] [["1"] #t]]]
[test/add #t [case "asd" [["as"] #f] [["qwe"] #f] [["asd"] #t]]]
[test/add #t [case [+ 1 2] [[3.1] #f] [[3.0] #t] [3 #t]]]
[test/add #t [< 3 3.1]]
[test/add #t [< 3.0 3.1]]
[test/add #t [< 3.2 4]]
[test/add #t [> 4 3.1]]
[test/add #t [> 4 3.9]]
[test/add #t [> 4.0 3.9]]
[test/add #t [> 3.1 3]]
[test/add #f [> 4.0 4]]
[test/add #f [< 4.0 4]]
[test/add #f [< 4 4.0]]
[test/add #f [> 4 4.0]]
[test/add #f [> -14 -14.0]]
[test/add #f [< -14 -14.0]]
[test/add #t [== -4 -4.0]]
[test/add #t [== -3.0 -3]]
[test/add #t [== 4 4.0]]
[test/add #t [== 4.0 4]]
[test/add #t [case [+ 1 2] [[1] #f] [[2 3] #t]]]
[test/add #t [case [+ 1 1] [[1] #f] [[2 3] #t]]]
[test/add #f [case [+ 0 1] [[1] #f] [[2 3] #t]]]
[test/add #nil [case [+ 2 2] [[1] #f] [[2 3] #t]]]
[test/add 123 [case [+ 2 2] [[1] #f] [[2 3] #t] [otherwise 123]]]
[test/add #t [def i 1] [case [++ i] [[9] #f] [[4] #f] [[2] #t]]]
[test/add :arity-error [try [fn [err] [car err]] [compile '[cons 123 234 345]]]]
[test/add #t [== car [resolve [car '[car asd]]]]]
[test/add #t [pos? [index-of [describe/closure [[defn stackTraceTest [] [current-lambda]]]] "stackTraceTest"]]]
[test/add 2 [case 'asd [['qwe] 1] [['asd] 2] [otherwise 3]]]
[test/add 10 [reduce #[1 2 3 4] add/int 0]]
[test/add "1,2,3,4" [join #[1 2 3 4] ","]]
[test/add 2 [count #[1 2 3 4] even?]]
[test/add 14 [reduce [map #[1 2 3 4] [+x 1]] + 0]]
[test/add 3 [length #[1 2 3]]]
[test/add 5 [count '[4 30 22 23 21 15 7 28 16 25 2 10] [bit-set?! 0]]]
[test/add 7 [count #[4 30 22 23 21 15 7 28 16 25 2 10] [bit-set?! 1]]]
[test/add 7 [count '[4 30 22 23 21 15 7 28 16 25 2 10] [bit-clear?! 0]]]
[test/add 5 [count #[4 30 22 23 21 15 7 28 16 25 2 10] [bit-clear?! 1]]]
[test/add '["123"] [split "123" "\n"]]
[test/add '["" ""] [split "\n" "\n"]]
[test/add '["123" "456"] [split "123\n456" "\n"]]
[test/add '["" "" ""] [split "\n\n" "\n"]]
[test/add '["1" "2" "3"] [split "1\n2\n3" "\n"]]
[test/add '["" "" "" ""] [split "\n\n\n" "\n"]]
[test/add '["1" "2" "3" "4"] [split "1\n2\n3\n4" "\n"]]
[test/add "#@[a: 1 b: 2]" [str/write [tree/zip '[:a :b] '[1 2]]]]
[test/add "#@[a: #nil b: #nil]" [str/write [tree/zip '[:a :b] '[]]]]
[test/add "#@[a: 1 b: #nil]" [str/write [tree/zip '[:a :b] '[1]]]]
[test/add "#@[]" [str/write [tree/zip #nil '[1 2]]]]
[test/add "123" [str/write [read/single "123;asd"]]]
[test/add '[123] [read "123"]]
[test/add '[123] [read "123;asd"]]
[test/add '[123 234] [read "123;asd\n234"]]
[test/add '[234] [read ";asd\n;qwe\n234;asd"]]
[test/add '[2 1 0] [let [[ret #nil]] [for [i 0 3] [set! ret [cons i ret]]] ret]]
[test/add '[1 2 3] [let [[ret #nil]] [for [i 3 0 -1] [set! ret [cons i ret]]] ret]]
[test/add '[20 10 0] [let [[ret #nil]] [for [i 0 30 10] [set! ret [cons i ret]]] ret]]
[test/add "#@[a: 1 b: 2]" [str/write [-> [tree/new] [tree/set! :a 1] [tree/set! :b 2]]]]
[test/add '[3 2 1] [->> '[1] [cons 2] [cons 3]]]
[test/add 2 [-> 2]]
[test/add '[1] [->> '[1]]]
[test/add 10 [sum '[1 2 3 4]]]
[test/add 0 [popcount 0]]
[test/add :type-error [try car [popcount #nil]]]
[test/add :type-error [try car [popcount ""]]]
[test/add 1 [popcount 1]]
[test/add 1 [popcount 2]]
[test/add 2 [popcount 3]]
[test/add 4 [popcount 15]]
[test/add "##[]" [str/write [sort #[]]]]
[test/add "##[1]" [str/write [sort #[1]]]]
[test/add "##[1 2 3]" [str/write [sort #[3 2 1]]]]
[test/add "##[1 2 3 9]" [str/write [sort #[3 9 2 1]]]]
[test/add '[1 2 3] [list/sort/bubble '[2 1 3]]]
[test/add '[1 2 3] [list/sort/bubble '[2 1 3]]]
[test/add '[1] [list/sort/bubble '[1]]]
[test/add '[] [list/sort/bubble '[]]]
[test/add '[1 2 3] [sort '[1 2 3]]]
[test/add '[1 3 9] [sort '[1 3 9]]]
[test/add '[1 9] [sort '[1 9]]]
[test/add '[1 1 2 9] [sort '[1 1 2 9]]]
[test/add '[1.0 2.0 3.0] [sort '[3.0 1.0 2.0]]]
[test/add '["a" "m" "z"] [sort '["m" "a" "z"]]]
[test/add '["a" "m" "z"] [sort '["z" "m" "a"]]]
[test/add '["a" "m" "z"] [sort '["a" "z" "m"]]]
[test/add '["Z" "a" "m" "z"] [sort '["a" "Z" "m" "z"]]]
[test/add '["aggressionen" "mit" "zauberer"] [sort '["zauberer" "aggressionen" "mit"]]]
[test/add '[1 2 3] [list/sort/merge '[1 2 3]]]
[test/add '[1 2 3] [list/sort/merge '[3 2 1]]]
[test/add '[1] [list/sort/merge '[1]]]
[test/add '[] [list/sort/merge '[]]]
[test/add '[-2 3 4 5 9 333 1000] [list/sort/merge '[9 3 5 1000 333 4 -2]]]
[test/add '[1.0 2.0 3.0] [list/sort/merge '[3.0 1.0 2.0]]]
[test/add '["a" "m" "z"] [list/sort/merge '["m" "a" "z"]]]
[test/add '["a" "m" "z"] [list/sort/merge '["z" "m" "a"]]]
[test/add '["a" "m" "z"] [list/sort/merge '["a" "z" "m"]]]
[test/add '["Z" "a" "m"] [list/sort/merge '["a" "Z" "m"]]]
[test/add #\( [char-at "([{<>}])" 0]]
[test/add #\[ [char-at "([{<>}])" 1]]
[test/add #\{ [char-at "([{<>}])" 2]]
[test/add #\< [char-at "([{<>}])" 3]]
[test/add #\> [char-at "([{<>}])" 4]]
[test/add #\} [char-at "([{<>}])" 5]]
[test/add #\] [char-at "([{<>}])" 6]]
[test/add #\) [char-at "([{<>}])" 7]]
[test/add #t [< 1442693 12049880844]]
[test/add 12051323537 [+ 1442693 12049880844]]
[test/add '[:a 1] [tree/list [tree/dup @[:a 1]]]]
[test/add '[:a 1] [tree/list [tree/dup @['a 1]]]]
[test/add "#@[a: 1]" [def t @[a: 1]] [-> [tree/dup @[:a 1]] [tree/++ :a]] [str/write t]]
[test/add "#@[a: 2]" [def t @[a: 1]] [str/write [-> [tree/dup @[:a 1]] [tree/++ :a]]]]
[test/add '[1 2 3] [nreverse [list 3 2 1]]]
[test/add '[1 2 3 4 5 6 7 8 9] [nreverse [list 9 8 7 6 5 4 3 2 1]]]
[test/add '[1] [nreverse [list 1]]]
[test/add '[2 1] [nreverse [cons 1 [cons 2 #nil]]]]
[test/add #nil [nreverse #nil]]
[test/add :tree [type-of @[]]]
[test/add #nil [tree/list @[]]]
[test/add #nil [tree/keys @[]]]
[test/add #nil [tree/values @[]]]
[test/add '[123] [tree/values @[:asd 123]]]
[test/add '[:asd] [tree/keys @[:asd 123]]]
[test/add '[:asd 123] [tree/list [apply tree/new [tree/list @[:asd 123]]]]]
[test/add :tree [type-of @[:asd 123]]]
[test/add '[:asd 123] [tree/list [tree/dup @[:asd 123]]]]
[test/add #nil [tree/list [tree/dup @[]]]]
[test/add :type-error [try [fn [err] [car err]] [tree/list [tree/dup #nil]]]]
[test/add :type-error [try [fn [err] [car err]] [tree/list [tree/dup 123]]]]
[test/add :type-error [try [fn [err] [car err]] [tree/list [tree/dup '[]]]]]
[test/add "asd" [string "asd"]]
[test/add "123" [string 123]]
[test/add "#t" [string #t]]
[test/add "" [string #nil]]
[test/add "[1 2 3]" [string '[1 2 3]]]
[test/add "[1 2 3]" [string '[1 2 3]]]
[test/add "#@[a: 3]" [string @[:a 3]]]
[test/add "asd" [cat "a" #nil "s" "" "d"]]
[test/add '[1 2 3] [append '[1 2] '[3] ]]
[test/add '[1 2 3] [append '[1] '[2 3]]]
[test/add '[1 2 3] [append '[1 2 3] #nil]]
[test/add :unbound-variable [try car [case 'asd [[asd] #f] [['asd] #t]]]]
[test/add :unbound-variable [try car [case 'asd [[asd] #f] ['asd #t]]]]
[test/add :division-by-zero [try car [/ 1 0]]]
[test/add '[1 2 3 4] [[fn a a] 1 2 3 4]]
[test/add 1 [[fn [a . b] a] 1 2 3]]
[test/add '[2 3] [[fn [a . b] b] 1 2 3]]
[test/add '[3] [[fn [a b . c] c] 1 2 3]]
[test/add 2 [[fn [a b . c] b] 1 2 3]]
[test/add 1 [[fn [a b . c] a] 1 2 3]]
[test/add #nil [[fn [a b c . d] d] 1 2 3]]
[test/add 3 [[fn [a b c . d] c] 1 2 3]]
[test/add 2 [[fn [a b c . d] b] 1 2 3]]
[test/add 1 [[fn [a b c . d] a] 1 2 3]]
[test/add 122 [-> @[:asd 123] [tree/-- :asd] [tree/ref :asd]]]
[test/add 124 [-> @[:asd 123] [tree/++ :asd] [tree/ref :asd]]]
[test/add 10 [def m 5] [for [i 0 m] [++ m] [when [> m 50] [set! i 100]]] m]
[test/add #t [do [for [i 0 10] [set! i 20] [when [> i 30] [throw [list :error]]]] #t]]
[test/add #f [== @[:a 1] #[:a 1]]]
[test/add #f [== @[:a 1] #[:b 1]]]
[test/add #t [let [[a @[:a 1]]] [== a a]]]
[test/add '[2 3 4] [-> '[1 2 3 4] [delete 1]]]
[test/add '[1 2 3 4 5] [flatten #[1 2 3 4 5]]]
[test/add '[1 2 3 4 5] [flatten '[1 2 3 4 5]]]
[test/add '[1 2 3 4 5] [flatten '[[1 2] [3] [[[4] 5]]]]]
[test/add '[1 2 3 4 5] [flatten [list '[1 2] #[3] #['[[4] 5]]]]]
[test/add "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz" [cat "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z" "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"]]
[test/add 6 [- 7 1]]
[test/add '[:asd "Test"] [list :asd "Test"]]
[test/add 10 [let [[t 0]] [for-in [l [list 1 2 3 4]] [+= t l]] t]]
[test/add 1 [let [[t 0]] [for-in [l [list 1]] [+= t l]] t]]
[test/add 0 [let [[t 0]] [for-in [l [list]] [+= t l]] t]]
[test/add #t [symbol? [apply gensym]]]
[test/add 1 [apply car '[[1 . 2]]]]
[test/add 1 [apply car '[[1 2]]]]
[test/add 2 [apply cdr '[[1 . 2]]]]
[test/add '[2] [apply cdr '[[1 2]]]]
[test/add 22 [[resolve [str->sym "+"]] 10 12]]
[test/add 1 [length '[1]]]
[test/add 2 [length '[1 #nil]]]
[test/add 3 [length '[1 #nil 2]]]
[test/add 3 [length '[1 1 2]]]
[test/add 4 [length '[1 1 2 #nil]]]
[test/add 4 [length '[1 #nil 2 #nil]]]
[test/add 4 [length '[#nil #nil 2 #nil]]]
[test/add 4 [length '[#nil #nil #nil #nil]]]
[test/add 5 [length '[#nil #nil #nil #nil 5]]]
[test/add :type-error [try car [tree/values]]]
[test/add :type-error [try car [tree/keys #nil]]]
[test/add :type-error [try car [tree/has? #nil]]]
[test/add :type-error [try car [tree/has?]]]
[test/add 5 [eval [read/single "[+ 2 3]"]]]
[test/add 5 [eval [read/single "[+ 2 ; 5\n 3]"]]]
[test/add 5 [eval [read/single "[+ 2 #! 5\n 3]"]]]
[test/add '[1 3] [read/single "[1 #| 2 |# 3]"]]
[test/add 5 [eval [read/single "[+ 2 #| 5 |# 3]"]]]
[test/add #t [do [event-fire @[]] #t]]
[test/add #t [let [[ret #f]] [event-fire @[:asd [fn [] [set! ret #t]]]] ret]]
[test/add #t [let [[ret #t]] [for-in [l #nil] [set! ret #f]] ret]]
[test/add #f [let [[ret #t]] [for-in [l '[]] [set! ret #f]] ret]]
[test/add 0 [string/length ""]]
[test/add 1 [string/length "1"]]
[test/add 2 [string/length "  "]]
[test/add 2 [string/length "λ"]]
[test/add :type-error [try car [string/pad-start 123 4 #\0]]]
[test/add :type-error [try car [string/pad-start "123" 4 #\0]]]
[test/add :type-error [try car [string/pad-end 123 4 #\0]]]
[test/add " 123" [string/pad-start 123 4]]
[test/add "0123" [string/pad-start 123 4 "0"]]
[test/add " 123" [string/pad-start "123" 4]]
[test/add "123 " [string/pad-end 123 4]]
[test/add "1230" [string/pad-end 123 4 "0"]]
[test/add "123 " [string/pad-end "123" 4]]
[test/add :type-error [try car [str->sym 4]]]
[test/add "4" [sym->str [str->sym "4"]]]
[test/add #t [== [str->sym "3"] [str->sym "3"]]]
[test/add #f [== [str->sym "3"] [str->sym "2"]]]
[test/add :type-error [try car [sym->str 4]]]
[test/add :type-error [try car [sym->str "asd"]]]
[test/add "asd" [sym->str 'asd]]
[test/add :type-error [try car [char-at]]]
[test/add :bounds-error [try car [char-at "" -1]]]
[test/add :bounds-error [try car [char-at "" 1]]]
[test/add :type-error [try car [char-at "" :asd]]]
[test/add #t [case 3 [otherwise #t] [2 #f]]]
[test/add 0 [+]]
[test/add 1 [*]]
[test/add :arity-error [try car [-]]]
[test/add :arity-error [try car [/]]]
[test/add "#v[0.1 0.1 0.1]" [str/write [/ 1 [vec 10 10 10]]]]
[test/add :arity-error [try car [str/write [/ [vec 10 10 10]]]]]
[test/add 0 [popcount 0]]
[test/add 8 [popcount 255]]
[test/add 15 [popcount #b1100001000010000101101011010101101]]
[test/add 64 [popcount [lognot 0]]]
[test/add #nil [tree/key* @[]]]
[test/add :a [tree/key* @[:a 1]]]
[test/add 1 [tree/value* @[:a 1]]]
[test/add 0 [count #nil]]
[test/add 0 [count #[]]]
[test/add 1 [count '[1]]]
[test/add 1 [count #[1]]]
[test/add 3 [count '[1 2 3]]]
[test/add 3 [count #[1 2 3]]]
[test/add 0 [+]]
[test/add 3 [+ 1 2]]
[test/add 1 [*]]
[test/add #t [symbol? [car [symbol-table]]]]
[test/add #f [keyword? [car [symbol-table]]]]
[test/add '[1 3] [remove '[0 1 2 3] even?]]
[test/add #[1 3] [remove #[0 1 2 3] even?]]
[test/add 6 [reduce @[:a 1 :b 2 :c 3] + 0]]
[test/add @[] [filter @[:a 1] even?]]
[test/add @[:b 2] [filter @[:a 1 :b 2 :c 3] even?]]
[test/add @[:a 1 :c 3] [remove @[:a 1 :b 2 :c 3] even?]]
[test/add 4 [identity 4]]
[test/add "4" [identity "4"]]
[test/add #[1 2 3] [identity #[1 2 3]]]
[test/add "Polizei"
          [def eins [environment*]]
          [eval-in eins '[def say [fn [] "Eins"]]]
          [def zwei [eval-in eins '[environment*]]]
          [eval-in zwei '[def say [fn [] "Polizei"]]]
          [eval-in zwei '[say]]]
[test/add "Eins"
          [def eins [environment*]]
          [eval-in eins '[def say [fn [] "Eins"]]]
          [eval-in eins '[say]]]
[test/add 11 [def counter [let [[a 0]] [fn [b] [set! a [+ a [or b 1]]]]]] [counter 10] [counter]]
[test/add '[0 1 2 3 4] [range 5]]
[test/add #nil [range 0]]
[test/add #nil [range -1 1]]
[test/add '[0] [range 1]]
[test/add '[-1 0] [range 1 -1]]
[test/add '[1 0 -1] [range -2 1 -1]]
[test/add 19 [int [reduce [range 2.0 0.0 0.1] +]]]
[test/add 45 [reduce [range 10] +]]
[test/add 123456789 [read/single [reduce [range 10] cat]]]
[test/add 30 [reduce [map [range 5] [fn [α] [* α α]]] +]]
[test/add "null" [val->json #nil]]
[test/add "123" [val->json 123]]
[test/add "123.123" [val->json 123.123]]
[test/add "true" [val->json #t]]
[test/add "false" [val->json #f]]
[test/add "[1,2,3]" [val->json #[1 2 3]]]
[test/add "[1,true,3.0]" [val->json '(1 #t 3.0)]]
[test/add "\"asd\"" [val->json 'asd]]
[test/add "\"asd\"" [val->json :asd]]
[test/add "\"asd\"" [val->json "asd"]]
[test/add "{\"asd\": 123,\n\"qwe\": true}" [val->json @[asd: 123 qwe: #t]]]
[test/add @[:asd 123] [tree/set! #nil :asd 123]]
[test/add #t [int? [val->index 123]]]
[test/add 123 [index->val [val->index 123]]]
[test/add #t [int? [sym->index 'asd]]]
[test/add 'asd [index->sym [sym->index 'asd]]]
[test/add #t [> :b :a]]
[test/add #f [< :b :a]]
[test/add #t [> 'b 'a]]
[test/add #f [< 'b 'a]]
[test/add '[:a :b :c] [sort '[:b :c :a]]]
[test/add '[a b c] [sort '[b c a]]]
[test/add #t [[path/ext?! "asd"] "qwe.asd"]]
[test/add #f [[path/ext?! "as"] "qwe.asd"]]
[test/add #f [[path/ext?! "asd"] "qwe.as"]]
[test/add #t [[path/ext?! '["as" "asd"]] "qwe.as"]]
[test/add #t [[path/ext?! '["as" "asd"]] "qwe.asd"]]
[test/add :a [let [[list '[:a :b :c]]] [car list]]]
[test/add 15 [logior 1 2 4 8]]
[test/add 65536 [+ 1 [reduce [map [range 16] [fn [a] [ash 1 a]]] logior 0]]]

;[test/add :type-error [try car [do [def :asd #t] :asd]]]
;[test/add "Testing!" [let* [defn a [] "Testing!" [tree/ref [closure [closure-parent [current-closure]]] :documentation]] [a]]]

;[test/add 5 [def a 4] [for [i 0 10] [once [++ a]]] a]
;[test/add 102334155 [def fib-iter [fn [a b count] [cond [[== count 0] b] [#t [fib-iter [+ a b] a [- count 1]]]]]] [def fib [fn [n] [fib-iter 1 0 n]]] [fib 40]]

;[test/add #t [for [i 5 4]] #t]

; Having test defined somehow breaks the whole testing system, how come?
; [def test [+99 1]]

; This would interfere with quasiquote as a macro, still have to think about the consequences
;[test/add '[quasiquote [quasiquote [1 2 [unquote [unquote 3]]]]] ```[1 2 ,,,[+ 2 1]]]

; Still have to ponder whether [undefine!] should exist
;[test/add #f [undefine! testerle]]
;[test/add "#nil" [def testerle 123] [undefine! testerle] testerle]

; Has to wait until the new constant system is in place
;[test/add 3.14159 [set! π 3] π]
;;
