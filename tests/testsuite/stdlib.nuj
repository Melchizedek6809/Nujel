(#t (bit-test? #b1001 0))
(#f (bit-test? #b1001 1))
(#f (bit-test? #b1001 7))
(#b1111 (bit-set #b1011 2))
(#b1111 (bit-flip #b1011 2))
(#b1011 (bit-flip #b1111 2))
(#b1001 (bit-clear #b1011 1))
(#b1011 (bit-clear #b1011 2))
(:type-error (try car (sum 123)))
(10 (+ (sum '(1 2 3)) (apply (fn (Î±) (+ 1 Î±)) '(3))))
(15 (sum [1 2 3 4 5]))
(6 (sum '(1 2 3)))
(#t (every? '(1 2 3 4 5 6) int?))
(#f (every? '(1 2 3 4 5 6.0) int?))
(#t (every? '(1.0 6.0) float?))
(#f (every? '() float?))
(#t (every? [1 2 3 4 5 6] int?))
(#f (every? [1 2 3 4 5 6.0] int?))
(#t (every? [1.0 6.0] float?))
(#t (every? [] float?))
(0 (count #nil))
(0 (count []))
(1 (count '(1)))
(1 (count [1]))
(3 (count '(1 2 3)))
(3 (count [1 2 3]))
(2 (count [1 2 3 4] even?))
(3 (count '(1 2 3 4 5 6) odd?))
(3 (count '(1 2 3 4 5 6) even?))
(6 (count '(1 2 3 4 5 6) int?))
(0 (count '(1 2 3 4 5 6) float?))
(#t (boolean #t))
(#f (boolean #nil))
(#f (boolean #f))
(#t (boolean 0))
(#t (boolean 1))
(#t (boolean 0.1))
(#t (boolean ""))
(#t (boolean "a"))
(#f (not #t))
(#t (not #f))
(#t (not (< 5 1)))
(#t (not (= #f #t)))
(#t (not (< 3 2)))
(#t (caar '((#t) #f)))
(#t (cdar '((#f . #t) #f)))
('(#t) (cdar '((#f #t) #f)))
(#t (cddr '(#f #f . #t)))
('(#t) (cddr '(#f #f #t)))
(#t (cadar '((#f #t) #f)))
(#t (caddr '(#f #f #t)))
(#t (cdddr '(#f #f #f . #t)))
('(#t) (cdddr '(#f #f #f #t)))
(#t (cadddr '(#f #f #f #t)))
(#t (cddddr '(#f #f #f #f . #t)))
(#t (caddddr '(#f #f #f #f #t)))
(#t (cdddddr '(#f #f #f #f #f. #t)))(#t (equal? 1 1))
(#t (equal? 2.0 2.0))
(#f (equal? 2.0 2.1))
(#t (equal? :a :a))
(#f (equal? :a :b))
(#t (equal? '(1 :b "c") '(1 :b "c")))
(#f (equal? '(1 :b "c" [4.0]) '(1 :b "c")))
(#t (equal? '(1 :b "c" [4.0]) '(1 :b "c" [4.0])))
(#t (equal? ['(1 #o2 #x3) '(4.0 5.0 {:a 1 :b 2}) '("7" [8 88] :9)] ['(1 #o2 #x3) '(4.0 5.0 {:a 1 :b 2}) '("7" [8 88] :9)]))
(#t (not-equal? ['(1 #o2 #x3) '(4.0 5.0 {:a 1 :b 2}) '("7" [8 88] :9)] ['(1 #o2 #x3) '(4.0 5.0 {:a 1 :a 2}) '("7" [8 88] :9)]))
(#f (not-equal? :a :a))
(#t (not-equal? :a :b))
(#t (not-equal? '(1 :b "c" [4.0]) '(1 :b "c")))
(#t (not-equal? ['(1 #o2 #x3) '(4.0 5.0 6.0) '("7" [8 88] :9)] ['(1 #o2 #x3) '(4.0 5.0 6.0) '("7" [8 88] :99)]))
(#t (int? 123))
(#f (int? 123.123))
(#f (int? 'asd))
(#f (float? 123))
(#t (float? 123.123))
(#f (float? 'abc))
(#t (number? 123))
(#t (number? 123.123))
(#f (number? 'abc))
(#f (number? "123"))
(#t (bool? #t))
(#t (bool? #f))
(#f (bool? #nil))
(#f (bool? 123))
(#f (bool? 123.123))
(#f (bool? 'qwe))
(#t (pair? '()))
(#t (pair? '(123)))
(#f (pair? 123))
(#f (pair? 123.123))
(#f (pair? 'qwe))
(#t (array? []))
(#f (array? '(123)))
(#f (array? 123))
(#f (array? 123.123))
(#f (array? 'abc))
(#t (string? "asd"))
(#f (string? []))
(#f (string? '(123)))
(#f (string? 123))
(#f (string? 123.123))
(#f (string? 'abc))
(#t (symbol? 'abc))
(#f (symbol? "asd"))
(#f (symbol? '(123)))
(#f (symbol? 123))
(#f (symbol? 123.123))
(#t (environment? (current-closure)))
(#f (environment? []))
(#f (environment? '(123)))
(#t (tree? {}))
(#f (tree? (current-closure)))
(#f (tree? []))
(#f (tree? '(123)))
(#f (tree? 123))
(#f (tree? 123.123))
(#f (tree? 'abc))
(#t (collection? {}))
(#t (collection? []))
(#t (collection? '(123)))
(#f (collection? (current-closure)))
(#f (collection? 123))
(#f (collection? 123.123))
(#f (collection? 'abc))
(#t (keyword? :abc))
(#f (keyword? 'abc))
(#f (keyword? "asd"))
(#f (keyword? []))
(#f (keyword? '(123)))
(#f (keyword? 123))
(#f (keyword? 123.123))
(#t (macro? case))
(#f (macro? :abc))
(#t (lambda? min))
(#f (lambda? case))
(#f (lambda? (current-closure)))
(#f (lambda? 'abc))
(#t (native? sin))
(#f (native? (defn +123 (a) (+ a 123))))
(#f (native? (defmacro +123 (a) (+ a 123))))
(#t (buffer? #m00))
(#f (buffer? "asd"))
(#f (buffer? []))
(#t (buffer-view? (:u8 #m00)))
(#f (buffer-view? #m00))
(#f (buffer-view? "asd"))
(#f (buffer-view? []))
(#t (bytecode-array? #{##()01}))
(#f (bytecode-array? (:u8 #m00)))
(#f (bytecode-array? #m00))
(#f (bytecode-array? "asd"))
(#f (bytecode-array? []))
(#t (and (native? sin) (procedure? sin)))
(#t (and (lambda? min) (procedure? min)))
(#t (procedure? min))
(#t (procedure? sin))
(#f (procedure? case))
(#f (procedure? (current-closure)))
(#t (and (macro? case) (callable? case)))
(#t (callable? min))
(#t (callable? sin))
(#f (callable? (current-closure)))
(2 (min 2 4 9 25))
(1 (apply min '(1 4 9 25)))
(8.2 (reduce [32 9 8.2] min))
(4 (min 25.3 4 9.1))
(1 (apply min '(25 4 9 1)))
(1 (reduce [25 4 9 1] min))
(#nil (min))
(4 (min 4))
(4 (min 4 9))
(#nil (max))
(1 (max 1))
(9.1 (max 4 9.1))
(25 (max 1 4 9 25))
(25 (apply max '(1 4 9 25)))
(25 (reduce [1 4 9 25] max))
(31.0 (max 31.0 4 9 1))
(25 (apply max '(25 4 9 1)))
(25 (reduce [25 4 9 1] max))
(#f (let ((x #f)) (comment (set! x #t)) x))
("   123" (pad-start "123" 6))
("000123" (pad-start 123 6 "0"))
("-.-123" (pad-start '123 6 ".-"))
("123   " (pad-end "123" 6))
("123000" (pad-end 123 6 "0"))
("123.-." (pad-end '123 6 ".-"))
(" 123  " (pad-middle "123" 6))
("012300" (pad-middle 123 6 "0"))
("-123.-" (pad-middle '123 6 ".-"))
("Test" (trim " Test"))
("Test" (trim "Test "))
("Test" (trim "Test"))
("" (trim ""))
("Test" (trim "   Test\t\n"))
("Trim Test" (trim "   Trim Test    \n"))
("TESTING THE CAPITALIZATION!" (upper-case "Testing THE Capitalization!"))
("testing the capitalization!" (lower-case "Testing THE Capitalization!"))
("Testing The Capitalization!" (capitalize "Testing THE Capitalization!"))
