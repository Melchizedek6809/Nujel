(0 (:length (map/new)))
(1 (:length (map/new :asd 123)))
(123 (ref (map/new :asd 123) :asd))
(123 (ref (map/new 'asd 123) 'asd))
(#nil (ref (map/new :asd 123) 'asd))
(#nil (ref (map/new 'asd 123) :asd))
(123 (ref (map/new 234 123) 234))
(#nil (ref (map/new 234 123) :asd))
(#nil (ref (map/new 234 123) 123))
(123 (ref (map/new #t 123) #t))
(#nil (ref (map/new #t 123) #f))
(123 (ref (map/new #f 123) #f))
(#nil (ref (map/new #f 123) #t))
(:type-error (try (fn (a) (car a)) (map/new 123.234 123)))
(:type-error (try (fn (a) (car a)) (map/new #nil 123)))
(:type-error (try (fn (a) (car a)) (ref (map/new) 123.234)))
(:type-error (try (fn (a) (car a)) (ref (map/new) #nil)))
(:type-error (try (fn (a) (car a)) (def m (map/new)) (set! m #nil 1)))
(:type-error (try (fn (a) (car a)) (def m (map/new)) (set! m 123.234 1)))
(123 (def a (map/new :asd 123)) (def b (:clone a)) b.asd)
(123 (def a (map/new :asd 123)) (def b (:clone a)) (set! b.asd #f) a.asd)
(#f (def a (map/new :asd 123)) (def b (:clone a)) (set! b.asd #f) b.asd)
(123 (def k #mDEADBEEF) (def m (map/new)) (set! m k 123) (ref m k))
(#nil (def k #mDEADBEEF) (def m (map/new)) (set! m k 123) (ref m #mDEADBEEF))
(123 (def k "asd") (def m (map/new)) (set! m k 123) (ref m k))
(123 (def k "asd") (def m (map/new)) (set! m k 123) (ref m "asd"))
(123 (def k [123]) (def m (map/new)) (set! m k 123) (ref m k))
(#nil (def k [123]) (def m (map/new)) (set! m k 123) (ref m [123]))
(123 (def k min) (def m (map/new)) (set! m min 123) (ref m min))
(#nil (def k min) (def m (map/new)) (set! m min 123) (ref m (fn (a b) (if (< a b) a b))))
(123 (def k '(1 2 3)) (def m (map/new)) (set! m k 123) (ref m k))
(#nil (def k '(1 2 3)) (def m (map/new)) (set! m k 123) (ref m '(1 2 3)))
(123 (def k (map/new :asd 123)) (def m (map/new)) (set! m k 123) (ref m k))
(#nil (def k (map/new :asd 123)) (def m (map/new)) (set! m k 123) (ref m (map/new :asd 123)))
(123 (def k root-closure) (def m (map/new)) (set! m k 123) (ref m k))
('("b" :a 0 c) (def m (map/new 0 #nil :a 1 "b" "2" 'c #t)) (sort (:keys m))) ; We need to sort since the order of keys/values is undefined
('("2" 1 #nil #t) (def m (map/new 0 #nil :a 1 "b" "2" 'c #t)) (sort (:values m)))
(4 (def m (map/new 0 #nil :a 1 "b" "2" 'c #t)) (:length (:values m)))
(4 (def m (map/new 0 #nil :a 1 "b" "2" 'c #t)) (:length (:keys m)))
('(:a) (def m (map/new :a 1)) (:keys m))
('(1) (def m (map/new :a 1)) (:values m))
(#t (def m (map/new :a 1)) (>= (:size* m) 1))
(123 (def m (map/new :a 123)) ((fn () (dotimes (i (:size* m)) (when (= (:key* m i) :a) (return (:value* m i)))) #f)))
(1 (reduce (map/new :a 1 :b 2 :c 3) min 999))
(3 (reduce (map/new :a 1 :b 2 :c 3) max 0))
(6 (reduce (map/new :a 1 :b 2 :c 3) + 0))
(#nil (ref (filter (map/new :a 1 :b 2 :c 3) even?) :a))
(2 (ref (filter (map/new :a 1 :b 2 :c 3) even?) :b))
(#nil (ref (filter (map/new :a 1 :b 2 :c 3) even?) :c))
(6 (sum (map/new :a 1 :b 2 :c 3)))
(1 (ref (map/merge (map/new :a 1 :b 2) (map/new :c 3)) :a))
(2 (ref (map/merge (map/new :a 1 :b 2) (map/new :c 3)) :b))
(3 (ref (map/merge (map/new :a 1 :b 2) (map/new :c 3)) :c))
(1 (ref (map/zip '(:a :b :c) '(1 2 3)) :a))
(2 (ref (map/zip '(:a :b :c) '(1 2 3)) :b))
(3 (ref (map/zip '(:a :b :c) '(1 2 3)) :c))
(#nil (ref (filter (map/new :a 1 :b 2 :c 3) even?) :c))
