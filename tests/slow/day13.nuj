#!/usr/bin/env nujel

[defun fold/load [filename]
       [def points #nil]
       [def γ [reduce [split [file/read filename] "\n"]
                       [\ [α β]
                         [cond [[zero? [string/length β]] α]
                               [[== [char-at β 0] #\f]
                                [tree/set! α :folds [cons [split [caddr [split β " "]] "="] [tree/get α :folds]]]]
                               [#t [def τ [map [split β ","] read/single]]
                                   [set! points [cons τ points]]
                                   [tree/set! α :width  [max [tree/get α  :width] [+ 1 [car τ]]]]
                                   [tree/set! α :height [max [tree/get α :height] [+ 1 [cadr τ]]]]]]]
                      @[:width 0 :height 0 :folds #nil]]]
       [tree/set! γ :data [-> [array/allocate [* [tree/get γ :width] [tree/get γ :height]]] [array/fill! 0]]]
       [while points
              [array/set! [tree/get γ :data] [+ [caar points] [* [tree/get γ :width] [cadar points]]] 1]
              [cdr! points]]
       [tree/set! γ :folds [reverse [tree/get γ :folds]]]]

[defun fold-y [data y]
       [def ret [array/2d/allocate [tree/get data :width] [/ [tree/get data :height] 2]]]
       [def dh [tree/get data :height]]
       [def rw [tree/get ret :width]]
       [def rh [tree/get ret :height]]

       [for [y 0 rh]
       [for [x 0 rw]
            [array/2d/set! ret x y [+ [array/2d/ref data x y]
                                      [array/2d/ref data x [- dh y 1]]]]]]
       [tree/set! ret :folds [cdr [tree/get data :folds]]]]

[defun fold-x [data y]
       [def ret [array/2d/allocate [/ [tree/get data :width] 2] [tree/get data :height]]]
       [def dw [tree/get data :width]]
       [def rw [tree/get ret :width]]
       [def rh [tree/get ret :height]]

       [for [y 0 rh]
       [for [x 0 rw]
            [array/2d/set! ret x y [+ [array/2d/ref data x y]
                                      [array/2d/ref data [- dw x 1] y]]]]]
       [tree/set! ret :folds [cdr [tree/get data :folds]]]]

[defun do-fold [α]
       [if [== [caar [tree/get α :folds]] "x"]
           [fold-x α [cadr [tree/get α :folds]]]
           [fold-y α [cadr [tree/get α :folds]]]]]

[defun do-all-folds [α]
       [while [tree/get α :folds]
              [set! α [do-fold α]]]
       α]

[defun dot-count [α]
       [def β [tree/get α :data]]
       [def len [array/length β]]
       [def ret 0]
       [for [i 0 len]
            [when [> [array/ref β i] 0] [++ ret]]]
       ret]

[defun print-folded [α]
       [for [y 0 [tree/get α :height]]
       [for [x 0 [tree/get α :width]]
            [if [zero? [array/2d/ref α x y]]
                [display "."]
                [display "#"]]
       ][newline]]]
[def res-p1 [dot-count [do-fold [fold/load "tests/slow/day13.input"]]]]
[def final-map [do-all-folds [fold/load "tests/slow/day13.input"]]]
[def res-p2 [dot-count final-map]]

[when [!= res-p1 842]
      [throw [list :wrong-result "Wrong result" res-p1]]]
[when [!= res-p2 95]
      [throw [list :wrong-result "Wrong result" res-p2]]]
